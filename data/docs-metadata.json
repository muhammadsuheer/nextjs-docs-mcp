[
  {
    "id": "01-app-01-getting-started-01-installation",
    "path": "01-app\\01-getting-started\\01-installation.mdx",
    "title": "Installation",
    "description": "Learn how to create a new Next.js application with the `create-next-app` CLI, and set up TypeScript, ESLint, and Module Path Aliases.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Quick start",
        "slug": "quick-start"
      },
      {
        "level": 2,
        "text": "System requirements",
        "slug": "system-requirements"
      },
      {
        "level": 2,
        "text": "Create with the CLI",
        "slug": "create-with-the-cli"
      },
      {
        "level": 2,
        "text": "Manual installation",
        "slug": "manual-installation"
      },
      {
        "level": 3,
        "text": "Create the  directory",
        "slug": "create-the-directory"
      },
      {
        "level": 3,
        "text": "Create the  directory",
        "slug": "create-the-directory"
      },
      {
        "level": 3,
        "text": "Create the  folder (optional)",
        "slug": "create-the-folder-optional"
      },
      {
        "level": 2,
        "text": "Run the development server",
        "slug": "run-the-development-server"
      },
      {
        "level": 2,
        "text": "Set up TypeScript",
        "slug": "set-up-typescript"
      },
      {
        "level": 3,
        "text": "IDE Plugin",
        "slug": "ide-plugin"
      },
      {
        "level": 2,
        "text": "Set up linting",
        "slug": "set-up-linting"
      },
      {
        "level": 2,
        "text": "Set up Absolute Imports and Module Path Aliases",
        "slug": "set-up-absolute-imports-and-module-path-aliases"
      }
    ],
    "codeBlocks": [
      {
        "language": "bash",
        "code": "pnpm create next-app@latest my-app --yes\r\ncd my-app\r\npnpm dev",
        "context": "package=\"pnpm\""
      },
      {
        "language": "bash",
        "code": "npx create-next-app@latest my-app --yes\r\ncd my-app\r\nnpm run dev",
        "context": "package=\"npm\""
      },
      {
        "language": "bash",
        "code": "yarn create next-app@latest my-app --yes\r\ncd my-app\r\nyarn dev",
        "context": "package=\"yarn\""
      },
      {
        "language": "bash",
        "code": "bun create next-app@latest my-app --yes\r\ncd my-app\r\nbun dev",
        "context": "package=\"bun\""
      },
      {
        "language": "bash",
        "code": "npx create-next-app@latest",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "txt",
        "code": "What is your project named? my-app\r\nWould you like to use the recommended Next.js defaults?\r\n    Yes, use recommended defaults - TypeScript, ESLint, Tailwind CSS, App Router, Turbopack\r\n    No, reuse previous settings\r\n    No, customize settings - Choose your own preferences",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "txt",
        "code": "Would you like to use TypeScript? No / Yes\r\nWhich linter would you like to use? ESLint / Biome / None\r\nWould you like to use React Compiler? No / Yes\r\nWould you like to use Tailwind CSS? No / Yes\r\nWould you like your code inside a `src/` directory? No / Yes\r\nWould you like to use App Router? (recommended) No / Yes\r\nWould you like to customize the import alias (`@/*` by default)? No / Yes\r\nWhat import alias would you like configured? @/*",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "pnpm i next@latest react@latest react-dom@latest",
        "context": "package=\"pnpm\""
      },
      {
        "language": "bash",
        "code": "npm i next@latest react@latest react-dom@latest",
        "context": "package=\"npm\""
      },
      {
        "language": "bash",
        "code": "yarn add next@latest react@latest react-dom@latest",
        "context": "package=\"yarn\""
      },
      {
        "language": "bash",
        "code": "bun add next@latest react@latest react-dom@latest",
        "context": "package=\"bun\""
      },
      {
        "language": "json",
        "code": "{\r\n  \"scripts\": {\r\n    \"dev\": \"next dev\",\r\n    \"build\": \"next build\",\r\n    \"start\": \"next start\",\r\n    \"lint\": \"eslint\",\r\n    \"lint:fix\": \"eslint --fix\"\r\n  }\r\n}",
        "context": "filename=\"package.json\""
      },
      {
        "language": "tsx",
        "code": "export default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default function Page() {\r\n  return <h1>Hello, Next.js!</h1>\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function Page() {\r\n  return <h1>Hello, Next.js!</h1>\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default function Page() {\r\n  return <h1>Hello, Next.js!</h1>\r\n}",
        "context": "filename=\"pages/index.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function Page() {\r\n  return <h1>Hello, Next.js!</h1>\r\n}",
        "context": "filename=\"pages/index.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import type { AppProps } from 'next/app'\r\n\r\nexport default function App({ Component, pageProps }: AppProps) {\r\n  return <Component {...pageProps} />\r\n}",
        "context": "filename=\"pages/_app.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function App({ Component, pageProps }) {\r\n  return <Component {...pageProps} />\r\n}",
        "context": "filename=\"pages/_app.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { Html, Head, Main, NextScript } from 'next/document'\r\n\r\nexport default function Document() {\r\n  return (\r\n    <Html>\r\n      <Head />\r\n      <body>\r\n        <Main />\r\n        <NextScript />\r\n      </body>\r\n    </Html>\r\n  )\r\n}",
        "context": "filename=\"pages/_document.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { Html, Head, Main, NextScript } from 'next/document'\r\n\r\nexport default function Document() {\r\n  return (\r\n    <Html>\r\n      <Head />\r\n      <body>\r\n        <Main />\r\n        <NextScript />\r\n      </body>\r\n    </Html>\r\n  )\r\n}",
        "context": "filename=\"pages/_document.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Image from 'next/image'\r\n\r\nexport default function Page() {\r\n  return <Image src=\"/profile.png\" alt=\"Profile\" width={100} height={100} />\r\n}",
        "context": "filename=\"app/page.tsx\" highlight={4} switcher"
      },
      {
        "language": "jsx",
        "code": "import Image from 'next/image'\r\n\r\nexport default function Page() {\r\n  return <Image src=\"/profile.png\" alt=\"Profile\" width={100} height={100} />\r\n}",
        "context": "filename=\"app/page.js\" highlight={4} switcher"
      },
      {
        "language": "json",
        "code": "{\r\n  \"scripts\": {\r\n    \"lint\": \"eslint\",\r\n    \"lint:fix\": \"eslint --fix\"\r\n  }\r\n}",
        "context": "filename=\"package.json\""
      },
      {
        "language": "json",
        "code": "{\r\n  \"scripts\": {\r\n    \"lint\": \"biome check\",\r\n    \"format\": \"biome format --write\"\r\n  }\r\n}",
        "context": "filename=\"package.json\""
      },
      {
        "language": "bash",
        "code": "npx @next/codemod@canary next-lint-to-eslint-cli .",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "jsx",
        "code": "// Before\r\nimport { Button } from '../../../components/button'\r\n\r\n// After\r\nimport { Button } from '@/components/button'",
        "context": ""
      },
      {
        "language": "json",
        "code": "{\r\n  \"compilerOptions\": {\r\n    \"baseUrl\": \"src/\"\r\n  }\r\n}",
        "context": "filename=\"tsconfig.json or jsconfig.json\""
      },
      {
        "language": "json",
        "code": "{\r\n  \"compilerOptions\": {\r\n    \"baseUrl\": \"src/\",\r\n    \"paths\": {\r\n      \"@/styles/*\": [\"styles/*\"],\r\n      \"@/components/*\": [\"components/*\"]\r\n    }\r\n  }\r\n}",
        "context": "filename=\"tsconfig.json or jsconfig.json\""
      }
    ],
    "content": "Create a new Next.js app and run it locally. Quick start 1. Create a new Next.js app named my-app 2. cd my-app and start the dev server. 3. Visit http://localhost:3000. - --yes skips prompts using saved preferences or defaults. The default setup enables TypeScript, Tailwind, App Router, and Turbopack, with import alias @/. System requirements Before you begin, make sure your system meets the following requirements: - Node.js 20.9 or later. - macOS, Windows (including WSL), or Linux. Create with the CLI The quickest way to create a new Next.js app is using create-next-app, which sets up everything automatically for you. To create a project, run: On installation, you'll see the following prompts: If you choose to customize settings, you'll see the following prompts: After the prompts, create-next-app will create a folder with your project name and install the required dependencies. Manual installation To manually create a new Next.js app, install the required packages: > Good to know: The App Router uses React canary releases built-in, which include all the stable React 19 changes, as well as newer features being validated in frameworks. The Pages Router uses the React version you install in package.json. Then, add the following scripts to your package.json file: These scripts refer to the different stages of developing an application: - next dev: Starts the development server using Turbopack (default bundler). - next build: Builds the application for production. - next start: Starts the production server. - eslint: Runs ESLint. Turbopack is now the default bundler. To use Webpack run next dev --webpack or next build --webpack. See the Turbopack docs for configuration details. Create the app directory Next.js uses file-system routing, which means the routes in your application are determined by how you structure your files. Create an app folder. Then, inside app, create a layout.tsx file. This file is the root layout. It's required and must contain the and tags. Create a home page app/page.tsx with some initial content: Both layout.tsx and page.tsx will be rendered when the user visits the root of your application (/). > Good to know: > > - If you forget to create the root layout, Next.js will automatically create this file when running the development server with next dev. > - You can optionally use a src folder in the root of your project to separate your application's code from configuration files. Create the pages directory Next.js uses file-system routing, which means the routes in your application are determined by how you structure your files. Create a pages directory at the root of your project. Then, add an index.tsx file inside your pages folder. This will be your home page (/): Next, add an app.tsx file inside pages/ to define the global layout. Learn more about the custom App file. Finally, add a document.tsx file inside pages/ to control the initial response from the server. Learn more about the custom Document file. Create the public folder (optional) Create a public folder at the root of your project to store static assets such as images, fonts, etc. Files inside public can then be referenced by your code starting from the base URL (/). You can then reference these assets using the root path (/). For example, public/profile.png can be referenced as /profile.png: Run the development server 1. Run npm run dev to start the development server. 2. Visit http://localhost:3000 to view your application. 3. Edit the app/page.tsxpages/index.tsx file and save it to see the updated result in your browser. Set up TypeScript > Minimum TypeScript version: v5.1.0 Next.js comes with built-in TypeScript support. To add TypeScript to your project, rename a file to .ts / .tsx and run next dev. Next.js will automatically install the necessary dependencies and add a tsconfig.json file with the recommended config options. IDE Plugin Next.js includes a custom TypeScript plugin and type checker, which VSCode and other code editors can use for advanced type-checking and auto-completion. You can enable the plugin in VS Code by: 1. Opening the command palette (Ctrl/⌘ + Shift + P) 2. Searching for \"TypeScript: Select TypeScript Version\" 3. Selecting \"Use Workspace Version\" See the TypeScript reference page for more information. Set up linting Next.js supports linting with either ESLint or Biome. Choose a linter and run it directly via package.json scripts. - Use ESLint (comprehensive rules): - Or use Biome (fast linter + formatter): If your project previously used next lint, migrate your scripts to the ESLint CLI with the codemod: If you use ESLint, create an explicit config (recommended eslint.config.mjs). ESLint supports both the legacy .eslintrc. and the newer eslint.config.mjs formats. See the ESLint API reference for a recommended setup. > Good to know: Starting with Next.js 16, next build no longer runs the linter automatically. Instead, you can run your linter through NPM scripts. See the ESLint Plugin page for more information. Set up Absolute Imports and Module Path Aliases Next.js has in-built support for the \"paths\" and \"baseUrl\" options of tsconfig.json and jsconfig.json files. These options allow you to alias project directories to absolute paths, making it easier and cleaner to import modules. For example: To configure absolute imports, add the baseUrl configuration option to your tsconfig.json or jsconfig.json file. For example: In addition to configuring the baseUrl path, you can use the \"paths\" option to \"alias\" module paths. For example, the following configuration maps @/components/ to components/: Each of the \"paths\" are relative to the baseUrl location.",
    "excerpt": "Create a new Next.js app and run it locally. Quick start 1. Create a new Next.js app named my-app 2. cd my-app and start the dev server. 3. Visit http://localhost:3000. - --yes skips prompts using sav...",
    "url": "https://nextjs.org/docs/01-app/01-getting-started/01-installation"
  },
  {
    "id": "01-app-01-getting-started-02-project-structure",
    "path": "01-app\\01-getting-started\\02-project-structure.mdx",
    "title": "Project structure and organization",
    "description": "Learn the folder and file conventions in Next.js, and how to organize your project.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Folder and file conventions",
        "slug": "folder-and-file-conventions"
      },
      {
        "level": 3,
        "text": "Top-level folders",
        "slug": "top-level-folders"
      },
      {
        "level": 3,
        "text": "Top-level files",
        "slug": "top-level-files"
      },
      {
        "level": 3,
        "text": "Routing Files",
        "slug": "routing-files"
      },
      {
        "level": 3,
        "text": "Nested routes",
        "slug": "nested-routes"
      },
      {
        "level": 3,
        "text": "Dynamic routes",
        "slug": "dynamic-routes"
      },
      {
        "level": 3,
        "text": "Route groups and private folders",
        "slug": "route-groups-and-private-folders"
      },
      {
        "level": 3,
        "text": "Parallel and Intercepted Routes",
        "slug": "parallel-and-intercepted-routes"
      },
      {
        "level": 3,
        "text": "Metadata file conventions",
        "slug": "metadata-file-conventions"
      },
      {
        "level": 4,
        "text": "App icons",
        "slug": "app-icons"
      },
      {
        "level": 4,
        "text": "Open Graph and Twitter images",
        "slug": "open-graph-and-twitter-images"
      },
      {
        "level": 4,
        "text": "SEO",
        "slug": "seo"
      },
      {
        "level": 3,
        "text": "File conventions",
        "slug": "file-conventions"
      },
      {
        "level": 3,
        "text": "Routes",
        "slug": "routes"
      },
      {
        "level": 3,
        "text": "Dynamic routes",
        "slug": "dynamic-routes"
      },
      {
        "level": 2,
        "text": "Organizing your project",
        "slug": "organizing-your-project"
      },
      {
        "level": 3,
        "text": "Component hierarchy",
        "slug": "component-hierarchy"
      },
      {
        "level": 3,
        "text": "Colocation",
        "slug": "colocation"
      },
      {
        "level": 3,
        "text": "Private folders",
        "slug": "private-folders"
      },
      {
        "level": 3,
        "text": "Route groups",
        "slug": "route-groups"
      },
      {
        "level": 3,
        "text": " folder",
        "slug": "-folder"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Store project files outside of ",
        "slug": "store-project-files-outside-of-"
      },
      {
        "level": 3,
        "text": "Store project files in top-level folders inside of ",
        "slug": "store-project-files-in-top-level-folders-inside-of-"
      },
      {
        "level": 3,
        "text": "Split project files by feature or route",
        "slug": "split-project-files-by-feature-or-route"
      },
      {
        "level": 3,
        "text": "Organize routes without affecting the URL path",
        "slug": "organize-routes-without-affecting-the-url-path"
      },
      {
        "level": 3,
        "text": "Opting specific segments into a layout",
        "slug": "opting-specific-segments-into-a-layout"
      },
      {
        "level": 3,
        "text": "Opting for loading skeletons on a specific route",
        "slug": "opting-for-loading-skeletons-on-a-specific-route"
      },
      {
        "level": 3,
        "text": "Creating multiple root layouts",
        "slug": "creating-multiple-root-layouts"
      }
    ],
    "codeBlocks": [],
    "content": "This page provides an overview of all the folder and file conventions in Next.js, and recommendations for organizing your project. Folder and file conventions Top-level folders Top-level folders are used to organize your application's code and static assets. | | | | ------------------------------------------------------------------ | ---------------------------------- | | app | App Router | | pages | Pages Router | | public | Static assets to be served | | src | Optional application source folder | Top-level files Top-level files are used to configure your application, manage dependencies, run proxy, integrate monitoring tools, and define environment variables. | | | | ---------------------------------------------------------------------------- | --------------------------------------- | | Next.js | | | next.config.js | Configuration file for Next.js | | package.json | Project dependencies and scripts | | instrumentation.ts | OpenTelemetry and Instrumentation file | | proxy.ts | Next.js request proxy | | .env | Environment variables | | .env.local | Local environment variables | | .env.production | Production environment variables | | .env.development | Development environment variables | | eslint.config.mjs | Configuration file for ESLint | | .gitignore | Git files and folders to ignore | | next-env.d.ts | TypeScript declaration file for Next.js | | tsconfig.json | Configuration file for TypeScript | | jsconfig.json | Configuration file for JavaScript | Routing Files Add page to expose a route, layout for shared UI such as header, nav, or footer, loading for skeletons, error for error boundaries, and route for APIs. | | | | | ----------------------------------------------------------------------------- | ------------------- | ---------------------------- | | layout | .js .jsx .tsx | Layout | | page | .js .jsx .tsx | Page | | loading | .js .jsx .tsx | Loading UI | | not-found | .js .jsx .tsx | Not found UI | | error | .js .jsx .tsx | Error UI | | global-error | .js .jsx .tsx | Global error UI | | route | .js .ts | API endpoint | | template | .js .jsx .tsx | Re-rendered layout | | default | .js .jsx .tsx | Parallel route fallback page | Nested routes Folders define URL segments. Nesting folders nests segments. Layouts at any level wrap their child segments. A route becomes public when a page or route file exists. | Path | URL pattern | Notes | | --------------------------- | --------------- | ----------------------------- | | app/layout.tsx | — | Root layout wraps all routes | | app/blog/layout.tsx | — | Wraps /blog and descendants | | app/page.tsx | / | Public route | | app/blog/page.tsx | /blog | Public route | | app/blog/authors/page.tsx | /blog/authors | Public route | Dynamic routes Parameterize segments with square brackets. Use [segment] for a single param, [...segment] for catch‑all, and [[...segment]] for optional catch‑all. Access values via the params prop. | Path | URL pattern | | ------------------------------- | -------------------------------------------------------------------- | | app/blog/[slug]/page.tsx | /blog/my-first-post | | app/shop/[...slug]/page.tsx | /shop/clothing, /shop/clothing/shirts | | app/docs/[[...slug]]/page.tsx | /docs, /docs/layouts-and-pages, /docs/api-reference/use-router | Route groups and private folders Organize code without changing URLs with route groups (group), and colocate non-routable files with private folders folder. | Path | URL pattern | Notes | | ------------------------------- | ----------- | ----------------------------------------- | | app/(marketing)/page.tsx | / | Group omitted from URL | | app/(shop)/cart/page.tsx | /cart | Share layouts within (shop) | | app/blog/components/Post.tsx | — | Not routable; safe place for UI utilities | | app/blog/lib/data.ts | — | Not routable; safe place for utils | Parallel and Intercepted Routes These features fit specific UI patterns, such as slot-based layouts or modal routing. Use @slot for named slots rendered by a parent layout. Use intercept patterns to render another route inside the current layout without changing the URL, for example, to show a details view as a modal over a list. | Pattern (docs) | Meaning | Typical use case | | ------------------------------------------------------------------------------------------- | -------------------- | ---------------------------------------- | | @folder | Named slot | Sidebar + main content | | (.)folder | Intercept same level | Preview sibling route in a modal | | (..)folder | Intercept parent | Open a child of the parent as an overlay | | (..)(..)folder | Intercept two levels | Deeply nested overlay | | (...)folder | Intercept from root | Show arbitrary route in current view | Metadata file conventions App icons | | | | | --------------------------------------------------------------------------------------------------------------- | ----------------------------------- | ------------------------ | | favicon | .ico | Favicon file | | icon | .ico .jpg .jpeg .png .svg | App Icon file | | icon | .js .ts .tsx | Generated App Icon | | apple-icon | .jpg .jpeg, .png | Apple App Icon file | | apple-icon | .js .ts .tsx | Generated Apple App Icon | Open Graph and Twitter images | | | | | --------------------------------------------------------------------------------------------------------------------------- | ---------------------------- | -------------------------- | | opengraph-image | .jpg .jpeg .png .gif | Open Graph image file | | opengraph-image | .js .ts .tsx | Generated Open Graph image | | twitter-image | .jpg .jpeg .png .gif | Twitter image file | | twitter-image | .js .ts .tsx | Generated Twitter image | SEO | | | | | ------------------------------------------------------------------------------------------------------------ | ----------- | --------------------- | | sitemap | .xml | Sitemap file | | sitemap | .js .ts | Generated Sitemap | | robots | .txt | Robots file | | robots | .js .ts | Generated Robots file | File conventions | | | | | ----------------------------------------------------------------------------------------------------------- | ------------------- | ----------------- | | app | .js .jsx .tsx | Custom App | | document | .js .jsx .tsx | Custom Document | | error | .js .jsx .tsx | Custom Error Page | | 404 | .js .jsx .tsx | 404 Error Page | | 500 | .js .jsx .tsx | 500 Error Page | Routes | | | | | ---------------------------------------------------------------------------------------------- | ------------------- | ----------- | | Folder convention | | | | index | .js .jsx .tsx | Home page | | folder/index | .js .jsx .tsx | Nested page | | File convention | | | | index | .js .jsx .tsx | Home page | | file | .js .jsx .tsx | Nested page | Dynamic routes | | | | | ----------------------------------------------------------------------------------------------------------------- | ------------------- | -------------------------------- | | Folder convention | | | | [[folder]/index](/docs/pages/building-your-application/routing/dynamic-routes) | .js .jsx .tsx | Dynamic route segment | | [[...folder]/index](/docs/pages/building-your-application/routing/dynamic-routescatch-all-segments) | .js .jsx .tsx | Catch-all route segment | | [[[...folder]]/index](/docs/pages/building-your-application/routing/dynamic-routesoptional-catch-all-segments) | .js .jsx .tsx | Optional catch-all route segment | | File convention | | | | [[file]](/docs/pages/building-your-application/routing/dynamic-routes) | .js .jsx .tsx | Dynamic route segment | | [[...file]](/docs/pages/building-your-application/routing/dynamic-routescatch-all-segments) | .js .jsx .tsx | Catch-all route segment | | [[[...file]]](/docs/pages/building-your-application/routing/dynamic-routesoptional-catch-all-segments) | .js .jsx .tsx | Optional catch-all route segment | Organizing your project Next.js is unopinionated about how you organize and colocate your project files. But it does provide several features to help you organize your project. Component hierarchy The components defined in special files are rendered in a specific hierarchy: - layout.js - template.js - error.js (React error boundary) - loading.js (React suspense boundary) - not-found.js (React error boundary for \"not found\" UI) - page.js or nested layout.js The components are rendered recursively in nested routes, meaning the components of a route segment will be nested inside the components of its parent segment. Colocation In the app directory, nested folders define route structure. Each folder represents a route segment that is mapped to a corresponding segment in a URL path. However, even though route structure is defined through folders, a route is not publicly accessible until a page.js or route.js file is added to a route segment. And, even when a route is made publicly accessible, only the content returned by page.js or route.js is sent to the client. This means that project files can be safely colocated inside route segments in the app directory without accidentally being routable. > Good to know: While you can colocate your project files in app you don't have to. If you prefer, you can keep them outside the app directory. Private folders Private folders can be created by prefixing a folder with an underscore: folderName This indicates the folder is a private implementation detail and should not be considered by the routing system, thereby opting the folder and all its subfolders out of routing. Since files in the app directory can be safely colocated by default, private folders are not required for colocation. However, they can be useful for: - Separating UI logic from routing logic. - Consistently organizing internal files across a project and the Next.js ecosystem. - Sorting and grouping files in code editors. - Avoiding potential naming conflicts with future Next.js file conventions. > Good to know: > > - While not a framework convention, you might also consider marking files outside private folders as \"private\" using the same underscore pattern. > - You can create URL segments that start with an underscore by prefixing the folder name with %5F (the URL-encoded form of an underscore): %5FfolderName. > - If you don't use private folders, it would be helpful to know Next.js special file conventions to prevent unexpected naming conflicts. Route groups Route groups can be created by wrapping a folder in parenthesis: (folderName) This indicates the folder is for organizational purposes and should not be included in the route's URL path. Route groups are useful for: - Organizing routes by site section, intent, or team. e.g. marketing pages, admin pages, etc. - Enabling nested layouts in the same route segment level: - Creating multiple nested layouts in the same segment, including multiple root layouts - Adding a layout to a subset of routes in a common segment src folder Next.js supports storing application code (including app) inside an optional src folder. This separates application code from project configuration files which mostly live in the root of a project. Examples The following section lists a very high-level overview of common strategies. The simplest takeaway is to choose a strategy that works for you and your team and be consistent across the project. > Good to know: In our examples below, we're using components and lib folders as generalized placeholders, their naming has no special framework significance and your projects might use other folders like ui, utils, hooks, styles, etc. Store project files outside of app This strategy stores all application code in shared folders in the root of your project and keeps the app directory purely for routing purposes. Store project files in top-level folders inside of app This strategy stores all application code in shared folders in the root of the app directory. Split project files by feature or route This strategy stores globally shared application code in the root app directory and splits more specific application code into the route segments that use them. Organize routes without affecting the URL path To organize routes without affecting the URL, create a group to keep related routes together. The folders in parenthesis will be omitted from the URL (e.g. (marketing) or (shop)). Even though routes inside (marketing) and (shop) share the same URL hierarchy, you can create a different layout for each group by adding a layout.js file inside their folders. Opting specific segments into a layout To opt specific routes into a layout, create a new route group (e.g. (shop)) and move the routes that share the same layout into the group (e.g. account and cart). The routes outside of the group will not share the layout (e.g. checkout). Opting for loading skeletons on a specific route To apply a loading skeleton via a loading.js file to a specific route, create a new route group (e.g., /(overview)) and then move your loading.tsx inside that route group. Now, the loading.tsx file will only apply to your dashboard → overview page instead of all your dashboard pages without affecting the URL path structure. Creating multiple root layouts To create multiple root layouts, remove the top-level layout.js file, and add a layout.js file inside each route group. This is useful for partitioning an application into sections that have a completely different UI or experience. The and tags need to be added to each root layout. In the example above, both (marketing) and (shop) have their own root layout.",
    "excerpt": "This page provides an overview of all the folder and file conventions in Next.js, and recommendations for organizing your project. Folder and file conventions Top-level folders Top-level folders are u...",
    "url": "https://nextjs.org/docs/01-app/01-getting-started/02-project-structure"
  },
  {
    "id": "01-app-01-getting-started-03-layouts-and-pages",
    "path": "01-app\\01-getting-started\\03-layouts-and-pages.mdx",
    "title": "Layouts and Pages",
    "description": "Learn how to create your first pages and layouts, and link between them with the Link component.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Creating a page",
        "slug": "creating-a-page"
      },
      {
        "level": 2,
        "text": "Creating a layout",
        "slug": "creating-a-layout"
      },
      {
        "level": 2,
        "text": "Creating a nested route",
        "slug": "creating-a-nested-route"
      },
      {
        "level": 2,
        "text": "Nesting layouts",
        "slug": "nesting-layouts"
      },
      {
        "level": 2,
        "text": "Creating a dynamic segment",
        "slug": "creating-a-dynamic-segment"
      },
      {
        "level": 2,
        "text": "Rendering with search params",
        "slug": "rendering-with-search-params"
      },
      {
        "level": 3,
        "text": "What to use and when",
        "slug": "what-to-use-and-when"
      },
      {
        "level": 2,
        "text": "Linking between pages",
        "slug": "linking-between-pages"
      },
      {
        "level": 2,
        "text": "Route Props Helpers",
        "slug": "route-props-helpers"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "export default function Page() {\r\n  return <h1>Hello Next.js!</h1>\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function Page() {\r\n  return <h1>Hello Next.js!</h1>\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default function DashboardLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>\r\n        {/* Layout UI */}\r\n        {/* Place children where you want to render a page or nested layout */}\r\n        <main>{children}</main>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function DashboardLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>\r\n        {/* Layout UI */}\r\n        {/* Place children where you want to render a page or nested layout */}\r\n        <main>{children}</main>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "// Dummy imports\r\nimport { getPosts } from '@/lib/posts'\r\nimport { Post } from '@/ui/post'\r\n\r\nexport default async function Page() {\r\n  const posts = await getPosts()\r\n\r\n  return (\r\n    <ul>\r\n      {posts.map((post) => (\r\n        <Post key={post.id} post={post} />\r\n      ))}\r\n    </ul>\r\n  )\r\n}",
        "context": "filename=\"app/blog/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "// Dummy imports\r\nimport { getPosts } from '@/lib/posts'\r\nimport { Post } from '@/ui/post'\r\n\r\nexport default async function Page() {\r\n  const posts = await getPosts()\r\n\r\n  return (\r\n    <ul>\r\n      {posts.map((post) => (\r\n        <Post key={post.id} post={post} />\r\n      ))}\r\n    </ul>\r\n  )\r\n}",
        "context": "filename=\"app/blog/[slug]/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "function generateStaticParams() {}\r\n\r\nexport default function Page() {\r\n  return <h1>Hello, Blog Post Page!</h1>\r\n}",
        "context": "filename=\"app/blog/[slug]/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "function generateStaticParams() {}\r\n\r\nexport default function Page() {\r\n  return <h1>Hello, Blog Post Page!</h1>\r\n}",
        "context": "filename=\"app/blog/[slug]/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default function BlogLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return <section>{children}</section>\r\n}",
        "context": "filename=\"app/blog/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function BlogLayout({ children }) {\r\n  return <section>{children}</section>\r\n}",
        "context": "filename=\"app/blog/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default async function BlogPostPage({\r\n  params,\r\n}: {\r\n  params: Promise<{ slug: string }>\r\n}) {\r\n  const { slug } = await params\r\n  const post = await getPost(slug)\r\n\r\n  return (\r\n    <div>\r\n      <h1>{post.title}</h1>\r\n      <p>{post.content}</p>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/blog/[slug]/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default async function BlogPostPage({ params }) {\r\n  const { slug } = await params\r\n  const post = await getPost(slug)\r\n\r\n  return (\r\n    <div>\r\n      <h1>{post.title}</h1>\r\n      <p>{post.content}</p>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/blog/[slug]/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default async function Page({\r\n  searchParams,\r\n}: {\r\n  searchParams: Promise<{ [key: string]: string | string[] | undefined }>\r\n}) {\r\n  const filters = (await searchParams).filters\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default async function Page({ searchParams }) {\r\n  const filters = (await searchParams).filters\r\n}",
        "context": "filename=\"app/page.jsx\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default async function Post({ post }) {\r\n  const posts = await getPosts()\r\n\r\n  return (\r\n    <ul>\r\n      {posts.map((post) => (\r\n        <li key={post.slug}>\r\n          <Link href={`/blog/${post.slug}`}>{post.title}</Link>\r\n        </li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}",
        "context": "filename=\"app/ui/post.tsx\" highlight={1,10} switcher"
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default async function Post({ post }) {\r\n  const posts = await getPosts()\r\n\r\n  return (\r\n    <ul>\r\n      {posts.map((post) => (\r\n        <li key={post.slug}>\r\n          <Link href={`/blog/${post.slug}`}>{post.title}</Link>\r\n        </li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}",
        "context": "filename=\"app/ui/post.js\" highlight={1,10}  switcher"
      },
      {
        "language": "tsx",
        "code": "export default async function Page(props: PageProps<'/blog/[slug]'>) {\r\n  const { slug } = await props.params\r\n  return <h1>Blog post: {slug}</h1>\r\n}",
        "context": "filename=\"app/blog/[slug]/page.tsx\""
      },
      {
        "language": "tsx",
        "code": "export default function Layout(props: LayoutProps<'/dashboard'>) {\r\n  return (\r\n    <section>\r\n      {props.children}\r\n      {/* If you have app/dashboard/@analytics, it appears as a typed slot: */}\r\n      {/* {props.analytics} */}\r\n    </section>\r\n  )\r\n}",
        "context": "filename=\"app/dashboard/layout.tsx\""
      }
    ],
    "content": "Next.js uses file-system based routing, meaning you can use folders and files to define routes. This page will guide you through how to create layouts and pages, and link between them. Creating a page A page is UI that is rendered on a specific route. To create a page, add a page file inside the app directory and default export a React component. For example, to create an index page (/): Creating a layout A layout is UI that is shared between multiple pages. On navigation, layouts preserve state, remain interactive, and do not rerender. You can define a layout by default exporting a React component from a layout file. The component should accept a children prop which can be a page or another layout. For example, to create a layout that accepts your index page as child, add a layout file inside the app directory: The layout above is called a root layout because it's defined at the root of the app directory. The root layout is required and must contain html and body tags. Creating a nested route A nested route is a route composed of multiple URL segments. For example, the /blog/[slug] route is composed of three segments: - / (Root Segment) - blog (Segment) - [slug] (Leaf Segment) In Next.js: - Folders are used to define the route segments that map to URL segments. - Files (like page and layout) are used to create UI that is shown for a segment. To create nested routes, you can nest folders inside each other. For example, to add a route for /blog, create a folder called blog in the app directory. Then, to make /blog publicly accessible, add a page.tsx file: You can continue nesting folders to create nested routes. For example, to create a route for a specific blog post, create a new [slug] folder inside blog and add a page file: Wrapping a folder name in square brackets (e.g. [slug]) creates a dynamic route segment which is used to generate multiple pages from data. e.g. blog posts, product pages, etc. Nesting layouts By default, layouts in the folder hierarchy are also nested, which means they wrap child layouts via their children prop. You can nest layouts by adding layout inside specific route segments (folders). For example, to create a layout for the /blog route, add a new layout file inside the blog folder. If you were to combine the two layouts above, the root layout (app/layout.js) would wrap the blog layout (app/blog/layout.js), which would wrap the blog (app/blog/page.js) and blog post page (app/blog/[slug]/page.js). Creating a dynamic segment Dynamic segments allow you to create routes that are generated from data. For example, instead of manually creating a route for each individual blog post, you can create a dynamic segment to generate the routes based on blog post data. To create a dynamic segment, wrap the segment (folder) name in square brackets: [segmentName]. For example, in the app/blog/[slug]/page.tsx route, the [slug] is the dynamic segment. Learn more about Dynamic Segments and the params props. Nested layouts within Dynamic Segments, can also access the params props. Rendering with search params In a Server Component page, you can access search parameters using the searchParams prop: Using searchParams opts your page into dynamic rendering because it requires a incoming request to read the search parameters from. Client Components can read search params using the useSearchParams hook. Learn more about useSearchParams in statically rendered and dynamically rendered routes. What to use and when - Use the searchParams prop when you need search parameters to load data for the page (e.g. pagination, filtering from a database). - Use useSearchParams when search parameters are used only on the client (e.g. filtering a list already loaded via props). - As a small optimization, you can use new URLSearchParams(window.location.search) in callbacks or event handlers to read search params without triggering re-renders. Linking between pages You can use the component to navigate between routes. is a built-in Next.js component that extends the HTML tag to provide prefetching and client-side navigation. For example, to generate a list of blog posts, import from next/link and pass a href prop to the component: > Good to know: is the primary way to navigate between routes in Next.js. You can also use the useRouter hook for more advanced navigation. Route Props Helpers Next.js exposes utility types that infer params and named slots from your route structure: - PageProps: Props for page components, including params and searchParams. - LayoutProps: Props for layout components, including children and any named slots (e.g. folders like @analytics). These are globally available helpers, generated when running either next dev, next build or next typegen. > Good to know > > - Static routes resolve params to {}. > - PageProps, LayoutProps are global helpers — no imports required. > - Types are generated during next dev, next build or next typegen.",
    "excerpt": "Next.js uses file-system based routing, meaning you can use folders and files to define routes. This page will guide you through how to create layouts and pages, and link between them. Creating a page...",
    "url": "https://nextjs.org/docs/01-app/01-getting-started/03-layouts-and-pages"
  },
  {
    "id": "01-app-01-getting-started-04-linking-and-navigating",
    "path": "01-app\\01-getting-started\\04-linking-and-navigating.mdx",
    "title": "Linking and Navigating",
    "description": "Learn how the built-in navigation optimizations work, including prefetching, prerendering, and client-side navigation, and how to optimize navigation for dynamic routes and slow networks.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "How navigation works",
        "slug": "how-navigation-works"
      },
      {
        "level": 3,
        "text": "Server Rendering",
        "slug": "server-rendering"
      },
      {
        "level": 3,
        "text": "Prefetching",
        "slug": "prefetching"
      },
      {
        "level": 3,
        "text": "Streaming",
        "slug": "streaming"
      },
      {
        "level": 3,
        "text": "Client-side transitions",
        "slug": "client-side-transitions"
      },
      {
        "level": 2,
        "text": "What can make transitions slow?",
        "slug": "what-can-make-transitions-slow"
      },
      {
        "level": 3,
        "text": "Dynamic routes without ",
        "slug": "dynamic-routes-without-"
      },
      {
        "level": 3,
        "text": "Dynamic segments without ",
        "slug": "dynamic-segments-without-"
      },
      {
        "level": 3,
        "text": "Slow networks",
        "slug": "slow-networks"
      },
      {
        "level": 3,
        "text": "Disabling prefetching",
        "slug": "disabling-prefetching"
      },
      {
        "level": 3,
        "text": "Hydration not completed",
        "slug": "hydration-not-completed"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Native History API",
        "slug": "native-history-api"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Layout({ children }: { children: React.ReactNode }) {\r\n  return (\r\n    <html>\r\n      <body>\r\n        <nav>\r\n          {/* Prefetched when the link is hovered or enters the viewport */}\r\n          <Link href=\"/blog\">Blog</Link>\r\n          {/* No prefetching */}\r\n          <a href=\"/contact\">Contact</a>\r\n        </nav>\r\n        {children}\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Layout() {\r\n  return (\r\n    <html>\r\n      <body>\r\n        <nav>\r\n          {/* Prefetched when the link is hovered or enters the viewport */}\r\n          <Link href=\"/blog\">Blog</Link>\r\n          {/* No prefetching */}\r\n          <a href=\"/contact\">Contact</a>\r\n        </nav>\r\n        {children}\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default function Loading() {\r\n  // Add fallback UI that will be shown while the route is loading.\r\n  return <LoadingSkeleton />\r\n}",
        "context": "filename=\"app/dashboard/loading.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function Loading() {\r\n  // Add fallback UI that will be shown while the route is loading.\r\n  return <LoadingSkeleton />\r\n}",
        "context": "filename=\"app/dashboard/loading.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default function Loading() {\r\n  return <LoadingSkeleton />\r\n}",
        "context": "filename=\"app/blog/[slug]/loading.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function Loading() {\r\n  return <LoadingSkeleton />\r\n}",
        "context": "filename=\"app/blog/[slug]/loading.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export async function generateStaticParams() {\r\n  const posts = await fetch('https://.../posts').then((res) => res.json())\r\n\r\n  return posts.map((post) => ({\r\n    slug: post.slug,\r\n  }))\r\n}\r\n\r\nexport default async function Page({\r\n  params,\r\n}: {\r\n  params: Promise<{ slug: string }>\r\n}) {\r\n  const { slug } = await params\r\n  // ...\r\n}",
        "context": "filename=\"app/blog/[slug]/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export async function generateStaticParams() {\r\n  const posts = await fetch('https://.../posts').then((res) => res.json())\r\n\r\n  return posts.map((post) => ({\r\n    slug: post.slug,\r\n  }))\r\n\r\nexport default async function Page({ params }) {\r\n  const { slug } = await params\r\n  // ...\r\n}",
        "context": "filename=\"app/blog/[slug]/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { useLinkStatus } from 'next/link'\r\n\r\nexport default function LoadingIndicator() {\r\n  const { pending } = useLinkStatus()\r\n  return (\r\n    <span aria-hidden className={`link-hint ${pending ? 'is-pending' : ''}`} />\r\n  )\r\n}",
        "context": "filename=\"app/ui/loading-indicator.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { useLinkStatus } from 'next/link'\r\n\r\nexport default function LoadingIndicator() {\r\n  const { pending } = useLinkStatus()\r\n  return (\r\n    <span aria-hidden className={`link-hint ${pending ? 'is-pending' : ''}`} />\r\n  )\r\n}",
        "context": "filename=\"app/ui/loading-indicator.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "<Link prefetch={false} href=\"/blog\">\r\n  Blog\r\n</Link>",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport Link from 'next/link'\r\nimport { useState } from 'react'\r\n\r\nfunction HoverPrefetchLink({\r\n  href,\r\n  children,\r\n}: {\r\n  href: string\r\n  children: React.ReactNode\r\n}) {\r\n  const [active, setActive] = useState(false)\r\n\r\n  return (\r\n    <Link\r\n      href={href}\r\n      prefetch={active ? null : false}\r\n      onMouseEnter={() => setActive(true)}\r\n    >\r\n      {children}\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"app/ui/hover-prefetch-link.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport Link from 'next/link'\r\nimport { useState } from 'react'\r\n\r\nfunction HoverPrefetchLink({ href, children }) {\r\n  const [active, setActive] = useState(false)\r\n\r\n  return (\r\n    <Link\r\n      href={href}\r\n      prefetch={active ? null : false}\r\n      onMouseEnter={() => setActive(true)}\r\n    >\r\n      {children}\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"app/ui/hover-prefetch-link.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { useSearchParams } from 'next/navigation'\r\n\r\nexport default function SortProducts() {\r\n  const searchParams = useSearchParams()\r\n\r\n  function updateSorting(sortOrder: string) {\r\n    const params = new URLSearchParams(searchParams.toString())\r\n    params.set('sort', sortOrder)\r\n    window.history.pushState(null, '', `?${params.toString()}`)\r\n  }\r\n\r\n  return (\r\n    <>\r\n      <button onClick={() => updateSorting('asc')}>Sort Ascending</button>\r\n      <button onClick={() => updateSorting('desc')}>Sort Descending</button>\r\n    </>\r\n  )\r\n}",
        "context": "fileName=\"app/ui/sort-products.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { useSearchParams } from 'next/navigation'\r\n\r\nexport default function SortProducts() {\r\n  const searchParams = useSearchParams()\r\n\r\n  function updateSorting(sortOrder) {\r\n    const params = new URLSearchParams(searchParams.toString())\r\n    params.set('sort', sortOrder)\r\n    window.history.pushState(null, '', `?${params.toString()}`)\r\n  }\r\n\r\n  return (\r\n    <>\r\n      <button onClick={() => updateSorting('asc')}>Sort Ascending</button>\r\n      <button onClick={() => updateSorting('desc')}>Sort Descending</button>\r\n    </>\r\n  )\r\n}",
        "context": "fileName=\"app/ui/sort-products.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { usePathname } from 'next/navigation'\r\n\r\nexport function LocaleSwitcher() {\r\n  const pathname = usePathname()\r\n\r\n  function switchLocale(locale: string) {\r\n    // e.g. '/en/about' or '/fr/contact'\r\n    const newPath = `/${locale}${pathname}`\r\n    window.history.replaceState(null, '', newPath)\r\n  }\r\n\r\n  return (\r\n    <>\r\n      <button onClick={() => switchLocale('en')}>English</button>\r\n      <button onClick={() => switchLocale('fr')}>French</button>\r\n    </>\r\n  )\r\n}",
        "context": "fileName=\"app/ui/locale-switcher.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { usePathname } from 'next/navigation'\r\n\r\nexport function LocaleSwitcher() {\r\n  const pathname = usePathname()\r\n\r\n  function switchLocale(locale) {\r\n    // e.g. '/en/about' or '/fr/contact'\r\n    const newPath = `/${locale}${pathname}`\r\n    window.history.replaceState(null, '', newPath)\r\n  }\r\n\r\n  return (\r\n    <>\r\n      <button onClick={() => switchLocale('en')}>English</button>\r\n      <button onClick={() => switchLocale('fr')}>French</button>\r\n    </>\r\n  )\r\n}",
        "context": "fileName=\"app/ui/locale-switcher.js\" switcher"
      }
    ],
    "content": "In Next.js, routes are rendered on the server by default. This often means the client has to wait for a server response before a new route can be shown. Next.js comes with built-in prefetching, streaming, and client-side transitions ensuring navigation stays fast and responsive. This guide explains how navigation works in Next.js and how you can optimize it for dynamic routes and slow networks. How navigation works To understand how navigation works in Next.js, it helps to be familiar with the following concepts: - Server Rendering - Prefetching - Streaming - Client-side transitions Server Rendering In Next.js, Layouts and Pages are React Server Components by default. On initial and subsequent navigations, the Server Component Payload is generated on the server before being sent to the client. There are two types of server rendering, based on when it happens: - Static Rendering (or Prerendering) happens at build time or during revalidation and the result is cached. - Dynamic Rendering happens at request time in response to a client request. The trade-off of server rendering is that the client must wait for the server to respond before the new route can be shown. Next.js addresses this delay by prefetching routes the user is likely to visit and performing client-side transitions. > Good to know: HTML is also generated for the initial visit. Prefetching Prefetching is the process of loading a route in the background before the user navigates to it. This makes navigation between routes in your application feel instant, because by the time a user clicks on a link, the data to render the next route is already available client side. Next.js automatically prefetches routes linked with the component when they enter the user's viewport. How much of the route is prefetched depends on whether it's static or dynamic: - Static Route: the full route is prefetched. - Dynamic Route: prefetching is skipped, or the route is partially prefetched if loading.tsx is present. By skipping or partially prefetching dynamic routes, Next.js avoids unnecessary work on the server for routes the users may never visit. However, waiting for a server response before navigation can give the users the impression that the app is not responding. To improve the navigation experience to dynamic routes, you can use streaming. Streaming Streaming allows the server to send parts of a dynamic route to the client as soon as they're ready, rather than waiting for the entire route to be rendered. This means users see something sooner, even if parts of the page are still loading. For dynamic routes, it means they can be partially prefetched. That is, shared layouts and loading skeletons can be requested ahead of time. To use streaming, create a loading.tsx in your route folder: Behind the scenes, Next.js will automatically wrap the page.tsx contents in a boundary. The prefetched fallback UI will be shown while the route is loading, and swapped for the actual content once ready. > Good to know: You can also use to create loading UI for nested components. Benefits of loading.tsx: - Immediate navigation and visual feedback for the user. - Shared layouts remain interactive and navigation is interruptible. - Improved Core Web Vitals: TTFB, FCP, and TTI. To further improve the navigation experience, Next.js performs a client-side transition with the component. Client-side transitions Traditionally, navigation to a server-rendered page triggers a full page load. This clears state, resets scroll position, and blocks interactivity. Next.js avoids this with client-side transitions using the component. Instead of reloading the page, it updates the content dynamically by: - Keeping any shared layouts and UI. - Replacing the current page with the prefetched loading state or a new page if available. Client-side transitions are what makes a server-rendered apps feel like client-rendered apps. And when paired with prefetching and streaming, it enables fast transitions, even for dynamic routes. What can make transitions slow? These Next.js optimizations make navigation fast and responsive. However, under certain conditions, transitions can still feel slow. Here are some common causes and how to improve the user experience: Dynamic routes without loading.tsx When navigating to a dynamic route, the client must wait for the server response before showing the result. This can give the users the impression that the app is not responding. We recommend adding loading.tsx to dynamic routes to enable partial prefetching, trigger immediate navigation, and display a loading UI while the route renders. > Good to know: In development mode, you can use the Next.js Devtools to identify if the route is static or dynamic. See devIndicators for more information. Dynamic segments without generateStaticParams If a dynamic segment could be prerendered but isn't because it's missing generateStaticParams, the route will fallback to dynamic rendering at request time. Ensure the route is statically generated at build time by adding generateStaticParams: Slow networks On slow or unstable networks, prefetching may not finish before the user clicks a link. This can affect both static and dynamic routes. In these cases, the loading.js fallback may not appear immediately because it hasn't been prefetched yet. To improve perceived performance, you can use the useLinkStatus hook to show immediate feedback while the transition is in progress. You can \"debounce\" the hint by adding an initial animation delay (e.g. 100ms) and starting as invisible (e.g. opacity: 0). This means the loading indicator will only be shown if the navigation takes longer than the specified delay. See the useLinkStatus reference for a CSS example. > Good to know: You can use other visual feedback patterns like a progress bar. View an example here. Disabling prefetching You can opt out of prefetching by setting the prefetch prop to false on the component. This is useful to avoid unnecessary usage of resources when rendering large lists of links (e.g. an infinite scroll table). However, disabling prefetching comes with trade-offs: - Static routes will only be fetched when the user clicks the link. - Dynamic routes will need to be rendered on the server first before the client can navigate to it. To reduce resource usage without fully disabling prefetch, you can prefetch only on hover. This limits prefetching to routes the user is more likely to visit, rather than all links in the viewport. Hydration not completed is a Client Component and must be hydrated before it can prefetch routes. On the initial visit, large JavaScript bundles can delay hydration, preventing prefetching from starting right away. React mitigates this with Selective Hydration and you can further improve this by: - Using the @next/bundle-analyzer plugin to identify and reduce bundle size by removing large dependencies. - Moving logic from the client to the server where possible. See the Server and Client Components docs for guidance. Examples Native History API Next.js allows you to use the native window.history.pushState and window.history.replaceState methods to update the browser's history stack without reloading the page. pushState and replaceState calls integrate into the Next.js Router, allowing you to sync with usePathname and useSearchParams. window.history.pushState Use it to add a new entry to the browser's history stack. The user can navigate back to the previous state. For example, to sort a list of products: window.history.replaceState Use it to replace the current entry on the browser's history stack. The user is not able to navigate back to the previous state. For example, to switch the application's locale:",
    "excerpt": "In Next.js, routes are rendered on the server by default. This often means the client has to wait for a server response before a new route can be shown. Next.js comes with built-in prefetching, stream...",
    "url": "https://nextjs.org/docs/01-app/01-getting-started/04-linking-and-navigating"
  },
  {
    "id": "01-app-01-getting-started-05-server-and-client-components",
    "path": "01-app\\01-getting-started\\05-server-and-client-components.mdx",
    "title": "Server and Client Components",
    "description": "Learn how you can use React Server and Client Components to render parts of your application on the server or the client.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "When to use Server and Client Components?",
        "slug": "when-to-use-server-and-client-components"
      },
      {
        "level": 2,
        "text": "How do Server and Client Components work in Next.js?",
        "slug": "how-do-server-and-client-components-work-in-nextjs"
      },
      {
        "level": 3,
        "text": "On the server",
        "slug": "on-the-server"
      },
      {
        "level": 3,
        "text": "On the client (first load)",
        "slug": "on-the-client-first-load"
      },
      {
        "level": 3,
        "text": "Subsequent Navigations",
        "slug": "subsequent-navigations"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Using Client Components",
        "slug": "using-client-components"
      },
      {
        "level": 3,
        "text": "Reducing JS bundle size",
        "slug": "reducing-js-bundle-size"
      },
      {
        "level": 3,
        "text": "Passing data from Server to Client Components",
        "slug": "passing-data-from-server-to-client-components"
      },
      {
        "level": 3,
        "text": "Interleaving Server and Client Components",
        "slug": "interleaving-server-and-client-components"
      },
      {
        "level": 3,
        "text": "Context providers",
        "slug": "context-providers"
      },
      {
        "level": 3,
        "text": "Third-party components",
        "slug": "third-party-components"
      },
      {
        "level": 3,
        "text": "Preventing environment poisoning",
        "slug": "preventing-environment-poisoning"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "import LikeButton from '@/app/ui/like-button'\r\nimport { getPost } from '@/lib/data'\r\n\r\nexport default async function Page({\r\n  params,\r\n}: {\r\n  params: Promise<{ id: string }>\r\n}) {\r\n  const { id } = await params\r\n  const post = await getPost(id)\r\n\r\n  return (\r\n    <div>\r\n      <main>\r\n        <h1>{post.title}</h1>\r\n        {/* ... */}\r\n        <LikeButton likes={post.likes} />\r\n      </main>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/[id]/page.tsx\" highlight={1,12} switcher"
      },
      {
        "language": "jsx",
        "code": "import LikeButton from '@/app/ui/like-button'\r\nimport { getPost } from '@/lib/data'\r\n\r\nexport default async function Page({ params }) {\r\n  const post = await getPost(params.id)\r\n\r\n  return (\r\n    <div>\r\n      <main>\r\n        <h1>{post.title}</h1>\r\n        {/* ... */}\r\n        <LikeButton likes={post.likes} />\r\n      </main>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/[id]/page.js\" highlight={1,12} switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { useState } from 'react'\r\n\r\nexport default function LikeButton({ likes }: { likes: number }) {\r\n  // ...\r\n}",
        "context": "filename=\"app/ui/like-button.tsx\" highlight={1} switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { useState } from 'react'\r\n\r\nexport default function LikeButton({ likes }) {\r\n  // ...\r\n}",
        "context": "filename=\"app/ui/like-button.js\" highlight={1} switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { useState } from 'react'\r\n\r\nexport default function Counter() {\r\n  const [count, setCount] = useState(0)\r\n\r\n  return (\r\n    <div>\r\n      <p>{count} likes</p>\r\n      <button onClick={() => setCount(count + 1)}>Click me</button>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/ui/counter.tsx\" highlight={1} switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { useState } from 'react'\r\n\r\nexport default function Counter() {\r\n  const [count, setCount] = useState(0)\r\n\r\n  return (\r\n    <div>\r\n      <p>{count} likes</p>\r\n      <button onClick={() => setCount(count + 1)}>Click me</button>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/ui/counter.js\" highlight={1} switcher"
      },
      {
        "language": "tsx",
        "code": "// Client Component\r\nimport Search from './search'\r\n// Server Component\r\nimport Logo from './logo'\r\n\r\n// Layout is a Server Component by default\r\nexport default function Layout({ children }: { children: React.ReactNode }) {\r\n  return (\r\n    <>\r\n      <nav>\r\n        <Logo />\r\n        <Search />\r\n      </nav>\r\n      <main>{children}</main>\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" highlight={12} switcher"
      },
      {
        "language": "jsx",
        "code": "// Client Component\r\nimport Search from './search'\r\n// Server Component\r\nimport Logo from './logo'\r\n\r\n// Layout is a Server Component by default\r\nexport default function Layout({ children }) {\r\n  return (\r\n    <>\r\n      <nav>\r\n        <Logo />\r\n        <Search />\r\n      </nav>\r\n      <main>{children}</main>\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" highlight={12} switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nexport default function Search() {\r\n  // ...\r\n}",
        "context": "filename=\"app/ui/search.tsx\" highlight={1} switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nexport default function Search() {\r\n  // ...\r\n}",
        "context": "filename=\"app/ui/search.js\" highlight={1} switcher"
      },
      {
        "language": "tsx",
        "code": "import LikeButton from '@/app/ui/like-button'\r\nimport { getPost } from '@/lib/data'\r\n\r\nexport default async function Page({\r\n  params,\r\n}: {\r\n  params: Promise<{ id: string }>\r\n}) {\r\n  const { id } = await params\r\n  const post = await getPost(id)\r\n\r\n  return <LikeButton likes={post.likes} />\r\n}",
        "context": "filename=\"app/[id]/page.tsx\" highlight={1,7} switcher"
      },
      {
        "language": "jsx",
        "code": "import LikeButton from '@/app/ui/like-button'\r\nimport { getPost } from '@/lib/data'\r\n\r\nexport default async function Page({ params }) {\r\n  const post = await getPost(params.id)\r\n\r\n  return <LikeButton likes={post.likes} />\r\n}",
        "context": "filename=\"app/[id]/page.js\" highlight={1,7} switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nexport default function LikeButton({ likes }: { likes: number }) {\r\n  // ...\r\n}",
        "context": "filename=\"app/ui/like-button.tsx\" highlight={1} switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nexport default function LikeButton({ likes }) {\r\n  // ...\r\n}",
        "context": "filename=\"app/ui/like-button.js\" highlight={1} switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nexport default function Modal({ children }: { children: React.ReactNode }) {\r\n  return <div>{children}</div>\r\n}",
        "context": "filename=\"app/ui/modal.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nexport default function Modal({ children }) {\r\n  return <div>{children}</div>\r\n}",
        "context": "filename=\"app/ui/modal.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Modal from './ui/modal'\r\nimport Cart from './ui/cart'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <Modal>\r\n      <Cart />\r\n    </Modal>\r\n  )\r\n}",
        "context": "filename=\"app/page.tsx\"  highlight={7} switcher"
      },
      {
        "language": "jsx",
        "code": "import Modal from './ui/modal'\r\nimport Cart from './ui/cart'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <Modal>\r\n      <Cart />\r\n    </Modal>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\" highlight={7} switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { createContext } from 'react'\r\n\r\nexport const ThemeContext = createContext({})\r\n\r\nexport default function ThemeProvider({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return <ThemeContext.Provider value=\"dark\">{children}</ThemeContext.Provider>\r\n}",
        "context": "filename=\"app/theme-provider.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { createContext } from 'react'\r\n\r\nexport const ThemeContext = createContext({})\r\n\r\nexport default function ThemeProvider({ children }) {\r\n  return <ThemeContext.Provider value=\"dark\">{children}</ThemeContext.Provider>\r\n}",
        "context": "filename=\"app/theme-provider.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import ThemeProvider from './theme-provider'\r\n\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html>\r\n      <body>\r\n        <ThemeProvider>{children}</ThemeProvider>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import ThemeProvider from './theme-provider'\r\n\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html>\r\n      <body>\r\n        <ThemeProvider>{children}</ThemeProvider>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { useState } from 'react'\r\nimport { Carousel } from 'acme-carousel'\r\n\r\nexport default function Gallery() {\r\n  const [isOpen, setIsOpen] = useState(false)\r\n\r\n  return (\r\n    <div>\r\n      <button onClick={() => setIsOpen(true)}>View pictures</button>\r\n      {/* Works, since Carousel is used within a Client Component */}\r\n      {isOpen && <Carousel />}\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/gallery.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { useState } from 'react'\r\nimport { Carousel } from 'acme-carousel'\r\n\r\nexport default function Gallery() {\r\n  const [isOpen, setIsOpen] = useState(false)\r\n\r\n  return (\r\n    <div>\r\n      <button onClick={() => setIsOpen(true)}>View pictures</button>\r\n      {/*  Works, since Carousel is used within a Client Component */}\r\n      {isOpen && <Carousel />}\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/gallery.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { Carousel } from 'acme-carousel'\r\n\r\nexport default Carousel",
        "context": "filename=\"app/carousel.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { Carousel } from 'acme-carousel'\r\n\r\nexport default Carousel",
        "context": "filename=\"app/carousel.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Carousel from './carousel'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <div>\r\n      <p>View pictures</p>\r\n      {/*  Works, since Carousel is a Client Component */}\r\n      <Carousel />\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Carousel from './carousel'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <div>\r\n      <p>View pictures</p>\r\n      {/*  Works, since Carousel is a Client Component */}\r\n      <Carousel />\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "ts",
        "code": "export async function getData() {\r\n  const res = await fetch('https://external-service.com/data', {\r\n    headers: {\r\n      authorization: process.env.API_KEY,\r\n    },\r\n  })\r\n\r\n  return res.json()\r\n}",
        "context": "filename=\"lib/data.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export async function getData() {\r\n  const res = await fetch('https://external-service.com/data', {\r\n    headers: {\r\n      authorization: process.env.API_KEY,\r\n    },\r\n  })\r\n\r\n  return res.json()\r\n}",
        "context": "filename=\"lib/data.js\" switcher"
      },
      {
        "language": "js",
        "code": "import 'server-only'\r\n\r\nexport async function getData() {\r\n  const res = await fetch('https://external-service.com/data', {\r\n    headers: {\r\n      authorization: process.env.API_KEY,\r\n    },\r\n  })\r\n\r\n  return res.json()\r\n}",
        "context": "filename=\"lib/data.js\""
      },
      {
        "language": "bash",
        "code": "npm install server-only",
        "context": "package=\"npm\""
      },
      {
        "language": "bash",
        "code": "yarn add server-only",
        "context": "package=\"yarn\""
      },
      {
        "language": "bash",
        "code": "pnpm add server-only",
        "context": "package=\"pnpm\""
      },
      {
        "language": "bash",
        "code": "bun add server-only",
        "context": "package=\"bun\""
      }
    ],
    "content": "By default, layouts and pages are Server Components, which lets you fetch data and render parts of your UI on the server, optionally cache the result, and stream it to the client. When you need interactivity or browser APIs, you can use Client Components to layer in functionality. This page explains how Server and Client Components work in Next.js and when to use them, with examples of how to compose them together in your application. When to use Server and Client Components? The client and server environments have different capabilities. Server and Client components allow you to run logic in each environment depending on your use case. Use Client Components when you need: - State and event handlers. E.g. onClick, onChange. - Lifecycle logic. E.g. useEffect. - Browser-only APIs. E.g. localStorage, window, Navigator.geolocation, etc. - Custom hooks. Use Server Components when you need: - Fetch data from databases or APIs close to the source. - Use API keys, tokens, and other secrets without exposing them to the client. - Reduce the amount of JavaScript sent to the browser. - Improve the First Contentful Paint (FCP), and stream content progressively to the client. For example, the component is a Server Component that fetches data about a post, and passes it as props to the which handles client-side interactivity. How do Server and Client Components work in Next.js? On the server On the server, Next.js uses React's APIs to orchestrate rendering. The rendering work is split into chunks, by individual route segments (layouts and pages): - Server Components are rendered into a special data format called the React Server Component Payload (RSC Payload). - Client Components and the RSC Payload are used to pre-render HTML. > What is the React Server Component Payload (RSC)? > > The RSC Payload is a compact binary representation of the rendered React Server Components tree. It's used by React on the client to update the browser's DOM. The RSC Payload contains: > > - The rendered result of Server Components > - Placeholders for where Client Components should be rendered and references to their JavaScript files > - Any props passed from a Server Component to a Client Component On the client (first load) Then, on the client: 1. HTML is used to immediately show a fast non-interactive preview of the route to the user. 2. RSC Payload is used to reconcile the Client and Server Component trees. 3. JavaScript is used to hydrate Client Components and make the application interactive. > What is hydration? > > Hydration is React's process for attaching event handlers to the DOM, to make the static HTML interactive. Subsequent Navigations On subsequent navigations: - The RSC Payload is prefetched and cached for instant navigation. - Client Components are rendered entirely on the client, without the server-rendered HTML. Examples Using Client Components You can create a Client Component by adding the \"use client\" directive at the top of the file, above your imports. \"use client\" is used to declare a boundary between the Server and Client module graphs (trees). Once a file is marked with \"use client\", all its imports and child components are considered part of the client bundle. This means you don't need to add the directive to every component that is intended for the client. Reducing JS bundle size To reduce the size of your client JavaScript bundles, add 'use client' to specific interactive components instead of marking large parts of your UI as Client Components. For example, the component contains mostly static elements like a logo and navigation links, but includes an interactive search bar. is interactive and needs to be a Client Component, however, the rest of the layout can remain a Server Component. Passing data from Server to Client Components You can pass data from Server Components to Client Components using props. Alternatively, you can stream data from a Server Component to a Client Component with the use Hook. See an example. > Good to know: Props passed to Client Components need to be serializable by React. Interleaving Server and Client Components You can pass Server Components as a prop to a Client Component. This allows you to visually nest server-rendered UI within Client components. A common pattern is to use children to create a slot in a . For example, a component that fetches data on the server, inside a component that uses client state to toggle visibility. Then, in a parent Server Component (e.g.), you can pass a as the child of the : In this pattern, all Server Components will be rendered on the server ahead of time, including those as props. The resulting RSC payload will contain references of where Client Components should be rendered within the component tree. Context providers React context is commonly used to share global state like the current theme. However, React context is not supported in Server Components. To use context, create a Client Component that accepts children: Then, import it into a Server Component (e.g. layout): Your Server Component will now be able to directly render your provider, and all other Client Components throughout your app will be able to consume this context. > Good to know: You should render providers as deep as possible in the tree – notice how ThemeProvider only wraps {children} instead of the entire document. This makes it easier for Next.js to optimize the static parts of your Server Components. Third-party components When using a third-party component that relies on client-only features, you can wrap it in a Client Component to ensure it works as expected. For example, the can be imported from the acme-carousel package. This component uses useState, but it doesn't yet have the \"use client\" directive. If you use within a Client Component, it will work as expected: However, if you try to use it directly within a Server Component, you'll see an error. This is because Next.js doesn't know is using client-only features. To fix this, you can wrap third-party components that rely on client-only features in your own Client Components: Now, you can use directly within a Server Component: > Advice for Library Authors > > If you’re building a component library, add the \"use client\" directive to entry points that rely on client-only features. This lets your users import components into Server Components without needing to create wrappers. > > It's worth noting some bundlers might strip out \"use client\" directives. You can find an example of how to configure esbuild to include the \"use client\" directive in the React Wrap Balancer and Vercel Analytics repositories. Preventing environment poisoning JavaScript modules can be shared between both Server and Client Components modules. This means it's possible to accidentally import server-only code into the client. For example, consider the following function: This function contains an APIKEY that should never be exposed to the client. In Next.js, only environment variables prefixed with NEXTPUBLIC are included in the client bundle. If variables are not prefixed, Next.js replaces them with an empty string. As a result, even though getData() can be imported and executed on the client, it won't work as expected. To prevent accidental usage in Client Components, you can use the server-only package. Then, import the package into a file that contains server-only code: Now, if you try to import the module into a Client Component, there will be a build-time error. The corresponding client-only package can be used to mark modules that contain client-only logic like code that accesses the window object. In Next.js, installing server-only or client-only is optional. However, if your linting rules flag extraneous dependencies, you may install them to avoid issues. Next.js handles server-only and client-only imports internally to provide clearer error messages when a module is used in the wrong environment. The contents of these packages from NPM are not used by Next.js. Next.js also provides its own type declarations for server-only and client-only, for TypeScript configurations where noUncheckedSideEffectImports is active.",
    "excerpt": "By default, layouts and pages are Server Components, which lets you fetch data and render parts of your UI on the server, optionally cache the result, and stream it to the client. When you need intera...",
    "url": "https://nextjs.org/docs/01-app/01-getting-started/05-server-and-client-components"
  },
  {
    "id": "01-app-01-getting-started-06-cache-components",
    "path": "01-app\\01-getting-started\\06-cache-components.mdx",
    "title": "Cache Components",
    "description": "Learn how to use Cache Components and combine the benefits of static and dynamic rendering.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Cache Components",
        "slug": "cache-components"
      },
      {
        "level": 2,
        "text": "How it works",
        "slug": "how-it-works"
      },
      {
        "level": 3,
        "text": "1. Suspense for runtime data",
        "slug": "1-suspense-for-runtime-data"
      },
      {
        "level": 3,
        "text": "2. Suspense for dynamic data",
        "slug": "2-suspense-for-dynamic-data"
      },
      {
        "level": 3,
        "text": "3. Cached data with ",
        "slug": "3-cached-data-with-"
      },
      {
        "level": 2,
        "text": "Using Suspense boundaries",
        "slug": "using-suspense-boundaries"
      },
      {
        "level": 3,
        "text": "Missing Suspense boundaries",
        "slug": "missing-suspense-boundaries"
      },
      {
        "level": 3,
        "text": "How streaming works",
        "slug": "how-streaming-works"
      },
      {
        "level": 2,
        "text": "Using ",
        "slug": "using-"
      },
      {
        "level": 3,
        "text": "Basic usage",
        "slug": "basic-usage"
      },
      {
        "level": 3,
        "text": "Caveats",
        "slug": "caveats"
      },
      {
        "level": 4,
        "text": "Arguments must be serializable",
        "slug": "arguments-must-be-serializable"
      },
      {
        "level": 4,
        "text": "Accepting unserializable values without introspection",
        "slug": "accepting-unserializable-values-without-introspection"
      },
      {
        "level": 4,
        "text": "Avoid passing dynamic inputs",
        "slug": "avoid-passing-dynamic-inputs"
      },
      {
        "level": 3,
        "text": "Tagging and revalidating",
        "slug": "tagging-and-revalidating"
      },
      {
        "level": 4,
        "text": "With ",
        "slug": "with-"
      },
      {
        "level": 4,
        "text": "With ",
        "slug": "with-"
      },
      {
        "level": 2,
        "text": "Enabling Cache Components",
        "slug": "enabling-cache-components"
      },
      {
        "level": 3,
        "text": "Navigation with Cache Components",
        "slug": "navigation-with-cache-components"
      },
      {
        "level": 3,
        "text": "Effect on route segment config",
        "slug": "effect-on-route-segment-config"
      },
      {
        "level": 2,
        "text": "Before vs. after Cache Components",
        "slug": "before-vs-after-cache-components"
      },
      {
        "level": 3,
        "text": "Before Cache Components",
        "slug": "before-cache-components"
      },
      {
        "level": 3,
        "text": "With Cache Components",
        "slug": "with-cache-components"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Dynamic APIs",
        "slug": "dynamic-apis"
      },
      {
        "level": 3,
        "text": "Passing dynamic props",
        "slug": "passing-dynamic-props"
      },
      {
        "level": 2,
        "text": "Route Handlers with Cache Components",
        "slug": "route-handlers-with-cache-components"
      },
      {
        "level": 2,
        "text": "Frequently Asked Questions",
        "slug": "frequently-asked-questions"
      },
      {
        "level": 3,
        "text": "Does this replace Partial Prerendering (PPR)?",
        "slug": "does-this-replace-partial-prerendering-ppr"
      },
      {
        "level": 3,
        "text": "What should I cache first?",
        "slug": "what-should-i-cache-first"
      },
      {
        "level": 3,
        "text": "How do I update cached content quickly?",
        "slug": "how-do-i-update-cached-content-quickly"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "export async function getProducts() {\r\n  'use cache'\r\n  const data = await db.query('SELECT * FROM products')\r\n  return data\r\n}",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "import { Suspense } from 'react'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <h1>This will be pre-rendered</h1>\r\n      <Suspense fallback={<Skeleton />}>\r\n        <DynamicContent />\r\n      </Suspense>\r\n    </>\r\n  )\r\n}\r\n\r\nasync function DynamicContent() {\r\n  const res = await fetch('http://api.cms.com/posts')\r\n  const { posts } = await res.json()\r\n  return <div>{/* ... */}</div>\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { Suspense } from 'react'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <h1>This will be pre-rendered</h1>\r\n      <Suspense fallback={<Skeleton />}>\r\n        <DynamicContent />\r\n      </Suspense>\r\n    </>\r\n  )\r\n}\r\n\r\nasync function DynamicContent() {\r\n  const res = await fetch('http://api.cms.com/posts')\r\n  const { posts } = await res.json()\r\n  return <div>{/* ... */}</div>\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { cacheLife } from 'next/cache'\r\n\r\nexport default async function Page() {\r\n  'use cache'\r\n  cacheLife('hours')\r\n  // fetch or compute\r\n  return <div>...</div>\r\n}",
        "context": "filename=\"app/page.tsx\" highlight={1,4,5} switcher"
      },
      {
        "language": "jsx",
        "code": "import { cacheLife } from 'next/cache'\r\n\r\nexport default async function Page() {\r\n  'use cache'\r\n  cacheLife('hours')\r\n  // fetch or compute\r\n  return <div>...</div>\r\n}",
        "context": "filename=\"app/page.js\" highlight={1,4,5} switcher"
      },
      {
        "language": "tsx",
        "code": "import { ReactNode } from 'react'\r\n\r\nexport async function CachedWrapper({ children }: { children: ReactNode }) {\r\n  'use cache'\r\n  // Don't introspect children, just pass it through\r\n  return (\r\n    <div className=\"wrapper\">\r\n      <header>Cached Header</header>\r\n      {children}\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/cached-wrapper.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export async function CachedWrapper({ children }) {\r\n  'use cache'\r\n  // Don't introspect children, just pass it through\r\n  return (\r\n    <div className=\"wrapper\">\r\n      <header>Cached Header</header>\r\n      {children}\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/cached-wrapper.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { cacheTag, updateTag } from 'next/cache'\r\n\r\nexport async function getCart() {\r\n  'use cache'\r\n  cacheTag('cart')\r\n  // fetch data\r\n}\r\n\r\nexport async function updateCart(itemId: string) {\r\n  'use server'\r\n  // write data using the itemId\r\n  // update the user cart\r\n  updateTag('cart')\r\n}",
        "context": "filename=\"app/actions.ts\" highlight={1,4,5,13}"
      },
      {
        "language": "tsx",
        "code": "import { cacheTag, revalidateTag } from 'next/cache'\r\n\r\nexport async function getPosts() {\r\n  'use cache'\r\n  cacheTag('posts')\r\n  // fetch data\r\n}\r\n\r\nexport async function createPost(post: FormData) {\r\n  'use server'\r\n  // write data using the FormData\r\n  revalidateTag('posts', 'max')\r\n}",
        "context": "filename=\"app/actions.ts\" highlight={1,4,5,12}"
      },
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  cacheComponents: true,\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\" highlight={4} switcher"
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  cacheComponents: true,\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\" highlight={3} switcher"
      },
      {
        "language": "tsx",
        "code": "// Before - No longer needed\r\nexport const dynamic = 'force-dynamic'\r\n\r\nexport default function Page() {\r\n  return <div>...</div>\r\n}",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "// After - Just remove it, pages are dynamic by default\r\nexport default function Page() {\r\n  return <div>...</div>\r\n}",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "// Before\r\nexport const dynamic = 'force-static'\r\n\r\nexport default async function Page() {\r\n  const data = await fetch('https://api.example.com/data')\r\n  return <div>...</div>\r\n}",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "// After - Use 'use cache' instead\r\nexport default async function Page() {\r\n  'use cache'\r\n  const data = await fetch('https://api.example.com/data')\r\n  return <div>...</div>\r\n}",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "// Before\r\nexport const revalidate = 3600 // 1 hour\r\n\r\nexport default async function Page() {\r\n  return <div>...</div>\r\n}",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "// After - Use cacheLife\r\nimport { cacheLife } from 'next/cache'\r\n\r\nexport default async function Page() {\r\n  'use cache'\r\n  cacheLife('hours')\r\n  return <div>...</div>\r\n}",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "// Before\r\nexport const fetchCache = 'force-cache'",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "// After - Use 'use cache' to control caching behavior\r\nexport default async function Page() {\r\n  'use cache'\r\n  // All fetches here are cached\r\n  return <div>...</div>\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import { cookies } from 'next/headers'\r\n\r\nexport async function User() {\r\n  const session = (await cookies()).get('session')?.value\r\n  return '...'\r\n}",
        "context": "filename=\"app/user.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { cookies } from 'next/headers'\r\n\r\nexport async function User() {\r\n  const session = (await cookies()).get('session')?.value\r\n  return '...'\r\n}",
        "context": "filename=\"app/user.tsx\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { Suspense } from 'react'\r\nimport { User, AvatarSkeleton } from './user'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <section>\r\n      <h1>This will be pre-rendered</h1>\r\n      <Suspense fallback={<AvatarSkeleton />}>\r\n        <User />\r\n      </Suspense>\r\n    </section>\r\n  )\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { Suspense } from 'react'\r\nimport { User, AvatarSkeleton } from './user'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <section>\r\n      <h1>This will be pre-rendered</h1>\r\n      <Suspense fallback={<AvatarSkeleton />}>\r\n        <User />\r\n      </Suspense>\r\n    </section>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { Table, TableSkeleton } from './table'\r\nimport { Suspense } from 'react'\r\n\r\nexport default function Page({\r\n  searchParams,\r\n}: {\r\n  searchParams: Promise<{ sort: string }>\r\n}) {\r\n  return (\r\n    <section>\r\n      <h1>This will be pre-rendered</h1>\r\n      <Suspense fallback={<TableSkeleton />}>\r\n        <Table searchParams={searchParams.then((search) => search.sort)} />\r\n      </Suspense>\r\n    </section>\r\n  )\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { Table, TableSkeleton } from './table'\r\nimport { Suspense } from 'react'\r\n\r\nexport default function Page({ searchParams }) {\r\n  return (\r\n    <section>\r\n      <h1>This will be pre-rendered</h1>\r\n      <Suspense fallback={<TableSkeleton />}>\r\n        <Table searchParams={searchParams.then((search) => search.sort)} />\r\n      </Suspense>\r\n    </section>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export async function Table({ sortPromise }: { sortPromise: Promise<string> }) {\r\n  const sort = (await sortPromise) === 'true'\r\n  return '...'\r\n}",
        "context": "filename=\"app/table.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export async function Table({ sortPromise }) {\r\n  const sort = (await sortPromise) === 'true'\r\n  return '...'\r\n}",
        "context": "filename=\"app/table.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export async function GET() {\r\n  return Response.json({\r\n    randomNumber: Math.random(),\r\n  })\r\n}",
        "context": "filename=\"app/api/random-number/route.ts\""
      },
      {
        "language": "tsx",
        "code": "export async function GET() {\r\n  return Response.json({\r\n    projectName: 'Next.js',\r\n  })\r\n}",
        "context": "filename=\"app/api/project-info/route.ts\""
      },
      {
        "language": "tsx",
        "code": "export async function GET() {\r\n  const products = await db.query('SELECT * FROM products')\r\n\r\n  return Response.json(products)\r\n}",
        "context": "filename=\"app/api/products/route.ts\""
      },
      {
        "language": "tsx",
        "code": "import { cacheLife } from 'next/cache'\r\n\r\nexport async function GET() {\r\n  const products = await getProducts()\r\n\r\n  return Response.json(products)\r\n}\r\n\r\nasync function getProducts() {\r\n  'use cache'\r\n  cacheLife('hours')\r\n\r\n  return await db.query('SELECT * FROM products')\r\n}",
        "context": "filename=\"app/api/products/route.ts\""
      }
    ],
    "content": "Cache Components is a new approach to rendering and caching in Next.js that provides fine-grained control over what gets cached and when, while ensuring a great user experience through Partial Prerendering (PPR). Cache Components When developing dynamic applications, you have to balance two primary approaches: - Fully static pages load fast but can't show personalized or real-time data - Fully dynamic pages can show fresh data but require rendering everything on each request, leading to slower initial loads With Cache Components enabled, Next.js treats all routes as dynamic by default. Every request renders with the latest available data. However, most pages are made up of both static and dynamic parts, and not all dynamic data needs to be resolved from source on every request. Cache Components allows you to mark data, and even parts of your UI as cacheable, which includes them in the pre-render pass alongside static parts of the page. > Before Cache Components, Next.js tried to statically optimize entire pages automatically, which could lead to unexpected behavior when adding dynamic code. Cache Components implements Partial Prerendering (PPR), and use cache to give you the best of both worlds: When a user visits a route: - The server sends a static shell containing cached content, ensuring a fast initial load - Dynamic sections wrapped in Suspense boundaries display fallback UI in the shell - Only the dynamic parts render to replace their fallbacks, streaming in parallel as they become ready - You can include otherwise-dynamic data in the initial shell by caching it with use cache > 🎥 Watch: Why PPR and how it works → YouTube (10 minutes). How it works > Good to know: Cache Components is an opt-in feature. Enable it by setting the cacheComponents flag to true in your Next config file. See Enabling Cache Components for more details. Cache Components gives you three key tools to control rendering: 1. Suspense for runtime data Some data is only available at runtime when an actual user makes a request. APIs like cookies, headers, and searchParams access request-specific information. Wrap components using these APIs in Suspense boundaries so the rest of the page can be pre-rendered as a static shell. Runtime APIs include: - cookies - headers - searchParams prop - params prop - This is runtime data unless you provide at least one example value through generateStaticParams. When provided, those specific param values are treated as static for prerendered paths, while other values remain runtime 2. Suspense for dynamic data Dynamic data like fetch calls or database queries (db.query(...)) can change between requests but isn't user-specific. The connection API is meta-dynamic—it represents waiting for a user navigation even though there's no actual data to return. Wrap components that use these in Suspense boundaries to enable streaming. Dynamic data patterns include: - fetch requests - Database queries - connection 3. Cached data with use cache Add use cache to any Server Component to make it cached and include it in the pre-rendered shell. You cannot use runtime APIs from inside a cached component. You can also mark utility functions as use cache and call them from Server Components. Using Suspense boundaries React Suspense boundaries let you define what fallback UI to use when it wraps dynamic or runtime data. Content outside the boundary, including the fallback UI, is pre-rendered as a static shell, while content inside the boundary streams in when ready. Here's how to use Suspense with Cache Components: At build time, Next.js pre-renders the static content and the fallback UI, while the dynamic content is postponed until a user requests the route. > Good to know: Wrapping a component in Suspense doesn't make it dynamic; your API usage does. Suspense acts as a boundary that encapsulates dynamic content and enables streaming. Missing Suspense boundaries Cache Components enforces that dynamic code must be wrapped in a Suspense boundary. If you forget, you'll see the Uncached data was accessed outside of error: > Uncached data was accessed outside of > > This delays the entire page from rendering, resulting in a slow user > experience. Next.js uses this error to ensure your app loads instantly > on every navigation. > > To fix this, you can either: > > Wrap the component in a boundary. This allows Next.js to stream its contents to the user as soon as it's ready, without blocking the rest of the app. > > or > > Move the asynchronous await into a Cache Component(\"use cache\"). This allows Next.js to statically prerender the component as part of the HTML document, so it's instantly visible to the user. > > Note that request-specific information, such as params, cookies, and headers, is not available during static prerendering, so it must be wrapped in . This error helps prevent a situation where, instead of getting a static shell instantly, users would hit a blocking runtime render with nothing to show. To fix it, add a Suspense boundary or use use cache to cache the work instead. How streaming works Streaming splits the route into chunks and progressively streams them to the client as they become ready. This allows the user to see parts of the page immediately, before the entire content has finished rendering. With partial pre-rendering, the initial UI can be sent immediately to the browser while the dynamic parts render. This decreases time to UI and may decrease total request time depending on how much of your UI is pre-rendered. To reduce network overhead, the full response, including static HTML and streamed dynamic parts, is sent in a single HTTP request. This avoids extra round-trips and improves both initial load and overall performance. Using use cache While Suspense boundaries manage dynamic content, the use cache directive is available for caching data or computations that don't change often. Basic usage Add use cache to cache a page, component, or async function, and define a lifetime with cacheLife: Caveats When using use cache, keep these constraints in mind: Arguments must be serializable Like Server Actions, arguments to cached functions must be serializable. This means you can pass primitives, plain objects, and arrays, but not class instances, functions, or other complex types. Accepting unserializable values without introspection You can accept unserializable values as arguments as long as you don't introspect them. However, you can return them. This allows patterns like cached components that accept Server or Client Components as children: Avoid passing dynamic inputs You must not pass dynamic or runtime data into use cache functions unless you avoid introspecting them. Passing values from cookies(), headers(), or other runtime APIs as arguments will cause errors, as the cache key cannot be determined at pre-render time. Tagging and revalidating Tag cached data with cacheTag and revalidate it after mutations using updateTag in Server Actions for immediate updates, or revalidateTag delay in updates are acceptable. With updateTag Use updateTag when you need to expire and immediately refresh cached data within the same request: With revalidateTag Use revalidateTag when you want to invalidate only properly tagged cached entries with stale-while-revalidate behavior. This is ideal for static content that can tolerate eventual consistency. For more detailed explanation and usage examples, see the use cache API reference. Enabling Cache Components You can enable Cache Components (which includes PPR) by adding the cacheComponents option to your Next config file: Navigation with Cache Components When the cacheComponents flag is enabled, Next.js uses React's component to preserve component state during client-side navigation. Rather than unmounting the previous route when you navigate away, Next.js sets the Activity mode to \"hidden\". This means: - Component state is preserved when navigating between routes - When you navigate back, the previous route reappears with its state intact - Effects are cleaned up when a route is hidden, and recreated when it becomes visible again This behavior improves the navigation experience by maintaining UI state (form inputs, or expanded sections) when users navigate back and forth between routes. > Good to know: Next.js uses heuristics to keep a few recently visited routes \"hidden\", while older routes are removed from the DOM to prevent excessive growth. Effect on route segment config When Cache Components is enabled, several route segment config options are no longer needed or supported. Here's what changes and how to migrate: dynamic = \"force-dynamic\" Not needed. All pages are dynamic by default with Cache Components enabled, so this configuration is unnecessary. dynamic = \"force-static\" Replace with use cache. You must add use cache to each Layout and Page for the associated route instead. Note: force-static previously allowed the use of runtime APIs like cookies(), but this is no longer supported. If you add use cache and see an error related to runtime data, you must remove the use of runtime APIs. revalidate Replace with cacheLife. Use the cacheLife function to define cache duration instead of the route segment config. fetchCache Not needed. With use cache, all data fetching within a cached scope is automatically cached, making fetchCache unnecessary. runtime = 'edge' Not supported. Cache Components requires Node.js runtime and will throw errors with Edge Runtime. Before vs. after Cache Components Understanding how Cache Components changes your mental model: Before Cache Components - Static by default: Next.js tried to pre-render and cache as much as possible for you unless you opted out - Route-level controls: Switches like dynamic, revalidate, fetchCache controlled caching for the whole page - Limits of fetch: Using fetch alone was incomplete, as it didn't cover direct database clients or other server-side IO. A nested fetch switching to dynamic (e.g., { cache: 'no-store' }) could unintentionally change the entire route behavior With Cache Components - Dynamic by default: Everything is dynamic by default. You decide which parts to cache by adding use cache where it helps - Fine-grained control: File/component/function-level use cache and cacheLife control caching exactly where you need it - Streaming stays: Use or a loading.(js|tsx) file to stream dynamic parts while the shell shows immediately - Beyond fetch: Using the use cache directive caching can be applied to all server IO (database calls, APIs, computations), not just fetch. Nested fetch calls won't silently flip an entire route because behavior is governed by explicit cache boundaries and Suspense Examples Dynamic APIs When accessing runtime APIs like cookies(), Next.js will only pre-render the fallback UI above this component. In this example, we have no fallback defined, so Next.js shows an error instructing us to provide one. The component needs to be wrapped in Suspense because it uses the cookies API: Now we have a Suspense boundary around our User component we can pre-render the Page with a Skeleton UI and stream in the UI when a specific user makes a request Passing dynamic props Components only opt into dynamic rendering when the value is accessed. For example, if you are reading searchParams from a component, you can forward this value to another component as a prop: Inside of the table component, accessing the value from searchParams will make the component dynamic while the rest of the page will be pre-rendered. Route Handlers with Cache Components GET Route Handlers follow the same model as normal UI routes in your application. They are dynamic by default, can be pre-rendered when deterministic, and you can use cache to include more dynamic data in the cached response. Dynamic example, returns a different number for every request: A handler that returns only static data will be pre-rendered at build time: If you had a route that returned fresh dynamic data on every request, say products from a database: To cache this and avoid hitting the database on every request, extract the dynamic work into a use cache function and set cacheLife('hours') so the database is queried at most once per hour: > Good to know > > - use cache cannot be used directly inside a Route Handler body; extract to a helper. > - Cached responses revalidate according to cacheLife when a new request arrives. > - Using runtime APIs like cookies() or headers(), or calling connection(), always defers to request time (no pre-rendering). Frequently Asked Questions Does this replace Partial Prerendering (PPR)? No. Cache Components implements PPR as a feature. The old experimental PPR flag has been removed but PPR is here to stay. PPR provides the static shell and streaming infrastructure; use cache lets you include optimized dynamic output in that shell when beneficial. What should I cache first? What you cache should be a function of what you want your UI loading states to be. If data doesn't depend on runtime data and you're okay with a cached value being served for multiple requests over a period of time, use use cache with cacheLife to describe that behavior. For content management systems with update mechanisms, consider using tags with longer cache durations and rely on revalidateTag to mark static initial UI as ready for revalidation. This pattern allows you to serve fast, cached responses while still updating content when it actually changes, rather than expiring the cache preemptively. How do I update cached content quickly? Use cacheTag to tag your cached data, then trigger updateTag or revalidateTag.",
    "excerpt": "Cache Components is a new approach to rendering and caching in Next.js that provides fine-grained control over what gets cached and when, while ensuring a great user experience through Partial Prerend...",
    "url": "https://nextjs.org/docs/01-app/01-getting-started/06-cache-components"
  },
  {
    "id": "01-app-01-getting-started-07-fetching-data",
    "path": "01-app\\01-getting-started\\07-fetching-data.mdx",
    "title": "Fetching Data",
    "description": "Learn how to fetch data and stream content that depends on data.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Fetching data",
        "slug": "fetching-data"
      },
      {
        "level": 3,
        "text": "Server Components",
        "slug": "server-components"
      },
      {
        "level": 4,
        "text": "With the  API",
        "slug": "with-the-api"
      },
      {
        "level": 4,
        "text": "With an ORM or database",
        "slug": "with-an-orm-or-database"
      },
      {
        "level": 3,
        "text": "Client Components",
        "slug": "client-components"
      },
      {
        "level": 4,
        "text": "Streaming data with the  hook",
        "slug": "streaming-data-with-the-hook"
      },
      {
        "level": 4,
        "text": "Community libraries",
        "slug": "community-libraries"
      },
      {
        "level": 2,
        "text": "Deduplicate requests and cache data",
        "slug": "deduplicate-requests-and-cache-data"
      },
      {
        "level": 2,
        "text": "Streaming",
        "slug": "streaming"
      },
      {
        "level": 3,
        "text": "With ",
        "slug": "with-"
      },
      {
        "level": 3,
        "text": "With ",
        "slug": "with-"
      },
      {
        "level": 3,
        "text": "Creating meaningful loading states",
        "slug": "creating-meaningful-loading-states"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Sequential data fetching",
        "slug": "sequential-data-fetching"
      },
      {
        "level": 3,
        "text": "Parallel data fetching",
        "slug": "parallel-data-fetching"
      },
      {
        "level": 3,
        "text": "Preloading data",
        "slug": "preloading-data"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "export default async function Page() {\r\n  const data = await fetch('https://api.vercel.app/blog')\r\n  const posts = await data.json()\r\n  return (\r\n    <ul>\r\n      {posts.map((post) => (\r\n        <li key={post.id}>{post.title}</li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}",
        "context": "filename=\"app/blog/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default async function Page() {\r\n  const data = await fetch('https://api.vercel.app/blog')\r\n  const posts = await data.json()\r\n  return (\r\n    <ul>\r\n      {posts.map((post) => (\r\n        <li key={post.id}>{post.title}</li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}",
        "context": "filename=\"app/blog/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { db, posts } from '@/lib/db'\r\n\r\nexport default async function Page() {\r\n  const allPosts = await db.select().from(posts)\r\n  return (\r\n    <ul>\r\n      {allPosts.map((post) => (\r\n        <li key={post.id}>{post.title}</li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}",
        "context": "filename=\"app/blog/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { db, posts } from '@/lib/db'\r\n\r\nexport default async function Page() {\r\n  const allPosts = await db.select().from(posts)\r\n  return (\r\n    <ul>\r\n      {allPosts.map((post) => (\r\n        <li key={post.id}>{post.title}</li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}",
        "context": "filename=\"app/blog/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Posts from '@/app/ui/posts'\r\nimport { Suspense } from 'react'\r\n\r\nexport default function Page() {\r\n  // Don't await the data fetching function\r\n  const posts = getPosts()\r\n\r\n  return (\r\n    <Suspense fallback={<div>Loading...</div>}>\r\n      <Posts posts={posts} />\r\n    </Suspense>\r\n  )\r\n}",
        "context": "filename=\"app/blog/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Posts from '@/app/ui/posts'\r\nimport { Suspense } from 'react'\r\n\r\nexport default function Page() {\r\n  // Don't await the data fetching function\r\n  const posts = getPosts()\r\n\r\n  return (\r\n    <Suspense fallback={<div>Loading...</div>}>\r\n      <Posts posts={posts} />\r\n    </Suspense>\r\n  )\r\n}",
        "context": "filename=\"app/blog/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\nimport { use } from 'react'\r\n\r\nexport default function Posts({\r\n  posts,\r\n}: {\r\n  posts: Promise<{ id: string; title: string }[]>\r\n}) {\r\n  const allPosts = use(posts)\r\n\r\n  return (\r\n    <ul>\r\n      {allPosts.map((post) => (\r\n        <li key={post.id}>{post.title}</li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}",
        "context": "filename=\"app/ui/posts.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\nimport { use } from 'react'\r\n\r\nexport default function Posts({ posts }) {\r\n  const allPosts = use(posts)\r\n\r\n  return (\r\n    <ul>\r\n      {allPosts.map((post) => (\r\n        <li key={post.id}>{post.title}</li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}",
        "context": "filename=\"app/ui/posts.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\nimport useSWR from 'swr'\r\n\r\nconst fetcher = (url) => fetch(url).then((r) => r.json())\r\n\r\nexport default function BlogPage() {\r\n  const { data, error, isLoading } = useSWR(\r\n    'https://api.vercel.app/blog',\r\n    fetcher\r\n  )\r\n\r\n  if (isLoading) return <div>Loading...</div>\r\n  if (error) return <div>Error: {error.message}</div>\r\n\r\n  return (\r\n    <ul>\r\n      {data.map((post: { id: string; title: string }) => (\r\n        <li key={post.id}>{post.title}</li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}",
        "context": "filename=\"app/blog/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport useSWR from 'swr'\r\n\r\nconst fetcher = (url) => fetch(url).then((r) => r.json())\r\n\r\nexport default function BlogPage() {\r\n  const { data, error, isLoading } = useSWR(\r\n    'https://api.vercel.app/blog',\r\n    fetcher\r\n  )\r\n\r\n  if (isLoading) return <div>Loading...</div>\r\n  if (error) return <div>Error: {error.message}</div>\r\n\r\n  return (\r\n    <ul>\r\n      {data.map((post) => (\r\n        <li key={post.id}>{post.title}</li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}",
        "context": "filename=\"app/blog/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { cache } from 'react'\r\nimport { db, posts, eq } from '@/lib/db'\r\n\r\nexport const getPost = cache(async (id: string) => {\r\n  const post = await db.query.posts.findFirst({\r\n    where: eq(posts.id, parseInt(id)),\r\n  })\r\n})",
        "context": "filename=\"app/lib/data.ts\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { cache } from 'react'\r\nimport { db, posts, eq } from '@/lib/db'\r\nimport { notFound } from 'next/navigation'\r\n\r\nexport const getPost = cache(async (id) => {\r\n  const post = await db.query.posts.findFirst({\r\n    where: eq(posts.id, parseInt(id)),\r\n  })\r\n})",
        "context": "filename=\"app/lib/data.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default function Loading() {\r\n  // Define the Loading UI here\r\n  return <div>Loading...</div>\r\n}",
        "context": "filename=\"app/blog/loading.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function Loading() {\r\n  // Define the Loading UI here\r\n  return <div>Loading...</div>\r\n}",
        "context": "filename=\"app/blog/loading.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { Suspense } from 'react'\r\nimport BlogList from '@/components/BlogList'\r\nimport BlogListSkeleton from '@/components/BlogListSkeleton'\r\n\r\nexport default function BlogPage() {\r\n  return (\r\n    <div>\r\n      {/* This content will be sent to the client immediately */}\r\n      <header>\r\n        <h1>Welcome to the Blog</h1>\r\n        <p>Read the latest posts below.</p>\r\n      </header>\r\n      <main>\r\n        {/* Any content wrapped in a <Suspense> boundary will be streamed */}\r\n        <Suspense fallback={<BlogListSkeleton />}>\r\n          <BlogList />\r\n        </Suspense>\r\n      </main>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/blog/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { Suspense } from 'react'\r\nimport BlogList from '@/components/BlogList'\r\nimport BlogListSkeleton from '@/components/BlogListSkeleton'\r\n\r\nexport default function BlogPage() {\r\n  return (\r\n    <div>\r\n      {/* This content will be sent to the client immediately */}\r\n      <header>\r\n        <h1>Welcome to the Blog</h1>\r\n        <p>Read the latest posts below.</p>\r\n      </header>\r\n      <main>\r\n        {/* Any content wrapped in a <Suspense> boundary will be streamed */}\r\n        <Suspense fallback={<BlogListSkeleton />}>\r\n          <BlogList />\r\n        </Suspense>\r\n      </main>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/blog/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default async function Page({\r\n  params,\r\n}: {\r\n  params: Promise<{ username: string }>\r\n}) {\r\n  const { username } = await params\r\n  // Get artist information\r\n  const artist = await getArtist(username)\r\n\r\n  return (\r\n    <>\r\n      <h1>{artist.name}</h1>\r\n      {/* Show fallback UI while the Playlists component is loading */}\r\n      <Suspense fallback={<div>Loading...</div>}>\r\n        {/* Pass the artist ID to the Playlists component */}\r\n        <Playlists artistID={artist.id} />\r\n      </Suspense>\r\n    </>\r\n  )\r\n}\r\n\r\nasync function Playlists({ artistID }: { artistID: string }) {\r\n  // Use the artist ID to fetch playlists\r\n  const playlists = await getArtistPlaylists(artistID)\r\n\r\n  return (\r\n    <ul>\r\n      {playlists.map((playlist) => (\r\n        <li key={playlist.id}>{playlist.name}</li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}",
        "context": "filename=\"app/artist/[username]/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default async function Page({ params }) {\r\n  const { username } = await params\r\n  // Get artist information\r\n  const artist = await getArtist(username)\r\n\r\n  return (\r\n    <>\r\n      <h1>{artist.name}</h1>\r\n      {/* Show fallback UI while the Playlists component is loading */}\r\n      <Suspense fallback={<div>Loading...</div>}>\r\n        {/* Pass the artist ID to the Playlists component */}\r\n        <Playlists artistID={artist.id} />\r\n      </Suspense>\r\n    </>\r\n  )\r\n}\r\n\r\nasync function Playlists({ artistID }) {\r\n  // Use the artist ID to fetch playlists\r\n  const playlists = await getArtistPlaylists(artistID)\r\n\r\n  return (\r\n    <ul>\r\n      {playlists.map((playlist) => (\r\n        <li key={playlist.id}>{playlist.name}</li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}",
        "context": "filename=\"app/artist/[username]/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { getArtist, getAlbums } from '@/app/lib/data'\r\n\r\nexport default async function Page({ params }) {\r\n  // These requests will be sequential\r\n  const { username } = await params\r\n  const artist = await getArtist(username)\r\n  const albums = await getAlbums(username)\r\n  return <div>{artist.name}</div>\r\n}",
        "context": "filename=\"app/artist/[username]/page.tsx\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Albums from './albums'\r\n\r\nasync function getArtist(username: string) {\r\n  const res = await fetch(`https://api.example.com/artist/${username}`)\r\n  return res.json()\r\n}\r\n\r\nasync function getAlbums(username: string) {\r\n  const res = await fetch(`https://api.example.com/artist/${username}/albums`)\r\n  return res.json()\r\n}\r\n\r\nexport default async function Page({\r\n  params,\r\n}: {\r\n  params: Promise<{ username: string }>\r\n}) {\r\n  const { username } = await params\r\n\r\n  // Initiate requests\r\n  const artistData = getArtist(username)\r\n  const albumsData = getAlbums(username)\r\n\r\n  const [artist, albums] = await Promise.all([artistData, albumsData])\r\n\r\n  return (\r\n    <>\r\n      <h1>{artist.name}</h1>\r\n      <Albums list={albums} />\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/artist/[username]/page.tsx\" highlight={3,8,23} switcher"
      },
      {
        "language": "jsx",
        "code": "import Albums from './albums'\r\n\r\nasync function getArtist(username) {\r\n  const res = await fetch(`https://api.example.com/artist/${username}`)\r\n  return res.json()\r\n}\r\n\r\nasync function getAlbums(username) {\r\n  const res = await fetch(`https://api.example.com/artist/${username}/albums`)\r\n  return res.json()\r\n}\r\n\r\nexport default async function Page({ params }) {\r\n  const { username } = await params\r\n\r\n  // Initiate requests\r\n  const artistData = getArtist(username)\r\n  const albumsData = getAlbums(username)\r\n\r\n  const [artist, albums] = await Promise.all([artistData, albumsData])\r\n\r\n  return (\r\n    <>\r\n      <h1>{artist.name}</h1>\r\n      <Albums list={albums} />\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/artist/[username]/page.js\" highlight={3,8,19} switcher"
      },
      {
        "language": "tsx",
        "code": "import { getItem, checkIsAvailable } from '@/lib/data'\r\n\r\nexport default async function Page({\r\n  params,\r\n}: {\r\n  params: Promise<{ id: string }>\r\n}) {\r\n  const { id } = await params\r\n  // starting loading item data\r\n  preload(id)\r\n  // perform another asynchronous task\r\n  const isAvailable = await checkIsAvailable()\r\n\r\n  return isAvailable ? <Item id={id} /> : null\r\n}\r\n\r\nexport const preload = (id: string) => {\r\n  // void evaluates the given expression and returns undefined\r\n  // https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/void\r\n  void getItem(id)\r\n}\r\nexport async function Item({ id }: { id: string }) {\r\n  const result = await getItem(id)\r\n  // ...\r\n}",
        "context": "filename=\"app/item/[id]/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { getItem, checkIsAvailable } from '@/lib/data'\r\n\r\nexport default async function Page({ params }) {\r\n  const { id } = await params\r\n  // starting loading item data\r\n  preload(id)\r\n  // perform another asynchronous task\r\n  const isAvailable = await checkIsAvailable()\r\n\r\n  return isAvailable ? <Item id={id} /> : null\r\n}\r\n\r\nexport const preload = (id) => {\r\n  // void evaluates the given expression and returns undefined\r\n  // https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/void\r\n  void getItem(id)\r\n}\r\nexport async function Item({ id }) {\r\n  const result = await getItem(id)\r\n  // ...",
        "context": "filename=\"app/item/[id]/page.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { cache } from 'react'\r\nimport 'server-only'\r\nimport { getItem } from '@/lib/data'\r\n\r\nexport const preload = (id: string) => {\r\n  void getItem(id)\r\n}\r\n\r\nexport const getItem = cache(async (id: string) => {\r\n  // ...\r\n})",
        "context": "filename=\"utils/get-item.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { cache } from 'react'\r\nimport 'server-only'\r\nimport { getItem } from '@/lib/data'\r\n\r\nexport const preload = (id) => {\r\n  void getItem(id)\r\n}\r\n\r\nexport const getItem = cache(async (id) => {\r\n  // ...\r\n})",
        "context": "filename=\"utils/get-item.js\" switcher"
      }
    ],
    "content": "This page will walk you through how you can fetch data in Server and Client Components, and how to stream components that depend on data. Fetching data Server Components You can fetch data in Server Components using: 1. The fetch API 2. An ORM or database With the fetch API To fetch data with the fetch API, turn your component into an asynchronous function, and await the fetch call. For example: > Good to know: > > - fetch responses are not cached by default. However, Next.js will pre-render the route and the output will be cached for improved performance. If you'd like to opt into dynamic rendering, use the { cache: 'no-store' } option. See the fetch API Reference. > - During development, you can log fetch calls for better visibility and debugging. See the logging API reference. With an ORM or database Since Server Components are rendered on the server, you can safely make database queries using an ORM or database client. Turn your component into an asynchronous function, and await the call: Client Components There are two ways to fetch data in Client Components, using: 1. React's use hook 2. A community library like SWR or React Query Streaming data with the use hook You can use React's use hook to stream data from the server to client. Start by fetching data in your Server component, and pass the promise to your Client Component as prop: Then, in your Client Component, use the use hook to read the promise: In the example above, the component is wrapped in a boundary. This means the fallback will be shown while the promise is being resolved. Learn more about streaming. Community libraries You can use a community library like SWR or React Query to fetch data in Client Components. These libraries have their own semantics for caching, streaming, and other features. For example, with SWR: Deduplicate requests and cache data One way to deduplicate fetch requests is with request memoization. With this mechanism, fetch calls using GET or HEAD with the same URL and options in a single render pass are combined into one request. This happens automatically, and you can opt out by passing an Abort signal to fetch. Request memoization is scoped to the lifetime of a request. You can also deduplicate fetch requests by using Next.js’ Data Cache, for example by setting cache: 'force-cache' in your fetch options. Data Cache allows sharing data across the current render pass and incoming requests. If you are not using fetch, and instead using an ORM or database directly, you can wrap your data access with the React cache function. Streaming > Warning: The content below assumes the cacheComponents config option is enabled in your application. The flag was introduced in Next.js 15 canary. When you fetch data in Server Components, the data is fetched and rendered on the server for each request. If you have any slow data requests, the whole route will be blocked from rendering until all the data is fetched. To improve the initial load time and user experience, you can use streaming to break up the page's HTML into smaller chunks and progressively send those chunks from the server to the client. There are two ways you can implement streaming in your application: 1. Wrapping a page with a loading.js file 2. Wrapping a component with With loading.js You can create a loading.js file in the same folder as your page to stream the entire page while the data is being fetched. For example, to stream app/blog/page.js, add the file inside the app/blog folder. On navigation, the user will immediately see the layout and a loading state while the page is being rendered. The new content will then be automatically swapped in once rendering is complete. Behind-the-scenes, loading.js will be nested inside layout.js, and will automatically wrap the page.js file and any children below in a boundary. This approach works well for route segments (layouts and pages), but for more granular streaming, you can use . With allows you to be more granular about what parts of the page to stream. For example, you can immediately show any page content that falls outside of the boundary, and stream in the list of blog posts inside the boundary. Creating meaningful loading states An instant loading state is fallback UI that is shown immediately to the user after navigation. For the best user experience, we recommend designing loading states that are meaningful and help users understand the app is responding. For example, you can use skeletons and spinners, or a small but meaningful part of future screens such as a cover photo, title, etc. In development, you can preview and inspect the loading state of your components using the React Devtools. Examples Sequential data fetching Sequential data fetching happens when nested components in a tree each fetch their own data and the requests are not deduplicated, leading to longer response times. There may be cases where you want this pattern because one fetch depends on the result of the other. For example, the component will only start fetching data once the component has finished fetching data because depends on the artistID prop: To improve the user experience, you should use React to show a fallback while data is being fetch. This will enable streaming and prevent the whole route from being blocked by the sequential data requests. Parallel data fetching Parallel data fetching happens when data requests in a route are eagerly initiated and start at the same time. By default, layouts and pages are rendered in parallel. So each segment starts fetching data as soon as possible. However, within any component, multiple async/await requests can still be sequential if placed after the other. For example, getAlbums will be blocked until getArtist is resolved: Start multiple requests by calling fetch, then await them with Promise.all. Requests begin as soon as fetch is called. > Good to know: If one request fails when using Promise.all, the entire operation will fail. To handle this, you can use the Promise.allSettled method instead. Preloading data You can preload data by creating an utility function that you eagerly call above blocking requests. conditionally renders based on the checkIsAvailable() function. You can call preload() before checkIsAvailable() to eagerly initiate data dependencies. By the time is rendered, its data has already been fetched. Additionally, you can use React's cache function and the server-only package to create a reusable utility function. This approach allows you to cache the data fetching function and ensure that it's only executed on the server.",
    "excerpt": "This page will walk you through how you can fetch data in Server and Client Components, and how to stream components that depend on data. Fetching data Server Components You can fetch data in Server C...",
    "url": "https://nextjs.org/docs/01-app/01-getting-started/07-fetching-data"
  },
  {
    "id": "01-app-01-getting-started-08-updating-data",
    "path": "01-app\\01-getting-started\\08-updating-data.mdx",
    "title": "Updating Data",
    "description": "Learn how to mutate data using Server Functions.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "What are Server Functions?",
        "slug": "what-are-server-functions"
      },
      {
        "level": 2,
        "text": "Creating Server Functions",
        "slug": "creating-server-functions"
      },
      {
        "level": 3,
        "text": "Server Components",
        "slug": "server-components"
      },
      {
        "level": 3,
        "text": "Client Components",
        "slug": "client-components"
      },
      {
        "level": 3,
        "text": "Passing actions as props",
        "slug": "passing-actions-as-props"
      },
      {
        "level": 2,
        "text": "Invoking Server Functions",
        "slug": "invoking-server-functions"
      },
      {
        "level": 3,
        "text": "Forms",
        "slug": "forms"
      },
      {
        "level": 3,
        "text": "Event Handlers",
        "slug": "event-handlers"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Showing a pending state",
        "slug": "showing-a-pending-state"
      },
      {
        "level": 3,
        "text": "Revalidating",
        "slug": "revalidating"
      },
      {
        "level": 3,
        "text": "Redirecting",
        "slug": "redirecting"
      },
      {
        "level": 3,
        "text": "Cookies",
        "slug": "cookies"
      },
      {
        "level": 3,
        "text": "useEffect",
        "slug": "useeffect"
      }
    ],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "export async function createPost(formData: FormData) {\r\n  'use server'\r\n  const title = formData.get('title')\r\n  const content = formData.get('content')\r\n\r\n  // Update data\r\n  // Revalidate cache\r\n}\r\n\r\nexport async function deletePost(formData: FormData) {\r\n  'use server'\r\n  const id = formData.get('id')\r\n\r\n  // Update data\r\n  // Revalidate cache\r\n}",
        "context": "filename=\"app/lib/actions.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export async function createPost(formData) {\r\n  'use server'\r\n  const title = formData.get('title')\r\n  const content = formData.get('content')\r\n\r\n  // Update data\r\n  // Revalidate cache\r\n}\r\n\r\nexport async function deletePost(formData) {\r\n  'use server'\r\n  const id = formData.get('id')\r\n\r\n  // Update data\r\n  // Revalidate cache\r\n}",
        "context": "filename=\"app/lib/actions.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default function Page() {\r\n  // Server Action\r\n  async function createPost(formData: FormData) {\r\n    'use server'\r\n    // ...\r\n  }\r\n\r\n  return <></>\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function Page() {\r\n  // Server Action\r\n  async function createPost(formData: FormData) {\r\n    'use server'\r\n    // ...\r\n  }\r\n\r\n  return <></>\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "ts",
        "code": "'use server'\r\n\r\nexport async function createPost() {}",
        "context": "filename=\"app/actions.ts\" switcher"
      },
      {
        "language": "js",
        "code": "'use server'\r\n\r\nexport async function createPost() {}",
        "context": "filename=\"app/actions.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { createPost } from '@/app/actions'\r\n\r\nexport function Button() {\r\n  return <button formAction={createPost}>Create</button>\r\n}",
        "context": "filename=\"app/ui/button.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { createPost } from '@/app/actions'\r\n\r\nexport function Button() {\r\n  return <button formAction={createPost}>Create</button>\r\n}",
        "context": "filename=\"app/ui/button.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "<ClientComponent updateItemAction={updateItem} />",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nexport default function ClientComponent({\r\n  updateItemAction,\r\n}: {\r\n  updateItemAction: (formData: FormData) => void\r\n}) {\r\n  return <form action={updateItemAction}>{/* ... */}</form>\r\n}",
        "context": "filename=\"app/client-component.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nexport default function ClientComponent({ updateItemAction }) {\r\n  return <form action={updateItemAction}>{/* ... */}</form>\r\n}",
        "context": "filename=\"app/client-component.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { createPost } from '@/app/actions'\r\n\r\nexport function Form() {\r\n  return (\r\n    <form action={createPost}>\r\n      <input type=\"text\" name=\"title\" />\r\n      <input type=\"text\" name=\"content\" />\r\n      <button type=\"submit\">Create</button>\r\n    </form>\r\n  )\r\n}",
        "context": "filename=\"app/ui/form.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { createPost } from '@/app/actions'\r\n\r\nexport function Form() {\r\n  return (\r\n    <form action={createPost}>\r\n      <input type=\"text\" name=\"title\" />\r\n      <input type=\"text\" name=\"content\" />\r\n      <button type=\"submit\">Create</button>\r\n    </form>\r\n  )\r\n}",
        "context": "filename=\"app/ui/form.js\" switcher"
      },
      {
        "language": "ts",
        "code": "'use server'\r\n\r\nexport async function createPost(formData: FormData) {\r\n  const title = formData.get('title')\r\n  const content = formData.get('content')\r\n\r\n  // Update data\r\n  // Revalidate cache\r\n}",
        "context": "filename=\"app/actions.ts\" switcher"
      },
      {
        "language": "js",
        "code": "'use server'\r\n\r\nexport async function createPost(formData) {\r\n  const title = formData.get('title')\r\n  const content = formData.get('content')\r\n\r\n  // Update data\r\n  // Revalidate cache\r\n}",
        "context": "filename=\"app/actions.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { incrementLike } from './actions'\r\nimport { useState } from 'react'\r\n\r\nexport default function LikeButton({ initialLikes }: { initialLikes: number }) {\r\n  const [likes, setLikes] = useState(initialLikes)\r\n\r\n  return (\r\n    <>\r\n      <p>Total Likes: {likes}</p>\r\n      <button\r\n        onClick={async () => {\r\n          const updatedLikes = await incrementLike()\r\n          setLikes(updatedLikes)\r\n        }}\r\n      >\r\n        Like\r\n      </button>\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/like-button.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { incrementLike } from './actions'\r\nimport { useState } from 'react'\r\n\r\nexport default function LikeButton({ initialLikes }) {\r\n  const [likes, setLikes] = useState(initialLikes)\r\n\r\n  return (\r\n    <>\r\n      <p>Total Likes: {likes}</p>\r\n      <button\r\n        onClick={async () => {\r\n          const updatedLikes = await incrementLike()\r\n          setLikes(updatedLikes)\r\n        }}\r\n      >\r\n        Like\r\n      </button>\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/like-button.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { useActionState, startTransition } from 'react'\r\nimport { createPost } from '@/app/actions'\r\nimport { LoadingSpinner } from '@/app/ui/loading-spinner'\r\n\r\nexport function Button() {\r\n  const [state, action, pending] = useActionState(createPost, false)\r\n\r\n  return (\r\n    <button onClick={() => startTransition(action)}>\r\n      {pending ? <LoadingSpinner /> : 'Create Post'}\r\n    </button>\r\n  )\r\n}",
        "context": "filename=\"app/ui/button.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { useActionState, startTransition } from 'react'\r\nimport { createPost } from '@/app/actions'\r\nimport { LoadingSpinner } from '@/app/ui/loading-spinner'\r\n\r\nexport function Button() {\r\n  const [state, action, pending] = useActionState(createPost, false)\r\n\r\n  return (\r\n    <button onClick={() => startTransition(action)}>\r\n      {pending ? <LoadingSpinner /> : 'Create Post'}\r\n    </button>\r\n  )\r\n}",
        "context": "filename=\"app/ui/button.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { revalidatePath } from 'next/cache'\r\n\r\nexport async function createPost(formData: FormData) {\r\n  'use server'\r\n  // Update data\r\n  // ...\r\n\r\n  revalidatePath('/posts')\r\n}",
        "context": "filename=\"app/lib/actions.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { revalidatePath } from 'next/cache'\r\n\r\nexport async function createPost(formData) {\r\n  'use server'\r\n  // Update data\r\n  // ...\r\n  revalidatePath('/posts')\r\n}",
        "context": "filename=\"app/actions.js\" switcher"
      },
      {
        "language": "ts",
        "code": "'use server'\r\n\r\nimport { revalidatePath } from 'next/cache'\r\nimport { redirect } from 'next/navigation'\r\n\r\nexport async function createPost(formData: FormData) {\r\n  // Update data\r\n  // ...\r\n\r\n  revalidatePath('/posts')\r\n  redirect('/posts')\r\n}",
        "context": "filename=\"app/lib/actions.ts\" switcher"
      },
      {
        "language": "js",
        "code": "'use server'\r\n\r\nimport { revalidatePath } from 'next/cache'\r\nimport { redirect } from 'next/navigation'\r\n\r\nexport async function createPost(formData) {\r\n  // Update data\r\n  // ...\r\n\r\n  revalidatePath('/posts')\r\n  redirect('/posts')\r\n}",
        "context": "filename=\"app/actions.js\" switcher"
      },
      {
        "language": "ts",
        "code": "'use server'\r\n\r\nimport { cookies } from 'next/headers'\r\n\r\nexport async function exampleAction() {\r\n  const cookieStore = await cookies()\r\n\r\n  // Get cookie\r\n  cookieStore.get('name')?.value\r\n\r\n  // Set cookie\r\n  cookieStore.set('name', 'Delba')\r\n\r\n  // Delete cookie\r\n  cookieStore.delete('name')\r\n}",
        "context": "filename=\"app/actions.ts\" switcher"
      },
      {
        "language": "js",
        "code": "'use server'\r\n\r\nimport { cookies } from 'next/headers'\r\n\r\nexport async function exampleAction() {\r\n  // Get cookie\r\n  const cookieStore = await cookies()\r\n\r\n  // Get cookie\r\n  cookieStore.get('name')?.value\r\n\r\n  // Set cookie\r\n  cookieStore.set('name', 'Delba')\r\n\r\n  // Delete cookie\r\n  cookieStore.delete('name')\r\n}",
        "context": "filename=\"app/actions.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { incrementViews } from './actions'\r\nimport { useState, useEffect, useTransition } from 'react'\r\n\r\nexport default function ViewCount({ initialViews }: { initialViews: number }) {\r\n  const [views, setViews] = useState(initialViews)\r\n  const [isPending, startTransition] = useTransition()\r\n\r\n  useEffect(() => {\r\n    startTransition(async () => {\r\n      const updatedViews = await incrementViews()\r\n      setViews(updatedViews)\r\n    })\r\n  }, [])\r\n\r\n  // You can use `isPending` to give users feedback\r\n  return <p>Total Views: {views}</p>\r\n}",
        "context": "filename=\"app/view-count.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { incrementViews } from './actions'\r\nimport { useState, useEffect, useTransition } from 'react'\r\n\r\nexport default function ViewCount({ initialViews }) {\r\n  const [views, setViews] = useState(initialViews)\r\n  const [isPending, startTransition] = useTransition()\r\n\r\n  useEffect(() => {\r\n    startTransition(async () => {\r\n      const updatedViews = await incrementViews()\r\n      setViews(updatedViews)\r\n    })\r\n  }, [])\r\n\r\n  // You can use `isPending` to give users feedback\r\n  return <p>Total Views: {views}</p>\r\n}",
        "context": "filename=\"app/view-count.js\" switcher"
      }
    ],
    "content": "You can update data in Next.js using React's Server Functions. This page will go through how you can create and invoke Server Functions. What are Server Functions? A Server Function is an asynchronous function that runs on the server. They can be called from the client through a network request, which is why they must be asynchronous. In an action or mutation context, they are also called Server Actions. By convention, a Server Action is an async function used with startTransition. This happens automatically when the function is: - Passed to a using the action prop. - Passed to a using the formAction prop. In Next.js, Server Actions integrate with the framework's caching architecture. When an action is invoked, Next.js can return both the updated UI and new data in a single server roundtrip. Behind the scenes, actions use the POST method, and only this HTTP method can invoke them. Creating Server Functions A Server Function can be defined by using the use server directive. You can place the directive at the top of an asynchronous function to mark the function as a Server Function, or at the top of a separate file to mark all exports of that file. Server Components Server Functions can be inlined in Server Components by adding the \"use server\" directive to the top of the function body: > Good to know: Server Components support progressive enhancement by default, meaning forms that call Server Actions will be submitted even if JavaScript hasn't loaded yet or is disabled. Client Components It's not possible to define Server Functions in Client Components. However, you can invoke them in Client Components by importing them from a file that has the \"use server\" directive at the top of it: > Good to know: In Client Components, forms invoking Server Actions will queue submissions if JavaScript isn't loaded yet, and will be prioritized for hydration. After hydration, the browser does not refresh on form submission. Passing actions as props You can also pass an action to a Client Component as a prop: Invoking Server Functions There are two main ways you can invoke a Server Function: 1. Forms in Server and Client Components 2. Event Handlers and useEffect in Client Components > Good to know: Server Functions are designed for server-side mutations. The client currently dispatches and awaits them one at a time. This is an implementation detail and may change. If you need parallel data fetching, use data fetching in Server Components, or perform parallel work inside a single Server Function or Route Handler. Forms React extends the HTML element to allow a Server Function to be invoked with the HTML action prop. When invoked in a form, the function automatically receives the FormData object. You can extract the data using the native FormData methods: Event Handlers You can invoke a Server Function in a Client Component by using event handlers such as onClick. Examples Showing a pending state While executing a Server Function, you can show a loading indicator with React's useActionState hook. This hook returns a pending boolean: Revalidating After performing an update, you can revalidate the Next.js cache and show the updated data by calling revalidatePath or revalidateTag within the Server Function: Redirecting You may want to redirect the user to a different page after performing an update. You can do this by calling redirect within the Server Function. Calling redirect throws a framework handled control-flow exception. Any code after it won't execute. If you need fresh data, call revalidatePath or revalidateTag beforehand. Cookies You can get, set, and delete cookies inside a Server Action using the cookies API. When you set or delete a cookie in a Server Action, Next.js re-renders the current page and its layouts on the server so the UI reflects the new cookie value. > Good to know: The server update applies to the current React tree, re-rendering, mounting, or unmounting components, as needed. Client state is preserved for re-rendered components, and effects re-run if their dependencies changed. useEffect You can use the React useEffect hook to invoke a Server Action when the component mounts or a dependency changes. This is useful for mutations that depend on global events or need to be triggered automatically. For example, onKeyDown for app shortcuts, an intersection observer hook for infinite scrolling, or when the component mounts to update a view count:",
    "excerpt": "You can update data in Next.js using React's Server Functions. This page will go through how you can create and invoke Server Functions. What are Server Functions? A Server Function is an asynchronous...",
    "url": "https://nextjs.org/docs/01-app/01-getting-started/08-updating-data"
  },
  {
    "id": "01-app-01-getting-started-09-caching-and-revalidating",
    "path": "01-app\\01-getting-started\\09-caching-and-revalidating.mdx",
    "title": "Caching and Revalidating",
    "description": "Learn how to cache and revalidate data in your application.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "export default async function Page() {\r\n  const data = await fetch('https://...', { cache: 'force-cache' })\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default async function Page() {\r\n  const data = await fetch('https://...', { cache: 'force-cache' })\r\n}",
        "context": "filename=\"app/page.jsx\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default async function Page() {\r\n  const data = await fetch('https://...', { next: { revalidate: 3600 } })\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default async function Page() {\r\n  const data = await fetch('https://...', { next: { revalidate: 3600 } })\r\n}",
        "context": "filename=\"app/page.jsx\" switcher"
      },
      {
        "language": "ts",
        "code": "import { db } from '@/lib/db'\r\nexport async function getUserById(id: string) {\r\n  return db\r\n    .select()\r\n    .from(users)\r\n    .where(eq(users.id, id))\r\n    .then((res) => res[0])\r\n}",
        "context": "filename=\"app/lib/data.ts\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { db } from '@/lib/db'\r\n\r\nexport async function getUserById(id) {\r\n  return db\r\n    .select()\r\n    .from(users)\r\n    .where(eq(users.id, id))\r\n    .then((res) => res[0])\r\n}",
        "context": "filename=\"app/lib/data.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { unstable_cache } from 'next/cache'\r\nimport { getUserById } from '@/app/lib/data'\r\n\r\nexport default async function Page({\r\n  params,\r\n}: {\r\n  params: Promise<{ userId: string }>\r\n}) {\r\n  const { userId } = await params\r\n\r\n  const getCachedUser = unstable_cache(\r\n    async () => {\r\n      return getUserById(userId)\r\n    },\r\n    [userId] // add the user ID to the cache key\r\n  )\r\n}",
        "context": "filename=\"app/page.tsx\" highlight={2,11,13} switcher"
      },
      {
        "language": "jsx",
        "code": "import { unstable_cache } from 'next/cache'\r\nimport { getUserById } from '@/app/lib/data'\r\n\r\nexport default async function Page({ params }) {\r\n  const { userId } = await params\r\n\r\n  const getCachedUser = unstable_cache(\r\n    async () => {\r\n      return getUserById(userId)\r\n    },\r\n    [userId] // add the user ID to the cache key\r\n  )\r\n}",
        "context": "filename=\"app/page.js\" highlight={2,7,9} switcher"
      },
      {
        "language": "tsx",
        "code": "const getCachedUser = unstable_cache(\r\n  async () => {\r\n    return getUserById(userId)\r\n  },\r\n  [userId],\r\n  {\r\n    tags: ['user'],\r\n    revalidate: 3600,\r\n  }\r\n)",
        "context": "filename=\"app/page.tsx\" highlight={6-9} switcher"
      },
      {
        "language": "jsx",
        "code": "const getCachedUser = unstable_cache(\r\n  async () => {\r\n    return getUserById(userId)\r\n  },\r\n  [userId],\r\n  {\r\n    tags: ['user'],\r\n    revalidate: 3600,\r\n  }\r\n)",
        "context": "filename=\"app/page.js\" highlight={6-9} switcher"
      },
      {
        "language": "tsx",
        "code": "export async function getUserById(id: string) {\r\n  const data = await fetch(`https://...`, {\r\n    next: {\r\n      tags: ['user'],\r\n    },\r\n  })\r\n}",
        "context": "filename=\"app/lib/data.ts\" highlight={3-5} switcher"
      },
      {
        "language": "jsx",
        "code": "export async function getUserById(id) {\r\n  const data = await fetch(`https://...`, {\r\n    next: {\r\n      tags: ['user'],\r\n    },\r\n  })\r\n}",
        "context": "filename=\"app/lib/data.js\" highlight={3-5} switcher"
      },
      {
        "language": "tsx",
        "code": "export const getUserById = unstable_cache(\r\n  async (id: string) => {\r\n    return db.query.users.findFirst({ where: eq(users.id, id) })\r\n  },\r\n  ['user'], // Needed if variables are not passed as parameters\r\n  {\r\n    tags: ['user'],\r\n  }\r\n)",
        "context": "filename=\"app/lib/data.ts\" highlight={6-8} switcher"
      },
      {
        "language": "jsx",
        "code": "export const getUserById = unstable_cache(\r\n  async (id) => {\r\n    return db.query.users.findFirst({ where: eq(users.id, id) })\r\n  },\r\n  ['user'], // Needed if variables are not passed as parameters\r\n  {\r\n    tags: ['user'],\r\n  }\r\n)",
        "context": "filename=\"app/lib/data.js\" highlight={6-8} switcher"
      },
      {
        "language": "tsx",
        "code": "import { revalidateTag } from 'next/cache'\r\n\r\nexport async function updateUser(id: string) {\r\n  // Mutate data\r\n  revalidateTag('user', 'max') // Recommended: Uses stale-while-revalidate\r\n}",
        "context": "filename=\"app/lib/actions.ts\" highlight={1,5} switcher"
      },
      {
        "language": "jsx",
        "code": "import { revalidateTag } from 'next/cache'\r\n\r\nexport async function updateUser(id) {\r\n  // Mutate data\r\n  revalidateTag('user', 'max') // Recommended: Uses stale-while-revalidate\r\n}",
        "context": "filename=\"app/lib/actions.js\" highlight={1,5} switcher"
      },
      {
        "language": "tsx",
        "code": "import { revalidatePath } from 'next/cache'\r\n\r\nexport async function updateUser(id: string) {\r\n  // Mutate data\r\n  revalidatePath('/profile')",
        "context": "filename=\"app/lib/actions.ts\" highlight={1} switcher"
      },
      {
        "language": "jsx",
        "code": "import { revalidatePath } from 'next/cache'\r\n\r\nexport async function updateUser(id) {\r\n  // Mutate data\r\n  revalidatePath('/profile')",
        "context": "filename=\"app/lib/actions.js\" highlight={1} switcher"
      },
      {
        "language": "tsx",
        "code": "import { updateTag } from 'next/cache'\r\nimport { redirect } from 'next/navigation'\r\n\r\nexport async function createPost(formData: FormData) {\r\n  // Create post in database\r\n  const post = await db.post.create({\r\n    data: {\r\n      title: formData.get('title'),\r\n      content: formData.get('content'),\r\n    },\r\n  })\r\n\r\n  // Immediately expire cache so the new post is visible\r\n  updateTag('posts')\r\n  updateTag(`post-${post.id}`)\r\n\r\n  redirect(`/posts/${post.id}`)\r\n}",
        "context": "filename=\"app/lib/actions.ts\" highlight={1,6} switcher"
      },
      {
        "language": "jsx",
        "code": "import { updateTag } from 'next/cache'\r\nimport { redirect } from 'next/navigation'\r\n\r\nexport async function createPost(formData) {\r\n  // Create post in database\r\n  const post = await db.post.create({\r\n    data: {\r\n      title: formData.get('title'),\r\n      content: formData.get('content'),\r\n    },\r\n  })\r\n\r\n  // Immediately expire cache so the new post is visible\r\n  updateTag('posts')\r\n  updateTag(`post-${post.id}`)\r\n\r\n  redirect(`/posts/${post.id}`)\r\n}",
        "context": "filename=\"app/lib/actions.js\" highlight={1,6} switcher"
      }
    ],
    "content": "Caching is a technique for storing the result of data fetching and other computations so that future requests for the same data can be served faster, without doing the work again. While revalidation allows you to update cache entries without having to rebuild your entire application. Next.js provides a few APIs to handle caching and revalidation. This guide will walk you through when and how to use them. - fetch - unstablecache - revalidatePath - revalidateTag - updateTag fetch By default, fetch requests are not cached. You can cache individual requests by setting the cache option to 'force-cache'. > Good to know: Although fetch requests are not cached by default, Next.js will pre-render routes that have fetch requests and cache the HTML. If you want to guarantee a route is dynamic, use the connection API. To revalidate the data returned by a fetch request, you can use the next.revalidate option. This will revalidate the data after a specified amount of seconds. See the fetch API reference to learn more. unstablecache unstablecache allows you to cache the result of database queries and other async functions. To use it, wrap unstablecache around the function. For example: The function accepts a third optional object to define how the cache should be revalidated. It accepts: - tags: an array of tags used by Next.js to revalidate the cache. - revalidate: the number of seconds after cache should be revalidated. See the unstablecache API reference to learn more. revalidateTag revalidateTag is used to revalidate cache entries based on a tag and following an event. The function now supports two behaviors: - With profile=\"max\": Uses stale-while-revalidate semantics, serving stale content while fetching fresh content in the background - Without the second argument: Legacy behavior that immediately expires the cache (deprecated) To use it with fetch, start by tagging the function with the next.tags option: Alternatively, you can mark an unstablecache function with the tags option: Then, call revalidateTag in a Route Handler or Server Action: You can reuse the same tag in multiple functions to revalidate them all at once. See the revalidateTag API reference to learn more. revalidatePath revalidatePath is used to revalidate a route and following an event. To use it, call it in a Route Handler or Server Action: See the revalidatePath API reference to learn more. updateTag updateTag is specifically designed for Server Actions to immediately expire cached data for read-your-own-writes scenarios. Unlike revalidateTag, it can only be used within Server Actions and immediately expires the cache entry. The key differences between revalidateTag and updateTag: - updateTag: Only in Server Actions, immediately expires cache, for read-your-own-writes - revalidateTag: In Server Actions and Route Handlers, supports stale-while-revalidate with profile=\"max\" See the updateTag API reference to learn more.",
    "excerpt": "Caching is a technique for storing the result of data fetching and other computations so that future requests for the same data can be served faster, without doing the work again. While revalidation a...",
    "url": "https://nextjs.org/docs/01-app/01-getting-started/09-caching-and-revalidating"
  },
  {
    "id": "01-app-01-getting-started-10-error-handling",
    "path": "01-app\\01-getting-started\\10-error-handling.mdx",
    "title": "Error Handling",
    "description": "Learn how to display expected errors and handle uncaught exceptions.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Handling expected errors",
        "slug": "handling-expected-errors"
      },
      {
        "level": 3,
        "text": "Server Functions",
        "slug": "server-functions"
      },
      {
        "level": 3,
        "text": "Server Components",
        "slug": "server-components"
      },
      {
        "level": 3,
        "text": "Not found",
        "slug": "not-found"
      },
      {
        "level": 2,
        "text": "Handling uncaught exceptions",
        "slug": "handling-uncaught-exceptions"
      },
      {
        "level": 3,
        "text": "Nested error boundaries",
        "slug": "nested-error-boundaries"
      },
      {
        "level": 3,
        "text": "Global errors",
        "slug": "global-errors"
      }
    ],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "'use server'\r\n\r\nexport async function createPost(prevState: any, formData: FormData) {\r\n  const title = formData.get('title')\r\n  const content = formData.get('content')\r\n\r\n  const res = await fetch('https://api.vercel.app/posts', {\r\n    method: 'POST',\r\n    body: { title, content },\r\n  })\r\n  const json = await res.json()\r\n\r\n  if (!res.ok) {\r\n    return { message: 'Failed to create post' }\r\n  }\r\n}",
        "context": "filename=\"app/actions.ts\" switcher"
      },
      {
        "language": "js",
        "code": "'use server'\r\n\r\nexport async function createPost(prevState, formData) {\r\n  const title = formData.get('title')\r\n  const content = formData.get('content')\r\n\r\n  const res = await fetch('https://api.vercel.app/posts', {\r\n    method: 'POST',\r\n    body: { title, content },\r\n  })\r\n  const json = await res.json()\r\n\r\n  if (!res.ok) {\r\n    return { message: 'Failed to create post' }\r\n  }\r\n}",
        "context": "filename=\"app/actions.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { useActionState } from 'react'\r\nimport { createPost } from '@/app/actions'\r\n\r\nconst initialState = {\r\n  message: '',\r\n}\r\n\r\nexport function Form() {\r\n  const [state, formAction, pending] = useActionState(createPost, initialState)\r\n\r\n  return (\r\n    <form action={formAction}>\r\n      <label htmlFor=\"title\">Title</label>\r\n      <input type=\"text\" id=\"title\" name=\"title\" required />\r\n      <label htmlFor=\"content\">Content</label>\r\n      <textarea id=\"content\" name=\"content\" required />\r\n      {state?.message && <p aria-live=\"polite\">{state.message}</p>}\r\n      <button disabled={pending}>Create Post</button>\r\n    </form>\r\n  )\r\n}",
        "context": "filename=\"app/ui/form.tsx\" highlight={11,19} switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { useActionState } from 'react'\r\nimport { createPost } from '@/app/actions'\r\n\r\nconst initialState = {\r\n  message: '',\r\n}\r\n\r\nexport function Form() {\r\n  const [state, formAction, pending] = useActionState(createPost, initialState)\r\n\r\n  return (\r\n    <form action={formAction}>\r\n      <label htmlFor=\"title\">Title</label>\r\n      <input type=\"text\" id=\"title\" name=\"title\" required />\r\n      <label htmlFor=\"content\">Content</label>\r\n      <textarea id=\"content\" name=\"content\" required />\r\n      {state?.message && <p aria-live=\"polite\">{state.message}</p>}\r\n      <button disabled={pending}>Create Post</button>\r\n    </form>\r\n  )\r\n}",
        "context": "filename=\"app/ui/form.js\" highlight={11,19} switcher"
      },
      {
        "language": "tsx",
        "code": "export default async function Page() {\r\n  const res = await fetch(`https://...`)\r\n  const data = await res.json()\r\n\r\n  if (!res.ok) {\r\n    return 'There was an error.'\r\n  }\r\n\r\n  return '...'\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default async function Page() {\r\n  const res = await fetch(`https://...`)\r\n  const data = await res.json()\r\n\r\n  if (!res.ok) {\r\n    return 'There was an error.'\r\n  }\r\n\r\n  return '...'\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { getPostBySlug } from '@/lib/posts'\r\n\r\nexport default async function Page({ params }: { params: { slug: string } }) {\r\n  const { slug } = await params\r\n  const post = getPostBySlug(slug)\r\n\r\n  if (!post) {\r\n    notFound()\r\n  }\r\n\r\n  return <div>{post.title}</div>\r\n}",
        "context": "filename=\"app/blog/[slug]/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { getPostBySlug } from '@/lib/posts'\r\n\r\nexport default async function Page({ params }) {\r\n  const { slug } = await params\r\n  const post = getPostBySlug(slug)\r\n\r\n  if (!post) {\r\n    notFound()\r\n  }\r\n\r\n  return <div>{post.title}</div>\r\n}",
        "context": "filename=\"app/blog/[slug]/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default function NotFound() {\r\n  return <div>404 - Page Not Found</div>\r\n}",
        "context": "filename=\"app/blog/[slug]/not-found.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function NotFound() {\r\n  return <div>404 - Page Not Found</div>\r\n}",
        "context": "filename=\"app/blog/[slug]/not-found.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client' // Error boundaries must be Client Components\r\n\r\nimport { useEffect } from 'react'\r\n\r\nexport default function Error({\r\n  error,\r\n  reset,\r\n}: {\r\n  error: Error & { digest?: string }\r\n  reset: () => void\r\n}) {\r\n  useEffect(() => {\r\n    // Log the error to an error reporting service\r\n    console.error(error)\r\n  }, [error])\r\n\r\n  return (\r\n    <div>\r\n      <h2>Something went wrong!</h2>\r\n      <button\r\n        onClick={\r\n          // Attempt to recover by trying to re-render the segment\r\n          () => reset()\r\n        }\r\n      >\r\n        Try again\r\n      </button>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/dashboard/error.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client' // Error boundaries must be Client Components\r\n\r\nimport { useEffect } from 'react'\r\n\r\nexport default function Error({ error, reset }) {\r\n  useEffect(() => {\r\n    // Log the error to an error reporting service\r\n    console.error(error)\r\n  }, [error])\r\n\r\n  return (\r\n    <div>\r\n      <h2>Something went wrong!</h2>\r\n      <button\r\n        onClick={\r\n          // Attempt to recover by trying to re-render the segment\r\n          () => reset()\r\n        }\r\n      >\r\n        Try again\r\n      </button>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/dashboard/error.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { useState } from 'react'\r\n\r\nexport function Button() {\r\n  const [error, setError] = useState(null)\r\n\r\n  const handleClick = () => {\r\n    try {\r\n      // do some work that might fail\r\n      throw new Error('Exception')\r\n    } catch (reason) {\r\n      setError(reason)\r\n    }\r\n  }\r\n\r\n  if (error) {\r\n    /* render fallback UI */\r\n  }\r\n\r\n  return (\r\n    <button type=\"button\" onClick={handleClick}>\r\n      Click me\r\n    </button>\r\n  )\r\n}",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { useTransition } from 'react'\r\n\r\nexport function Button() {\r\n  const [pending, startTransition] = useTransition()\r\n\r\n  const handleClick = () =>\r\n    startTransition(() => {\r\n      throw new Error('Exception')\r\n    })\r\n\r\n  return (\r\n    <button type=\"button\" onClick={handleClick}>\r\n      Click me\r\n    </button>\r\n  )\r\n}",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "'use client' // Error boundaries must be Client Components\r\n\r\nexport default function GlobalError({\r\n  error,\r\n  reset,\r\n}: {\r\n  error: Error & { digest?: string }\r\n  reset: () => void\r\n}) {\r\n  return (\r\n    // global-error must include html and body tags\r\n    <html>\r\n      <body>\r\n        <h2>Something went wrong!</h2>\r\n        <button onClick={() => reset()}>Try again</button>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/global-error.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client' // Error boundaries must be Client Components\r\n\r\nexport default function GlobalError({ error, reset }) {\r\n  return (\r\n    // global-error must include html and body tags\r\n    <html>\r\n      <body>\r\n        <h2>Something went wrong!</h2>\r\n        <button onClick={() => reset()}>Try again</button>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/global-error.js\" switcher"
      }
    ],
    "content": "Errors can be divided into two categories: expected errors and uncaught exceptions. This page will walk you through how you can handle these errors in your Next.js application. Handling expected errors Expected errors are those that can occur during the normal operation of the application, such as those from server-side form validation or failed requests. These errors should be handled explicitly and returned to the client. Server Functions You can use the useActionState hook to handle expected errors in Server Functions. For these errors, avoid using try/catch blocks and throw errors. Instead, model expected errors as return values. You can pass your action to the useActionState hook and use the returned state to display an error message. Server Components When fetching data inside of a Server Component, you can use the response to conditionally render an error message or redirect. Not found You can call the notFound function within a route segment and use the not-found.js file to show a 404 UI. Handling uncaught exceptions Uncaught exceptions are unexpected errors that indicate bugs or issues that should not occur during the normal flow of your application. These should be handled by throwing errors, which will then be caught by error boundaries. Nested error boundaries Next.js uses error boundaries to handle uncaught exceptions. Error boundaries catch errors in their child components and display a fallback UI instead of the component tree that crashed. Create an error boundary by adding an error.js file inside a route segment and exporting a React component: Errors will bubble up to the nearest parent error boundary. This allows for granular error handling by placing error.tsx files at different levels in the route hierarchy. Error boundaries don’t catch errors inside event handlers. They’re designed to catch errors during rendering to show a fallback UI instead of crashing the whole app. In general, errors in event handlers or async code aren’t handled by error boundaries because they run after rendering. To handle these cases, catch the error manually and store it using useState or useReducer, then update the UI to inform the user. Note that unhandled errors inside startTransition from useTransition, will bubble up to the nearest error boundary. Global errors While less common, you can handle errors in the root layout using the global-error.js file, located in the root app directory, even when leveraging internationalization. Global error UI must define its own and tags, since it is replacing the root layout or template when active.",
    "excerpt": "Errors can be divided into two categories: expected errors and uncaught exceptions. This page will walk you through how you can handle these errors in your Next.js application. Handling expected error...",
    "url": "https://nextjs.org/docs/01-app/01-getting-started/10-error-handling"
  },
  {
    "id": "01-app-01-getting-started-11-css",
    "path": "01-app\\01-getting-started\\11-css.mdx",
    "title": "CSS",
    "description": "Learn about the different ways to add CSS to your application, including Tailwind CSS, CSS Modules, Global CSS, and more.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Tailwind CSS",
        "slug": "tailwind-css"
      },
      {
        "level": 2,
        "text": "CSS Modules",
        "slug": "css-modules"
      },
      {
        "level": 2,
        "text": "Global CSS",
        "slug": "global-css"
      },
      {
        "level": 2,
        "text": "External stylesheets",
        "slug": "external-stylesheets"
      },
      {
        "level": 3,
        "text": "Import styles from ",
        "slug": "import-styles-from-"
      },
      {
        "level": 2,
        "text": "Ordering and Merging",
        "slug": "ordering-and-merging"
      },
      {
        "level": 3,
        "text": "Recommendations",
        "slug": "recommendations"
      },
      {
        "level": 2,
        "text": "Development vs Production",
        "slug": "development-vs-production"
      }
    ],
    "codeBlocks": [
      {
        "language": "bash",
        "code": "pnpm add -D tailwindcss @tailwindcss/postcss",
        "context": "package=\"pnpm\""
      },
      {
        "language": "bash",
        "code": "npm install -D tailwindcss @tailwindcss/postcss",
        "context": "package=\"npm\""
      },
      {
        "language": "bash",
        "code": "yarn add -D tailwindcss @tailwindcss/postcss",
        "context": "package=\"yarn\""
      },
      {
        "language": "bash",
        "code": "bun add -D tailwindcss @tailwindcss/postcss",
        "context": "package=\"bun\""
      },
      {
        "language": "js",
        "code": "export default {\r\n  plugins: {\r\n    '@tailwindcss/postcss': {},\r\n  },\r\n}",
        "context": "filename=\"postcss.config.mjs\""
      },
      {
        "language": "css",
        "code": "@import 'tailwindcss';",
        "context": "filename=\"app/globals.css\""
      },
      {
        "language": "tsx",
        "code": "import './globals.css'\r\n\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import './globals.css'\r\n\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default function Page() {\r\n  return (\r\n    <main className=\"flex min-h-screen flex-col items-center justify-between p-24\">\r\n      <h1 className=\"text-4xl font-bold\">Welcome to Next.js!</h1>\r\n    </main>\r\n  )\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function Page() {\r\n  return (\r\n    <main className=\"flex min-h-screen flex-col items-center justify-between p-24\">\r\n      <h1 className=\"text-4xl font-bold\">Welcome to Next.js!</h1>\r\n    </main>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "bash",
        "code": "pnpm add -D tailwindcss @tailwindcss/postcss",
        "context": "package=\"pnpm\""
      },
      {
        "language": "bash",
        "code": "npm install -D tailwindcss @tailwindcss/postcss",
        "context": "package=\"npm\""
      },
      {
        "language": "bash",
        "code": "yarn add -D tailwindcss @tailwindcss/postcss",
        "context": "package=\"yarn\""
      },
      {
        "language": "bash",
        "code": "bun add -D tailwindcss @tailwindcss/postcss",
        "context": "package=\"bun\""
      },
      {
        "language": "js",
        "code": "export default {\r\n  plugins: {\r\n    '@tailwindcss/postcss': {},\r\n  },\r\n}",
        "context": "filename=\"postcss.config.mjs\""
      },
      {
        "language": "css",
        "code": "@import 'tailwindcss';",
        "context": "filename=\"styles/globals.css\""
      },
      {
        "language": "jsx",
        "code": "import '@/styles/globals.css'\r\n\r\nexport default function MyApp({ Component, pageProps }) {\r\n  return <Component {...pageProps} />\r\n}",
        "context": "filename=\"pages/_app.js\""
      },
      {
        "language": "tsx",
        "code": "export default function Home() {\r\n  return (\r\n    <main className=\"flex min-h-screen flex-col items-center justify-between p-24\">\r\n      <h1 className=\"text-4xl font-bold\">Welcome to Next.js!</h1>\r\n    </main>\r\n  )\r\n}",
        "context": "filename=\"pages/index.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function Home() {\r\n  return (\r\n    <main className=\"flex min-h-screen flex-col items-center justify-between p-24\">\r\n      <h1 className=\"text-4xl font-bold\">Welcome to Next.js!</h1>\r\n    </main>\r\n  )\r\n}",
        "context": "filename=\"pages/index.js\" switcher"
      },
      {
        "language": "css",
        "code": ".blog {\r\n  padding: 24px;\r\n}",
        "context": "filename=\"app/blog/blog.module.css\""
      },
      {
        "language": "tsx",
        "code": "import styles from './blog.module.css'\r\n\r\nexport default function Page() {\r\n  return <main className={styles.blog}></main>\r\n}",
        "context": "filename=\"app/blog/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import styles from './blog.module.css'\r\n\r\nexport default function Layout() {\r\n  return <main className={styles.blog}></main>\r\n}",
        "context": "filename=\"app/blog/page.js\" switcher"
      },
      {
        "language": "css",
        "code": ".blog {\r\n  padding: 24px;\r\n}",
        "context": "filename=\"/styles/blog.module.css\""
      },
      {
        "language": "tsx",
        "code": "import styles from './blog.module.css'\r\n\r\nexport default function Page() {\r\n  return <main className={styles.blog}></main>\r\n}",
        "context": "filename=\"pages/blog/index.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import styles from './blog.module.css'\r\n\r\nexport default function Page() {\r\n  return <main className={styles.blog}></main>\r\n}",
        "context": "filename=\"pages/blog/index.js\" switcher"
      },
      {
        "language": "css",
        "code": "body {\r\n  padding: 20px 20px 60px;\r\n  max-width: 680px;\r\n  margin: 0 auto;\r\n}",
        "context": "filename=\"app/global.css\""
      },
      {
        "language": "tsx",
        "code": "// These styles apply to every route in the application\r\nimport './global.css'\r\n\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "// These styles apply to every route in the application\r\nimport './global.css'\r\n\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import '@/styles/global.css'\r\n\r\nexport default function MyApp({ Component, pageProps }) {\r\n  return <Component {...pageProps} />\r\n}",
        "context": "filename=\"pages/_app.js\""
      },
      {
        "language": "tsx",
        "code": "import 'bootstrap/dist/css/bootstrap.css'\r\n\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body className=\"container\">{children}</body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import 'bootstrap/dist/css/bootstrap.css'\r\n\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body className=\"container\">{children}</body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "import 'bootstrap/dist/css/bootstrap.css'\r\n\r\nexport default function MyApp({ Component, pageProps }) {\r\n  return <Component {...pageProps} />\r\n}",
        "context": "filename=\"pages/_app.js\""
      },
      {
        "language": "jsx",
        "code": "import { useState } from 'react'\r\nimport { Dialog } from '@reach/dialog'\r\nimport VisuallyHidden from '@reach/visually-hidden'\r\nimport '@reach/dialog/styles.css'\r\n\r\nfunction ExampleDialog(props) {\r\n  const [showDialog, setShowDialog] = useState(false)\r\n  const open = () => setShowDialog(true)\r\n  const close = () => setShowDialog(false)\r\n\r\n  return (\r\n    <div>\r\n      <button onClick={open}>Open Dialog</button>\r\n      <Dialog isOpen={showDialog} onDismiss={close}>\r\n        <button className=\"close-button\" onClick={close}>\r\n          <VisuallyHidden>Close</VisuallyHidden>\r\n          <span aria-hidden>×</span>\r\n        </button>\r\n        <p>Hello there. I am a dialog</p>\r\n      </Dialog>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"components/example-dialog.js\""
      },
      {
        "language": "tsx",
        "code": "import { BaseButton } from './base-button'\r\nimport styles from './page.module.css'\r\n\r\nexport default function Page() {\r\n  return <BaseButton className={styles.primary} />\r\n}",
        "context": "filename=\"page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { BaseButton } from './base-button'\r\nimport styles from './page.module.css'\r\n\r\nexport default function Page() {\r\n  return <BaseButton className={styles.primary} />\r\n}",
        "context": "filename=\"page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import styles from './base-button.module.css'\r\n\r\nexport function BaseButton() {\r\n  return <button className={styles.primary} />\r\n}",
        "context": "filename=\"base-button.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import styles from './base-button.module.css'\r\n\r\nexport function BaseButton() {\r\n  return <button className={styles.primary} />\r\n}",
        "context": "filename=\"base-button.js\" switcher"
      }
    ],
    "content": "Next.js provides several ways to style your application using CSS, including: - Tailwind CSS - CSS Modules - Global CSS - External Stylesheets - Sass - CSS-in-JS Tailwind CSS Tailwind CSS is a utility-first CSS framework that provides low-level utility classes to build custom designs. Install Tailwind CSS: Add the PostCSS plugin to your postcss.config.mjs file: Import Tailwind in your global CSS file: Import the CSS file in your root layout: Now you can start using Tailwind's utility classes in your application: Install Tailwind CSS: Add the PostCSS plugin to your postcss.config.mjs file: Import Tailwind in your global CSS file: Import the CSS file in your pages/app.js file: Now you can start using Tailwind's utility classes in your application: > Good to know: If you need broader browser support for very old browsers, see the Tailwind CSS v3 setup instructions. CSS Modules CSS Modules locally scope CSS by generating unique class names. This allows you to use the same class in different files without worrying about naming collisions. To start using CSS Modules, create a new file with the extension .module.css and import it into any component inside the app directory: To start using CSS Modules, create a new file with the extension .module.css and import it into any component inside the pages directory: Global CSS You can use global CSS to apply styles across your application. Create a app/global.css file and import it in the root layout to apply the styles to every route in your application: > Good to know: Global styles can be imported into any layout, page, or component inside the app directory. However, since Next.js uses React's built-in support for stylesheets to integrate with Suspense, this currently does not remove stylesheets as you navigate between routes which can lead to conflicts. We recommend using global styles for truly global CSS (like Tailwind's base styles), Tailwind CSS for component styling, and CSS Modules for custom scoped CSS when needed. Import the stylesheet in the pages/app.js file to apply the styles to every route in your application: Due to the global nature of stylesheets, and to avoid conflicts, you should import them inside pages/app.js. External stylesheets Stylesheets published by external packages can be imported anywhere in the app directory, including colocated components: > Good to know: In React 19, can also be used. See the React link documentation for more information. Next.js allows you to import CSS files from a JavaScript file. This is possible because Next.js extends the concept of import beyond JavaScript. Import styles from nodemodules Since Next.js 9.5.4, importing a CSS file from nodemodules is permitted anywhere in your application. For global stylesheets, like bootstrap or nprogress, you should import the file inside pages/app.js. For example: To import CSS required by a third-party component, you can do so in your component. For example: Ordering and Merging Next.js optimizes CSS during production builds by automatically chunking (merging) stylesheets. The order of your CSS depends on the order you import styles in your code. For example, base-button.module.css will be ordered before page.module.css since is imported before page.module.css: Recommendations To keep CSS ordering predictable: - Try to contain CSS imports to a single JavaScript or TypeScript entry file - Import global styles and Tailwind stylesheets in the root of your application. - Use Tailwind CSS for most styling needs as it covers common design patterns with utility classes. - Use CSS Modules for component-specific styles when Tailwind utilities aren't sufficient. - Use a consistent naming convention for your CSS modules. For example, using .module.css over .tsx. - Extract shared styles into shared components to avoid duplicate imports. - Turn off linters or formatters that auto-sort imports like ESLint’s sort-imports. - You can use the cssChunking option in next.config.js to control how CSS is chunked. Development vs Production - In development (next dev), CSS updates apply instantly with Fast Refresh. - In production (next build), all CSS files are automatically concatenated into many minified and code-split .css files, ensuring the minimal amount of CSS is loaded for a route. - CSS still loads with JavaScript disabled in production, but JavaScript is required in development for Fast Refresh. - CSS ordering can behave differently in development, always ensure to check the build (next build) to verify the final CSS order.",
    "excerpt": "Next.js provides several ways to style your application using CSS, including: - Tailwind CSS - CSS Modules - Global CSS - External Stylesheets - Sass - CSS-in-JS Tailwind CSS Tailwind CSS is a utility...",
    "url": "https://nextjs.org/docs/01-app/01-getting-started/11-css"
  },
  {
    "id": "01-app-01-getting-started-12-images",
    "path": "01-app\\01-getting-started\\12-images.mdx",
    "title": "Image Optimization",
    "description": "Learn how to optimize images in Next.js",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Local images",
        "slug": "local-images"
      },
      {
        "level": 2,
        "text": "Remote images",
        "slug": "remote-images"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "import Image from 'next/image'\r\n\r\nexport default function Page() {\r\n  return <Image src=\"\" alt=\"\" />\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Image from 'next/image'\r\n\r\nexport default function Page() {\r\n  return <Image src=\"\" alt=\"\" />\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Image from 'next/image'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <Image\r\n      src=\"/profile.png\"\r\n      alt=\"Picture of the author\"\r\n      width={500}\r\n      height={500}\r\n    />\r\n  )\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Image from 'next/image'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <Image\r\n      src=\"/profile.png\"\r\n      alt=\"Picture of the author\"\r\n      width={500}\r\n      height={500}\r\n    />\r\n  )\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Image from 'next/image'\r\nimport ProfileImage from './profile.png'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <Image\r\n      src={ProfileImage}\r\n      alt=\"Picture of the author\"\r\n      // width={500} automatically provided\r\n      // height={500} automatically provided\r\n      // blurDataURL=\"data:...\" automatically provided\r\n      // placeholder=\"blur\" // Optional blur-up while loading\r\n    />\r\n  )\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Image from 'next/image'\r\nimport ProfileImage from './profile.png'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <Image\r\n      src={ProfileImage}\r\n      alt=\"Picture of the author\"\r\n      // width={500} automatically provided\r\n      // height={500} automatically provided\r\n      // blurDataURL=\"data:...\" automatically provided\r\n      // placeholder=\"blur\" // Optional blur-up while loading\r\n    />\r\n  )\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Image from 'next/image'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <Image\r\n      src=\"https://s3.amazonaws.com/my-bucket/profile.png\"\r\n      alt=\"Picture of the author\"\r\n      width={500}\r\n      height={500}\r\n    />\r\n  )\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Image from 'next/image'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <Image\r\n      src=\"https://s3.amazonaws.com/my-bucket/profile.png\"\r\n      alt=\"Picture of the author\"\r\n      width={500}\r\n      height={500}\r\n    />\r\n  )\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst config: NextConfig = {\r\n  images: {\r\n    remotePatterns: [\r\n      {\r\n        protocol: 'https',\r\n        hostname: 's3.amazonaws.com',\r\n        port: '',\r\n        pathname: '/my-bucket/**',\r\n        search: '',\r\n      },\r\n    ],\r\n  },\r\n}\r\n\r\nexport default config",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    remotePatterns: [\r\n      {\r\n        protocol: 'https',\r\n        hostname: 's3.amazonaws.com',\r\n        port: '',\r\n        pathname: '/my-bucket/**',\r\n        search: '',\r\n      },\r\n    ],\r\n  },\r\n}",
        "context": "filename=\"next.config.js\" switcher"
      }
    ],
    "content": "The Next.js component extends the HTML element to provide: - Size optimization: Automatically serving correctly sized images for each device, using modern image formats like WebP. - Visual stability: Preventing layout shift automatically when images are loading. - Faster page loads: Only loading images when they enter the viewport using native browser lazy loading, with optional blur-up placeholders. - Asset flexibility: Resizing images on-demand, even images stored on remote servers. To start using , import it from next/image and render it within your component. The src property can be a local or remote image. > 🎥 Watch: Learn more about how to use next/image → YouTube (9 minutes). Local images You can store static files, like images and fonts, under a folder called public in the root directory. Files inside public can then be referenced by your code starting from the base URL (/). If the image is statically imported, Next.js will automatically determine the intrinsic width and height. These values are used to determine the image ratio and prevent Cumulative Layout Shift while your image is loading. Remote images To use a remote image, you can provide a URL string for the src property. Since Next.js does not have access to remote files during the build process, you'll need to provide the width, height and optional blurDataURL props manually. The width and height are used to infer the correct aspect ratio of image and avoid layout shift from the image loading in. Alternatively, you can use the fill property to make the image fill the size of the parent element. To safely allow images from remote servers, you need to define a list of supported URL patterns in next.config.js. Be as specific as possible to prevent malicious usage. For example, the following configuration will only allow images from a specific AWS S3 bucket:",
    "excerpt": "The Next.js component extends the HTML element to provide: - Size optimization: Automatically serving correctly sized images for each device, using modern image formats like WebP. - Visual stability:...",
    "url": "https://nextjs.org/docs/01-app/01-getting-started/12-images"
  },
  {
    "id": "01-app-01-getting-started-13-fonts",
    "path": "01-app\\01-getting-started\\13-fonts.mdx",
    "title": "Font Optimization",
    "description": "Learn how to optimize fonts in Next.js",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Google fonts",
        "slug": "google-fonts"
      },
      {
        "level": 2,
        "text": "Local fonts",
        "slug": "local-fonts"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "import { Geist } from 'next/font/google'\r\n\r\nconst geist = Geist({\r\n  subsets: ['latin'],\r\n})\r\n\r\nexport default function Layout({ children }: { children: React.ReactNode }) {\r\n  return (\r\n    <html lang=\"en\" className={geist.className}>\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" highlight={1,3-5,9} switcher"
      },
      {
        "language": "jsx",
        "code": "import { Geist } from 'next/font/google'\r\n\r\nconst geist = Geist({\r\n  subsets: ['latin'],\r\n})\r\n\r\nexport default function Layout({ children }) {\r\n  return (\r\n    <html className={geist.className}>\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" highlight={1,3-5,9} switcher"
      },
      {
        "language": "tsx",
        "code": "import { Geist } from 'next/font/google'\r\n\r\nconst geist = Geist({\r\n  subsets: ['latin'],\r\n})\r\n\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\" className={geist.className}>\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { Geist } from 'next/font/google'\r\n\r\nconst geist = Geist({\r\n  subsets: ['latin'],\r\n})\r\n\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\" className={geist.className}>\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { Roboto } from 'next/font/google'\r\n\r\nconst roboto = Roboto({\r\n  weight: '400',\r\n  subsets: ['latin'],\r\n})\r\n\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\" className={roboto.className}>\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" highlight={4} switcher"
      },
      {
        "language": "jsx",
        "code": "import { Roboto } from 'next/font/google'\r\n\r\nconst roboto = Roboto({\r\n  weight: '400',\r\n  subsets: ['latin'],\r\n})\r\n\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\" className={roboto.className}>\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\"  highlight={4} switcher"
      },
      {
        "language": "tsx",
        "code": "import localFont from 'next/font/local'\r\n\r\nconst myFont = localFont({\r\n  src: './my-font.woff2',\r\n})\r\n\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\" className={myFont.className}>\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import localFont from 'next/font/local'\r\n\r\nconst myFont = localFont({\r\n  src: './my-font.woff2',\r\n})\r\n\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\" className={myFont.className}>\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "js",
        "code": "const roboto = localFont({\r\n  src: [\r\n    {\r\n      path: './Roboto-Regular.woff2',\r\n      weight: '400',\r\n      style: 'normal',\r\n    },\r\n    {\r\n      path: './Roboto-Italic.woff2',\r\n      weight: '400',\r\n      style: 'italic',\r\n    },\r\n    {\r\n      path: './Roboto-Bold.woff2',\r\n      weight: '700',\r\n      style: 'normal',\r\n    },\r\n    {\r\n      path: './Roboto-BoldItalic.woff2',\r\n      weight: '700',\r\n      style: 'italic',\r\n    },\r\n  ],\r\n})",
        "context": ""
      }
    ],
    "content": "The next/font module automatically optimizes your fonts and removes external network requests for improved privacy and performance. It includes built-in self-hosting for any font file. This means you can optimally load web fonts with no layout shift. To start using next/font, import it from next/font/local or next/font/google, call it as a function with the appropriate options, and set the className of the element you want to apply the font to. For example: Fonts are scoped to the component they're used in. To apply a font to your entire application, add it to the Root Layout. Google fonts You can automatically self-host any Google Font. Fonts are included stored as static assets and served from the same domain as your deployment, meaning no requests are sent to Google by the browser when the user visits your site. To start using a Google Font, import your chosen font from next/font/google: We recommend using variable fonts for the best performance and flexibility. But if you can't use a variable font, you will need to specify a weight: Local fonts To use a local font, import your font from next/font/local and specify the src of your local font file. Fonts can be stored in the public folder or co-located inside the app folder. For example: If you want to use multiple files for a single font family, src can be an array:",
    "excerpt": "The next/font module automatically optimizes your fonts and removes external network requests for improved privacy and performance. It includes built-in self-hosting for any font file. This means you...",
    "url": "https://nextjs.org/docs/01-app/01-getting-started/13-fonts"
  },
  {
    "id": "01-app-01-getting-started-14-metadata-and-og-images",
    "path": "01-app\\01-getting-started\\14-metadata-and-og-images.mdx",
    "title": "Metadata and OG images",
    "description": "Learn how to add metadata to your pages and create dynamic OG images.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Default fields",
        "slug": "default-fields"
      },
      {
        "level": 2,
        "text": "Static metadata",
        "slug": "static-metadata"
      },
      {
        "level": 2,
        "text": "Generated metadata",
        "slug": "generated-metadata"
      },
      {
        "level": 3,
        "text": "Streaming metadata",
        "slug": "streaming-metadata"
      },
      {
        "level": 3,
        "text": "Memoizing data requests",
        "slug": "memoizing-data-requests"
      },
      {
        "level": 2,
        "text": "File-based metadata",
        "slug": "file-based-metadata"
      },
      {
        "level": 2,
        "text": "Favicons",
        "slug": "favicons"
      },
      {
        "level": 2,
        "text": "Static Open Graph images",
        "slug": "static-open-graph-images"
      },
      {
        "level": 2,
        "text": "Generated Open Graph images",
        "slug": "generated-open-graph-images"
      }
    ],
    "codeBlocks": [
      {
        "language": "html",
        "code": "<meta charset=\"utf-8\" />\r\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "import type { Metadata } from 'next'\r\n\r\nexport const metadata: Metadata = {\r\n  title: 'My Blog',\r\n  description: '...',\r\n}\r\n\r\nexport default function Layout() {}",
        "context": "filename=\"app/blog/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  title: 'My Blog',\r\n  description: '...',\r\n}\r\n\r\nexport default function Layout() {}",
        "context": "filename=\"app/blog/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import type { Metadata, ResolvingMetadata } from 'next'\r\n\r\ntype Props = {\r\n  params: Promise<{ slug: string }>\r\n  searchParams: Promise<{ [key: string]: string | string[] | undefined }>\r\n}\r\n\r\nexport async function generateMetadata(\r\n  { params, searchParams }: Props,\r\n  parent: ResolvingMetadata\r\n): Promise<Metadata> {\r\n  const slug = (await params).slug\r\n\r\n  // fetch post information\r\n  const post = await fetch(`https://api.vercel.app/blog/${slug}`).then((res) =>\r\n    res.json()\r\n  )\r\n\r\n  return {\r\n    title: post.title,\r\n    description: post.description,\r\n  }\r\n}\r\n\r\nexport default function Page({ params, searchParams }: Props) {}",
        "context": "filename=\"app/blog/[slug]/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export async function generateMetadata({ params, searchParams }, parent) {\r\n  const slug = (await params).slug\r\n\r\n  // fetch post information\r\n  const post = await fetch(`https://api.vercel.app/blog/${slug}`).then((res) =>\r\n    res.json()\r\n  )\r\n\r\n  return {\r\n    title: post.title,\r\n    description: post.description,\r\n  }\r\n}\r\n\r\nexport default function Page({ params, searchParams }) {}",
        "context": "filename=\"app/blog/[slug]/page.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { cache } from 'react'\r\nimport { db } from '@/app/lib/db'\r\n\r\n// getPost will be used twice, but execute only once\r\nexport const getPost = cache(async (slug: string) => {\r\n  const res = await db.query.posts.findFirst({ where: eq(posts.slug, slug) })\r\n  return res\r\n})",
        "context": "filename=\"app/lib/data.ts\" highlight={5} switcher"
      },
      {
        "language": "js",
        "code": "import { cache } from 'react'\r\nimport { db } from '@/app/lib/db'\r\n\r\n// getPost will be used twice, but execute only once\r\nexport const getPost = cache(async (slug) => {\r\n  const res = await db.query.posts.findFirst({ where: eq(posts.slug, slug) })\r\n  return res\r\n})",
        "context": "filename=\"app/lib/data.js\" highlight={5} switcher"
      },
      {
        "language": "tsx",
        "code": "import { getPost } from '@/app/lib/data'\r\n\r\nexport async function generateMetadata({\r\n  params,\r\n}: {\r\n  params: { slug: string }\r\n}) {\r\n  const post = await getPost(params.slug)\r\n  return {\r\n    title: post.title,\r\n    description: post.description,\r\n  }\r\n}\r\n\r\nexport default async function Page({ params }: { params: { slug: string } }) {\r\n  const post = await getPost(params.slug)\r\n  return <div>{post.title}</div>\r\n}",
        "context": "filename=\"app/blog/[slug]/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { getPost } from '@/app/lib/data'\r\n\r\nexport async function generateMetadata({ params }) {\r\n  const post = await getPost(params.slug)\r\n  return {\r\n    title: post.title,\r\n    description: post.description,\r\n  }\r\n}\r\n\r\nexport default async function Page({ params }) {\r\n  const post = await getPost(params.slug)\r\n  return <div>{post.title}</div>\r\n}",
        "context": "filename=\"app/blog/[slug]/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { ImageResponse } from 'next/og'\r\nimport { getPost } from '@/app/lib/data'\r\n\r\n// Image metadata\r\nexport const size = {\r\n  width: 1200,\r\n  height: 630,\r\n}\r\n\r\nexport const contentType = 'image/png'\r\n\r\n// Image generation\r\nexport default async function Image({ params }: { params: { slug: string } }) {\r\n  const post = await getPost(params.slug)\r\n\r\n  return new ImageResponse(\r\n    (\r\n      // ImageResponse JSX element\r\n      <div\r\n        style={{\r\n          fontSize: 128,\r\n          background: 'white',\r\n          width: '100%',\r\n          height: '100%',\r\n          display: 'flex',\r\n          alignItems: 'center',\r\n          justifyContent: 'center',\r\n        }}\r\n      >\r\n        {post.title}\r\n      </div>\r\n    )\r\n  )\r\n}",
        "context": "filename=\"app/blog/[slug]/opengraph-image.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { ImageResponse } from 'next/og'\r\nimport { getPost } from '@/app/lib/data'\r\n\r\n// Image metadata\r\nexport const size = {\r\n  width: 1200,\r\n  height: 630,\r\n}\r\n\r\nexport const contentType = 'image/png'\r\n\r\n// Image generation\r\nexport default async function Image({ params }) {\r\n  const post = await getPost(params.slug)\r\n\r\n  return new ImageResponse(\r\n    (\r\n      // ImageResponse JSX element\r\n      <div\r\n        style={{\r\n          fontSize: 128,\r\n          background: 'white',\r\n          width: '100%',\r\n          height: '100%',\r\n          display: 'flex',\r\n          alignItems: 'center',\r\n          justifyContent: 'center',\r\n        }}\r\n      >\r\n        {post.title}\r\n      </div>\r\n    )\r\n  )\r\n}",
        "context": "filename=\"app/blog/[slug]/opengraph-image.js\" switcher"
      }
    ],
    "content": "The Metadata APIs can be used to define your application metadata for improved SEO and web shareability and include: 1. The static metadata object 2. The dynamic generateMetadata function 3. Special file conventions that can be used to add static or dynamically generated favicons and OG images. With all the options above, Next.js will automatically generate the relevant tags for your page, which can be inspected in the browser's developer tools. The metadata object and generateMetadata function exports are only supported in Server Components. Default fields There are two default meta tags that are always added even if a route doesn't define metadata: - The meta charset tag sets the character encoding for the website. - The meta viewport tag sets the viewport width and scale for the website to adjust for different devices. The other metadata fields can be defined with the Metadata object (for static metadata) or the generateMetadata function (for generated metadata). Static metadata To define static metadata, export a Metadata object from a static layout.js or page.js file. For example, to add a title and description to the blog route: You can view a full list of available options, in the generateMetadata documentation. Generated metadata You can use generateMetadata function to fetch metadata that depends on data. For example, to fetch the title and description for a specific blog post: Streaming metadata For dynamically rendered pages, Next.js streams metadata separately, injecting it into the HTML once generateMetadata resolves, without blocking UI rendering. Streaming metadata improves perceived performance by allowing visual content to stream first. Streaming metadata is disabled for bots and crawlers that expect metadata to be in the tag (e.g. Twitterbot, Slackbot, Bingbot). These are detected by using the User Agent header from the incoming request. You can customize or disable streaming metadata completely, with the htmlLimitedBots option in your Next.js config file. Statically rendered pages don’t use streaming since metadata is resolved at build time. Learn more about streaming metadata. Memoizing data requests There may be cases where you need to fetch the same data for metadata and the page itself. To avoid duplicate requests, you can use React's cache function to memoize the return value and only fetch the data once. For example, to fetch the blog post information for both the metadata and the page: File-based metadata The following special files are available for metadata: - favicon.ico, apple-icon.jpg, and icon.jpg - opengraph-image.jpg and twitter-image.jpg - robots.txt - sitemap.xml You can use these for static metadata, or you can programmatically generate these files with code. Favicons Favicons are small icons that represent your site in bookmarks and search results. To add a favicon to your application, create a favicon.ico and add to the root of the app folder. > You can also programmatically generate favicons using code. See the favicon docs for more information. Static Open Graph images Open Graph (OG) images are images that represent your site in social media. To add a static OG image to your application, create a opengraph-image.png file in the root of the app folder. You can also add OG images for specific routes by creating a opengraph-image.png deeper down the folder structure. For example, to create an OG image specific to the /blog route, add a opengraph-image.jpg file inside the blog folder. The more specific image will take precedence over any OG images above it in the folder structure. > Other image formats such as jpeg, png, and gif are also supported. See the Open Graph Image docs for more information. Generated Open Graph images The ImageResponse constructor allows you to generate dynamic images using JSX and CSS. This is useful for OG images that depend on data. For example, to generate a unique OG image for each blog post, add a opengraph-image.tsx file inside the blog folder, and import the ImageResponse constructor from next/og: ImageResponse supports common CSS properties including flexbox and absolute positioning, custom fonts, text wrapping, centering, and nested images. See the full list of supported CSS properties. > Good to know: > > - Examples are available in the Vercel OG Playground. > - ImageResponse uses @vercel/og, satori, and resvg to convert HTML and CSS into PNG. > - Only flexbox and a subset of CSS properties are supported. Advanced layouts (e.g. display: grid) will not work.",
    "excerpt": "The Metadata APIs can be used to define your application metadata for improved SEO and web shareability and include: 1. The static metadata object 2. The dynamic generateMetadata function 3. Special f...",
    "url": "https://nextjs.org/docs/01-app/01-getting-started/14-metadata-and-og-images"
  },
  {
    "id": "01-app-01-getting-started-15-route-handlers",
    "path": "01-app\\01-getting-started\\15-route-handlers.mdx",
    "title": "Route Handlers",
    "description": "Learn how to use Route Handlers",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Route Handlers",
        "slug": "route-handlers"
      },
      {
        "level": 3,
        "text": "Convention",
        "slug": "convention"
      },
      {
        "level": 3,
        "text": "Supported HTTP Methods",
        "slug": "supported-http-methods"
      },
      {
        "level": 3,
        "text": "Extended  and  APIs",
        "slug": "extended-and-apis"
      },
      {
        "level": 3,
        "text": "Caching",
        "slug": "caching"
      },
      {
        "level": 3,
        "text": "Special Route Handlers",
        "slug": "special-route-handlers"
      },
      {
        "level": 3,
        "text": "Route Resolution",
        "slug": "route-resolution"
      },
      {
        "level": 3,
        "text": "Route Context Helper",
        "slug": "route-context-helper"
      }
    ],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "export async function GET(request: Request) {}",
        "context": "filename=\"app/api/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export async function GET(request) {}",
        "context": "filename=\"app/api/route.js\" switcher"
      },
      {
        "language": "ts",
        "code": "export const dynamic = 'force-static'\r\n\r\nexport async function GET() {\r\n  const res = await fetch('https://data.mongodb-api.com/...', {\r\n    headers: {\r\n      'Content-Type': 'application/json',\r\n      'API-Key': process.env.DATA_API_KEY,\r\n    },\r\n  })\r\n  const data = await res.json()\r\n\r\n  return Response.json({ data })\r\n}",
        "context": "filename=\"app/items/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export const dynamic = 'force-static'\r\n\r\nexport async function GET() {\r\n  const res = await fetch('https://data.mongodb-api.com/...', {\r\n    headers: {\r\n      'Content-Type': 'application/json',\r\n      'API-Key': process.env.DATA_API_KEY,\r\n    },\r\n  })\r\n  const data = await res.json()\r\n\r\n  return Response.json({ data })\r\n}",
        "context": "filename=\"app/items/route.js\" switcher"
      },
      {
        "language": "ts",
        "code": "export default function Page() {\r\n  return <h1>Hello, Next.js!</h1>\r\n}\r\n\r\n// Conflict\r\n// `app/route.ts`\r\nexport async function POST(request: Request) {}",
        "context": "filename=\"app/page.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export default function Page() {\r\n  return <h1>Hello, Next.js!</h1>\r\n}\r\n\r\n// Conflict\r\n// `app/route.js`\r\nexport async function POST(request) {}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import type { NextRequest } from 'next/server'\r\n\r\nexport async function GET(_req: NextRequest, ctx: RouteContext<'/users/[id]'>) {\r\n  const { id } = await ctx.params\r\n  return Response.json({ id })\r\n}",
        "context": "filename=\"app/users/[id]/route.ts\" switcher"
      }
    ],
    "content": "Route Handlers Route Handlers allow you to create custom request handlers for a given route using the Web Request and Response APIs. > Good to know: Route Handlers are only available inside the app directory. They are the equivalent of API Routes inside the pages directory meaning you do not need to use API Routes and Route Handlers together. Convention Route Handlers are defined in a route.js|ts file inside the app directory: Route Handlers can be nested anywhere inside the app directory, similar to page.js and layout.js. But there cannot be a route.js file at the same route segment level as page.js. Supported HTTP Methods The following HTTP methods are supported: GET, POST, PUT, PATCH, DELETE, HEAD, and OPTIONS. If an unsupported method is called, Next.js will return a 405 Method Not Allowed response. Extended NextRequest and NextResponse APIs In addition to supporting the native Request and Response APIs, Next.js extends them with NextRequest and NextResponse to provide convenient helpers for advanced use cases. Caching Route Handlers are not cached by default. You can, however, opt into caching for GET methods. Other supported HTTP methods are not cached. To cache a GET method, use a route config option such as export const dynamic = 'force-static' in your Route Handler file. > Good to know: Other supported HTTP methods are not cached, even if they are placed alongside a GET method that is cached, in the same file. Special Route Handlers Special Route Handlers like sitemap.ts, opengraph-image.tsx, and icon.tsx, and other metadata files remain static by default unless they use Dynamic APIs or dynamic config options. Route Resolution You can consider a route the lowest level routing primitive. - They do not participate in layouts or client-side navigations like page. - There cannot be a route.js file at the same route as page.js. | Page | Route | Result | | -------------------- | ------------------ | ---------------------------- | | app/page.js | app/route.js | Conflict | | app/page.js | app/api/route.js | Valid | | app/[user]/page.js | app/api/route.js | Valid | Each route.js or page.js file takes over all HTTP verbs for that route. Read more about how Route Handlers complement your frontend application, or explore the Route Handlers API Reference. Route Context Helper In TypeScript, you can type the context parameter for Route Handlers with the globally available RouteContext helper: > Good to know > > - Types are generated during next dev, next build or next typegen.",
    "excerpt": "Route Handlers Route Handlers allow you to create custom request handlers for a given route using the Web Request and Response APIs. > Good to know: Route Handlers are only available inside the app di...",
    "url": "https://nextjs.org/docs/01-app/01-getting-started/15-route-handlers"
  },
  {
    "id": "01-app-01-getting-started-16-proxy",
    "path": "01-app\\01-getting-started\\16-proxy.mdx",
    "title": "Proxy",
    "description": "Learn how to use Proxy",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Proxy",
        "slug": "proxy"
      },
      {
        "level": 3,
        "text": "Use cases",
        "slug": "use-cases"
      },
      {
        "level": 3,
        "text": "Convention",
        "slug": "convention"
      },
      {
        "level": 3,
        "text": "Example",
        "slug": "example"
      }
    ],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "import { NextResponse } from 'next/server'\r\nimport type { NextRequest } from 'next/server'\r\n\r\n// This function can be marked `async` if using `await` inside\r\nexport function proxy(request: NextRequest) {\r\n  return NextResponse.redirect(new URL('/home', request.url))\r\n}\r\n\r\n// See \"Matching Paths\" below to learn more\r\nexport const config = {\r\n  matcher: '/about/:path*',\r\n}",
        "context": "filename=\"proxy.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { NextResponse } from 'next/server'\r\n\r\n// This function can be marked `async` if using `await` inside\r\nexport function proxy(request) {\r\n  return NextResponse.redirect(new URL('/home', request.url))\r\n}\r\n\r\n// See \"Matching Paths\" below to learn more\r\nexport const config = {\r\n  matcher: '/about/:path*',\r\n}",
        "context": "filename=\"proxy.js\" switcher"
      }
    ],
    "content": "Proxy Proxy allows you to run code before a request is completed. Then, based on the incoming request, you can modify the response by rewriting, redirecting, modifying the request or response headers, or responding directly. Use cases Some common scenarios where Proxy is effective include: - Quick redirects after reading parts of the incoming request - Rewriting to different pages based on A/B tests or experiments - Modifying headers for all pages or a subset of pages Proxy is not intended for slow data fetching. While Proxy can be helpful for optimistic checks such as permission-based redirects, it should not be used as a full session management or authorization solution. Using fetch with options.cache, options.next.revalidate, or options.next.tags, has no effect in Proxy. Convention Create a proxy.ts (or .js) file in the project root, or inside src if applicable, so that it is located at the same level as pages or app. > Note: While only one proxy.ts file is supported per project, you can still organize your proxy logic into modules. Break out proxy functionalities into separate .ts or .js files and import them into your main proxy.ts file. This allows for cleaner management of route-specific proxy, aggregated in the proxy.ts for centralized control. By enforcing a single proxy file, it simplifies configuration, prevents potential conflicts, and optimizes performance by avoiding multiple proxy layers. Example Read more about using proxy, or refer to the proxy API reference.",
    "excerpt": "Proxy Proxy allows you to run code before a request is completed. Then, based on the incoming request, you can modify the response by rewriting, redirecting, modifying the request or response headers,...",
    "url": "https://nextjs.org/docs/01-app/01-getting-started/16-proxy"
  },
  {
    "id": "01-app-01-getting-started-17-deploying",
    "path": "01-app\\01-getting-started\\17-deploying.mdx",
    "title": "Deploying",
    "description": "Learn how to deploy your Next.js application.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Node.js server",
        "slug": "nodejs-server"
      },
      {
        "level": 3,
        "text": "Templates",
        "slug": "templates"
      },
      {
        "level": 2,
        "text": "Docker",
        "slug": "docker"
      },
      {
        "level": 3,
        "text": "Templates",
        "slug": "templates"
      },
      {
        "level": 2,
        "text": "Static export",
        "slug": "static-export"
      },
      {
        "level": 3,
        "text": "Templates",
        "slug": "templates"
      },
      {
        "level": 2,
        "text": "Adapters",
        "slug": "adapters"
      }
    ],
    "codeBlocks": [
      {
        "language": "json",
        "code": "{\r\n  \"scripts\": {\r\n    \"dev\": \"next dev\",\r\n    \"build\": \"next build\",\r\n    \"start\": \"next start\"\r\n  }\r\n}",
        "context": "filename=\"package.json\""
      }
    ],
    "content": "Next.js can be deployed as a Node.js server, Docker container, static export, or adapted to run on different platforms. | Deployment Option | Feature Support | | -------------------------------- | ----------------- | | Node.js server | All | | Docker container | All | | Static export | Limited | | Adapters | Platform-specific | Node.js server Next.js can be deployed to any provider that supports Node.js. Ensure your package.json has the \"build\" and \"start\" scripts: Then, run npm run build to build your application and npm run start to start the Node.js server. This server supports all Next.js features. If needed, you can also eject to a custom server. Node.js deployments support all Next.js features. Learn how to configure them for your infrastructure. Templates - Flightcontrol - Railway - Replit Docker Next.js can be deployed to any provider that supports Docker containers. This includes container orchestrators like Kubernetes or a cloud provider that runs Docker. Docker deployments support all Next.js features. Learn how to configure them for your infrastructure. > Note for development: While Docker is excellent for production deployments, consider using local development (npm run dev) instead of Docker during development on Mac and Windows for better performance. Learn more about optimizing local development. Templates - Docker - Docker Multi-Environment - DigitalOcean - Fly.io - Google Cloud Run - Render - SST Static export Next.js enables starting as a static site or Single-Page Application (SPA), then later optionally upgrading to use features that require a server. Since Next.js supports static exports, it can be deployed and hosted on any web server that can serve HTML/CSS/JS static assets. This includes tools like AWS S3, Nginx, or Apache. Running as a static export does not support Next.js features that require a server. Learn more. Templates - GitHub Pages Adapters Next.js can be adapted to run on different platforms to support their infrastructure capabilities. Refer to each provider's documentation for information on supported Next.js features: - AWS Amplify Hosting - Cloudflare - Deno Deploy - Netlify - Vercel > Note: We are working on a Deployment Adapters API for all platforms to adopt. After completion, we will add documentation on how to write your own adapters.",
    "excerpt": "Next.js can be deployed as a Node.js server, Docker container, static export, or adapted to run on different platforms. | Deployment Option | Feature Support | | -------------------------------- | ---...",
    "url": "https://nextjs.org/docs/01-app/01-getting-started/17-deploying"
  },
  {
    "id": "01-app-01-getting-started-18-upgrading",
    "path": "01-app\\01-getting-started\\18-upgrading.mdx",
    "title": "Upgrading",
    "description": "Learn how to upgrade your Next.js application to the latest version or canary.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Latest version",
        "slug": "latest-version"
      },
      {
        "level": 2,
        "text": "Canary version",
        "slug": "canary-version"
      },
      {
        "level": 3,
        "text": "Features available in canary",
        "slug": "features-available-in-canary"
      }
    ],
    "codeBlocks": [
      {
        "language": "bash",
        "code": "npx @next/codemod@latest upgrade latest",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "pnpm i next@latest react@latest react-dom@latest eslint-config-next@latest",
        "context": "package=\"pnpm\""
      },
      {
        "language": "bash",
        "code": "npm i next@latest react@latest react-dom@latest eslint-config-next@latest",
        "context": "package=\"npm\""
      },
      {
        "language": "bash",
        "code": "yarn add next@latest react@latest react-dom@latest eslint-config-next@latest",
        "context": "package=\"yarn\""
      },
      {
        "language": "bash",
        "code": "bun add next@latest react@latest react-dom@latest eslint-config-next@latest",
        "context": "package=\"bun\""
      },
      {
        "language": "bash",
        "code": "npm i next@canary",
        "context": "filename=\"Terminal\""
      }
    ],
    "content": "Latest version To update to the latest version of Next.js, you can use the upgrade codemod: If you prefer to upgrade manually, install the latest Next.js and React versions: Canary version To update to the latest canary, make sure you're on the latest version of Next.js and everything is working as expected. Then, run the following command: Features available in canary The following features are currently available in canary: Caching: - \"use cache\" - cacheLife - cacheTag - cacheComponents Authentication: - forbidden - unauthorized - forbidden.js - unauthorized.js - authInterrupts",
    "excerpt": "Latest version To update to the latest version of Next.js, you can use the upgrade codemod: If you prefer to upgrade manually, install the latest Next.js and React versions: Canary version To update t...",
    "url": "https://nextjs.org/docs/01-app/01-getting-started/18-upgrading"
  },
  {
    "id": "01-app-01-getting-started-index",
    "path": "01-app\\01-getting-started\\index.mdx",
    "title": "Getting Started",
    "description": "Learn how to create full-stack web applications with the Next.js App Router.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Pre-requisite knowledge",
        "slug": "pre-requisite-knowledge"
      },
      {
        "level": 2,
        "text": "Next Steps",
        "slug": "next-steps"
      }
    ],
    "codeBlocks": [],
    "content": "Welcome to the Next.js documentation! This Getting Started section will help you create your first Next.js app and learn the core features you'll use in every project. Pre-requisite knowledge Our documentation assumes some familiarity with web development. Before getting started, it'll help if you're comfortable with: - HTML - CSS - JavaScript - React If you're new to React or need a refresher, we recommend starting with our React Foundations course, and the Next.js Foundations course that has you building an application as you learn. Next Steps",
    "excerpt": "Welcome to the Next.js documentation! This Getting Started section will help you create your first Next.js app and learn the core features you'll use in every project. Pre-requisite knowledge Our docu...",
    "url": "https://nextjs.org/docs/01-app/01-getting-started"
  },
  {
    "id": "01-app-02-guides-analytics",
    "path": "01-app\\02-guides\\analytics.mdx",
    "title": "How to add analytics to your Next.js application",
    "description": "Measure and track page performance using Next.js Speed Insights",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Client Instrumentation",
        "slug": "client-instrumentation"
      },
      {
        "level": 2,
        "text": "Build Your Own",
        "slug": "build-your-own"
      },
      {
        "level": 2,
        "text": "Web Vitals",
        "slug": "web-vitals"
      },
      {
        "level": 2,
        "text": "Custom Metrics",
        "slug": "custom-metrics"
      },
      {
        "level": 2,
        "text": "Sending results to external systems",
        "slug": "sending-results-to-external-systems"
      }
    ],
    "codeBlocks": [
      {
        "language": "js",
        "code": "// Initialize analytics before the app starts\r\nconsole.log('Analytics initialized')\r\n\r\n// Set up global error tracking\r\nwindow.addEventListener('error', (event) => {\r\n  // Send to your error tracking service\r\n  reportError(event.error)\r\n})",
        "context": "filename=\"instrumentation-client.js\""
      },
      {
        "language": "jsx",
        "code": "import { useReportWebVitals } from 'next/web-vitals'\r\n\r\nfunction MyApp({ Component, pageProps }) {\r\n  useReportWebVitals((metric) => {\r\n    console.log(metric)\r\n  })\r\n\r\n  return <Component {...pageProps} />\r\n}",
        "context": "filename=\"pages/_app.js\""
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { useReportWebVitals } from 'next/web-vitals'\r\n\r\nexport function WebVitals() {\r\n  useReportWebVitals((metric) => {\r\n    console.log(metric)\r\n  })\r\n}",
        "context": "filename=\"app/_components/web-vitals.js\""
      },
      {
        "language": "jsx",
        "code": "import { WebVitals } from './_components/web-vitals'\r\n\r\nexport default function Layout({ children }) {\r\n  return (\r\n    <html>\r\n      <body>\r\n        <WebVitals />\r\n        {children}\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\""
      },
      {
        "language": "jsx",
        "code": "import { useReportWebVitals } from 'next/web-vitals'\r\n\r\nfunction MyApp({ Component, pageProps }) {\r\n  useReportWebVitals((metric) => {\r\n    switch (metric.name) {\r\n      case 'FCP': {\r\n        // handle FCP results\r\n      }\r\n      case 'LCP': {\r\n        // handle LCP results\r\n      }\r\n      // ...\r\n    }\r\n  })\r\n\r\n  return <Component {...pageProps} />\r\n}",
        "context": "filename=\"pages/_app.js\""
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { useReportWebVitals } from 'next/web-vitals'\r\n\r\nexport function WebVitals() {\r\n  useReportWebVitals((metric) => {\r\n    switch (metric.name) {\r\n      case 'FCP': {\r\n        // handle FCP results\r\n      }\r\n      case 'LCP': {\r\n        // handle LCP results\r\n      }\r\n      // ...\r\n    }\r\n  })\r\n}",
        "context": "filename=\"app/_components/web-vitals.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { useReportWebVitals } from 'next/web-vitals'\r\n\r\nexport function WebVitals() {\r\n  useReportWebVitals((metric) => {\r\n    switch (metric.name) {\r\n      case 'FCP': {\r\n        // handle FCP results\r\n      }\r\n      case 'LCP': {\r\n        // handle LCP results\r\n      }\r\n      // ...\r\n    }\r\n  })\r\n}",
        "context": "filename=\"app/_components/web-vitals.js\" switcher"
      },
      {
        "language": "js",
        "code": "export function reportWebVitals(metric) {\r\n  switch (metric.name) {\r\n    case 'Next.js-hydration':\r\n      // handle hydration results\r\n      break\r\n    case 'Next.js-route-change-to-render':\r\n      // handle route-change to render results\r\n      break\r\n    case 'Next.js-render':\r\n      // handle render results\r\n      break\r\n    default:\r\n      break\r\n  }\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "useReportWebVitals((metric) => {\r\n  const body = JSON.stringify(metric)\r\n  const url = 'https://example.com/analytics'\r\n\r\n  // Use `navigator.sendBeacon()` if available, falling back to `fetch()`.\r\n  if (navigator.sendBeacon) {\r\n    navigator.sendBeacon(url, body)\r\n  } else {\r\n    fetch(url, { body, method: 'POST', keepalive: true })\r\n  }\r\n})",
        "context": ""
      },
      {
        "language": "js",
        "code": "useReportWebVitals((metric) => {\r\n  // Use `window.gtag` if you initialized Google Analytics as this example:\r\n  // https://github.com/vercel/next.js/blob/canary/examples/with-google-analytics\r\n  window.gtag('event', metric.name, {\r\n    value: Math.round(\r\n      metric.name === 'CLS' ? metric.value * 1000 : metric.value\r\n    ), // values must be integers\r\n    event_label: metric.id, // id unique to current page load\r\n    non_interaction: true, // avoids affecting bounce rate.\r\n  })\r\n})",
        "context": ""
      }
    ],
    "content": "Next.js has built-in support for measuring and reporting performance metrics. You can either use the useReportWebVitals hook to manage reporting yourself, or alternatively, Vercel provides a managed service to automatically collect and visualize metrics for you. Client Instrumentation For more advanced analytics and monitoring needs, Next.js provides a instrumentation-client.js|ts file that runs before your application's frontend code starts executing. This is ideal for setting up global analytics, error tracking, or performance monitoring tools. To use it, create an instrumentation-client.js or instrumentation-client.ts file in your application's root directory: Build Your Own View the API Reference for more information. > Since the useReportWebVitals hook requires the 'use client' directive, the most performant approach is to create a separate component that the root layout imports. This confines the client boundary exclusively to the WebVitals component. View the API Reference for more information. Web Vitals Web Vitals are a set of useful metrics that aim to capture the user experience of a web page. The following web vitals are all included: - Time to First Byte (TTFB) - First Contentful Paint (FCP) - Largest Contentful Paint (LCP) - First Input Delay (FID) - Cumulative Layout Shift (CLS) - Interaction to Next Paint (INP) You can handle all the results of these metrics using the name property. Custom Metrics In addition to the core metrics listed above, there are some additional custom metrics that measure the time it takes for the page to hydrate and render: - Next.js-hydration: Length of time it takes for the page to start and finish hydrating (in ms) - Next.js-route-change-to-render: Length of time it takes for a page to start rendering after a route change (in ms) - Next.js-render: Length of time it takes for a page to finish render after a route change (in ms) You can handle all the results of these metrics separately: These metrics work in all browsers that support the User Timing API. Sending results to external systems You can send results to any endpoint to measure and track real user performance on your site. For example: > Good to know: If you use Google Analytics, using the > id value can allow you to construct metric distributions manually (to calculate percentiles, > etc.) > > > Read more about sending results to Google Analytics.",
    "excerpt": "Next.js has built-in support for measuring and reporting performance metrics. You can either use the useReportWebVitals hook to manage reporting yourself, or alternatively, Vercel provides a managed s...",
    "url": "https://nextjs.org/docs/01-app/02-guides/analytics"
  },
  {
    "id": "01-app-02-guides-authentication",
    "path": "01-app\\02-guides\\authentication.mdx",
    "title": "How to implement authentication in Next.js",
    "description": "Learn how to implement authentication in your Next.js application.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Authentication",
        "slug": "authentication"
      },
      {
        "level": 3,
        "text": "Sign-up and login functionality",
        "slug": "sign-up-and-login-functionality"
      },
      {
        "level": 4,
        "text": "1. Capture user credentials",
        "slug": "1-capture-user-credentials"
      },
      {
        "level": 4,
        "text": "2. Validate form fields on the server",
        "slug": "2-validate-form-fields-on-the-server"
      },
      {
        "level": 4,
        "text": "3. Create a user or check user credentials",
        "slug": "3-create-a-user-or-check-user-credentials"
      },
      {
        "level": 2,
        "text": "Session Management",
        "slug": "session-management"
      },
      {
        "level": 3,
        "text": "Stateless Sessions",
        "slug": "stateless-sessions"
      },
      {
        "level": 4,
        "text": "1. Generating a secret key",
        "slug": "1-generating-a-secret-key"
      },
      {
        "level": 4,
        "text": "2. Encrypting and decrypting sessions",
        "slug": "2-encrypting-and-decrypting-sessions"
      },
      {
        "level": 4,
        "text": "3. Setting cookies (recommended options)",
        "slug": "3-setting-cookies-recommended-options"
      },
      {
        "level": 4,
        "text": "Updating (or refreshing) sessions",
        "slug": "updating-or-refreshing-sessions"
      },
      {
        "level": 4,
        "text": "Deleting the session",
        "slug": "deleting-the-session"
      },
      {
        "level": 4,
        "text": "Setting and deleting cookies",
        "slug": "setting-and-deleting-cookies"
      },
      {
        "level": 3,
        "text": "Database Sessions",
        "slug": "database-sessions"
      },
      {
        "level": 2,
        "text": "Authorization",
        "slug": "authorization"
      },
      {
        "level": 3,
        "text": "Optimistic checks with Proxy (Optional)",
        "slug": "optimistic-checks-with-proxy-optional"
      },
      {
        "level": 3,
        "text": "Creating a Data Access Layer (DAL)",
        "slug": "creating-a-data-access-layer-dal"
      },
      {
        "level": 3,
        "text": "Using Data Transfer Objects (DTO)",
        "slug": "using-data-transfer-objects-dto"
      },
      {
        "level": 3,
        "text": "Server Components",
        "slug": "server-components"
      },
      {
        "level": 3,
        "text": "Layouts and auth checks",
        "slug": "layouts-and-auth-checks"
      },
      {
        "level": 3,
        "text": "Server Actions",
        "slug": "server-actions"
      },
      {
        "level": 3,
        "text": "Route Handlers",
        "slug": "route-handlers"
      },
      {
        "level": 2,
        "text": "Context Providers",
        "slug": "context-providers"
      },
      {
        "level": 3,
        "text": "Creating a Data Access Layer (DAL)",
        "slug": "creating-a-data-access-layer-dal"
      },
      {
        "level": 4,
        "text": "Protecting API Routes",
        "slug": "protecting-api-routes"
      },
      {
        "level": 2,
        "text": "Resources",
        "slug": "resources"
      },
      {
        "level": 3,
        "text": "Auth Libraries",
        "slug": "auth-libraries"
      },
      {
        "level": 3,
        "text": "Session Management Libraries",
        "slug": "session-management-libraries"
      },
      {
        "level": 2,
        "text": "Further Reading",
        "slug": "further-reading"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "import { signup } from '@/app/actions/auth'\r\n\r\nexport function SignupForm() {\r\n  return (\r\n    <form action={signup}>\r\n      <div>\r\n        <label htmlFor=\"name\">Name</label>\r\n        <input id=\"name\" name=\"name\" placeholder=\"Name\" />\r\n      </div>\r\n      <div>\r\n        <label htmlFor=\"email\">Email</label>\r\n        <input id=\"email\" name=\"email\" type=\"email\" placeholder=\"Email\" />\r\n      </div>\r\n      <div>\r\n        <label htmlFor=\"password\">Password</label>\r\n        <input id=\"password\" name=\"password\" type=\"password\" />\r\n      </div>\r\n      <button type=\"submit\">Sign Up</button>\r\n    </form>\r\n  )\r\n}",
        "context": "filename=\"app/ui/signup-form.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { signup } from '@/app/actions/auth'\r\n\r\nexport function SignupForm() {\r\n  return (\r\n    <form action={signup}>\r\n      <div>\r\n        <label htmlFor=\"name\">Name</label>\r\n        <input id=\"name\" name=\"name\" placeholder=\"Name\" />\r\n      </div>\r\n      <div>\r\n        <label htmlFor=\"email\">Email</label>\r\n        <input id=\"email\" name=\"email\" type=\"email\" placeholder=\"Email\" />\r\n      </div>\r\n      <div>\r\n        <label htmlFor=\"password\">Password</label>\r\n        <input id=\"password\" name=\"password\" type=\"password\" />\r\n      </div>\r\n      <button type=\"submit\">Sign Up</button>\r\n    </form>\r\n  )\r\n}",
        "context": "filename=\"app/ui/signup-form.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export async function signup(formData: FormData) {}",
        "context": "filename=\"app/actions/auth.ts\" switcher"
      },
      {
        "language": "jsx",
        "code": "export async function signup(formData) {}",
        "context": "filename=\"app/actions/auth.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import * as z from 'zod'\r\n\r\nexport const SignupFormSchema = z.object({\r\n  name: z\r\n    .string()\r\n    .min(2, { error: 'Name must be at least 2 characters long.' })\r\n    .trim(),\r\n  email: z.email({ error: 'Please enter a valid email.' }).trim(),\r\n  password: z\r\n    .string()\r\n    .min(8, { error: 'Be at least 8 characters long' })\r\n    .regex(/[a-zA-Z]/, { error: 'Contain at least one letter.' })\r\n    .regex(/[0-9]/, { error: 'Contain at least one number.' })\r\n    .regex(/[^a-zA-Z0-9]/, {\r\n      error: 'Contain at least one special character.',\r\n    })\r\n    .trim(),\r\n})\r\n\r\nexport type FormState =\r\n  | {\r\n      errors?: {\r\n        name?: string[]\r\n        email?: string[]\r\n        password?: string[]\r\n      }\r\n      message?: string\r\n    }\r\n  | undefined",
        "context": "filename=\"app/lib/definitions.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import * as z from 'zod'\r\n\r\nexport const SignupFormSchema = z.object({\r\n  name: z\r\n    .string()\r\n    .min(2, { error: 'Name must be at least 2 characters long.' })\r\n    .trim(),\r\n  email: z.email({ error: 'Please enter a valid email.' }).trim(),\r\n  password: z\r\n    .string()\r\n    .min(8, { error: 'Be at least 8 characters long' })\r\n    .regex(/[a-zA-Z]/, { error: 'Contain at least one letter.' })\r\n    .regex(/[0-9]/, { error: 'Contain at least one number.' })\r\n    .regex(/[^a-zA-Z0-9]/, {\r\n      error: 'Contain at least one special character.',\r\n    })\r\n    .trim(),\r\n})",
        "context": "filename=\"app/lib/definitions.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { SignupFormSchema, FormState } from '@/app/lib/definitions'\r\n\r\nexport async function signup(state: FormState, formData: FormData) {\r\n  // Validate form fields\r\n  const validatedFields = SignupFormSchema.safeParse({\r\n    name: formData.get('name'),\r\n    email: formData.get('email'),\r\n    password: formData.get('password'),\r\n  })\r\n\r\n  // If any form fields are invalid, return early\r\n  if (!validatedFields.success) {\r\n    return {\r\n      errors: validatedFields.error.flatten().fieldErrors,\r\n    }\r\n  }\r\n\r\n  // Call the provider or db to create a user...\r\n}",
        "context": "filename=\"app/actions/auth.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { SignupFormSchema } from '@/app/lib/definitions'\r\n\r\nexport async function signup(state, formData) {\r\n  // Validate form fields\r\n  const validatedFields = SignupFormSchema.safeParse({\r\n    name: formData.get('name'),\r\n    email: formData.get('email'),\r\n    password: formData.get('password'),\r\n  })\r\n\r\n  // If any form fields are invalid, return early\r\n  if (!validatedFields.success) {\r\n    return {\r\n      errors: validatedFields.error.flatten().fieldErrors,\r\n    }\r\n  }\r\n\r\n  // Call the provider or db to create a user...\r\n}",
        "context": "filename=\"app/actions/auth.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { signup } from '@/app/actions/auth'\r\nimport { useActionState } from 'react'\r\n\r\nexport default function SignupForm() {\r\n  const [state, action, pending] = useActionState(signup, undefined)\r\n\r\n  return (\r\n    <form action={action}>\r\n      <div>\r\n        <label htmlFor=\"name\">Name</label>\r\n        <input id=\"name\" name=\"name\" placeholder=\"Name\" />\r\n      </div>\r\n      {state?.errors?.name && <p>{state.errors.name}</p>}\r\n\r\n      <div>\r\n        <label htmlFor=\"email\">Email</label>\r\n        <input id=\"email\" name=\"email\" placeholder=\"Email\" />\r\n      </div>\r\n      {state?.errors?.email && <p>{state.errors.email}</p>}\r\n\r\n      <div>\r\n        <label htmlFor=\"password\">Password</label>\r\n        <input id=\"password\" name=\"password\" type=\"password\" />\r\n      </div>\r\n      {state?.errors?.password && (\r\n        <div>\r\n          <p>Password must:</p>\r\n          <ul>\r\n            {state.errors.password.map((error) => (\r\n              <li key={error}>- {error}</li>\r\n            ))}\r\n          </ul>\r\n        </div>\r\n      )}\r\n      <button disabled={pending} type=\"submit\">\r\n        Sign Up\r\n      </button>\r\n    </form>\r\n  )\r\n}",
        "context": "filename=\"app/ui/signup-form.tsx\" switcher highlight={7,15,21,27-36}"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { signup } from '@/app/actions/auth'\r\nimport { useActionState } from 'react'\r\n\r\nexport default function SignupForm() {\r\n  const [state, action, pending] = useActionState(signup, undefined)\r\n\r\n  return (\r\n    <form action={action}>\r\n      <div>\r\n        <label htmlFor=\"name\">Name</label>\r\n        <input id=\"name\" name=\"name\" placeholder=\"Name\" />\r\n      </div>\r\n      {state?.errors?.name && <p>{state.errors.name}</p>}\r\n\r\n      <div>\r\n        <label htmlFor=\"email\">Email</label>\r\n        <input id=\"email\" name=\"email\" placeholder=\"Email\" />\r\n      </div>\r\n      {state?.errors?.email && <p>{state.errors.email}</p>}\r\n\r\n      <div>\r\n        <label htmlFor=\"password\">Password</label>\r\n        <input id=\"password\" name=\"password\" type=\"password\" />\r\n      </div>\r\n      {state?.errors?.password && (\r\n        <div>\r\n          <p>Password must:</p>\r\n          <ul>\r\n            {state.errors.password.map((error) => (\r\n              <li key={error}>- {error}</li>\r\n            ))}\r\n          </ul>\r\n        </div>\r\n      )}\r\n      <button disabled={pending} type=\"submit\">\r\n        Sign Up\r\n      </button>\r\n    </form>\r\n  )\r\n}",
        "context": "filename=\"app/ui/signup-form.js\" switcher highlight={7,15,21,27-36}"
      },
      {
        "language": "tsx",
        "code": "export async function signup(state: FormState, formData: FormData) {\r\n  // 1. Validate form fields\r\n  // ...\r\n\r\n  // 2. Prepare data for insertion into database\r\n  const { name, email, password } = validatedFields.data\r\n  // e.g. Hash the user's password before storing it\r\n  const hashedPassword = await bcrypt.hash(password, 10)\r\n\r\n  // 3. Insert the user into the database or call an Auth Library's API\r\n  const data = await db\r\n    .insert(users)\r\n    .values({\r\n      name,\r\n      email,\r\n      password: hashedPassword,\r\n    })\r\n    .returning({ id: users.id })\r\n\r\n  const user = data[0]\r\n\r\n  if (!user) {\r\n    return {\r\n      message: 'An error occurred while creating your account.',\r\n    }\r\n  }\r\n\r\n  // TODO:\r\n  // 4. Create user session\r\n  // 5. Redirect user\r\n}",
        "context": "filename=\"app/actions/auth.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export async function signup(state, formData) {\r\n  // 1. Validate form fields\r\n  // ...\r\n\r\n  // 2. Prepare data for insertion into database\r\n  const { name, email, password } = validatedFields.data\r\n  // e.g. Hash the user's password before storing it\r\n  const hashedPassword = await bcrypt.hash(password, 10)\r\n\r\n  // 3. Insert the user into the database or call an Library API\r\n  const data = await db\r\n    .insert(users)\r\n    .values({\r\n      name,\r\n      email,\r\n      password: hashedPassword,\r\n    })\r\n    .returning({ id: users.id })\r\n\r\n  const user = data[0]\r\n\r\n  if (!user) {\r\n    return {\r\n      message: 'An error occurred while creating your account.',\r\n    }\r\n  }\r\n\r\n  // TODO:\r\n  // 4. Create user session\r\n  // 5. Redirect user\r\n}",
        "context": "filename=\"app/actions/auth.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { FormEvent } from 'react'\r\nimport { useRouter } from 'next/router'\r\n\r\nexport default function LoginPage() {\r\n  const router = useRouter()\r\n\r\n  async function handleSubmit(event: FormEvent<HTMLFormElement>) {\r\n    event.preventDefault()\r\n\r\n    const formData = new FormData(event.currentTarget)\r\n    const email = formData.get('email')\r\n    const password = formData.get('password')\r\n\r\n    const response = await fetch('/api/auth/login', {\r\n      method: 'POST',\r\n      headers: { 'Content-Type': 'application/json' },\r\n      body: JSON.stringify({ email, password }),\r\n    })\r\n\r\n    if (response.ok) {\r\n      router.push('/profile')\r\n    } else {\r\n      // Handle errors\r\n    }\r\n  }\r\n\r\n  return (\r\n    <form onSubmit={handleSubmit}>\r\n      <input type=\"email\" name=\"email\" placeholder=\"Email\" required />\r\n      <input type=\"password\" name=\"password\" placeholder=\"Password\" required />\r\n      <button type=\"submit\">Login</button>\r\n    </form>\r\n  )\r\n}",
        "context": "filename=\"pages/login.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { FormEvent } from 'react'\r\nimport { useRouter } from 'next/router'\r\n\r\nexport default function LoginPage() {\r\n  const router = useRouter()\r\n\r\n  async function handleSubmit(event) {\r\n    event.preventDefault()\r\n\r\n    const formData = new FormData(event.currentTarget)\r\n    const email = formData.get('email')\r\n    const password = formData.get('password')\r\n\r\n    const response = await fetch('/api/auth/login', {\r\n      method: 'POST',\r\n      headers: { 'Content-Type': 'application/json' },\r\n      body: JSON.stringify({ email, password }),\r\n    })\r\n\r\n    if (response.ok) {\r\n      router.push('/profile')\r\n    } else {\r\n      // Handle errors\r\n    }\r\n  }\r\n\r\n  return (\r\n    <form onSubmit={handleSubmit}>\r\n      <input type=\"email\" name=\"email\" placeholder=\"Email\" required />\r\n      <input type=\"password\" name=\"password\" placeholder=\"Password\" required />\r\n      <button type=\"submit\">Login</button>\r\n    </form>\r\n  )\r\n}",
        "context": "filename=\"pages/login.jsx\" switcher"
      },
      {
        "language": "ts",
        "code": "import type { NextApiRequest, NextApiResponse } from 'next'\r\nimport { signIn } from '@/auth'\r\n\r\nexport default async function handler(\r\n  req: NextApiRequest,\r\n  res: NextApiResponse\r\n) {\r\n  try {\r\n    const { email, password } = req.body\r\n    await signIn('credentials', { email, password })\r\n\r\n    res.status(200).json({ success: true })\r\n  } catch (error) {\r\n    if (error.type === 'CredentialsSignin') {\r\n      res.status(401).json({ error: 'Invalid credentials.' })\r\n    } else {\r\n      res.status(500).json({ error: 'Something went wrong.' })\r\n    }\r\n  }\r\n}",
        "context": "filename=\"pages/api/auth/login.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { signIn } from '@/auth'\r\n\r\nexport default async function handler(req, res) {\r\n  try {\r\n    const { email, password } = req.body\r\n    await signIn('credentials', { email, password })\r\n\r\n    res.status(200).json({ success: true })\r\n  } catch (error) {\r\n    if (error.type === 'CredentialsSignin') {\r\n      res.status(401).json({ error: 'Invalid credentials.' })\r\n    } else {\r\n      res.status(500).json({ error: 'Something went wrong.' })\r\n    }\r\n  }\r\n}",
        "context": "filename=\"pages/api/auth/login.js\" switcher"
      },
      {
        "language": "bash",
        "code": "openssl rand -base64 32",
        "context": "filename=\"terminal\""
      },
      {
        "language": "bash",
        "code": "SESSION_SECRET=your_secret_key",
        "context": "filename=\".env\""
      },
      {
        "language": "js",
        "code": "const secretKey = process.env.SESSION_SECRET",
        "context": "filename=\"app/lib/session.js\""
      },
      {
        "language": "tsx",
        "code": "import 'server-only'\r\nimport { SignJWT, jwtVerify } from 'jose'\r\nimport { SessionPayload } from '@/app/lib/definitions'\r\n\r\nconst secretKey = process.env.SESSION_SECRET\r\nconst encodedKey = new TextEncoder().encode(secretKey)\r\n\r\nexport async function encrypt(payload: SessionPayload) {\r\n  return new SignJWT(payload)\r\n    .setProtectedHeader({ alg: 'HS256' })\r\n    .setIssuedAt()\r\n    .setExpirationTime('7d')\r\n    .sign(encodedKey)\r\n}\r\n\r\nexport async function decrypt(session: string | undefined = '') {\r\n  try {\r\n    const { payload } = await jwtVerify(session, encodedKey, {\r\n      algorithms: ['HS256'],\r\n    })\r\n    return payload\r\n  } catch (error) {\r\n    console.log('Failed to verify session')\r\n  }\r\n}",
        "context": "filename=\"app/lib/session.ts\" switcher"
      },
      {
        "language": "jsx",
        "code": "import 'server-only'\r\nimport { SignJWT, jwtVerify } from 'jose'\r\n\r\nconst secretKey = process.env.SESSION_SECRET\r\nconst encodedKey = new TextEncoder().encode(secretKey)\r\n\r\nexport async function encrypt(payload) {\r\n  return new SignJWT(payload)\r\n    .setProtectedHeader({ alg: 'HS256' })\r\n    .setIssuedAt()\r\n    .setExpirationTime('7d')\r\n    .sign(encodedKey)\r\n}\r\n\r\nexport async function decrypt(session) {\r\n  try {\r\n    const { payload } = await jwtVerify(session, encodedKey, {\r\n      algorithms: ['HS256'],\r\n    })\r\n    return payload\r\n  } catch (error) {\r\n    console.log('Failed to verify session')\r\n  }\r\n}",
        "context": "filename=\"app/lib/session.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import 'server-only'\r\nimport { cookies } from 'next/headers'\r\n\r\nexport async function createSession(userId: string) {\r\n  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)\r\n  const session = await encrypt({ userId, expiresAt })\r\n  const cookieStore = await cookies()\r\n\r\n  cookieStore.set('session', session, {\r\n    httpOnly: true,\r\n    secure: true,\r\n    expires: expiresAt,\r\n    sameSite: 'lax',\r\n    path: '/',\r\n  })\r\n}",
        "context": "filename=\"app/lib/session.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import 'server-only'\r\nimport { cookies } from 'next/headers'\r\n\r\nexport async function createSession(userId) {\r\n  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)\r\n  const session = await encrypt({ userId, expiresAt })\r\n  const cookieStore = await cookies()\r\n\r\n  cookieStore.set('session', session, {\r\n    httpOnly: true,\r\n    secure: true,\r\n    expires: expiresAt,\r\n    sameSite: 'lax',\r\n    path: '/',\r\n  })\r\n}",
        "context": "filename=\"app/lib/session.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { createSession } from '@/app/lib/session'\r\n\r\nexport async function signup(state: FormState, formData: FormData) {\r\n  // Previous steps:\r\n  // 1. Validate form fields\r\n  // 2. Prepare data for insertion into database\r\n  // 3. Insert the user into the database or call an Library API\r\n\r\n  // Current steps:\r\n  // 4. Create user session\r\n  await createSession(user.id)\r\n  // 5. Redirect user\r\n  redirect('/profile')\r\n}",
        "context": "filename=\"app/actions/auth.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { createSession } from '@/app/lib/session'\r\n\r\nexport async function signup(state, formData) {\r\n  // Previous steps:\r\n  // 1. Validate form fields\r\n  // 2. Prepare data for insertion into database\r\n  // 3. Insert the user into the database or call an Library API\r\n\r\n  // Current steps:\r\n  // 4. Create user session\r\n  await createSession(user.id)\r\n  // 5. Redirect user\r\n  redirect('/profile')\r\n}",
        "context": "filename=\"app/actions/auth.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import 'server-only'\r\nimport { cookies } from 'next/headers'\r\nimport { decrypt } from '@/app/lib/session'\r\n\r\nexport async function updateSession() {\r\n  const session = (await cookies()).get('session')?.value\r\n  const payload = await decrypt(session)\r\n\r\n  if (!session || !payload) {\r\n    return null\r\n  }\r\n\r\n  const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)\r\n\r\n  const cookieStore = await cookies()\r\n  cookieStore.set('session', session, {\r\n    httpOnly: true,\r\n    secure: true,\r\n    expires: expires,\r\n    sameSite: 'lax',\r\n    path: '/',\r\n  })\r\n}",
        "context": "filename=\"app/lib/session.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import 'server-only'\r\nimport { cookies } from 'next/headers'\r\nimport { decrypt } from '@/app/lib/session'\r\n\r\nexport async function updateSession() {\r\n  const session = (await cookies()).get('session')?.value\r\n  const payload = await decrypt(session)\r\n\r\n  if (!session || !payload) {\r\n    return null\r\n  }\r\n\r\n  const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)(\r\n    await cookies()\r\n  ).set('session', session, {\r\n    httpOnly: true,\r\n    secure: true,\r\n    expires: expires,\r\n    sameSite: 'lax',\r\n    path: '/',\r\n  })\r\n}",
        "context": "filename=\"app/lib/session.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import 'server-only'\r\nimport { cookies } from 'next/headers'\r\n\r\nexport async function deleteSession() {\r\n  const cookieStore = await cookies()\r\n  cookieStore.delete('session')\r\n}",
        "context": "filename=\"app/lib/session.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import 'server-only'\r\nimport { cookies } from 'next/headers'\r\n\r\nexport async function deleteSession() {\r\n  const cookieStore = await cookies()\r\n  cookieStore.delete('session')\r\n}",
        "context": "filename=\"app/lib/session.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { cookies } from 'next/headers'\r\nimport { deleteSession } from '@/app/lib/session'\r\n\r\nexport async function logout() {\r\n  await deleteSession()\r\n  redirect('/login')\r\n}",
        "context": "filename=\"app/actions/auth.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { cookies } from 'next/headers'\r\nimport { deleteSession } from '@/app/lib/session'\r\n\r\nexport async function logout() {\r\n  await deleteSession()\r\n  redirect('/login')\r\n}",
        "context": "filename=\"app/actions/auth.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { serialize } from 'cookie'\r\nimport type { NextApiRequest, NextApiResponse } from 'next'\r\nimport { encrypt } from '@/app/lib/session'\r\n\r\nexport default function handler(req: NextApiRequest, res: NextApiResponse) {\r\n  const sessionData = req.body\r\n  const encryptedSessionData = encrypt(sessionData)\r\n\r\n  const cookie = serialize('session', encryptedSessionData, {\r\n    httpOnly: true,\r\n    secure: process.env.NODE_ENV === 'production',\r\n    maxAge: 60 * 60 * 24 * 7, // One week\r\n    path: '/',\r\n  })\r\n  res.setHeader('Set-Cookie', cookie)\r\n  res.status(200).json({ message: 'Successfully set cookie!' })\r\n}",
        "context": "filename=\"pages/api/login.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { serialize } from 'cookie'\r\nimport { encrypt } from '@/app/lib/session'\r\n\r\nexport default function handler(req, res) {\r\n  const sessionData = req.body\r\n  const encryptedSessionData = encrypt(sessionData)\r\n\r\n  const cookie = serialize('session', encryptedSessionData, {\r\n    httpOnly: true,\r\n    secure: process.env.NODE_ENV === 'production',\r\n    maxAge: 60 * 60 * 24 * 7, // One week\r\n    path: '/',\r\n  })\r\n  res.setHeader('Set-Cookie', cookie)\r\n  res.status(200).json({ message: 'Successfully set cookie!' })\r\n}",
        "context": "filename=\"pages/api/login.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import cookies from 'next/headers'\r\nimport { db } from '@/app/lib/db'\r\nimport { encrypt } from '@/app/lib/session'\r\n\r\nexport async function createSession(id: number) {\r\n  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)\r\n\r\n  // 1. Create a session in the database\r\n  const data = await db\r\n    .insert(sessions)\r\n    .values({\r\n      userId: id,\r\n      expiresAt,\r\n    })\r\n    // Return the session ID\r\n    .returning({ id: sessions.id })\r\n\r\n  const sessionId = data[0].id\r\n\r\n  // 2. Encrypt the session ID\r\n  const session = await encrypt({ sessionId, expiresAt })\r\n\r\n  // 3. Store the session in cookies for optimistic auth checks\r\n  const cookieStore = await cookies()\r\n  cookieStore.set('session', session, {\r\n    httpOnly: true,\r\n    secure: true,\r\n    expires: expiresAt,\r\n    sameSite: 'lax',\r\n    path: '/',\r\n  })\r\n}",
        "context": "filename=\"app/lib/session.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import cookies from 'next/headers'\r\nimport { db } from '@/app/lib/db'\r\nimport { encrypt } from '@/app/lib/session'\r\n\r\nexport async function createSession(id) {\r\n  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)\r\n\r\n  // 1. Create a session in the database\r\n  const data = await db\r\n    .insert(sessions)\r\n    .values({\r\n      userId: id,\r\n      expiresAt,\r\n    })\r\n    // Return the session ID\r\n    .returning({ id: sessions.id })\r\n\r\n  const sessionId = data[0].id\r\n\r\n  // 2. Encrypt the session ID\r\n  const session = await encrypt({ sessionId, expiresAt })\r\n\r\n  // 3. Store the session in cookies for optimistic auth checks\r\n  const cookieStore = await cookies()\r\n  cookieStore.set('session', session, {\r\n    httpOnly: true,\r\n    secure: true,\r\n    expires: expiresAt,\r\n    sameSite: 'lax',\r\n    path: '/',\r\n  })\r\n}",
        "context": "filename=\"app/lib/session.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import db from '../../lib/db'\r\nimport type { NextApiRequest, NextApiResponse } from 'next'\r\n\r\nexport default async function handler(\r\n  req: NextApiRequest,\r\n  res: NextApiResponse\r\n) {\r\n  try {\r\n    const user = req.body\r\n    const sessionId = generateSessionId()\r\n    await db.insertSession({\r\n      sessionId,\r\n      userId: user.id,\r\n      createdAt: new Date(),\r\n    })\r\n\r\n    res.status(200).json({ sessionId })\r\n  } catch (error) {\r\n    res.status(500).json({ error: 'Internal Server Error' })\r\n  }\r\n}",
        "context": "filename=\"pages/api/create-session.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import db from '../../lib/db'\r\n\r\nexport default async function handler(req, res) {\r\n  try {\r\n    const user = req.body\r\n    const sessionId = generateSessionId()\r\n    await db.insertSession({\r\n      sessionId,\r\n      userId: user.id,\r\n      createdAt: new Date(),\r\n    })\r\n\r\n    res.status(200).json({ sessionId })\r\n  } catch (error) {\r\n    res.status(500).json({ error: 'Internal Server Error' })\r\n  }\r\n}",
        "context": "filename=\"pages/api/create-session.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { NextRequest, NextResponse } from 'next/server'\r\nimport { decrypt } from '@/app/lib/session'\r\nimport { cookies } from 'next/headers'\r\n\r\n// 1. Specify protected and public routes\r\nconst protectedRoutes = ['/dashboard']\r\nconst publicRoutes = ['/login', '/signup', '/']\r\n\r\nexport default async function proxy(req: NextRequest) {\r\n  // 2. Check if the current route is protected or public\r\n  const path = req.nextUrl.pathname\r\n  const isProtectedRoute = protectedRoutes.includes(path)\r\n  const isPublicRoute = publicRoutes.includes(path)\r\n\r\n  // 3. Decrypt the session from the cookie\r\n  const cookie = (await cookies()).get('session')?.value\r\n  const session = await decrypt(cookie)\r\n\r\n  // 4. Redirect to /login if the user is not authenticated\r\n  if (isProtectedRoute && !session?.userId) {\r\n    return NextResponse.redirect(new URL('/login', req.nextUrl))\r\n  }\r\n\r\n  // 5. Redirect to /dashboard if the user is authenticated\r\n  if (\r\n    isPublicRoute &&\r\n    session?.userId &&\r\n    !req.nextUrl.pathname.startsWith('/dashboard')\r\n  ) {\r\n    return NextResponse.redirect(new URL('/dashboard', req.nextUrl))\r\n  }\r\n\r\n  return NextResponse.next()\r\n}\r\n\r\n// Routes Proxy should not run on\r\nexport const config = {\r\n  matcher: ['/((?!api|_next/static|_next/image|.*\\\\.png$).*)'],\r\n}",
        "context": "filename=\"proxy.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { NextResponse } from 'next/server'\r\nimport { decrypt } from '@/app/lib/session'\r\nimport { cookies } from 'next/headers'\r\n\r\n// 1. Specify protected and public routes\r\nconst protectedRoutes = ['/dashboard']\r\nconst publicRoutes = ['/login', '/signup', '/']\r\n\r\nexport default async function proxy(req) {\r\n  // 2. Check if the current route is protected or public\r\n  const path = req.nextUrl.pathname\r\n  const isProtectedRoute = protectedRoutes.includes(path)\r\n  const isPublicRoute = publicRoutes.includes(path)\r\n\r\n  // 3. Decrypt the session from the cookie\r\n  const cookie = (await cookies()).get('session')?.value\r\n  const session = await decrypt(cookie)\r\n\r\n  // 5. Redirect to /login if the user is not authenticated\r\n  if (isProtectedRoute && !session?.userId) {\r\n    return NextResponse.redirect(new URL('/login', req.nextUrl))\r\n  }\r\n\r\n  // 6. Redirect to /dashboard if the user is authenticated\r\n  if (\r\n    isPublicRoute &&\r\n    session?.userId &&\r\n    !req.nextUrl.pathname.startsWith('/dashboard')\r\n  ) {\r\n    return NextResponse.redirect(new URL('/dashboard', req.nextUrl))\r\n  }\r\n\r\n  return NextResponse.next()\r\n}\r\n\r\n// Routes Proxy should not run on\r\nexport const config = {\r\n  matcher: ['/((?!api|_next/static|_next/image|.*\\\\.png$).*)'],\r\n}",
        "context": "filename=\"proxy.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import 'server-only'\r\n\r\nimport { cookies } from 'next/headers'\r\nimport { decrypt } from '@/app/lib/session'\r\n\r\nexport const verifySession = cache(async () => {\r\n  const cookie = (await cookies()).get('session')?.value\r\n  const session = await decrypt(cookie)\r\n\r\n  if (!session?.userId) {\r\n    redirect('/login')\r\n  }\r\n\r\n  return { isAuth: true, userId: session.userId }\r\n})",
        "context": "filename=\"app/lib/dal.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import 'server-only'\r\n\r\nimport { cookies } from 'next/headers'\r\nimport { decrypt } from '@/app/lib/session'\r\n\r\nexport const verifySession = cache(async () => {\r\n  const cookie = (await cookies()).get('session')?.value\r\n  const session = await decrypt(cookie)\r\n\r\n  if (!session.userId) {\r\n    redirect('/login')\r\n  }\r\n\r\n  return { isAuth: true, userId: session.userId }\r\n})",
        "context": "filename=\"app/lib/dal.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export const getUser = cache(async () => {\r\n  const session = await verifySession()\r\n  if (!session) return null\r\n\r\n  try {\r\n    const data = await db.query.users.findMany({\r\n      where: eq(users.id, session.userId),\r\n      // Explicitly return the columns you need rather than the whole user object\r\n      columns: {\r\n        id: true,\r\n        name: true,\r\n        email: true,\r\n      },\r\n    })\r\n\r\n    const user = data[0]\r\n\r\n    return user\r\n  } catch (error) {\r\n    console.log('Failed to fetch user')\r\n    return null\r\n  }\r\n})",
        "context": "filename=\"app/lib/dal.ts\" switcher"
      },
      {
        "language": "jsx",
        "code": "export const getUser = cache(async () => {\r\n  const session = await verifySession()\r\n  if (!session) return null\r\n\r\n  try {\r\n    const data = await db.query.users.findMany({\r\n      where: eq(users.id, session.userId),\r\n      // Explicitly return the columns you need rather than the whole user object\r\n      columns: {\r\n        id: true,\r\n        name: true,\r\n        email: true,\r\n      },\r\n    })\r\n\r\n    const user = data[0]\r\n\r\n    return user\r\n  } catch (error) {\r\n    console.log('Failed to fetch user')\r\n    return null\r\n  }\r\n})",
        "context": "filename=\"app/lib/dal.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import 'server-only'\r\nimport { getUser } from '@/app/lib/dal'\r\n\r\nfunction canSeeUsername(viewer: User) {\r\n  return true\r\n}\r\n\r\nfunction canSeePhoneNumber(viewer: User, team: string) {\r\n  return viewer.isAdmin || team === viewer.team\r\n}\r\n\r\nexport async function getProfileDTO(slug: string) {\r\n  const data = await db.query.users.findMany({\r\n    where: eq(users.slug, slug),\r\n    // Return specific columns here\r\n  })\r\n  const user = data[0]\r\n\r\n  const currentUser = await getUser(user.id)\r\n\r\n  // Or return only what's specific to the query here\r\n  return {\r\n    username: canSeeUsername(currentUser) ? user.username : null,\r\n    phonenumber: canSeePhoneNumber(currentUser, user.team)\r\n      ? user.phonenumber\r\n      : null,\r\n  }\r\n}",
        "context": "filename=\"app/lib/dto.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import 'server-only'\r\nimport { getUser } from '@/app/lib/dal'\r\n\r\nfunction canSeeUsername(viewer) {\r\n  return true\r\n}\r\n\r\nfunction canSeePhoneNumber(viewer, team) {\r\n  return viewer.isAdmin || team === viewer.team\r\n}\r\n\r\nexport async function getProfileDTO(slug) {\r\n  const data = await db.query.users.findMany({\r\n    where: eq(users.slug, slug),\r\n    // Return specific columns here\r\n  })\r\n  const user = data[0]\r\n\r\n  const currentUser = await getUser(user.id)\r\n\r\n  // Or return only what's specific to the query here\r\n  return {\r\n    username: canSeeUsername(currentUser) ? user.username : null,\r\n    phonenumber: canSeePhoneNumber(currentUser, user.team)\r\n      ? user.phonenumber\r\n      : null,\r\n  }\r\n}",
        "context": "filename=\"app/lib/dto.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { verifySession } from '@/app/lib/dal'\r\n\r\nexport default async function Dashboard() {\r\n  const session = await verifySession()\r\n  const userRole = session?.user?.role // Assuming 'role' is part of the session object\r\n\r\n  if (userRole === 'admin') {\r\n    return <AdminDashboard />\r\n  } else if (userRole === 'user') {\r\n    return <UserDashboard />\r\n  } else {\r\n    redirect('/login')\r\n  }\r\n}",
        "context": "filename=\"app/dashboard/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { verifySession } from '@/app/lib/dal'\r\n\r\nexport default async function Dashboard() {\r\n  const session = await verifySession()\r\n  const userRole = session?.user?.role // Assuming 'role' is part of the session object\r\n\r\n  if (userRole === 'admin') {\r\n    return <AdminDashboard />\r\n  } else if (userRole === 'user') {\r\n    return <UserDashboard />\r\n  } else {\r\n    redirect('/login')\r\n  }\r\n}",
        "context": "filename=\"app/dashboard/page.jsx\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default async function Layout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode;\r\n}) {\r\n  const user = await getUser();\r\n\r\n  return (\r\n    // ...\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default async function Layout({ children }) {\r\n  const user = await getUser();\r\n\r\n  return (\r\n    // ...\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "ts",
        "code": "export const getUser = cache(async () => {\r\n  const session = await verifySession()\r\n  if (!session) return null\r\n\r\n  // Get user ID from session and fetch data\r\n})",
        "context": "filename=\"app/lib/dal.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export const getUser = cache(async () => {\r\n  const session = await verifySession()\r\n  if (!session) return null\r\n\r\n  // Get user ID from session and fetch data\r\n})",
        "context": "filename=\"app/lib/dal.js\" switcher"
      },
      {
        "language": "ts",
        "code": "'use server'\r\nimport { verifySession } from '@/app/lib/dal'\r\n\r\nexport async function serverAction(formData: FormData) {\r\n  const session = await verifySession()\r\n  const userRole = session?.user?.role\r\n\r\n  // Return early if user is not authorized to perform the action\r\n  if (userRole !== 'admin') {\r\n    return null\r\n  }\r\n\r\n  // Proceed with the action for authorized users\r\n}",
        "context": "filename=\"app/lib/actions.ts\" switcher"
      },
      {
        "language": "js",
        "code": "'use server'\r\nimport { verifySession } from '@/app/lib/dal'\r\n\r\nexport async function serverAction() {\r\n  const session = await verifySession()\r\n  const userRole = session.user.role\r\n\r\n  // Return early if user is not authorized to perform the action\r\n  if (userRole !== 'admin') {\r\n    return null\r\n  }\r\n\r\n  // Proceed with the action for authorized users\r\n}",
        "context": "filename=\"app/lib/actions.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { verifySession } from '@/app/lib/dal'\r\n\r\nexport async function GET() {\r\n  // User authentication and role verification\r\n  const session = await verifySession()\r\n\r\n  // Check if the user is authenticated\r\n  if (!session) {\r\n    // User is not authenticated\r\n    return new Response(null, { status: 401 })\r\n  }\r\n\r\n  // Check if the user has the 'admin' role\r\n  if (session.user.role !== 'admin') {\r\n    // User is authenticated but does not have the right permissions\r\n    return new Response(null, { status: 403 })\r\n  }\r\n\r\n  // Continue for authorized users\r\n}",
        "context": "filename=\"app/api/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { verifySession } from '@/app/lib/dal'\r\n\r\nexport async function GET() {\r\n  // User authentication and role verification\r\n  const session = await verifySession()\r\n\r\n  // Check if the user is authenticated\r\n  if (!session) {\r\n    // User is not authenticated\r\n    return new Response(null, { status: 401 })\r\n  }\r\n\r\n  // Check if the user has the 'admin' role\r\n  if (session.user.role !== 'admin') {\r\n    // User is authenticated but does not have the right permissions\r\n    return new Response(null, { status: 403 })\r\n  }\r\n\r\n  // Continue for authorized users\r\n}",
        "context": "filename=\"app/api/route.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { ContextProvider } from 'auth-lib'\r\n\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>\r\n        <ContextProvider>{children}</ContextProvider>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.ts\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client';\r\n\r\nimport { useSession } from \"auth-lib\";\r\n\r\nexport default function Profile() {\r\n  const { userId } = useSession();\r\n  const { data } = useSWR(`/api/user/${userId}`, fetcher)\r\n\r\n  return (\r\n    // ...\r\n  );\r\n}",
        "context": "filename=\"app/ui/profile.ts switcher"
      },
      {
        "language": "jsx",
        "code": "'use client';\r\n\r\nimport { useSession } from \"auth-lib\";\r\n\r\nexport default function Profile() {\r\n  const { userId } = useSession();\r\n  const { data } = useSWR(`/api/user/${userId}`, fetcher)\r\n\r\n  return (\r\n    // ...\r\n  );\r\n}",
        "context": "filename=\"app/ui/profile.js switcher"
      },
      {
        "language": "ts",
        "code": "import { NextApiRequest, NextApiResponse } from 'next'\r\n\r\nexport default async function handler(\r\n  req: NextApiRequest,\r\n  res: NextApiResponse\r\n) {\r\n  const session = await getSession(req)\r\n\r\n  // Check if the user is authenticated\r\n  if (!session) {\r\n    res.status(401).json({\r\n      error: 'User is not authenticated',\r\n    })\r\n    return\r\n  }\r\n\r\n  // Check if the user has the 'admin' role\r\n  if (session.user.role !== 'admin') {\r\n    res.status(401).json({\r\n      error: 'Unauthorized access: User does not have admin privileges.',\r\n    })\r\n    return\r\n  }\r\n\r\n  // Proceed with the route for authorized users\r\n  // ... implementation of the API Route\r\n}",
        "context": "filename=\"pages/api/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export default async function handler(req, res) {\r\n  const session = await getSession(req)\r\n\r\n  // Check if the user is authenticated\r\n  if (!session) {\r\n    res.status(401).json({\r\n      error: 'User is not authenticated',\r\n    })\r\n    return\r\n  }\r\n\r\n  // Check if the user has the 'admin' role\r\n  if (session.user.role !== 'admin') {\r\n    res.status(401).json({\r\n      error: 'Unauthorized access: User does not have admin privileges.',\r\n    })\r\n    return\r\n  }\r\n\r\n  // Proceed with the route for authorized users\r\n  // ... implementation of the API Route\r\n}",
        "context": "filename=\"pages/api/route.js\" switcher"
      }
    ],
    "content": "Understanding authentication is crucial for protecting your application's data. This page will guide you through what React and Next.js features to use to implement auth. Before starting, it helps to break down the process into three concepts: 1. Authentication: Verifies if the user is who they say they are. It requires the user to prove their identity with something they have, such as a username and password. 2. Session Management: Tracks the user's auth state across requests. 3. Authorization: Decides what routes and data the user can access. This diagram shows the authentication flow using React and Next.js features: The examples on this page walk through basic username and password auth for educational purposes. While you can implement a custom auth solution, for increased security and simplicity, we recommend using an authentication library. These offer built-in solutions for authentication, session management, and authorization, as well as additional features such as social logins, multi-factor authentication, and role-based access control. You can find a list in the Auth Libraries section. Authentication Sign-up and login functionality You can use the element with React's Server Actions and useActionState to capture user credentials, validate form fields, and call your Authentication Provider's API or database. Since Server Actions always execute on the server, they provide a secure environment for handling authentication logic. Here are the steps to implement signup/login functionality: 1. Capture user credentials To capture user credentials, create a form that invokes a Server Action on submission. For example, a signup form that accepts the user's name, email, and password: 2. Validate form fields on the server Use the Server Action to validate the form fields on the server. If your authentication provider doesn't provide form validation, you can use a schema validation library like Zod or Yup. Using Zod as an example, you can define a form schema with appropriate error messages: To prevent unnecessary calls to your authentication provider's API or database, you can return early in the Server Action if any form fields do not match the defined schema. Back in your , you can use React's useActionState hook to display validation errors while the form is submitting: > Good to know: > > - In React 19, useFormStatus includes additional keys on the returned object, like data, method, and action. If you are not using React 19, only the pending key is available. > - Before mutating data, you should always ensure a user is also authorized to perform the action. See Authentication and Authorization. 3. Create a user or check user credentials After validating form fields, you can create a new user account or check if the user exists by calling your authentication provider's API or database. Continuing from the previous example: After successfully creating the user account or verifying the user credentials, you can create a session to manage the user's auth state. Depending on your session management strategy, the session can be stored in a cookie or database, or both. Continue to the Session Management section to learn more. > Tips: > > - The example above is verbose since it breaks down the authentication steps for the purpose of education. This highlights that implementing your own secure solution can quickly become complex. Consider using an Auth Library to simplify the process. > - To improve the user experience, you may want to check for duplicate emails or usernames earlier in the registration flow. For example, as the user types in a username or the input field loses focus. This can help prevent unnecessary form submissions and provide immediate feedback to the user. You can debounce requests with libraries such as use-debounce to manage the frequency of these checks. Here are the steps to implement a sign-up and/or login form: 1. The user submits their credentials through a form. 2. The form sends a request that is handled by an API route. 3. Upon successful verification, the process is completed, indicating the user's successful authentication. 4. If verification is unsuccessful, an error message is shown. Consider a login form where users can input their credentials: The form above has two input fields for capturing the user's email and password. On submission, it triggers a function that sends a POST request to an API route (/api/auth/login). You can then call your Authentication Provider's API in the API route to handle authentication: Session Management Session management ensures that the user's authenticated state is preserved across requests. It involves creating, storing, refreshing, and deleting sessions or tokens. There are two types of sessions: 1. Stateless: Session data (or a token) is stored in the browser's cookies. The cookie is sent with each request, allowing the session to be verified on the server. This method is simpler, but can be less secure if not implemented correctly. 2. Database: Session data is stored in a database, with the user's browser only receiving the encrypted session ID. This method is more secure, but can be complex and use more server resources. > Good to know: While you can use either method, or both, we recommend using a session management library such as iron-session or Jose. Stateless Sessions To create and manage stateless sessions, there are a few steps you need to follow: 1. Generate a secret key, which will be used to sign your session, and store it as an environment variable. 2. Write logic to encrypt/decrypt session data using a session management library. 3. Manage cookies using the Next.js cookies API. In addition to the above, consider adding functionality to update (or refresh) the session when the user returns to the application, and delete the session when the user logs out. > Good to know: Check if your auth library includes session management. 1. Generating a secret key There are a few ways you can generate secret key to sign your session. For example, you may choose to use the openssl command in your terminal: This command generates a 32-character random string that you can use as your secret key and store in your environment variables file: You can then reference this key in your session management logic: 2. Encrypting and decrypting sessions Next, you can use your preferred session management library to encrypt and decrypt sessions. Continuing from the previous example, we'll use Jose (compatible with the Edge Runtime) and React's server-only package to ensure that your session management logic is only executed on the server. > Tips: > > - The payload should contain the minimum, unique user data that'll be used in subsequent requests, such as the user's ID, role, etc. It should not contain personally identifiable information like phone number, email address, credit card information, etc, or sensitive data like passwords. 3. Setting cookies (recommended options) To store the session in a cookie, use the Next.js cookies API. The cookie should be set on the server, and include the recommended options: - HttpOnly: Prevents client-side JavaScript from accessing the cookie. - Secure: Use https to send the cookie. - SameSite: Specify whether the cookie can be sent with cross-site requests. - Max-Age or Expires: Delete the cookie after a certain period. - Path: Define the URL path for the cookie. Please refer to MDN for more information on each of these options. Back in your Server Action, you can invoke the createSession() function, and use the redirect() API to redirect the user to the appropriate page: > Tips: > > - Cookies should be set on the server to prevent client-side tampering. > - 🎥 Watch: Learn more about stateless sessions and authentication with Next.js → YouTube (11 minutes). Updating (or refreshing) sessions You can also extend the session's expiration time. This is useful for keeping the user logged in after they access the application again. For example: > Tip: Check if your auth library supports refresh tokens, which can be used to extend the user's session. Deleting the session To delete the session, you can delete the cookie: Then you can reuse the deleteSession() function in your application, for example, on logout: Setting and deleting cookies You can use API Routes to set the session as a cookie on the server: Database Sessions To create and manage database sessions, you'll need to follow these steps: 1. Create a table in your database to store session and data (or check if your Auth Library handles this). 2. Implement functionality to insert, update, and delete sessions 3. Encrypt the session ID before storing it in the user's browser, and ensure the database and cookie stay in sync (this is optional, but recommended for optimistic auth checks in Proxy). For example: > Tips: > > - For faster access, you may consider adding server caching for the lifetime of the session. You can also keep the session data in your primary database, and combine data requests to reduce the number of queries. > - You may opt to use database sessions for more advanced use cases, such as keeping track of the last time a user logged in, or number of active devices, or give users the ability to log out of all devices. After implementing session management, you'll need to add authorization logic to control what users can access and do within your application. Continue to the Authorization section to learn more. Creating a Session on the Server: Authorization Once a user is authenticated and a session is created, you can implement authorization to control what the user can access and do within your application. There are two main types of authorization checks: 1. Optimistic: Checks if the user is authorized to access a route or perform an action using the session data stored in the cookie. These checks are useful for quick operations, such as showing/hiding UI elements or redirecting users based on permissions or roles. 2. Secure: Checks if the user is authorized to access a route or perform an action using the session data stored in the database. These checks are more secure and are used for operations that require access to sensitive data or actions. For both cases, we recommend: - Creating a Data Access Layer to centralize your authorization logic - Using Data Transfer Objects (DTO) to only return the necessary data - Optionally use Proxy to perform optimistic checks. Optimistic checks with Proxy (Optional) There are some cases where you may want to use Proxy and redirect users based on permissions: - To perform optimistic checks. Since Proxy runs on every route, it's a good way to centralize redirect logic and pre-filter unauthorized users. - To protect static routes that share data between users (e.g. content behind a paywall). However, since Proxy runs on every route, including prefetched routes, it's important to only read the session from the cookie (optimistic checks), and avoid database checks to prevent performance issues. For example: While Proxy can be useful for initial checks, it should not be your only line of defense in protecting your data. The majority of security checks should be performed as close as possible to your data source, see Data Access Layer for more information. > Tips: > > - In Proxy, you can also read cookies using req.cookies.get('session').value. > - Proxy uses the Node.js runtime, check if your Auth library and session management library are compatible. You may need to use Middleware if your Auth library only supports Edge Runtime > - You can use the matcher property in the Proxy to specify which routes Proxy should run on. Although, for auth, it's recommended Proxy runs on all routes. Creating a Data Access Layer (DAL) We recommend creating a DAL to centralize your data requests and authorization logic. The DAL should include a function that verifies the user's session as they interact with your application. At the very least, the function should check if the session is valid, then redirect or return the user information needed to make further requests. For example, create a separate file for your DAL that includes a verifySession() function. Then use React's cache API to memoize the return value of the function during a React render pass: You can then invoke the verifySession() function in your data requests, Server Actions, Route Handlers: > Tip: > > - A DAL can be used to protect data fetched at request time. However, for static routes that share data between users, data will be fetched at build time and not at request time. Use Proxy to protect static routes. > - For secure checks, you can check if the session is valid by comparing the session ID with your database. Use React's cache function to avoid unnecessary duplicate requests to the database during a render pass. > - You may wish to consolidate related data requests in a JavaScript class that runs verifySession() before any methods. Using Data Transfer Objects (DTO) When retrieving data, it's recommended you return only the necessary data that will be used in your application, and not entire objects. For example, if you're fetching user data, you might only return the user's ID and name, rather than the entire user object which could contain passwords, phone numbers, etc. However, if you have no control over the returned data structure, or are working in a team where you want to avoid whole objects being passed to the client, you can use strategies such as specifying what fields are safe to be exposed to the client. By centralizing your data requests and authorization logic in a DAL and using DTOs, you can ensure that all data requests are secure and consistent, making it easier to maintain, audit, and debug as your application scales. > Good to know: > > - There are a couple of different ways you can define a DTO, from using toJSON(), to individual functions like the example above, or JS classes. Since these are JavaScript patterns and not a React or Next.js feature, we recommend doing some research to find the best pattern for your application. > - Learn more about security best practices in our Security in Next.js article. Server Components Auth check in Server Components are useful for role-based access. For example, to conditionally render components based on the user's role: In the example, we use the verifySession() function from our DAL to check for 'admin', 'user', and unauthorized roles. This pattern ensures that each user interacts only with components appropriate to their role. Layouts and auth checks Due to Partial Rendering, be cautious when doing checks in Layouts as these don't re-render on navigation, meaning the user session won't be checked on every route change. Instead, you should do the checks close to your data source or the component that'll be conditionally rendered. For example, consider a shared layout that fetches the user data and displays the user image in a nav. Instead of doing the auth check in the layout, you should fetch the user data (getUser()) in the layout and do the auth check in your DAL. This guarantees that wherever getUser() is called within your application, the auth check is performed, and prevents developers forgetting to check the user is authorized to access the data. > Good to know: > > - A common pattern in SPAs is to return null in a layout or a top-level component if a user is not authorized. This pattern is not recommended since Next.js applications have multiple entry points, which will not prevent nested route segments and Server Actions from being accessed. Server Actions Treat Server Actions with the same security considerations as public-facing API endpoints, and verify if the user is allowed to perform a mutation. In the example below, we check the user's role before allowing the action to proceed: Route Handlers Treat Route Handlers with the same security considerations as public-facing API endpoints, and verify if the user is allowed to access the Route Handler. For example: The example above demonstrates a Route Handler with a two-tier security check. It first checks for an active session, and then verifies if the logged-in user is an 'admin'. Context Providers Using context providers for auth works due to interleaving. However, React context is not supported in Server Components, making them only applicable to Client Components. This works, but any child Server Components will be rendered on the server first, and will not have access to the context provider’s session data: If session data is needed in Client Components (e.g. for client-side data fetching), use React’s taintUniqueValue API to prevent sensitive session data from being exposed to the client. Creating a Data Access Layer (DAL) Protecting API Routes API Routes in Next.js are essential for handling server-side logic and data management. It's crucial to secure these routes to ensure that only authorized users can access specific functionalities. This typically involves verifying the user's authentication status and their role-based permissions. Here's an example of securing an API Route: This example demonstrates an API Route with a two-tier security check for authentication and authorization. It first checks for an active session, and then verifies if the logged-in user is an 'admin'. This approach ensures secure access, limited to authenticated and authorized users, maintaining robust security for request processing. Resources Now that you've learned about authentication in Next.js, here are Next.js-compatible libraries and resources to help you implement secure authentication and session management: Auth Libraries - Auth0 - Better Auth - Clerk - Descope - Kinde - Logto - NextAuth.js - Ory - Stack Auth - Supabase - Stytch - WorkOS Session Management Libraries - Iron Session - Jose Further Reading To continue learning about authentication and security, check out the following resources: - How to think about security in Next.js - Understanding XSS Attacks - Understanding CSRF Attacks - The Copenhagen Book",
    "excerpt": "Understanding authentication is crucial for protecting your application's data. This page will guide you through what React and Next.js features to use to implement auth. Before starting, it helps to...",
    "url": "https://nextjs.org/docs/01-app/02-guides/authentication"
  },
  {
    "id": "01-app-02-guides-backend-for-frontend",
    "path": "01-app\\02-guides\\backend-for-frontend.mdx",
    "title": "How to use Next.js as a backend for your frontend",
    "description": "Learn how to use Next.js as a backend framework",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Public Endpoints",
        "slug": "public-endpoints"
      },
      {
        "level": 2,
        "text": "Content types",
        "slug": "content-types"
      },
      {
        "level": 3,
        "text": "Consuming request payloads",
        "slug": "consuming-request-payloads"
      },
      {
        "level": 2,
        "text": "Manipulating data",
        "slug": "manipulating-data"
      },
      {
        "level": 2,
        "text": "Proxying to a backend",
        "slug": "proxying-to-a-backend"
      },
      {
        "level": 2,
        "text": "NextRequest and NextResponse",
        "slug": "nextrequest-and-nextresponse"
      },
      {
        "level": 2,
        "text": "Webhooks and callback URLs",
        "slug": "webhooks-and-callback-urls"
      },
      {
        "level": 2,
        "text": "Redirects",
        "slug": "redirects"
      },
      {
        "level": 2,
        "text": "Proxy",
        "slug": "proxy"
      },
      {
        "level": 2,
        "text": "Security",
        "slug": "security"
      },
      {
        "level": 3,
        "text": "Working with headers",
        "slug": "working-with-headers"
      },
      {
        "level": 3,
        "text": "Rate limiting",
        "slug": "rate-limiting"
      },
      {
        "level": 3,
        "text": "Verify payloads",
        "slug": "verify-payloads"
      },
      {
        "level": 3,
        "text": "Access to protected resources",
        "slug": "access-to-protected-resources"
      },
      {
        "level": 2,
        "text": "Preflight Requests",
        "slug": "preflight-requests"
      },
      {
        "level": 2,
        "text": "Library patterns",
        "slug": "library-patterns"
      },
      {
        "level": 2,
        "text": "More examples",
        "slug": "more-examples"
      },
      {
        "level": 2,
        "text": "Caveats",
        "slug": "caveats"
      },
      {
        "level": 3,
        "text": "Server Components",
        "slug": "server-components"
      },
      {
        "level": 3,
        "text": "Server Actions",
        "slug": "server-actions"
      },
      {
        "level": 3,
        "text": " mode",
        "slug": "-mode"
      },
      {
        "level": 3,
        "text": "Deployment environment",
        "slug": "deployment-environment"
      }
    ],
    "codeBlocks": [
      {
        "language": "bash",
        "code": "npx create-next-app@latest --api",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "ts",
        "code": "export function GET(request: Request) {}",
        "context": "filename=\"/app/api/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export function GET(request) {}",
        "context": "filename=\"/app/api/route.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { submit } from '@/lib/submit'\r\n\r\nexport async function POST(request: Request) {\r\n  try {\r\n    await submit(request)\r\n    return new Response(null, { status: 204 })\r\n  } catch (reason) {\r\n    const message =\r\n      reason instanceof Error ? reason.message : 'Unexpected error'\r\n\r\n    return new Response(message, { status: 500 })\r\n  }\r\n}",
        "context": "filename=\"/app/api/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { submit } from '@/lib/submit'\r\n\r\nexport async function POST(request) {\r\n  try {\r\n    await submit(request)\r\n    return new Response(null, { status: 204 })\r\n  } catch (reason) {\r\n    const message =\r\n      reason instanceof Error ? reason.message : 'Unexpected error'\r\n\r\n    return new Response(message, { status: 500 })\r\n  }\r\n}",
        "context": "filename=\"/app/api/route.js\" switcher"
      },
      {
        "language": "ts",
        "code": "export async function GET(request: Request) {\r\n  const rssResponse = await fetch(/* rss endpoint */)\r\n  const rssData = await rssResponse.json()\r\n\r\n  const rssFeed = `<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<rss version=\"2.0\">\r\n<channel>\r\n <title>${rssData.title}</title>\r\n <description>${rssData.description}</description>\r\n <link>${rssData.link}</link>\r\n <copyright>${rssData.copyright}</copyright>\r\n ${rssData.items.map((item) => {\r\n   return `<item>\r\n    <title>${item.title}</title>\r\n    <description>${item.description}</description>\r\n    <link>${item.link}</link>\r\n    <pubDate>${item.publishDate}</pubDate>\r\n    <guid isPermaLink=\"false\">${item.guid}</guid>\r\n </item>`\r\n })}\r\n</channel>\r\n</rss>`\r\n\r\n  const headers = new Headers({ 'content-type': 'application/xml' })\r\n\r\n  return new Response(rssFeed, { headers })\r\n}",
        "context": "filename=\"/app/rss.xml/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export async function GET(request) {\r\n  const rssResponse = await fetch(/* rss endpoint */)\r\n  const rssData = await rssResponse.json()\r\n\r\n  const rssFeed = `<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<rss version=\"2.0\">\r\n<channel>\r\n <title>${rssData.title}</title>\r\n <description>${rssData.description}</description>\r\n <link>${rssData.link}</link>\r\n <copyright>${rssData.copyright}</copyright>\r\n ${rssData.items.map((item) => {\r\n   return `<item>\r\n    <title>${item.title}</title>\r\n    <description>${item.description}</description>\r\n    <link>${item.link}</link>\r\n    <pubDate>${item.publishDate}</pubDate>\r\n    <guid isPermaLink=\"false\">${item.guid}</guid>\r\n </item>`\r\n })}\r\n</channel>\r\n</rss>`\r\n\r\n  const headers = new Headers({ 'content-type': 'application/xml' })\r\n\r\n  return new Response(rssFeed, { headers })\r\n}",
        "context": "filename=\"/app/rss.xml/route.js\" switcher"
      },
      {
        "language": "ts",
        "code": "export async function POST(request: Request) {\r\n  const res = await request.json()\r\n  return Response.json({ res })\r\n}",
        "context": "filename=\"/app/api/echo-body/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export async function POST(request) {\r\n  const res = await request.json()\r\n  return Response.json({ res })\r\n}",
        "context": "filename=\"/app/api/echo-body/route.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { sendMail, validateInputs } from '@/lib/email-transporter'\r\n\r\nexport async function POST(request: Request) {\r\n  const formData = await request.formData()\r\n  const email = formData.get('email')\r\n  const contents = formData.get('contents')\r\n\r\n  try {\r\n    await validateInputs({ email, contents })\r\n    const info = await sendMail({ email, contents })\r\n\r\n    return Response.json({ messageId: info.messageId })\r\n  } catch (reason) {\r\n    const message =\r\n      reason instanceof Error ? reason.message : 'Unexpected exception'\r\n\r\n    return new Response(message, { status: 500 })\r\n  }\r\n}",
        "context": "filename=\"/app/api/send-email/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { sendMail, validateInputs } from '@/lib/email-transporter'\r\n\r\nexport async function POST(request) {\r\n  const formData = await request.formData()\r\n  const email = formData.get('email')\r\n  const contents = formData.get('contents')\r\n\r\n  try {\r\n    await validateInputs({ email, contents })\r\n    const info = await sendMail({ email, contents })\r\n\r\n    return Response.json({ messageId: info.messageId })\r\n  } catch (reason) {\r\n    const message =\r\n      reason instanceof Error ? reason.message : 'Unexpected exception'\r\n\r\n    return new Response(message, { status: 500 })\r\n  }\r\n}",
        "context": "filename=\"/app/api/send-email/route.js\" switcher"
      },
      {
        "language": "ts",
        "code": "export async function POST(request: Request) {\r\n  try {\r\n    const clonedRequest = request.clone()\r\n\r\n    await request.body()\r\n    await clonedRequest.body()\r\n    await request.body() // Throws error\r\n\r\n    return new Response(null, { status: 204 })\r\n  } catch {\r\n    return new Response(null, { status: 500 })\r\n  }\r\n}",
        "context": "filename=\"/app/api/clone/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export async function POST(request) {\r\n  try {\r\n    const clonedRequest = request.clone()\r\n\r\n    await request.body()\r\n    await clonedRequest.body()\r\n    await request.body() // Throws error\r\n\r\n    return new Response(null, { status: 204 })\r\n  } catch {\r\n    return new Response(null, { status: 500 })\r\n  }\r\n}",
        "context": "filename=\"/app/api/clone/route.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { parseWeatherData } from '@/lib/weather'\r\n\r\nexport async function POST(request: Request) {\r\n  const body = await request.json()\r\n  const searchParams = new URLSearchParams({ lat: body.lat, lng: body.lng })\r\n\r\n  try {\r\n    const weatherResponse = await fetch(`${weatherEndpoint}?${searchParams}`)\r\n\r\n    if (!weatherResponse.ok) {\r\n      /* handle error */\r\n    }\r\n\r\n    const weatherData = await weatherResponse.text()\r\n    const payload = parseWeatherData.asJSON(weatherData)\r\n\r\n    return new Response(payload, { status: 200 })\r\n  } catch (reason) {\r\n    const message =\r\n      reason instanceof Error ? reason.message : 'Unexpected exception'\r\n\r\n    return new Response(message, { status: 500 })\r\n  }\r\n}",
        "context": "file=\"/app/api/weather/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { parseWeatherData } from '@/lib/weather'\r\n\r\nexport async function POST(request) {\r\n  const body = await request.json()\r\n  const searchParams = new URLSearchParams({ lat: body.lat, lng: body.lng })\r\n\r\n  try {\r\n    const weatherResponse = await fetch(`${weatherEndpoint}?${searchParams}`)\r\n\r\n    if (!weatherResponse.ok) {\r\n      /* handle error */\r\n    }\r\n\r\n    const weatherData = await weatherResponse.text()\r\n    const payload = parseWeatherData.asJSON(weatherData)\r\n\r\n    return new Response(payload, { status: 200 })\r\n  } catch (reason) {\r\n    const message =\r\n      reason instanceof Error ? reason.message : 'Unexpected exception'\r\n\r\n    return new Response(message, { status: 500 })\r\n  }\r\n}",
        "context": "file=\"/app/api/weather/route.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { isValidRequest } from '@/lib/utils'\r\n\r\nexport async function POST(request: Request, { params }) {\r\n  const clonedRequest = request.clone()\r\n  const isValid = await isValidRequest(clonedRequest)\r\n\r\n  if (!isValid) {\r\n    return new Response(null, { status: 400, statusText: 'Bad Request' })\r\n  }\r\n\r\n  const { slug } = await params\r\n  const pathname = slug.join('/')\r\n  const proxyURL = new URL(pathname, 'https://nextjs.org')\r\n  const proxyRequest = new Request(proxyURL, request)\r\n\r\n  try {\r\n    return fetch(proxyRequest)\r\n  } catch (reason) {\r\n    const message =\r\n      reason instanceof Error ? reason.message : 'Unexpected exception'\r\n\r\n    return new Response(message, { status: 500 })\r\n  }\r\n}",
        "context": "filename=\"/app/api/[...slug]/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { isValidRequest } from '@/lib/utils'\r\n\r\nexport async function POST(request, { params }) {\r\n  const clonedRequest = request.clone()\r\n  const isValid = await isValidRequest(clonedRequest)\r\n\r\n  if (!isValid) {\r\n    return new Response(null, { status: 400, statusText: 'Bad Request' })\r\n  }\r\n\r\n  const { slug } = await params\r\n  const pathname = slug.join('/')\r\n  const proxyURL = new URL(pathname, 'https://nextjs.org')\r\n  const proxyRequest = new Request(proxyURL, request)\r\n\r\n  try {\r\n    return fetch(proxyRequest)\r\n  } catch (reason) {\r\n    const message =\r\n      reason instanceof Error ? reason.message : 'Unexpected exception'\r\n\r\n    return new Response(message, { status: 500 })\r\n  }\r\n}",
        "context": "filename=\"/app/api/[...slug]/route.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { type NextRequest, NextResponse } from 'next/server'\r\n\r\nexport async function GET(request: NextRequest) {\r\n  const nextUrl = request.nextUrl\r\n\r\n  if (nextUrl.searchParams.get('redirect')) {\r\n    return NextResponse.redirect(new URL('/', request.url))\r\n  }\r\n\r\n  if (nextUrl.searchParams.get('rewrite')) {\r\n    return NextResponse.rewrite(new URL('/', request.url))\r\n  }\r\n\r\n  return NextResponse.json({ pathname: nextUrl.pathname })\r\n}",
        "context": "filename=\"/app/echo-pathname/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { NextResponse } from 'next/server'\r\n\r\nexport async function GET(request) {\r\n  const nextUrl = request.nextUrl\r\n\r\n  if (nextUrl.searchParams.get('redirect')) {\r\n    return NextResponse.redirect(new URL('/', request.url))\r\n  }\r\n\r\n  if (nextUrl.searchParams.get('rewrite')) {\r\n    return NextResponse.rewrite(new URL('/', request.url))\r\n  }\r\n\r\n  return NextResponse.json({ pathname: nextUrl.pathname })\r\n}",
        "context": "filename=\"/app/echo-pathname/route.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { type NextRequest, NextResponse } from 'next/server'\r\n\r\nexport async function GET(request: NextRequest) {\r\n  const token = request.nextUrl.searchParams.get('token')\r\n\r\n  if (token !== process.env.REVALIDATE_SECRET_TOKEN) {\r\n    return NextResponse.json({ success: false }, { status: 401 })\r\n  }\r\n\r\n  const tag = request.nextUrl.searchParams.get('tag')\r\n\r\n  if (!tag) {\r\n    return NextResponse.json({ success: false }, { status: 400 })\r\n  }\r\n\r\n  revalidateTag(tag)\r\n\r\n  return NextResponse.json({ success: true })\r\n}",
        "context": "filename=\"/app/webhook/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { NextResponse } from 'next/server'\r\n\r\nexport async function GET(request) {\r\n  const token = request.nextUrl.searchParams.get('token')\r\n\r\n  if (token !== process.env.REVALIDATE_SECRET_TOKEN) {\r\n    return NextResponse.json({ success: false }, { status: 401 })\r\n  }\r\n\r\n  const tag = request.nextUrl.searchParams.get('tag')\r\n\r\n  if (!tag) {\r\n    return NextResponse.json({ success: false }, { status: 400 })\r\n  }\r\n\r\n  revalidateTag(tag)\r\n\r\n  return NextResponse.json({ success: true })\r\n}",
        "context": "filename=\"/app/webhook/route.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { type NextRequest, NextResponse } from 'next/server'\r\n\r\nexport async function GET(request: NextRequest) {\r\n  const token = request.nextUrl.searchParams.get('session_token')\r\n  const redirectUrl = request.nextUrl.searchParams.get('redirect_url')\r\n\r\n  const response = NextResponse.redirect(new URL(redirectUrl, request.url))\r\n\r\n  response.cookies.set({\r\n    value: token,\r\n    name: '_token',\r\n    path: '/',\r\n    secure: true,\r\n    httpOnly: true,\r\n    expires: undefined, // session cookie\r\n  })\r\n\r\n  return response\r\n}",
        "context": "filename=\"/app/auth/callback/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { NextResponse } from 'next/server'\r\n\r\nexport async function GET(request) {\r\n  const token = request.nextUrl.searchParams.get('session_token')\r\n  const redirectUrl = request.nextUrl.searchParams.get('redirect_url')\r\n\r\n  const response = NextResponse.redirect(new URL(redirectUrl, request.url))\r\n\r\n  response.cookies.set({\r\n    value: token,\r\n    name: '_token',\r\n    path: '/',\r\n    secure: true,\r\n    httpOnly: true,\r\n    expires: undefined, // session cookie\r\n  })\r\n\r\n  return response\r\n}",
        "context": "filename=\"/app/auth/callback/route.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { redirect } from 'next/navigation'\r\n\r\nexport async function GET(request: Request) {\r\n  redirect('https://nextjs.org/')\r\n}",
        "context": "filename=\"app/api/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { redirect } from 'next/navigation'\r\n\r\nexport async function GET(request) {\r\n  redirect('https://nextjs.org/')\r\n}",
        "context": "filename=\"app/api/route.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { isAuthenticated } from '@lib/auth'\r\n\r\nexport const config = {\r\n  matcher: '/api/:function*',\r\n}\r\n\r\nexport function proxy(request: Request) {\r\n  if (!isAuthenticated(request)) {\r\n    return Response.json(\r\n      { success: false, message: 'authentication failed' },\r\n      { status: 401 }\r\n    )\r\n  }\r\n}",
        "context": "filename=\"proxy.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { isAuthenticated } from '@lib/auth'\r\n\r\nexport const config = {\r\n  matcher: '/api/:function*',\r\n}\r\n\r\nexport function proxy(request) {\r\n  if (!isAuthenticated(request)) {\r\n    return Response.json(\r\n      { success: false, message: 'authentication failed' },\r\n      { status: 401 }\r\n    )\r\n  }\r\n}",
        "context": "filename=\"proxy.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { NextResponse } from 'next/server'\r\n\r\nexport function proxy(request: Request) {\r\n  if (request.nextUrl.pathname === '/proxy-this-path') {\r\n    const rewriteUrl = new URL('https://nextjs.org')\r\n    return NextResponse.rewrite(rewriteUrl)\r\n  }\r\n}",
        "context": "filename=\"proxy.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { NextResponse } from 'next/server'\r\n\r\nexport function proxy(request) {\r\n  if (request.nextUrl.pathname === '/proxy-this-path') {\r\n    const rewriteUrl = new URL('https://nextjs.org')\r\n    return NextResponse.rewrite(rewriteUrl)\r\n  }\r\n}",
        "context": "filename=\"proxy.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { NextResponse } from 'next/server'\r\n\r\nexport function proxy(request: Request) {\r\n  if (request.nextUrl.pathname === '/v1/docs') {\r\n    request.nextUrl.pathname = '/v2/docs'\r\n    return NextResponse.redirect(request.nextUrl)\r\n  }\r\n}",
        "context": "filename=\"proxy.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { NextResponse } from 'next/server'\r\n\r\nexport function proxy(request) {\r\n  if (request.nextUrl.pathname === '/v1/docs') {\r\n    request.nextUrl.pathname = '/v2/docs'\r\n    return NextResponse.redirect(request.nextUrl)\r\n  }\r\n}",
        "context": "filename=\"proxy.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { NextResponse } from 'next/server'\r\nimport { checkRateLimit } from '@/lib/rate-limit'\r\n\r\nexport async function POST(request: Request) {\r\n  const { rateLimited } = await checkRateLimit(request)\r\n\r\n  if (rateLimited) {\r\n    return NextResponse.json({ error: 'Rate limit exceeded' }, { status: 429 })\r\n  }\r\n\r\n  return new Response(null, { status: 204 })\r\n}",
        "context": "filename=\"/app/resource/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { NextResponse } from 'next/server'\r\nimport { checkRateLimit } from '@/lib/rate-limit'\r\n\r\nexport async function POST(request) {\r\n  const { rateLimited } = await checkRateLimit(request)\r\n\r\n  if (rateLimited) {\r\n    return NextResponse.json({ error: 'Rate limit exceeded' }, { status: 429 })\r\n  }\r\n\r\n  return new Response(null, { status: 204 })\r\n}",
        "context": "filename=\"/app/resource/route.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { createHandler } from 'third-party-library'\r\n\r\nconst handler = createHandler({\r\n  /* library-specific options */\r\n})\r\n\r\nexport const GET = handler\r\n// or\r\nexport { handler as POST }",
        "context": "filename=\"/app/api/[...path]/route.ts\""
      },
      {
        "language": "ts",
        "code": "import { createMiddleware } from 'third-party-library'\r\n\r\nexport default createMiddleware()",
        "context": "filename=\"proxy.ts\""
      },
      {
        "language": "js",
        "code": "export const dynamic = 'force-static'\r\n\r\nexport function GET() {\r\n  return new Response('Hello World', { status: 200 })\r\n}",
        "context": "filename=\"app/hello-world/route.ts\""
      }
    ],
    "content": "Next.js supports the \"Backend for Frontend\" pattern. This lets you create public endpoints to handle HTTP requests and return any content type—not just HTML. You can also access data sources and perform side effects like updating remote data. If you are starting a new project, using create-next-app with the --api flag automatically includes an example route.ts in your new project’s app/ folder, demonstrating how to create an API endpoint. > Good to know: Next.js backend capabilities are not a full backend replacement. They serve as an API layer that: > > - is publicly reachable > - handles any HTTP request > - can return any content type To implement this pattern, use: - Route Handlers - proxy - In Pages Router, API Routes Public Endpoints Route Handlers are public HTTP endpoints. Any client can access them. Create a Route Handler using the route.ts or route.js file convention: This handles GET requests sent to /api. Use try/catch blocks for operations that may throw an exception: Avoid exposing sensitive information in error messages sent to the client. To restrict access, implement authentication and authorization. See Authentication. Content types Route Handlers let you serve non-UI responses, including JSON, XML, images, files, and plain text. Next.js uses file conventions for common endpoints: - sitemap.xml - opengraph-image.jpg, twitter-image - favicon, app icon, and apple-icon - manifest.json - robots.txt You can also define custom ones, such as: - llms.txt - rss.xml - .well-known For example, app/rss.xml/route.ts creates a Route Handler for rss.xml. Sanitize any input used to generate markup. Consuming request payloads Use Request instance methods like .json(), .formData(), or .text() to access the request body. GET and HEAD requests don’t carry a body. > Good to know: Validate data before passing it to other systems You can only read the request body once. Clone the request if you need to read it again: Manipulating data Route Handlers can transform, filter, and aggregate data from one or more sources. This keeps logic out of the frontend and avoids exposing internal systems. You can also offload heavy computations to the server and reduce client battery and data usage. > Good to know: This example uses POST to avoid putting geo-location data in the URL. GET requests may be cached or logged, which could expose sensitive info. Proxying to a backend You can use a Route Handler as a proxy to another backend. Add validation logic before forwarding the request. Or use: - proxy rewrites - rewrites in next.config.js. NextRequest and NextResponse Next.js extends the Request and Response Web APIs with methods that simplify common operations. These extensions are available in both Route Handlers and Proxy. Both provide methods for reading and manipulating cookies. NextRequest includes the nextUrl property, which exposes parsed values from the incoming request, for example, it makes it easier to access request pathname and search params. NextResponse provides helpers like next(), json(), redirect(), and rewrite(). You can pass NextRequest to any function expecting Request. Likewise, you can return NextResponse where a Response is expected. Learn more about NextRequest and NextResponse. Webhooks and callback URLs Use Route Handlers to receive event notifications from third-party applications. For example, revalidate a route when content changes in a CMS. Configure the CMS to call a specific endpoint on changes. Callback URLs are another use case. When a user completes a third-party flow, the third party sends them to a callback URL. Use a Route Handler to verify the response and decide where to redirect the user. Redirects Learn more about redirects in redirect and permanentRedirect Proxy Only one proxy file is allowed per project. Use config.matcher to target specific paths. Learn more about proxy. Use proxy to generate a response before the request reaches a route path. You can also proxy requests using proxy: Another type of response proxy can produce are redirects: Security Working with headers Be deliberate about where headers go, and avoid directly passing incoming request headers to the outgoing response. - Upstream request headers: In Proxy, NextResponse.next({ request: { headers } }) modifies the headers your server receives and does not expose them to the client. - Response headers: new Response(..., { headers }), NextResponse.json(..., { headers }), NextResponse.next({ headers }), or response.headers.set(...) send headers back to the client. If sensitive values were appended to these headers, they will be visible to clients. Learn more in NextResponse headers in Proxy. Rate limiting You can implement rate limiting in your Next.js backend. In addition to code-based checks, enable any rate limiting features provided by your host. Verify payloads Never trust incoming request data. Validate content type and size, and sanitize against XSS before use. Use timeouts to prevent abuse and protect server resources. Store user-generated static assets in dedicated services. When possible, upload them from the browser and store the returned URI in your database to reduce request size. Access to protected resources Always verify credentials before granting access. Do not rely on proxy alone for authentication and authorization. Remove sensitive or unnecessary data from responses and backend logs. Rotate credentials and API keys regularly. Preflight Requests Preflight requests use the OPTIONS method to ask the server if a request is allowed based on origin, method, and headers. If OPTIONS is not defined, Next.js adds it automatically and sets the Allow header based on the other defined methods. - CORS Library patterns Community libraries often use the factory pattern for Route Handlers. This creates a shared handler for GET and POST requests. The library customizes behavior based on the method and pathname in the request. Libraries can also provide a proxy factory. > Good to know: Third-party libraries may still refer to proxy as middleware. More examples See more examples on using Router Handlers and the proxy API references. These examples include, working with Cookies, Headers, Streaming, Proxy negative matching, and other useful code snippets. Caveats Server Components Fetch data in Server Components directly from its source, not via Route Handlers. For Server Components pre-rendered at build time, using Route Handlers will fail the build step. This is because, while building there is no server listening for these requests. For Server Components rendered on demand, fetching from Route Handlers is slower due to the extra HTTP round trip between the handler and the render process. > A server side fetch request uses absolute URLs. This implies an HTTP round trip, to an external server. During development, your own development server acts as the external server. At build time there is no server, and at runtime, the server is available through your public facing domain. Server Components cover most data-fetching needs. However, fetching data client side might be necessary for: - Data that depends on client-only Web APIs: - Geo-location API - Storage API - Audio API - File API - Frequently polled data For these, use community libraries like swr or react-query. Server Actions Server Actions let you run server-side code from the client. Their primary purpose is to mutate data from your frontend client. Server Actions are queued. Using them for data fetching introduces sequential execution. export mode export mode outputs a static site without a runtime server. Features that require the Next.js runtime are not supported, because this mode produces a static site, and no runtime server. In export mode, only GET Route Handlers are supported, in combination with the dynamic route segment config, set to 'force-static'. This can be used to generate static HTML, JSON, TXT, or other files. Deployment environment Some hosts deploy Route Handlers as lambda functions. This means: - Route Handlers cannot share data between requests. - The environment may not support writing to File System. - Long-running handlers may be terminated due to timeouts. - WebSockets won’t work because the connection closes on timeout, or after the response is generated.",
    "excerpt": "Next.js supports the \"Backend for Frontend\" pattern. This lets you create public endpoints to handle HTTP requests and return any content type—not just HTML. You can also access data sources and perfo...",
    "url": "https://nextjs.org/docs/01-app/02-guides/backend-for-frontend"
  },
  {
    "id": "01-app-02-guides-caching",
    "path": "01-app\\02-guides\\caching.mdx",
    "title": "Caching in Next.js",
    "description": "An overview of caching mechanisms in Next.js.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Overview",
        "slug": "overview"
      },
      {
        "level": 2,
        "text": "Rendering Strategies",
        "slug": "rendering-strategies"
      },
      {
        "level": 3,
        "text": "Static Rendering",
        "slug": "static-rendering"
      },
      {
        "level": 3,
        "text": "Dynamic Rendering",
        "slug": "dynamic-rendering"
      },
      {
        "level": 2,
        "text": "Request Memoization",
        "slug": "request-memoization"
      },
      {
        "level": 3,
        "text": "Duration",
        "slug": "duration"
      },
      {
        "level": 3,
        "text": "Revalidating",
        "slug": "revalidating"
      },
      {
        "level": 3,
        "text": "Opting out",
        "slug": "opting-out"
      },
      {
        "level": 2,
        "text": "Data Cache",
        "slug": "data-cache"
      },
      {
        "level": 3,
        "text": "Duration",
        "slug": "duration"
      },
      {
        "level": 3,
        "text": "Revalidating",
        "slug": "revalidating"
      },
      {
        "level": 4,
        "text": "Time-based Revalidation",
        "slug": "time-based-revalidation"
      },
      {
        "level": 4,
        "text": "On-demand Revalidation",
        "slug": "on-demand-revalidation"
      },
      {
        "level": 3,
        "text": "Opting out",
        "slug": "opting-out"
      },
      {
        "level": 2,
        "text": "Full Route Cache",
        "slug": "full-route-cache"
      },
      {
        "level": 3,
        "text": "1. React Rendering on the Server",
        "slug": "1-react-rendering-on-the-server"
      },
      {
        "level": 3,
        "text": "2. Next.js Caching on the Server (Full Route Cache)",
        "slug": "2-nextjs-caching-on-the-server-full-route-cache"
      },
      {
        "level": 3,
        "text": "3. React Hydration and Reconciliation on the Client",
        "slug": "3-react-hydration-and-reconciliation-on-the-client"
      },
      {
        "level": 3,
        "text": "4. Next.js Caching on the Client (Router Cache)",
        "slug": "4-nextjs-caching-on-the-client-router-cache"
      },
      {
        "level": 3,
        "text": "5. Subsequent Navigations",
        "slug": "5-subsequent-navigations"
      },
      {
        "level": 3,
        "text": "Static and Dynamic Rendering",
        "slug": "static-and-dynamic-rendering"
      },
      {
        "level": 3,
        "text": "Duration",
        "slug": "duration"
      },
      {
        "level": 3,
        "text": "Invalidation",
        "slug": "invalidation"
      },
      {
        "level": 3,
        "text": "Opting out",
        "slug": "opting-out"
      },
      {
        "level": 2,
        "text": "Client-side Router Cache",
        "slug": "client-side-router-cache"
      },
      {
        "level": 3,
        "text": "Duration",
        "slug": "duration"
      },
      {
        "level": 3,
        "text": "Invalidation",
        "slug": "invalidation"
      },
      {
        "level": 3,
        "text": "Opting out",
        "slug": "opting-out"
      },
      {
        "level": 2,
        "text": "Cache Interactions",
        "slug": "cache-interactions"
      },
      {
        "level": 3,
        "text": "Data Cache and Full Route Cache",
        "slug": "data-cache-and-full-route-cache"
      },
      {
        "level": 3,
        "text": "Data Cache and Client-side Router cache",
        "slug": "data-cache-and-client-side-router-cache"
      },
      {
        "level": 2,
        "text": "APIs",
        "slug": "apis"
      },
      {
        "level": 3,
        "text": " and ",
        "slug": "-and-"
      },
      {
        "level": 3,
        "text": "Dynamic APIs",
        "slug": "dynamic-apis"
      },
      {
        "level": 3,
        "text": "Segment Config Options",
        "slug": "segment-config-options"
      },
      {
        "level": 3,
        "text": "React  function",
        "slug": "react-function"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "async function getItem() {\r\n  // The `fetch` function is automatically memoized and the result\r\n  // is cached\r\n  const res = await fetch('https://.../item/1')\r\n  return res.json()\r\n}\r\n\r\n// This function is called twice, but only executed the first time\r\nconst item = await getItem() // cache MISS\r\n\r\n// The second call could be anywhere in your route\r\nconst item = await getItem() // cache HIT",
        "context": "filename=\"app/example.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "async function getItem() {\r\n  // The `fetch` function is automatically memoized and the result\r\n  // is cached\r\n  const res = await fetch('https://.../item/1')\r\n  return res.json()\r\n}\r\n\r\n// This function is called twice, but only executed the first time\r\nconst item = await getItem() // cache MISS\r\n\r\n// The second call could be anywhere in your route\r\nconst item = await getItem() // cache HIT",
        "context": "filename=\"app/example.js\" switcher"
      },
      {
        "language": "js",
        "code": "const { signal } = new AbortController()\r\nfetch(url, { signal })",
        "context": "filename=\"app/example.js\""
      },
      {
        "language": "js",
        "code": "// Revalidate at most every hour\r\nfetch('https://...', { next: { revalidate: 3600 } })",
        "context": ""
      },
      {
        "language": "js",
        "code": "let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "// Opt into caching\r\nfetch(`https://...`, { cache: 'force-cache' })",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "// Revalidate at most after 1 hour\r\nfetch(`https://...`, { next: { revalidate: 3600 } })",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "// Cache data with a tag\r\nfetch(`https://...`, { next: { tags: ['a', 'b', 'c'] } })",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "// Revalidate entries with a specific tag\r\nrevalidateTag('a')",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "revalidatePath('/')",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "export async function generateStaticParams() {\r\n  const posts = await fetch('https://.../posts').then((res) => res.json())\r\n\r\n  return posts.map((post) => ({\r\n    slug: post.slug,\r\n  }))\r\n}",
        "context": "filename=\"app/blog/[slug]/page.js\""
      },
      {
        "language": "jsx",
        "code": "export async function generateStaticParams() {\r\n  const posts = await fetch('https://.../posts').then((res) => res.json())\r\n\r\n  // Render the first 10 posts at build time\r\n  return posts.slice(0, 10).map((post) => ({\r\n    slug: post.slug,\r\n  }))\r\n}",
        "context": "filename=\"app/blog/[slug]/page.js\""
      },
      {
        "language": "jsx",
        "code": "export async function generateStaticParams() {\r\n  return []\r\n}",
        "context": "filename=\"app/blog/[slug]/page.js\""
      },
      {
        "language": "jsx",
        "code": "export const dynamic = 'force-static'",
        "context": "filename=\"app/changelog/[slug]/page.js\""
      },
      {
        "language": "ts",
        "code": "import { cache } from 'react'\r\nimport db from '@/lib/db'\r\n\r\nexport const getItem = cache(async (id: string) => {\r\n  const item = await db.item.findUnique({ id })\r\n  return item\r\n})",
        "context": "filename=\"utils/get-item.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { cache } from 'react'\r\nimport db from '@/lib/db'\r\n\r\nexport const getItem = cache(async (id) => {\r\n  const item = await db.item.findUnique({ id })\r\n  return item\r\n})",
        "context": "filename=\"utils/get-item.js\" switcher"
      }
    ],
    "content": "Next.js improves your application's performance and reduces costs by caching rendering work and data requests. This page provides an in-depth look at Next.js caching mechanisms, the APIs you can use to configure them, and how they interact with each other. > Good to know: This page helps you understand how Next.js works under the hood but is not essential knowledge to be productive with Next.js. Most of Next.js' caching heuristics are determined by your API usage and have defaults for the best performance with zero or minimal configuration. If you instead want to jump to examples, start here. Overview Here's a high-level overview of the different caching mechanisms and their purpose: | Mechanism | What | Where | Purpose | Duration | | ------------------------------------------- | -------------------------- | ------ | ----------------------------------------------- | ------------------------------- | | Request Memoization | Return values of functions | Server | Re-use data in a React Component tree | Per-request lifecycle | | Data Cache | Data | Server | Store data across user requests and deployments | Persistent (can be revalidated) | | Full Route Cache | HTML and RSC payload | Server | Reduce rendering cost and improve performance | Persistent (can be revalidated) | | Router Cache | RSC Payload | Client | Reduce server requests on navigation | User session or time-based | By default, Next.js will cache as much as possible to improve performance and reduce cost. This means routes are statically rendered and data requests are cached unless you opt out. The diagram below shows the default caching behavior: when a route is statically rendered at build time and when a static route is first visited. Caching behavior changes depending on whether the route is statically or dynamically rendered, data is cached or uncached, and whether a request is part of an initial visit or a subsequent navigation. Depending on your use case, you can configure the caching behavior for individual routes and data requests. Fetch caching is not supported in proxy. Any fetches done inside of your proxy will be uncached. Rendering Strategies To understand how caching works in Next.js, it's helpful to understand the rendering strategies available. The rendering strategy determines when your route's HTML is generated, which directly impacts what can be cached. Static Rendering With Static Rendering, routes are rendered at build time or in the background after data revalidation. The result is cached and can be reused across requests. Static routes are fully cached in the Full Route Cache. Dynamic Rendering With Dynamic Rendering, routes are rendered at request time. This happens when your route uses request-specific information like cookies, headers, or search params. A route becomes dynamic when it uses any of these APIs: - cookies - headers - connection - draftMode - searchParams prop - unstablenoStore - fetch with { cache: 'no-store' } Dynamic routes are not cached in the Full Route Cache, but can still use the Data Cache for data requests. > Good to know: You can use Cache Components to mix static and dynamic rendering within the same route. Request Memoization Next.js extends the fetch API to automatically memoize requests that have the same URL and options. This means you can call a fetch function for the same data in multiple places in a React component tree while only executing it once. For example, if you need to use the same data across a route (e.g. in a Layout, Page, and multiple components), you do not have to fetch data at the top of the tree, and forward props between components. Instead, you can fetch data in the components that need it without worrying about the performance implications of making multiple requests across the network for the same data. How Request Memoization Works - While rendering a route, the first time a particular request is called, its result will not be in memory and it'll be a cache MISS. - Therefore, the function will be executed, and the data will be fetched from the external source, and the result will be stored in memory. - Subsequent function calls of the request in the same render pass will be a cache HIT, and the data will be returned from memory without executing the function. - Once the route has been rendered and the rendering pass is complete, memory is \"reset\" and all request memoization entries are cleared. > Good to know: > > - Request memoization is a React feature, not a Next.js feature. It's included here to show how it interacts with the other caching mechanisms. > - Memoization only applies to the GET method in fetch requests. > - Memoization only applies to the React Component tree, this means: > - It applies to fetch requests in generateMetadata, generateStaticParams, Layouts, Pages, and other Server Components. > - It doesn't apply to fetch requests in Route Handlers as they are not a part of the React component tree. > - For cases where fetch is not suitable (e.g. some database clients, CMS clients, or GraphQL clients), you can use the React cache function to memoize functions. Duration The cache lasts the lifetime of a server request until the React component tree has finished rendering. Revalidating Since the memoization is not shared across server requests and only applies during rendering, there is no need to revalidate it. Opting out Memoization only applies to the GET method in fetch requests, other methods, such as POST and DELETE, are not memoized. This default behavior is a React optimization and we do not recommend opting out of it. To manage individual requests, you can use the signal property from AbortController. Data Cache Next.js has a built-in Data Cache that persists the result of data fetches across incoming server requests and deployments. This is possible because Next.js extends the native fetch API to allow each request on the server to set its own persistent caching semantics. > Good to know: In the browser, the cache option of fetch indicates how a request will interact with the browser's HTTP cache, in Next.js, the cache option indicates how a server-side request will interact with the server's Data Cache. You can use the cache and next.revalidate options of fetch to configure the caching behavior. In development mode, fetch data is reused for Hot Module Replacement (HMR), and caching options are ignored for hard refreshes. How the Data Cache Works - The first time a fetch request with the 'force-cache' option is called during rendering, Next.js checks the Data Cache for a cached response. - If a cached response is found, it's returned immediately and memoized. - If a cached response is not found, the request is made to the data source, the result is stored in the Data Cache, and memoized. - For uncached data (e.g. no cache option defined or using { cache: 'no-store' }), the result is always fetched from the data source, and memoized. - Whether the data is cached or uncached, the requests are always memoized to avoid making duplicate requests for the same data during a React render pass. > Differences between the Data Cache and Request Memoization > > While both caching mechanisms help improve performance by re-using cached data, the Data Cache is persistent across incoming requests and deployments, whereas memoization only lasts the lifetime of a request. Duration The Data Cache is persistent across incoming requests and deployments unless you revalidate or opt-out. Revalidating Cached data can be revalidated in two ways, with: - Time-based Revalidation: Revalidate data after a certain amount of time has passed and a new request is made. This is useful for data that changes infrequently and freshness is not as critical. - On-demand Revalidation: Revalidate data based on an event (e.g. form submission). On-demand revalidation can use a tag-based or path-based approach to revalidate groups of data at once. This is useful when you want to ensure the latest data is shown as soon as possible (e.g. when content from your headless CMS is updated). Time-based Revalidation To revalidate data at a timed interval, you can use the next.revalidate option of fetch to set the cache lifetime of a resource (in seconds). Alternatively, you can use Route Segment Config options to configure all fetch requests in a segment or for cases where you're not able to use fetch. How Time-based Revalidation Works - The first time a fetch request with revalidate is called, the data will be fetched from the external data source and stored in the Data Cache. - Any requests that are called within the specified timeframe (e.g. 60-seconds) will return the cached data. - After the timeframe, the next request will still return the cached (now stale) data. - Next.js will trigger a revalidation of the data in the background. - Once the data is fetched successfully, Next.js will update the Data Cache with the fresh data. - If the background revalidation fails, the previous data will be kept unaltered. This is similar to stale-while-revalidate behavior. On-demand Revalidation Data can be revalidated on-demand by path (revalidatePath) or by cache tag (revalidateTag). How On-Demand Revalidation Works - The first time a fetch request is called, the data will be fetched from the external data source and stored in the Data Cache. - When an on-demand revalidation is triggered, the appropriate cache entries will be purged from the cache. - This is different from time-based revalidation, which keeps the stale data in the cache until the fresh data is fetched. - The next time a request is made, it will be a cache MISS again, and the data will be fetched from the external data source and stored in the Data Cache. Opting out If you do not want to cache the response from fetch, you can do the following: Full Route Cache > Related terms: > > You may see the terms Automatic Static Optimization, Static Site Generation, or Static Rendering being used interchangeably to refer to the process of rendering and caching routes of your application at build time. Next.js automatically renders and caches routes at build time. This is an optimization that allows you to serve the cached route instead of rendering on the server for every request, resulting in faster page loads. To understand how the Full Route Cache works, it's helpful to look at how React handles rendering, and how Next.js caches the result: 1. React Rendering on the Server On the server, Next.js uses React's APIs to orchestrate rendering. The rendering work is split into chunks: by individual routes segments and Suspense boundaries. Each chunk is rendered in two steps: 1. React renders Server Components into a special data format, optimized for streaming, called the React Server Component Payload. 2. Next.js uses the React Server Component Payload and Client Component JavaScript instructions to render HTML on the server. This means we don't have to wait for everything to render before caching the work or sending a response. Instead, we can stream a response as work is completed. > What is the React Server Component Payload? > > The React Server Component Payload is a compact binary representation of the rendered React Server Components tree. It's used by React on the client to update the browser's DOM. The React Server Component Payload contains: > > - The rendered result of Server Components > - Placeholders for where Client Components should be rendered and references to their JavaScript files > - Any props passed from a Server Component to a Client Component > > To learn more, see the Server Components documentation. 2. Next.js Caching on the Server (Full Route Cache) The default behavior of Next.js is to cache the rendered result (React Server Component Payload and HTML) of a route on the server. This applies to statically rendered routes at build time, or during revalidation. 3. React Hydration and Reconciliation on the Client At request time, on the client: 1. The HTML is used to immediately show a fast non-interactive initial preview of the Client and Server Components. 2. The React Server Components Payload is used to reconcile the Client and rendered Server Component trees, and update the DOM. 3. The JavaScript instructions are used to hydrate Client Components and make the application interactive. 4. Next.js Caching on the Client (Router Cache) The React Server Component Payload is stored in the client-side Router Cache - a separate in-memory cache, split by individual route segment. This Router Cache is used to improve the navigation experience by storing previously visited routes and prefetching future routes. 5. Subsequent Navigations On subsequent navigations or during prefetching, Next.js will check if the React Server Components Payload is stored in the Router Cache. If so, it will skip sending a new request to the server. If the route segments are not in the cache, Next.js will fetch the React Server Components Payload from the server, and populate the Router Cache on the client. Static and Dynamic Rendering Whether a route is cached or not at build time depends on whether it's statically or dynamically rendered. Static routes are cached by default, whereas dynamic routes are rendered at request time, and not cached. This diagram shows the difference between statically and dynamically rendered routes, with cached and uncached data: Learn more about static and dynamic rendering. Duration By default, the Full Route Cache is persistent. This means that the render output is cached across user requests. Invalidation There are two ways you can invalidate the Full Route Cache: - Revalidating Data: Revalidating the Data Cache, will in turn invalidate the Router Cache by re-rendering components on the server and caching the new render output. - Redeploying: Unlike the Data Cache, which persists across deployments, the Full Route Cache is cleared on new deployments. Opting out You can opt out of the Full Route Cache, or in other words, dynamically render components for every incoming request, by: - Using a Dynamic API: This will opt the route out from the Full Route Cache and dynamically render it at request time. The Data Cache can still be used. - Using the dynamic = 'force-dynamic' or revalidate = 0 route segment config options: This will skip the Full Route Cache and the Data Cache. Meaning components will be rendered and data fetched on every incoming request to the server. The Router Cache will still apply as it's a client-side cache. - Opting out of the Data Cache: If a route has a fetch request that is not cached, this will opt the route out of the Full Route Cache. The data for the specific fetch request will be fetched for every incoming request. Other fetch requests that explicitly enable caching will still be cached in the Data Cache. This allows for a hybrid of cached and uncached data. Client-side Router Cache Next.js has an in-memory client-side router cache that stores the RSC payload of route segments, split by layouts, loading states, and pages. When a user navigates between routes, Next.js caches the visited route segments and prefetches the routes the user is likely to navigate to. This results in instant back/forward navigation, no full-page reload between navigations, and preservation of browser state and React state in shared layouts. With the Router Cache: - Layouts are cached and reused on navigation (partial rendering). - Loading states are cached and reused on navigation for instant navigation. - Pages are not cached by default, but are reused during browser backward and forward navigation. You can enable caching for page segments by using the experimental staleTimes config option. > Good to know: This cache specifically applies to Next.js and Server Components, and is different to the browser's bfcache, though it has a similar result. Duration The cache is stored in the browser's temporary memory. Two factors determine how long the router cache lasts: - Session: The cache persists across navigation. However, it's cleared on page refresh. - Automatic Invalidation Period: The cache of layouts and loading states is automatically invalidated after a specific time. The duration depends on how the resource was prefetched, and if the resource was statically generated: - Default Prefetching (prefetch={null} or unspecified): not cached for dynamic pages, 5 minutes for static pages. - Full Prefetching (prefetch={true} or router.prefetch): 5 minutes for both static & dynamic pages. While a page refresh will clear all cached segments, the automatic invalidation period only affects the individual segment from the time it was prefetched. > Good to know: The experimental staleTimes config option can be used to adjust the automatic invalidation times mentioned above. Invalidation There are two ways you can invalidate the Router Cache: - In a Server Action: - Revalidating data on-demand by path with (revalidatePath) or by cache tag with (revalidateTag) - Using cookies.set or cookies.delete invalidates the Router Cache to prevent routes that use cookies from becoming stale (e.g. authentication). - Calling router.refresh will invalidate the Router Cache and make a new request to the server for the current route. Opting out As of Next.js 15, page segments are opted out by default. > Good to know: You can also opt out of prefetching by setting the prefetch prop of the component to false. Cache Interactions When configuring the different caching mechanisms, it's important to understand how they interact with each other: Data Cache and Full Route Cache - Revalidating or opting out of the Data Cache will invalidate the Full Route Cache, as the render output depends on data. - Invalidating or opting out of the Full Route Cache does not affect the Data Cache. You can dynamically render a route that has both cached and uncached data. This is useful when most of your page uses cached data, but you have a few components that rely on data that needs to be fetched at request time. You can dynamically render without worrying about the performance impact of re-fetching all the data. Data Cache and Client-side Router cache - To immediately invalidate the Data Cache and Router cache, you can use revalidatePath or revalidateTag in a Server Action. - Revalidating the Data Cache in a Route Handler will not immediately invalidate the Router Cache as the Route Handler isn't tied to a specific route. This means Router Cache will continue to serve the previous payload until a hard refresh, or the automatic invalidation period has elapsed. APIs The following table provides an overview of how different Next.js APIs affect caching: | API | Router Cache | Full Route Cache | Data Cache | React Cache | | ----------------------------------------------------------------------- | -------------------------- | --------------------- | --------------------- | -------------------- | | | Cache | | | | | router.prefetch | Cache | | | | | router.refresh | Revalidate | | | | | fetch | | | Cache | Cache (GET and HEAD) | | fetch options.cache | | | Cache or Opt out | | | fetch options.next.revalidate | | Revalidate | Revalidate | | | fetch options.next.tags | | Cache | Cache | | | revalidateTag | Revalidate (Server Action) | Revalidate | Revalidate | | | revalidatePath | Revalidate (Server Action) | Revalidate | Revalidate | | | const revalidate | | Revalidate or Opt out | Revalidate or Opt out | | | const dynamic | | Cache or Opt out | Cache or Opt out | | | cookies | Revalidate (Server Action) | Opt out | | | | headers, searchParams | | Opt out | | | | generateStaticParams | | Cache | | | | React.cache | | | | Cache | | unstablecache | | | Cache | | By default, the component automatically prefetches routes from the Full Route Cache and adds the React Server Component Payload to the Router Cache. To disable prefetching, you can set the prefetch prop to false. But this will not skip the cache permanently, the route segment will still be cached client-side when the user visits the route. Learn more about the component. router.prefetch The prefetch option of the useRouter hook can be used to manually prefetch a route. This adds the React Server Component Payload to the Router Cache. See the useRouter hook API reference. router.refresh The refresh option of the useRouter hook can be used to manually refresh a route. This completely clears the Router Cache, and makes a new request to the server for the current route. refresh does not affect the Data or Full Route Cache. The rendered result will be reconciled on the client while preserving React state and browser state. See the useRouter hook API reference. fetch Data returned from fetch is not automatically cached in the Data Cache. By default, when no cache or next.revalidate options are provided: - Dynamic rendering: Fetch runs on every request and always returns fresh data. - Static rendering: Fetched data is stored in the Data Cache, and the rendered output in the Full Route Cache. Next.js serves this cached result until the path is revalidated. See the fetch API Reference for more options. fetch options.cache You can opt individual fetch into caching by setting the cache option to force-cache: See the fetch API Reference for more options. fetch options.next.revalidate You can use the next.revalidate option of fetch to set the revalidation period (in seconds) of an individual fetch request. This will revalidate the Data Cache, which in turn will revalidate the Full Route Cache. Fresh data will be fetched, and components will be re-rendered on the server. See the fetch API reference for more options. fetch options.next.tags and revalidateTag Next.js has a cache tagging system for fine-grained data caching and revalidation. 1. When using fetch or unstablecache, you have the option to tag cache entries with one or more tags. 2. Then, you can call revalidateTag to purge the cache entries associated with that tag. For example, you can set a tag when fetching data: Then, call revalidateTag with a tag to purge the cache entry: There are two places you can use revalidateTag, depending on what you're trying to achieve: 1. Route Handlers - to revalidate data in response of a third party event (e.g. webhook). This will not invalidate the Router Cache immediately as the Router Handler isn't tied to a specific route. 2. Server Actions - to revalidate data after a user action (e.g. form submission). This will invalidate the Router Cache for the associated route. revalidatePath revalidatePath allows you manually revalidate data and re-render the route segments below a specific path in a single operation. Calling the revalidatePath method revalidates the Data Cache, which in turn invalidates the Full Route Cache. There are two places you can use revalidatePath, depending on what you're trying to achieve: 1. Route Handlers - to revalidate data in response to a third party event (e.g. webhook). 2. Server Actions - to revalidate data after a user interaction (e.g. form submission, clicking a button). See the revalidatePath API reference for more information. > revalidatePath vs. router.refresh: > > Calling router.refresh will clear the Router cache, and re-render route segments on the server without invalidating the Data Cache or the Full Route Cache. > > The difference is that revalidatePath purges the Data Cache and Full Route Cache, whereas router.refresh() does not change the Data Cache and Full Route Cache, as it is a client-side API. Dynamic APIs Dynamic APIs like cookies and headers, and the searchParams prop in Pages depend on runtime incoming request information. Using them will opt a route out of the Full Route Cache, in other words, the route will be dynamically rendered. cookies Using cookies.set or cookies.delete in a Server Action invalidates the Router Cache to prevent routes that use cookies from becoming stale (e.g. to reflect authentication changes). See the cookies API reference. Segment Config Options The Route Segment Config options can be used to override the route segment defaults or when you're not able to use the fetch API (e.g. database client or 3rd party libraries). The following Route Segment Config options will opt out of the Full Route Cache: - const dynamic = 'force-dynamic' This config option will opt all fetches out of the Data Cache (i.e. no-store): - const fetchCache = 'default-no-store' See the fetchCache to see more advanced options. See the Route Segment Config documentation for more options. generateStaticParams For dynamic segments (e.g. app/blog/[slug]/page.js), paths provided by generateStaticParams are cached in the Full Route Cache at build time. At request time, Next.js will also cache paths that weren't known at build time the first time they're visited. To statically render all paths at build time, supply the full list of paths to generateStaticParams: To statically render a subset of paths at build time, and the rest the first time they're visited at runtime, return a partial list of paths: To statically render all paths the first time they're visited, return an empty array (no paths will be rendered at build time) or utilize export const dynamic = 'force-static': > Good to know: You must return an array from generateStaticParams, even if it's empty. Otherwise, the route will be dynamically rendered. To disable caching at request time, add the export const dynamicParams = false option in a route segment. When this config option is used, only paths provided by generateStaticParams will be served, and other routes will 404 or match (in the case of catch-all routes). React cache function The React cache function allows you to memoize the return value of a function, allowing you to call the same function multiple times while only executing it once. fetch requests using the GET or HEAD methods are automatically memoized, so you do not need to wrap it in React cache. However, for other fetch methods, or when using data fetching libraries (such as some database, CMS, or GraphQL clients) that don't inherently memoize requests, you can use cache to manually memoize data requests.",
    "excerpt": "Next.js improves your application's performance and reduces costs by caching rendering work and data requests. This page provides an in-depth look at Next.js caching mechanisms, the APIs you can use t...",
    "url": "https://nextjs.org/docs/01-app/02-guides/caching"
  },
  {
    "id": "01-app-02-guides-ci-build-caching",
    "path": "01-app\\02-guides\\ci-build-caching.mdx",
    "title": "How to configure Continuous Integration (CI) build caching",
    "description": "Learn how to configure CI to cache Next.js builds",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Vercel",
        "slug": "vercel"
      },
      {
        "level": 2,
        "text": "CircleCI",
        "slug": "circleci"
      },
      {
        "level": 2,
        "text": "Travis CI",
        "slug": "travis-ci"
      },
      {
        "level": 2,
        "text": "GitLab CI",
        "slug": "gitlab-ci"
      },
      {
        "level": 2,
        "text": "Netlify CI",
        "slug": "netlify-ci"
      },
      {
        "level": 2,
        "text": "AWS CodeBuild",
        "slug": "aws-codebuild"
      },
      {
        "level": 2,
        "text": "GitHub Actions",
        "slug": "github-actions"
      },
      {
        "level": 2,
        "text": "Bitbucket Pipelines",
        "slug": "bitbucket-pipelines"
      },
      {
        "level": 2,
        "text": "Heroku",
        "slug": "heroku"
      },
      {
        "level": 2,
        "text": "Azure Pipelines",
        "slug": "azure-pipelines"
      },
      {
        "level": 2,
        "text": "Jenkins (Pipeline)",
        "slug": "jenkins-pipeline"
      }
    ],
    "codeBlocks": [
      {
        "language": "yaml",
        "code": "steps:\r\n  - save_cache:\r\n      key: dependency-cache-{{ checksum \"yarn.lock\" }}\r\n      paths:\r\n        - ./node_modules\r\n        - ./.next/cache",
        "context": ""
      },
      {
        "language": "yaml",
        "code": "cache:\r\n  directories:\r\n    - $HOME/.cache/yarn\r\n    - node_modules\r\n    - .next/cache",
        "context": ""
      },
      {
        "language": "yaml",
        "code": "cache:\r\n  key: ${CI_COMMIT_REF_SLUG}\r\n  paths:\r\n    - node_modules/\r\n    - .next/cache/",
        "context": ""
      },
      {
        "language": "yaml",
        "code": "cache:\r\n  paths:\r\n    - 'node_modules/**/*' # Cache `node_modules` for faster `yarn` or `npm i`\r\n    - '.next/cache/**/*' # Cache Next.js for faster application rebuilds",
        "context": ""
      },
      {
        "language": "yaml",
        "code": "uses: actions/cache@v4\r\nwith:\r\n  # See here for caching with `yarn`, `bun` or other package managers https://github.com/actions/cache/blob/main/examples.md or you can leverage caching with actions/setup-node https://github.com/actions/setup-node\r\n  path: |\r\n    ~/.npm\r\n    ${{ github.workspace }}/.next/cache\r\n  # Generate a new cache whenever packages or source files change.\r\n  key: ${{ runner.os }}-nextjs-${{ hashFiles('**/package-lock.json') }}-${{ hashFiles('**/*.js', '**/*.jsx', '**/*.ts', '**/*.tsx') }}\r\n  # If source files changed but packages didn't, rebuild from a prior cache.\r\n  restore-keys: |\r\n    ${{ runner.os }}-nextjs-${{ hashFiles('**/package-lock.json') }}-",
        "context": ""
      },
      {
        "language": "yaml",
        "code": "definitions:\r\n  caches:\r\n    nextcache: .next/cache",
        "context": ""
      },
      {
        "language": "yaml",
        "code": "- step:\r\n    name: your_step_name\r\n    caches:\r\n      - node\r\n      - nextcache",
        "context": ""
      },
      {
        "language": "javascript",
        "code": "\"cacheDirectories\": [\".next/cache\"]",
        "context": ""
      },
      {
        "language": "yaml",
        "code": "- task: Cache@2\r\n  displayName: 'Cache .next/cache'\r\n  inputs:\r\n    key: next | $(Agent.OS) | yarn.lock\r\n    path: '$(System.DefaultWorkingDirectory)/.next/cache'",
        "context": ""
      },
      {
        "language": "yaml",
        "code": "stage(\"Restore npm packages\") {\r\n    steps {\r\n        // Writes lock-file to cache based on the GIT_COMMIT hash\r\n        writeFile file: \"next-lock.cache\", text: \"$GIT_COMMIT\"\r\n\r\n        cache(caches: [\r\n            arbitraryFileCache(\r\n                path: \"node_modules\",\r\n                includes: \"**/*\",\r\n                cacheValidityDecidingFile: \"package-lock.json\"\r\n            )\r\n        ]) {\r\n            sh \"npm install\"\r\n        }\r\n    }\r\n}\r\nstage(\"Build\") {\r\n    steps {\r\n        // Writes lock-file to cache based on the GIT_COMMIT hash\r\n        writeFile file: \"next-lock.cache\", text: \"$GIT_COMMIT\"\r\n\r\n        cache(caches: [\r\n            arbitraryFileCache(\r\n                path: \".next/cache\",\r\n                includes: \"**/*\",\r\n                cacheValidityDecidingFile: \"next-lock.cache\"\r\n            )\r\n        ]) {\r\n            // aka `next build`\r\n            sh \"npm run build\"\r\n        }\r\n    }\r\n}",
        "context": ""
      }
    ],
    "content": "To improve build performance, Next.js saves a cache to .next/cache that is shared between builds. To take advantage of this cache in Continuous Integration (CI) environments, your CI workflow will need to be configured to correctly persist the cache between builds. > If your CI is not configured to persist .next/cache between builds, you may see a No Cache Detected error. Here are some example cache configurations for common CI providers: Vercel Next.js caching is automatically configured for you. There's no action required on your part. If you are using Turborepo on Vercel, learn more here. CircleCI Edit your savecache step in .circleci/config.yml to include .next/cache: If you do not have a savecache key, please follow CircleCI's documentation on setting up build caching. Travis CI Add or merge the following into your .travis.yml: GitLab CI Add or merge the following into your .gitlab-ci.yml: Netlify CI Use Netlify Plugins with @netlify/plugin-nextjs. AWS CodeBuild Add (or merge in) the following to your buildspec.yml: GitHub Actions Using GitHub's actions/cache, add the following step in your workflow file: Bitbucket Pipelines Add or merge the following into your bitbucket-pipelines.yml at the top level (same level as pipelines): Then reference it in the caches section of your pipeline's step: Heroku Using Heroku's custom cache, add a cacheDirectories array in your top-level package.json: Azure Pipelines Using Azure Pipelines' Cache task, add the following task to your pipeline yaml file somewhere prior to the task that executes next build: Jenkins (Pipeline) Using Jenkins' Job Cacher plugin, add the following build step to your Jenkinsfile where you would normally run next build or npm install:",
    "excerpt": "To improve build performance, Next.js saves a cache to .next/cache that is shared between builds. To take advantage of this cache in Continuous Integration (CI) environments, your CI workflow will nee...",
    "url": "https://nextjs.org/docs/01-app/02-guides/ci-build-caching"
  },
  {
    "id": "01-app-02-guides-content-security-policy",
    "path": "01-app\\02-guides\\content-security-policy.mdx",
    "title": "How to set a Content Security Policy (CSP) for your Next.js application",
    "description": "Learn how to set a Content Security Policy (CSP) for your Next.js application.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Nonces",
        "slug": "nonces"
      },
      {
        "level": 3,
        "text": "Why use a nonce?",
        "slug": "why-use-a-nonce"
      },
      {
        "level": 3,
        "text": "Adding a nonce with Proxy",
        "slug": "adding-a-nonce-with-proxy"
      },
      {
        "level": 3,
        "text": "How nonces work in Next.js",
        "slug": "how-nonces-work-in-nextjs"
      },
      {
        "level": 3,
        "text": "Forcing dynamic rendering",
        "slug": "forcing-dynamic-rendering"
      },
      {
        "level": 3,
        "text": "Reading the nonce",
        "slug": "reading-the-nonce"
      },
      {
        "level": 2,
        "text": "Static vs Dynamic Rendering with CSP",
        "slug": "static-vs-dynamic-rendering-with-csp"
      },
      {
        "level": 3,
        "text": "Dynamic Rendering Requirement",
        "slug": "dynamic-rendering-requirement"
      },
      {
        "level": 3,
        "text": "Performance Implications",
        "slug": "performance-implications"
      },
      {
        "level": 3,
        "text": "When to use nonces",
        "slug": "when-to-use-nonces"
      },
      {
        "level": 2,
        "text": "Without Nonces",
        "slug": "without-nonces"
      },
      {
        "level": 2,
        "text": "Subresource Integrity (Experimental)",
        "slug": "subresource-integrity-experimental"
      },
      {
        "level": 3,
        "text": "How SRI works",
        "slug": "how-sri-works"
      },
      {
        "level": 3,
        "text": "Enabling SRI",
        "slug": "enabling-sri"
      },
      {
        "level": 3,
        "text": "CSP configuration with SRI",
        "slug": "csp-configuration-with-sri"
      },
      {
        "level": 3,
        "text": "Benefits of SRI over nonces",
        "slug": "benefits-of-sri-over-nonces"
      },
      {
        "level": 3,
        "text": "Limitations of SRI",
        "slug": "limitations-of-sri"
      },
      {
        "level": 2,
        "text": "Development vs Production Considerations",
        "slug": "development-vs-production-considerations"
      },
      {
        "level": 3,
        "text": "Development Environment",
        "slug": "development-environment"
      },
      {
        "level": 3,
        "text": "Production Deployment",
        "slug": "production-deployment"
      },
      {
        "level": 2,
        "text": "Troubleshooting",
        "slug": "troubleshooting"
      },
      {
        "level": 3,
        "text": "Third-party Scripts",
        "slug": "third-party-scripts"
      },
      {
        "level": 3,
        "text": "Common CSP Violations",
        "slug": "common-csp-violations"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "import { NextRequest, NextResponse } from 'next/server'\r\n\r\nexport function proxy(request: NextRequest) {\r\n  const nonce = Buffer.from(crypto.randomUUID()).toString('base64')\r\n  const cspHeader = `\r\n    default-src 'self';\r\n    script-src 'self' 'nonce-${nonce}' 'strict-dynamic';\r\n    style-src 'self' 'nonce-${nonce}';\r\n    img-src 'self' blob: data:;\r\n    font-src 'self';\r\n    object-src 'none';\r\n    base-uri 'self';\r\n    form-action 'self';\r\n    frame-ancestors 'none';\r\n    upgrade-insecure-requests;\r\n`\r\n  // Replace newline characters and spaces\r\n  const contentSecurityPolicyHeaderValue = cspHeader\r\n    .replace(/\\s{2,}/g, ' ')\r\n    .trim()\r\n\r\n  const requestHeaders = new Headers(request.headers)\r\n  requestHeaders.set('x-nonce', nonce)\r\n\r\n  requestHeaders.set(\r\n    'Content-Security-Policy',\r\n    contentSecurityPolicyHeaderValue\r\n  )\r\n\r\n  const response = NextResponse.next({\r\n    request: {\r\n      headers: requestHeaders,\r\n    },\r\n  })\r\n  response.headers.set(\r\n    'Content-Security-Policy',\r\n    contentSecurityPolicyHeaderValue\r\n  )\r\n\r\n  return response\r\n}",
        "context": "filename=\"proxy.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { NextResponse } from 'next/server'\r\n\r\nexport function proxy(request) {\r\n  const nonce = Buffer.from(crypto.randomUUID()).toString('base64')\r\n  const cspHeader = `\r\n    default-src 'self';\r\n    script-src 'self' 'nonce-${nonce}' 'strict-dynamic';\r\n    style-src 'self' 'nonce-${nonce}';\r\n    img-src 'self' blob: data:;\r\n    font-src 'self';\r\n    object-src 'none';\r\n    base-uri 'self';\r\n    form-action 'self';\r\n    frame-ancestors 'none';\r\n    upgrade-insecure-requests;\r\n`\r\n  // Replace newline characters and spaces\r\n  const contentSecurityPolicyHeaderValue = cspHeader\r\n    .replace(/\\s{2,}/g, ' ')\r\n    .trim()\r\n\r\n  const requestHeaders = new Headers(request.headers)\r\n  requestHeaders.set('x-nonce', nonce)\r\n  requestHeaders.set(\r\n    'Content-Security-Policy',\r\n    contentSecurityPolicyHeaderValue\r\n  )\r\n\r\n  const response = NextResponse.next({\r\n    request: {\r\n      headers: requestHeaders,\r\n    },\r\n  })\r\n  response.headers.set(\r\n    'Content-Security-Policy',\r\n    contentSecurityPolicyHeaderValue\r\n  )\r\n\r\n  return response\r\n}",
        "context": "filename=\"proxy.js\" switcher"
      },
      {
        "language": "ts",
        "code": "export const config = {\r\n  matcher: [\r\n    /*\r\n     * Match all request paths except for the ones starting with:\r\n     * - api (API routes)\r\n     * - _next/static (static files)\r\n     * - _next/image (image optimization files)\r\n     * - favicon.ico (favicon file)\r\n     */\r\n    {\r\n      source: '/((?!api|_next/static|_next/image|favicon.ico).*)',\r\n      missing: [\r\n        { type: 'header', key: 'next-router-prefetch' },\r\n        { type: 'header', key: 'purpose', value: 'prefetch' },\r\n      ],\r\n    },\r\n  ],\r\n}",
        "context": "filename=\"proxy.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export const config = {\r\n  matcher: [\r\n    /*\r\n     * Match all request paths except for the ones starting with:\r\n     * - api (API routes)\r\n     * - _next/static (static files)\r\n     * - _next/image (image optimization files)\r\n     * - favicon.ico (favicon file)\r\n     */\r\n    {\r\n      source: '/((?!api|_next/static|_next/image|favicon.ico).*)',\r\n      missing: [\r\n        { type: 'header', key: 'next-router-prefetch' },\r\n        { type: 'header', key: 'purpose', value: 'prefetch' },\r\n      ],\r\n    },\r\n  ],\r\n}",
        "context": "filename=\"proxy.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { connection } from 'next/server'\r\n\r\nexport default async function Page() {\r\n  // wait for an incoming request to render this page\r\n  await connection()\r\n  // Your page content\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { connection } from 'next/server'\r\n\r\nexport default async function Page() {\r\n  // wait for an incoming request to render this page\r\n  await connection()\r\n  // Your page content\r\n}",
        "context": "filename=\"app/page.jsx\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Script from 'next/script'\r\n\r\nimport type { GetServerSideProps } from 'next'\r\n\r\nexport default function Page({ nonce }) {\r\n  return (\r\n    <Script\r\n      src=\"https://www.googletagmanager.com/gtag/js\"\r\n      strategy=\"afterInteractive\"\r\n      nonce={nonce}\r\n    />\r\n  )\r\n}\r\n\r\nexport const getServerSideProps: GetServerSideProps = async ({ req }) => {\r\n  const nonce = req.headers['x-nonce']\r\n  return { props: { nonce } }\r\n}",
        "context": "filename=\"pages/index.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Script from 'next/script'\r\nexport default function Page({ nonce }) {\r\n  return (\r\n    <Script\r\n      src=\"https://www.googletagmanager.com/gtag/js\"\r\n      strategy=\"afterInteractive\"\r\n      nonce={nonce}\r\n    />\r\n  )\r\n}\r\n\r\nexport async function getServerSideProps({ req }) {\r\n  const nonce = req.headers['x-nonce']\r\n  return { props: { nonce } }\r\n}",
        "context": "filename=\"pages/index.jsx\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Document, {\r\n  Html,\r\n  Head,\r\n  Main,\r\n  NextScript,\r\n  DocumentContext,\r\n  DocumentInitialProps,\r\n} from 'next/document'\r\n\r\ninterface ExtendedDocumentProps extends DocumentInitialProps {\r\n  nonce?: string\r\n}\r\n\r\nclass MyDocument extends Document<ExtendedDocumentProps> {\r\n  static async getInitialProps(\r\n    ctx: DocumentContext\r\n  ): Promise<ExtendedDocumentProps> {\r\n    const initialProps = await Document.getInitialProps(ctx)\r\n    const nonce = ctx.req?.headers?.['x-nonce'] as string | undefined\r\n\r\n    return {\r\n      ...initialProps,\r\n      nonce,\r\n    }\r\n  }\r\n\r\n  render() {\r\n    const { nonce } = this.props\r\n\r\n    return (\r\n      <Html lang=\"en\">\r\n        <Head nonce={nonce} />\r\n        <body>\r\n          <Main />\r\n          <NextScript nonce={nonce} />\r\n        </body>\r\n      </Html>\r\n    )\r\n  }\r\n}\r\n\r\nexport default MyDocument",
        "context": "filename=\"pages/_document.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Document, { Html, Head, Main, NextScript } from 'next/document'\r\n\r\nclass MyDocument extends Document {\r\n  static async getInitialProps(ctx) {\r\n    const initialProps = await Document.getInitialProps(ctx)\r\n    const nonce = ctx.req?.headers?.['x-nonce']\r\n\r\n    return {\r\n      ...initialProps,\r\n      nonce,\r\n    }\r\n  }\r\n\r\n  render() {\r\n    const { nonce } = this.props\r\n\r\n    return (\r\n      <Html lang=\"en\">\r\n        <Head nonce={nonce} />\r\n        <body>\r\n          <Main />\r\n          <NextScript nonce={nonce} />\r\n        </body>\r\n      </Html>\r\n    )\r\n  }\r\n}\r\n\r\nexport default MyDocument",
        "context": "filename=\"pages/_document.jsx\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { headers } from 'next/headers'\r\nimport Script from 'next/script'\r\n\r\nexport default async function Page() {\r\n  const nonce = (await headers()).get('x-nonce')\r\n\r\n  return (\r\n    <Script\r\n      src=\"https://www.googletagmanager.com/gtag/js\"\r\n      strategy=\"afterInteractive\"\r\n      nonce={nonce}\r\n    />\r\n  )\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { headers } from 'next/headers'\r\nimport Script from 'next/script'\r\n\r\nexport default async function Page() {\r\n  const nonce = (await headers()).get('x-nonce')\r\n\r\n  return (\r\n    <Script\r\n      src=\"https://www.googletagmanager.com/gtag/js\"\r\n      strategy=\"afterInteractive\"\r\n      nonce={nonce}\r\n    />\r\n  )\r\n}",
        "context": "filename=\"app/page.jsx\" switcher"
      },
      {
        "language": "js",
        "code": "const cspHeader = `\r\n    default-src 'self';\r\n    script-src 'self' 'unsafe-eval' 'unsafe-inline';\r\n    style-src 'self' 'unsafe-inline';\r\n    img-src 'self' blob: data:;\r\n    font-src 'self';\r\n    object-src 'none';\r\n    base-uri 'self';\r\n    form-action 'self';\r\n    frame-ancestors 'none';\r\n    upgrade-insecure-requests;\r\n`\r\n\r\nmodule.exports = {\r\n  async headers() {\r\n    return [\r\n      {\r\n        source: '/(.*)',\r\n        headers: [\r\n          {\r\n            key: 'Content-Security-Policy',\r\n            value: cspHeader.replace(/\\n/g, ''),\r\n          },\r\n        ],\r\n      },\r\n    ]\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  experimental: {\r\n    sri: {\r\n      algorithm: 'sha256', // or 'sha384' or 'sha512'\r\n    },\r\n  },\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "const cspHeader = `\r\n    default-src 'self';\r\n    script-src 'self';\r\n    style-src 'self';\r\n    img-src 'self' blob: data:;\r\n    font-src 'self';\r\n    object-src 'none';\r\n    base-uri 'self';\r\n    form-action 'self';\r\n    frame-ancestors 'none';\r\n    upgrade-insecure-requests;\r\n`\r\n\r\nmodule.exports = {\r\n  experimental: {\r\n    sri: {\r\n      algorithm: 'sha256',\r\n    },\r\n  },\r\n  async headers() {\r\n    return [\r\n      {\r\n        source: '/(.*)',\r\n        headers: [\r\n          {\r\n            key: 'Content-Security-Policy',\r\n            value: cspHeader.replace(/\\n/g, ''),\r\n          },\r\n        ],\r\n      },\r\n    ]\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "ts",
        "code": "export function proxy(request: NextRequest) {\r\n  const nonce = Buffer.from(crypto.randomUUID()).toString('base64')\r\n  const isDev = process.env.NODE_ENV === 'development'\r\n\r\n  const cspHeader = `\r\n    default-src 'self';\r\n    script-src 'self' 'nonce-${nonce}' 'strict-dynamic' ${isDev ? \"'unsafe-eval'\" : ''};\r\n    style-src 'self' ${isDev ? \"'unsafe-inline'\" : `'nonce-${nonce}'`};\r\n    img-src 'self' blob: data:;\r\n    font-src 'self';\r\n    object-src 'none';\r\n    base-uri 'self';\r\n    form-action 'self';\r\n    frame-ancestors 'none';\r\n    upgrade-insecure-requests;\r\n`\r\n\r\n  // Rest of proxy implementation\r\n}",
        "context": "filename=\"proxy.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export function proxy(request) {\r\n  const nonce = Buffer.from(crypto.randomUUID()).toString('base64')\r\n  const isDev = process.env.NODE_ENV === 'development'\r\n\r\n  const cspHeader = `\r\n    default-src 'self';\r\n    script-src 'self' 'nonce-${nonce}' 'strict-dynamic' ${isDev ? \"'unsafe-eval'\" : ''};\r\n    style-src 'self' ${isDev ? \"'unsafe-inline'\" : `'nonce-${nonce}'`};\r\n    img-src 'self' blob: data:;\r\n    font-src 'self';\r\n    object-src 'none';\r\n    base-uri 'self';\r\n    form-action 'self';\r\n    frame-ancestors 'none';\r\n    upgrade-insecure-requests;\r\n`\r\n\r\n  // Rest of proxy implementation\r\n}",
        "context": "filename=\"proxy.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { GoogleTagManager } from '@next/third-parties/google'\r\nimport { headers } from 'next/headers'\r\n\r\nexport default async function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  const nonce = (await headers()).get('x-nonce')\r\n\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>\r\n        {children}\r\n        <GoogleTagManager gtmId=\"GTM-XYZ\" nonce={nonce} />\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { GoogleTagManager } from '@next/third-parties/google'\r\nimport { headers } from 'next/headers'\r\n\r\nexport default async function RootLayout({ children }) {\r\n  const nonce = (await headers()).get('x-nonce')\r\n\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>\r\n        {children}\r\n        <GoogleTagManager gtmId=\"GTM-XYZ\" nonce={nonce} />\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.jsx\" switcher"
      },
      {
        "language": "tsx",
        "code": "import type { AppProps } from 'next/app'\r\nimport Script from 'next/script'\r\n\r\nexport default function App({ Component, pageProps }: AppProps) {\r\n  const nonce = pageProps.nonce\r\n\r\n  return (\r\n    <>\r\n      <Component {...pageProps} />\r\n      <Script\r\n        src=\"https://www.googletagmanager.com/gtag/js\"\r\n        strategy=\"afterInteractive\"\r\n        nonce={nonce}\r\n      />\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"pages/_app.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Script from 'next/script'\r\n\r\nexport default function App({ Component, pageProps }) {\r\n  const nonce = pageProps.nonce\r\n\r\n  return (\r\n    <>\r\n      <Component {...pageProps} />\r\n      <Script\r\n        src=\"https://www.googletagmanager.com/gtag/js\"\r\n        strategy=\"afterInteractive\"\r\n        nonce={nonce}\r\n      />\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"pages/_app.jsx\" switcher"
      },
      {
        "language": "ts",
        "code": "const cspHeader = `\r\n  default-src 'self';\r\n  script-src 'self' 'nonce-${nonce}' 'strict-dynamic' https://www.googletagmanager.com;\r\n  connect-src 'self' https://www.google-analytics.com;\r\n  img-src 'self' data: https://www.google-analytics.com;\r\n`",
        "context": "filename=\"proxy.ts\" switcher"
      },
      {
        "language": "js",
        "code": "const cspHeader = `\r\n  default-src 'self';\r\n  script-src 'self' 'nonce-${nonce}' 'strict-dynamic' https://www.googletagmanager.com;\r\n  connect-src 'self' https://www.google-analytics.com;\r\n  img-src 'self' data: https://www.google-analytics.com;\r\n`",
        "context": "filename=\"proxy.js\" switcher"
      }
    ],
    "content": "Content Security Policy (CSP) is important to guard your Next.js application against various security threats such as cross-site scripting (XSS), clickjacking, and other code injection attacks. By using CSP, developers can specify which origins are permissible for content sources, scripts, stylesheets, images, fonts, objects, media (audio, video), iframes, and more. Examples - Strict CSP Nonces A nonce is a unique, random string of characters created for a one-time use. It is used in conjunction with CSP to selectively allow certain inline scripts or styles to execute, bypassing strict CSP directives. Why use a nonce? CSP can block both inline and external scripts to prevent attacks. A nonce lets you safely allow specific scripts to run—only if they include the matching nonce value. If an attacker wanted to load a script into your page, they'd need to guess the nonce value. That's why the nonce must be unpredictable and unique for every request. Adding a nonce with Proxy Proxy enables you to add headers and generate nonces before the page renders. Every time a page is viewed, a fresh nonce should be generated. This means that you must use dynamic rendering to add nonces. For example: By default, Proxy runs on all requests. You can filter Proxy to run on specific paths using a matcher. We recommend ignoring matching prefetches (from next/link) and static assets that don't need the CSP header. How nonces work in Next.js To use a nonce, your page must be dynamically rendered. This is because Next.js applies nonces during server-side rendering, based on the CSP header present in the request. Static pages are generated at build time, when no request or response headers exist—so no nonce can be injected. Here’s how nonce support works in a dynamically rendered page: 1. Proxy generates a nonce: Your proxy creates a unique nonce for the request, adds it to your Content-Security-Policy header, and also sets it in a custom x-nonce header. 2. Next.js extracts the nonce: During rendering, Next.js parses the Content-Security-Policy header and extracts the nonce using the 'nonce-{value}' pattern. 3. Nonce is applied automatically: Next.js attaches the nonce to: - Framework scripts (React, Next.js runtime) - Page-specific JavaScript bundles - Inline styles and scripts generated by Next.js - Any components using the nonce prop Because of this automatic behavior, you don’t need to manually add a nonce to each tag. Forcing dynamic rendering If you're using nonces, you may need to explicitly opt pages into dynamic rendering: Reading the nonce You can provide the nonce to your page using getServerSideProps: You can also access the nonce in document.tsx for Pages Router applications: You can read the nonce from a Server Component using headers: Static vs Dynamic Rendering with CSP Using nonces has important implications for how your Next.js application renders: Dynamic Rendering Requirement When you use nonces in your CSP, all pages must be dynamically rendered. This means: - Pages will build successfully but may encounter runtime errors if not properly configured for dynamic rendering - Each request generates a fresh page with a new nonce - Static optimization and Incremental Static Regeneration (ISR) are disabled - Pages cannot be cached by CDNs without additional configuration - Partial Prerendering (PPR) is incompatible with nonce-based CSP since static shell scripts won't have access to the nonce Performance Implications The shift from static to dynamic rendering affects performance: - Slower initial page loads: Pages must be generated on each request - Increased server load: Every request requires server-side rendering - No CDN caching: Dynamic pages cannot be cached at the edge by default - Higher hosting costs: More server resources needed for dynamic rendering When to use nonces Consider nonces when: - You have strict security requirements that prohibit 'unsafe-inline' - Your application handles sensitive data - You need to allow specific inline scripts while blocking others - Compliance requirements mandate strict CSP Without Nonces For applications that do not require nonces, you can set the CSP header directly in your next.config.js file: Subresource Integrity (Experimental) As an alternative to nonces, Next.js offers experimental support for hash-based CSP using Subresource Integrity (SRI). This approach allows you to maintain static generation while still having a strict CSP. > Good to know: This feature is experimental and only available with webpack bundler in App Router applications. How SRI works Instead of using nonces, SRI generates cryptographic hashes of your JavaScript files at build time. These hashes are added as integrity attributes to script tags, allowing browsers to verify that files haven't been modified during transit. Enabling SRI Add the experimental SRI configuration to your next.config.js: CSP configuration with SRI When SRI is enabled, you can continue using your existing CSP policies. SRI works independently by adding integrity attributes to your assets: > Good to know: For dynamic rendering scenarios, you can still generate nonces with proxy if needed, combining both SRI integrity attributes and nonce-based CSP approaches. Benefits of SRI over nonces - Static generation: Pages can be statically generated and cached - CDN compatibility: Static pages work with CDN caching - Better performance: No server-side rendering required for each request - Build-time security: Hashes are generated at build time, ensuring integrity Limitations of SRI - Experimental: Feature may change or be removed - Webpack only: Not available with Turbopack - App Router only: Not supported in Pages Router - Build-time only: Cannot handle dynamically generated scripts Development vs Production Considerations CSP implementation differs between development and production environments: Development Environment In development, you will need to enable 'unsafe-eval' to support APIs that provide additional debugging information: Production Deployment Common issues in production: - Nonce not applied: Ensure your proxy runs on all necessary routes - Static assets blocked: Verify your CSP allows Next.js static assets - Third-party scripts: Add necessary domains to your CSP policy Troubleshooting Third-party Scripts When using third-party scripts with CSP: When using third-party scripts with CSP, ensure you add the necessary domains and pass the nonce: Update your CSP to allow third-party domains: Common CSP Violations 1. Inline styles: Use CSS-in-JS libraries that support nonces or move styles to external files 2. Dynamic imports: Ensure dynamic imports are allowed in your script-src policy 3. WebAssembly: Add 'wasm-unsafe-eval' if using WebAssembly 4. Service workers: Add appropriate policies for service worker scripts Version History | Version | Changes | | ---------- | ------------------------------------------------------------- | | v14.0.0 | Experimental SRI support added for hash-based CSP | | v13.4.20 | Recommended for proper nonce handling and CSP header parsing. |",
    "excerpt": "Content Security Policy (CSP) is important to guard your Next.js application against various security threats such as cross-site scripting (XSS), clickjacking, and other code injection attacks. By usi...",
    "url": "https://nextjs.org/docs/01-app/02-guides/content-security-policy"
  },
  {
    "id": "01-app-02-guides-css-in-js",
    "path": "01-app\\02-guides\\css-in-js.mdx",
    "title": "How to use CSS-in-JS libraries",
    "description": "Use CSS-in-JS libraries with Next.js",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Configuring CSS-in-JS in ",
        "slug": "configuring-css-in-js-in-"
      },
      {
        "level": 3,
        "text": "Styled Components",
        "slug": "styled-components"
      },
      {
        "level": 3,
        "text": "Disabling JavaScript",
        "slug": "disabling-javascript"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport React, { useState } from 'react'\r\nimport { useServerInsertedHTML } from 'next/navigation'\r\nimport { StyleRegistry, createStyleRegistry } from 'styled-jsx'\r\n\r\nexport default function StyledJsxRegistry({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  // Only create stylesheet once with lazy initial state\r\n  // x-ref: https://reactjs.org/docs/hooks-reference.html#lazy-initial-state\r\n  const [jsxStyleRegistry] = useState(() => createStyleRegistry())\r\n\r\n  useServerInsertedHTML(() => {\r\n    const styles = jsxStyleRegistry.styles()\r\n    jsxStyleRegistry.flush()\r\n    return <>{styles}</>\r\n  })\r\n\r\n  return <StyleRegistry registry={jsxStyleRegistry}>{children}</StyleRegistry>\r\n}",
        "context": "filename=\"app/registry.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport React, { useState } from 'react'\r\nimport { useServerInsertedHTML } from 'next/navigation'\r\nimport { StyleRegistry, createStyleRegistry } from 'styled-jsx'\r\n\r\nexport default function StyledJsxRegistry({ children }) {\r\n  // Only create stylesheet once with lazy initial state\r\n  // x-ref: https://reactjs.org/docs/hooks-reference.html#lazy-initial-state\r\n  const [jsxStyleRegistry] = useState(() => createStyleRegistry())\r\n\r\n  useServerInsertedHTML(() => {\r\n    const styles = jsxStyleRegistry.styles()\r\n    jsxStyleRegistry.flush()\r\n    return <>{styles}</>\r\n  })\r\n\r\n  return <StyleRegistry registry={jsxStyleRegistry}>{children}</StyleRegistry>\r\n}",
        "context": "filename=\"app/registry.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import StyledJsxRegistry from './registry'\r\n\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html>\r\n      <body>\r\n        <StyledJsxRegistry>{children}</StyledJsxRegistry>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import StyledJsxRegistry from './registry'\r\n\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html>\r\n      <body>\r\n        <StyledJsxRegistry>{children}</StyledJsxRegistry>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  compiler: {\r\n    styledComponents: true,\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport React, { useState } from 'react'\r\nimport { useServerInsertedHTML } from 'next/navigation'\r\nimport { ServerStyleSheet, StyleSheetManager } from 'styled-components'\r\n\r\nexport default function StyledComponentsRegistry({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  // Only create stylesheet once with lazy initial state\r\n  // x-ref: https://reactjs.org/docs/hooks-reference.html#lazy-initial-state\r\n  const [styledComponentsStyleSheet] = useState(() => new ServerStyleSheet())\r\n\r\n  useServerInsertedHTML(() => {\r\n    const styles = styledComponentsStyleSheet.getStyleElement()\r\n    styledComponentsStyleSheet.instance.clearTag()\r\n    return <>{styles}</>\r\n  })\r\n\r\n  if (typeof window !== 'undefined') return <>{children}</>\r\n\r\n  return (\r\n    <StyleSheetManager sheet={styledComponentsStyleSheet.instance}>\r\n      {children}\r\n    </StyleSheetManager>\r\n  )\r\n}",
        "context": "filename=\"lib/registry.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport React, { useState } from 'react'\r\nimport { useServerInsertedHTML } from 'next/navigation'\r\nimport { ServerStyleSheet, StyleSheetManager } from 'styled-components'\r\n\r\nexport default function StyledComponentsRegistry({ children }) {\r\n  // Only create stylesheet once with lazy initial state\r\n  // x-ref: https://reactjs.org/docs/hooks-reference.html#lazy-initial-state\r\n  const [styledComponentsStyleSheet] = useState(() => new ServerStyleSheet())\r\n\r\n  useServerInsertedHTML(() => {\r\n    const styles = styledComponentsStyleSheet.getStyleElement()\r\n    styledComponentsStyleSheet.instance.clearTag()\r\n    return <>{styles}</>\r\n  })\r\n\r\n  if (typeof window !== 'undefined') return <>{children}</>\r\n\r\n  return (\r\n    <StyleSheetManager sheet={styledComponentsStyleSheet.instance}>\r\n      {children}\r\n    </StyleSheetManager>\r\n  )\r\n}",
        "context": "filename=\"lib/registry.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import StyledComponentsRegistry from './lib/registry'\r\n\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html>\r\n      <body>\r\n        <StyledComponentsRegistry>{children}</StyledComponentsRegistry>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import StyledComponentsRegistry from './lib/registry'\r\n\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html>\r\n      <body>\r\n        <StyledComponentsRegistry>{children}</StyledComponentsRegistry>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "function HiThere() {\r\n  return <p style={{ color: 'red' }}>hi there</p>\r\n}\r\n\r\nexport default HiThere",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "function HelloWorld() {\r\n  return (\r\n    <div>\r\n      Hello world\r\n      <p>scoped!</p>\r\n      <style jsx>{`\r\n        p {\r\n          color: blue;\r\n        }\r\n        div {\r\n          background: red;\r\n        }\r\n        @media (max-width: 600px) {\r\n          div {\r\n            background: blue;\r\n          }\r\n        }\r\n      `}</style>\r\n      <style global jsx>{`\r\n        body {\r\n          background: black;\r\n        }\r\n      `}</style>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default HelloWorld",
        "context": ""
      }
    ],
    "content": "> Warning: Using CSS-in-JS with newer React features like Server Components and Streaming requires library authors to support the latest version of React, including concurrent rendering. The following libraries are supported in Client Components in the app directory (alphabetical): - ant-design - chakra-ui - @fluentui/react-components - kuma-ui - @mui/material - @mui/joy - pandacss - styled-jsx - styled-components - stylex - tamagui - tss-react - vanilla-extract The following are currently working on support: - emotion > Good to know: We're testing out different CSS-in-JS libraries and we'll be adding more examples for libraries that support React 18 features and/or the app directory. Configuring CSS-in-JS in app Configuring CSS-in-JS is a three-step opt-in process that involves: 1. A style registry to collect all CSS rules in a render. 2. The new useServerInsertedHTML hook to inject rules before any content that might use them. 3. A Client Component that wraps your app with the style registry during initial server-side rendering. styled-jsx Using styled-jsx in Client Components requires using v5.1.0. First, create a new registry: Then, wrap your root layout with the registry: View an example here. Styled Components Below is an example of how to configure styled-components@6 or newer: First, enable styled-components in next.config.js. Then, use the styled-components API to create a global registry component to collect all CSS style rules generated during a render, and a function to return those rules. Then use the useServerInsertedHTML hook to inject the styles collected in the registry into the HTML tag in the root layout. Wrap the children of the root layout with the style registry component: View an example here. > Good to know: > > - During server rendering, styles will be extracted to a global registry and flushed to the of your HTML. This ensures the style rules are placed before any content that might use them. In the future, we may use an upcoming React feature to determine where to inject the styles. > - During streaming, styles from each chunk will be collected and appended to existing styles. After client-side hydration is complete, styled-components will take over as usual and inject any further dynamic styles. > - We specifically use a Client Component at the top level of the tree for the style registry because it's more efficient to extract CSS rules this way. It avoids re-generating styles on subsequent server renders, and prevents them from being sent in the Server Component payload. > - For advanced use cases where you need to configure individual properties of styled-components compilation, you can read our Next.js styled-components API reference to learn more. Examples - Styled JSX - Styled Components - Emotion - Linaria - Styletron - Cxs - Fela - Stitches It's possible to use any existing CSS-in-JS solution. The simplest one is inline styles: We bundle styled-jsx to provide support for isolated scoped CSS. The aim is to support \"shadow CSS\" similar to Web Components, which unfortunately do not support server-rendering and are JS-only. See the above examples for other popular CSS-in-JS solutions (like Styled Components). A component using styled-jsx looks like this: Please see the styled-jsx documentation for more examples. Disabling JavaScript Yes, if you disable JavaScript the CSS will still be loaded in the production build (next start). During development, we require JavaScript to be enabled to provide the best developer experience with Fast Refresh.",
    "excerpt": "> Warning: Using CSS-in-JS with newer React features like Server Components and Streaming requires library authors to support the latest version of React, including concurrent rendering. The following...",
    "url": "https://nextjs.org/docs/01-app/02-guides/css-in-js"
  },
  {
    "id": "01-app-02-guides-custom-server",
    "path": "01-app\\02-guides\\custom-server.mdx",
    "title": "How to set up a custom server in Next.js",
    "description": "Start a Next.js app programmatically using a custom server.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Disabling file-system routing",
        "slug": "disabling-file-system-routing"
      }
    ],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "import { createServer } from 'http'\r\nimport { parse } from 'url'\r\nimport next from 'next'\r\n\r\nconst port = parseInt(process.env.PORT || '3000', 10)\r\nconst dev = process.env.NODE_ENV !== 'production'\r\nconst app = next({ dev })\r\nconst handle = app.getRequestHandler()\r\n\r\napp.prepare().then(() => {\r\n  createServer((req, res) => {\r\n    const parsedUrl = parse(req.url!, true)\r\n    handle(req, res, parsedUrl)\r\n  }).listen(port)\r\n\r\n  console.log(\r\n    `> Server listening at http://localhost:${port} as ${\r\n      dev ? 'development' : process.env.NODE_ENV\r\n    }`\r\n  )\r\n})",
        "context": "filename=\"server.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { createServer } from 'http'\r\nimport { parse } from 'url'\r\nimport next from 'next'\r\n\r\nconst port = parseInt(process.env.PORT || '3000', 10)\r\nconst dev = process.env.NODE_ENV !== 'production'\r\nconst app = next({ dev })\r\nconst handle = app.getRequestHandler()\r\n\r\napp.prepare().then(() => {\r\n  createServer((req, res) => {\r\n    const parsedUrl = parse(req.url, true)\r\n    handle(req, res, parsedUrl)\r\n  }).listen(port)\r\n\r\n  console.log(\r\n    `> Server listening at http://localhost:${port} as ${\r\n      dev ? 'development' : process.env.NODE_ENV\r\n    }`\r\n  )\r\n})",
        "context": "filename=\"server.js\" switcher"
      },
      {
        "language": "json",
        "code": "{\r\n  \"scripts\": {\r\n    \"dev\": \"node server.js\",\r\n    \"build\": \"next build\",\r\n    \"start\": \"NODE_ENV=production node server.js\"\r\n  }\r\n}",
        "context": "filename=\"package.json\""
      },
      {
        "language": "js",
        "code": "import next from 'next'\r\n\r\nconst app = next({})",
        "context": ""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  useFileSystemPublicRoutes: false,\r\n}",
        "context": "filename=\"next.config.js\""
      }
    ],
    "content": "Next.js includes its own server with next start by default. If you have an existing backend, you can still use it with Next.js (this is not a custom server). A custom Next.js server allows you to programmatically start a server for custom patterns. The majority of the time, you will not need this approach. However, it's available if you need to eject. > Good to know: > > - Before deciding to use a custom server, keep in mind that it should only be used when the integrated router of Next.js can't meet your app requirements. A custom server will remove important performance optimizations, like Automatic Static Optimization. > - When using standalone output mode, it does not trace custom server files. This mode outputs a separate minimal server.js file, instead. These cannot be used together. Take a look at the following example of a custom server: > server.js does not run through the Next.js Compiler or bundling process. Make sure the syntax and source code this file requires are compatible with the current Node.js version you are using. View an example. To run the custom server, you'll need to update the scripts in package.json like so: Alternatively, you can set up nodemon (example). The custom server uses the following import to connect the server with the Next.js application: The above next import is a function that receives an object with the following options: | Option | Type | Description | | ------------ | ------------------ | ----------------------------------------------------------------------------------- | | conf | Object | The same object you would use in next.config.js. Defaults to {} | | dev | Boolean | (Optional) Whether or not to launch Next.js in dev mode. Defaults to false | | dir | String | (Optional) Location of the Next.js project. Defaults to '.' | | quiet | Boolean | (Optional) Hide error messages containing server information. Defaults to false | | hostname | String | (Optional) The hostname the server is running behind | | port | Number | (Optional) The port the server is running behind | | httpServer | node:httpServer | (Optional) The HTTP Server that Next.js is running behind | | turbopack | Boolean | (Optional) Enable Turbopack (enabled by default) | | webpack | Boolean | (Optional) Enable webpack | The returned app can then be used to let Next.js handle requests as required. Disabling file-system routing By default, Next will serve each file in the pages folder under a pathname matching the filename. If your project uses a custom server, this behavior may result in the same content being served from multiple paths, which can present problems with SEO and UX. To disable this behavior and prevent routing based on files in pages, open next.config.js and disable the useFileSystemPublicRoutes config: > Note that useFileSystemPublicRoutes disables filename routes from SSR; client-side routing may still access those paths. When using this option, you should guard against navigation to routes you do not want programmatically. > You may also wish to configure the client-side router to disallow client-side redirects to filename routes; for that refer to router.beforePopState.",
    "excerpt": "Next.js includes its own server with next start by default. If you have an existing backend, you can still use it with Next.js (this is not a custom server). A custom Next.js server allows you to prog...",
    "url": "https://nextjs.org/docs/01-app/02-guides/custom-server"
  },
  {
    "id": "01-app-02-guides-data-security",
    "path": "01-app\\02-guides\\data-security.mdx",
    "title": "How to think about data security in Next.js",
    "description": "Learn the built-in data security features in Next.js and learn best practices for protecting your application's data.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Data fetching approaches",
        "slug": "data-fetching-approaches"
      },
      {
        "level": 3,
        "text": "External HTTP APIs",
        "slug": "external-http-apis"
      },
      {
        "level": 3,
        "text": "Data Access Layer",
        "slug": "data-access-layer"
      },
      {
        "level": 3,
        "text": "Component-level data access",
        "slug": "component-level-data-access"
      },
      {
        "level": 2,
        "text": "Reading data",
        "slug": "reading-data"
      },
      {
        "level": 3,
        "text": "Passing data from server to client",
        "slug": "passing-data-from-server-to-client"
      },
      {
        "level": 3,
        "text": "Tainting",
        "slug": "tainting"
      },
      {
        "level": 3,
        "text": "Preventing client-side execution of server-only code",
        "slug": "preventing-client-side-execution-of-server-only-code"
      },
      {
        "level": 2,
        "text": "Mutating Data",
        "slug": "mutating-data"
      },
      {
        "level": 3,
        "text": "Built-in Server Actions Security features",
        "slug": "built-in-server-actions-security-features"
      },
      {
        "level": 3,
        "text": "Validating client input",
        "slug": "validating-client-input"
      },
      {
        "level": 3,
        "text": "Authentication and authorization",
        "slug": "authentication-and-authorization"
      },
      {
        "level": 3,
        "text": "Closures and encryption",
        "slug": "closures-and-encryption"
      },
      {
        "level": 3,
        "text": "Overwriting encryption keys (advanced)",
        "slug": "overwriting-encryption-keys-advanced"
      },
      {
        "level": 3,
        "text": "Allowed origins (advanced)",
        "slug": "allowed-origins-advanced"
      },
      {
        "level": 3,
        "text": "Avoiding side-effects during rendering",
        "slug": "avoiding-side-effects-during-rendering"
      },
      {
        "level": 2,
        "text": "Auditing",
        "slug": "auditing"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "import { cookies } from 'next/headers'\r\n\r\nexport default async function Page() {\r\n  const cookieStore = cookies()\r\n  const token = cookieStore.get('AUTH_TOKEN')?.value\r\n\r\n  const res = await fetch('https://api.example.com/profile', {\r\n    headers: {\r\n      Cookie: `AUTH_TOKEN=${token}`,\r\n      // Other headers\r\n    },\r\n  })\r\n\r\n  // ....\r\n}",
        "context": "filename=\"app/page.tsx\""
      },
      {
        "language": "ts",
        "code": "import { cache } from 'react'\r\nimport { cookies } from 'next/headers'\r\n\r\n// Cached helper methods makes it easy to get the same value in many places\r\n// without manually passing it around. This discourages passing it from Server\r\n// Component to Server Component which minimizes risk of passing it to a Client\r\n// Component.\r\nexport const getCurrentUser = cache(async () => {\r\n  const token = cookies().get('AUTH_TOKEN')\r\n  const decodedToken = await decryptAndValidate(token)\r\n  // Don't include secret tokens or private information as public fields.\r\n  // Use classes to avoid accidentally passing the whole object to the client.\r\n  return new User(decodedToken.id)\r\n})",
        "context": "filename=\"data/auth.ts\""
      },
      {
        "language": "tsx",
        "code": "import 'server-only'\r\nimport { getCurrentUser } from './auth'\r\n\r\nfunction canSeeUsername(viewer: User) {\r\n  // Public info for now, but can change\r\n  return true\r\n}\r\n\r\nfunction canSeePhoneNumber(viewer: User, team: string) {\r\n  // Privacy rules\r\n  return viewer.isAdmin || team === viewer.team\r\n}\r\n\r\nexport async function getProfileDTO(slug: string) {\r\n  // Don't pass values, read back cached values, also solves context and easier to make it lazy\r\n\r\n  // use a database API that supports safe templating of queries\r\n  const [rows] = await sql`SELECT * FROM user WHERE slug = ${slug}`\r\n  const userData = rows[0]\r\n\r\n  const currentUser = await getCurrentUser()\r\n\r\n  // only return the data relevant for this query and not everything\r\n  // <https://www.w3.org/2001/tag/doc/APIMinimization>\r\n  return {\r\n    username: canSeeUsername(currentUser) ? userData.username : null,\r\n    phonenumber: canSeePhoneNumber(currentUser, userData.team)\r\n      ? userData.phonenumber\r\n      : null,\r\n  }\r\n}",
        "context": "filename=\"data/user-dto.tsx\""
      },
      {
        "language": "tsx",
        "code": "import { getProfile } from '../../data/user'\r\n\r\nexport async function Page({ params: { slug } }) {\r\n  // This page can now safely pass around this profile knowing\r\n  // that it shouldn't contain anything sensitive.\r\n  const profile = await getProfile(slug);\r\n  ...\r\n}",
        "context": "filename=\"app/page.tsx\""
      },
      {
        "language": "tsx",
        "code": "import Profile from './components/profile.tsx'\r\n\r\nexport async function Page({ params: { slug } }) {\r\n  const [rows] = await sql`SELECT * FROM user WHERE slug = ${slug}`\r\n  const userData = rows[0]\r\n  // EXPOSED: This exposes all the fields in userData to the client because\r\n  // we are passing the data from the Server Component to the Client.\r\n  return <Profile user={userData} />\r\n}",
        "context": "filename=\"app/page.tsx\""
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\n// BAD: This is a bad props interface because it accepts way more data than the\r\n// Client Component needs and it encourages server components to pass all that\r\n// data down. A better solution would be to accept a limited object with just\r\n// the fields necessary for rendering the profile.\r\nexport default async function Profile({ user }: { user: User }) {\r\n  return (\r\n    <div>\r\n      <h1>{user.name}</h1>\r\n      ...\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/ui/profile.tsx\""
      },
      {
        "language": "ts",
        "code": "import { sql } from './db'\r\n\r\nexport async function getUser(slug: string) {\r\n  const [rows] = await sql`SELECT * FROM user WHERE slug = ${slug}`\r\n  const user = rows[0]\r\n\r\n  // Return only the public fields\r\n  return {\r\n    name: user.name,\r\n  }\r\n}",
        "context": "filename=\"data/user.ts\""
      },
      {
        "language": "tsx",
        "code": "import { getUser } from '../data/user'\r\nimport Profile from './ui/profile'\r\n\r\nexport default async function Page({\r\n  params: { slug },\r\n}: {\r\n  params: { slug: string }\r\n}) {\r\n  const publicProfile = await getUser(slug)\r\n  return <Profile user={publicProfile} />\r\n}",
        "context": "filename=\"app/page.tsx\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  experimental: {\r\n    taint: true,\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "bash",
        "code": "npm install server-only",
        "context": "package=\"npm\""
      },
      {
        "language": "bash",
        "code": "yarn add server-only",
        "context": "package=\"yarn\""
      },
      {
        "language": "bash",
        "code": "pnpm add server-only",
        "context": "package=\"pnpm\""
      },
      {
        "language": "bash",
        "code": "bun add server-only",
        "context": "package=\"bun\""
      },
      {
        "language": "ts",
        "code": "import 'server-only'\r\n\r\n//...",
        "context": "filename=\"lib/data.ts\""
      },
      {
        "language": "jsx",
        "code": "// app/actions.js\r\n'use server'\r\n\r\n// If this action **is** used in our application, Next.js\r\n// will create a secure ID to allow the client to reference\r\n// and call the Server Action.\r\nexport async function updateUserAction(formData) {}\r\n\r\n// If this action **is not** used in our application, Next.js\r\n// will automatically remove this code during `next build`\r\n// and will not create a public endpoint.\r\nexport async function deleteUserAction(formData) {}",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "// BAD: Trusting searchParams directly\r\nexport default async function Page({ searchParams }) {\r\n  const isAdmin = searchParams.get('isAdmin')\r\n  if (isAdmin === 'true') {\r\n    // Vulnerable: relies on untrusted client data\r\n    return <AdminPanel />\r\n  }\r\n}\r\n\r\n// GOOD: Re-verify every time\r\nimport { cookies } from 'next/headers'\r\nimport { verifyAdmin } from './auth'\r\n\r\nexport default async function Page() {\r\n  const token = cookies().get('AUTH_TOKEN')\r\n  const isAdmin = await verifyAdmin(token)\r\n\r\n  if (isAdmin) {\r\n    return <AdminPanel />\r\n  }\r\n}",
        "context": "filename=\"app/page.tsx\""
      },
      {
        "language": "tsx",
        "code": "'use server'\r\n\r\nimport { auth } from './lib'\r\n\r\nexport function addItem() {\r\n  const { user } = auth()\r\n  if (!user) {\r\n    throw new Error('You must be signed in to perform this action')\r\n  }\r\n\r\n  // ...\r\n}",
        "context": "filename=\"app/actions.ts\""
      },
      {
        "language": "tsx",
        "code": "export default async function Page() {\r\n  const publishVersion = await getLatestVersion();\r\n\r\n  async function publish() {\r\n    \"use server\";\r\n    if (publishVersion !== await getLatestVersion()) {\r\n      throw new Error('The version has changed since pressing publish');\r\n    }\r\n    ...\r\n  }\r\n\r\n  return (\r\n    <form>\r\n      <button formAction={publish}>Publish</button>\r\n    </form>\r\n  );\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default async function Page() {\r\n  const publishVersion = await getLatestVersion();\r\n\r\n  async function publish() {\r\n    \"use server\";\r\n    if (publishVersion !== await getLatestVersion()) {\r\n      throw new Error('The version has changed since pressing publish');\r\n    }\r\n    ...\r\n  }\r\n\r\n  return (\r\n    <form>\r\n      <button formAction={publish}>Publish</button>\r\n    </form>\r\n  );\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nmodule.exports = {\r\n  experimental: {\r\n    serverActions: {\r\n      allowedOrigins: ['my-proxy.com', '*.my-proxy.com'],\r\n    },\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "tsx",
        "code": "// BAD: Triggering a mutation during rendering\r\nexport default async function Page({ searchParams }) {\r\n  if (searchParams.get('logout')) {\r\n    cookies().delete('AUTH_TOKEN')\r\n  }\r\n\r\n  return <UserProfile />\r\n}",
        "context": "filename=\"app/page.tsx\""
      },
      {
        "language": "tsx",
        "code": "// GOOD: Using Server Actions to handle mutations\r\nimport { logout } from './actions'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <UserProfile />\r\n      <form action={logout}>\r\n        <button type=\"submit\">Logout</button>\r\n      </form>\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/page.tsx\""
      }
    ],
    "content": "React Server Components improve performance and simplify data fetching, but also shift where and how data is accessed, changing some of the traditional security assumptions for handling data in frontend apps. This guide will help you understand how to think about data security in Next.js and how to implement best practices. Data fetching approaches There are three main approaches we recommend for fetching data in Next.js, depending on the size and age of your project: - HTTP APIs: for existing large applications and organizations. - Data Access Layer: for new projects. - Component-Level Data Access: for prototypes and learning. We recommend choosing one data fetching approach and avoiding mixing them. This makes it clear for both developers working in your code base and security auditors what to expect. External HTTP APIs You should follow a Zero Trust model when adopting Server Components in an existing project. You can continue calling your existing API endpoints such as REST or GraphQL from Server Components using fetch, just as you would in Client Components. This approach works well when: - You already have security practices in place. - Separate backend teams use other languages or manage APIs independently. Data Access Layer For new projects, we recommend creating a dedicated Data Access Layer (DAL). This is a internal library that controls how and when data is fetched, and what gets passed to your render context. A Data Access Layer should: - Only run on the server. - Perform authorization checks. - Return safe, minimal Data Transfer Objects (DTOs). This approach centralizes all data access logic, making it easier to enforce consistent data access and reduces the risk of authorization bugs. You also get the benefit of sharing an in-memory cache across different parts of a request. > Good to know: Secret keys should be stored in environment variables, but only the Data Access Layer should access process.env. This keeps secrets from being exposed to other parts of the application. Component-level data access For quick prototypes and iteration, database queries can be placed directly in Server Components. This approach, however, makes it easier to accidentally expose private data to the client, for example: You should sanitize the data before passing it to the Client Component: Reading data Passing data from server to client On the initial load, both Server and Client Components run on the server to generate HTML. However, they execute in isolated module systems. This ensures that Server Components can access private data and APIs, while Client Components cannot. Server Components: - Run only on the server. - Can safely access environment variables, secrets, databases, and internal APIs. Client Components: - Run on the server during pre-rendering, but must follow the same security assumptions as code running in the browser. - Must not access privileged data or server-only modules. This ensures the app is secure by default, but it's possible to accidentally expose private data through how data is fetched or passed to components. Tainting To prevent accidental exposure of private data to the client, you can use React Taint APIs: - experimentaltaintObjectReference for data objects. - experimentaltaintUniqueValue for specific values. You can enable usage in your Next.js app with the experimental.taint option in next.config.js: This prevents the tainted objects or values from being passed to the client. However, it's an additional layer of protection, you should still filter and sanitize the data in your DAL before passing it to React's render context. > Good to know: > > - By default, environment variables are only available on the Server. Next.js exposes any environment variable prefixed with NEXTPUBLIC to the client. Learn more. > - Functions and classes are already blocked from being passed to Client Components by default. Preventing client-side execution of server-only code To prevent server-only code from being executed on the client, you can mark a module with the server-only package: This ensures that proprietary code or internal business logic stays on the server by causing a build error if the module is imported in the client environment. Mutating Data Next.js handles mutations with Server Actions. Built-in Server Actions Security features By default, when a Server Action is created and exported, it creates a public HTTP endpoint and should be treated with the same security assumptions and authorization checks. This means, even if a Server Action or utility function is not imported elsewhere in your code, it's still publicly accessible. To improve security, Next.js has the following built-in features: - Secure action IDs: Next.js creates encrypted, non-deterministic IDs to allow the client to reference and call the Server Action. These IDs are periodically recalculated between builds for enhanced security. - Dead code elimination: Unused Server Actions (referenced by their IDs) are removed from client bundle to avoid public access. > Good to know: > > The IDs are created during compilation and are cached for a maximum of 14 days. They will be regenerated when a new build is initiated or when the build cache is invalidated. > This security improvement reduces the risk in cases where an authentication layer is missing. However, you should still treat Server Actions like public HTTP endpoints. Validating client input You should always validate input from client, as they can be easily modified. For example, form data, URL parameters, headers, and searchParams: Authentication and authorization You should always ensure that a user is authorized to perform an action. For example: Learn more about Authentication in Next.js. Closures and encryption Defining a Server Action inside a component creates a closure where the action has access to the outer function's scope. For example, the publish action has access to the publishVersion variable: Closures are useful when you need to capture a snapshot of data (e.g. publishVersion) at the time of rendering so that it can be used later when the action is invoked. However, for this to happen, the captured variables are sent to the client and back to the server when the action is invoked. To prevent sensitive data from being exposed to the client, Next.js automatically encrypts the closed-over variables. A new private key is generated for each action every time a Next.js application is built. This means actions can only be invoked for a specific build. > Good to know: We don't recommend relying on encryption alone to prevent sensitive values from being exposed on the client. Overwriting encryption keys (advanced) When self-hosting your Next.js application across multiple servers, each server instance may end up with a different encryption key, leading to potential inconsistencies. To mitigate this, you can overwrite the encryption key using the process.env.NEXTSERVERACTIONSENCRYPTIONKEY environment variable. Specifying this variable ensures that your encryption keys are persistent across builds, and all server instances use the same key. This variable must be AES-GCM encrypted. This is an advanced use case where consistent encryption behavior across multiple deployments is critical for your application. You should consider standard security practices such key rotation and signing. > Good to know: Next.js applications deployed to Vercel automatically handle this. Allowed origins (advanced) Since Server Actions can be invoked in a element, this opens them up to CSRF attacks. Behind the scenes, Server Actions use the POST method, and only this HTTP method is allowed to invoke them. This prevents most CSRF vulnerabilities in modern browsers, particularly with SameSite cookies being the default. As an additional protection, Server Actions in Next.js also compare the Origin header to the Host header (or X-Forwarded-Host). If these don't match, the request will be aborted. In other words, Server Actions can only be invoked on the same host as the page that hosts it. For large applications that use reverse proxies or multi-layered backend architectures (where the server API differs from the production domain), it's recommended to use the configuration option serverActions.allowedOrigins option to specify a list of safe origins. The option accepts an array of strings. Learn more about Security and Server Actions. Avoiding side-effects during rendering Mutations (e.g. logging out users, updating databases, invalidating caches) should never be a side-effect, either in Server or Client Components. Next.js explicitly prevents setting cookies or triggering cache revalidation within render methods to avoid unintended side effects. Instead, you should use Server Actions to handle mutations. > Good to know: Next.js uses POST requests to handle mutations. This prevents accidental side-effects from GET requests, reducing Cross-Site Request Forgery (CSRF) risks. Auditing If you're doing an audit of a Next.js project, here are a few things we recommend looking extra at: - Data Access Layer: Is there an established practice for an isolated Data Access Layer? Verify that database packages and environment variables are not imported outside the Data Access Layer. - \"use client\" files: Are the Component props expecting private data? Are the type signatures overly broad? - \"use server\" files: Are the Action arguments validated in the action or inside the Data Access Layer? Is the user re-authorized inside the action? - /[param]/. Folders with brackets are user input. Are params validated? - proxy.ts and route.ts: Have a lot of power. Spend extra time auditing these using traditional techniques. Perform Penetration Testing or Vulnerability Scanning regularly or in alignment with your team's software development lifecycle.",
    "excerpt": "React Server Components improve performance and simplify data fetching, but also shift where and how data is accessed, changing some of the traditional security assumptions for handling data in fronte...",
    "url": "https://nextjs.org/docs/01-app/02-guides/data-security"
  },
  {
    "id": "01-app-02-guides-debugging",
    "path": "01-app\\02-guides\\debugging.mdx",
    "title": "How to use debugging tools with Next.js",
    "description": "Learn how to debug your Next.js application with VS Code, Chrome DevTools, or Firefox DevTools.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Debugging with VS Code",
        "slug": "debugging-with-vs-code"
      },
      {
        "level": 2,
        "text": "Using the Debugger in Jetbrains WebStorm",
        "slug": "using-the-debugger-in-jetbrains-webstorm"
      },
      {
        "level": 2,
        "text": "Debugging with Browser DevTools",
        "slug": "debugging-with-browser-devtools"
      },
      {
        "level": 3,
        "text": "Client-side code",
        "slug": "client-side-code"
      },
      {
        "level": 3,
        "text": "React Developer Tools",
        "slug": "react-developer-tools"
      },
      {
        "level": 3,
        "text": "Server-side code",
        "slug": "server-side-code"
      },
      {
        "level": 3,
        "text": "Inspect Server Errors with Browser DevTools",
        "slug": "inspect-server-errors-with-browser-devtools"
      },
      {
        "level": 3,
        "text": "Debugging on Windows",
        "slug": "debugging-on-windows"
      },
      {
        "level": 2,
        "text": "More information",
        "slug": "more-information"
      }
    ],
    "codeBlocks": [
      {
        "language": "json",
        "code": "{\r\n  \"version\": \"0.2.0\",\r\n  \"configurations\": [\r\n    {\r\n      \"name\": \"Next.js: debug server-side\",\r\n      \"type\": \"node-terminal\",\r\n      \"request\": \"launch\",\r\n      \"command\": \"npm run dev -- --inspect\"\r\n    },\r\n    {\r\n      \"name\": \"Next.js: debug client-side\",\r\n      \"type\": \"chrome\",\r\n      \"request\": \"launch\",\r\n      \"url\": \"http://localhost:3000\"\r\n    },\r\n    {\r\n      \"name\": \"Next.js: debug client-side (Firefox)\",\r\n      \"type\": \"firefox\",\r\n      \"request\": \"launch\",\r\n      \"url\": \"http://localhost:3000\",\r\n      \"reAttach\": true,\r\n      \"pathMappings\": [\r\n        {\r\n          \"url\": \"webpack://_N_E\",\r\n          \"path\": \"${workspaceFolder}\"\r\n        }\r\n      ]\r\n    },\r\n    {\r\n      \"name\": \"Next.js: debug full stack\",\r\n      \"type\": \"node\",\r\n      \"request\": \"launch\",\r\n      \"program\": \"${workspaceFolder}/node_modules/next/dist/bin/next\",\r\n      \"runtimeArgs\": [\"--inspect\"],\r\n      \"skipFiles\": [\"<node_internals>/**\"],\r\n      \"serverReadyAction\": {\r\n        \"action\": \"debugWithEdge\",\r\n        \"killOnServerStop\": true,\r\n        \"pattern\": \"- Local:.+(https?://.+)\",\r\n        \"uriFormat\": \"%s\",\r\n        \"webRoot\": \"${workspaceFolder}\"\r\n      }\r\n    }\r\n  ]\r\n}",
        "context": "filename=\"launch.json\""
      },
      {
        "language": "bash",
        "code": "next dev --inspect",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "Debugger listening on ws://127.0.0.1:9229/0cf90313-350d-4466-a748-cd60f4e47c95\r\nFor help, see: https://nodejs.org/en/docs/inspector\r\nready - started server on 0.0.0.0:3000, url: http://localhost:3000",
        "context": "filename=\"Terminal\""
      }
    ],
    "content": "This documentation explains how you can debug your Next.js frontend and backend code with full source maps support using the VS Code debugger, Chrome DevTools, or Firefox DevTools. Any debugger that can attach to Node.js can also be used to debug a Next.js application. You can find more details in the Node.js Debugging Guide. Debugging with VS Code Create a file named .vscode/launch.json at the root of your project with the following content: > Note: To use Firefox debugging in VS Code, you'll need to install the Firefox Debugger extension. npm run dev can be replaced with yarn dev if you're using Yarn or pnpm dev if you're using pnpm. In the \"Next.js: debug full stack\" configuration, serverReadyAction.action specifies which browser to open when the server is ready. debugWithEdge means to launch the Edge browser. If you are using Chrome, change this value to debugWithChrome. If you're changing the port number your application starts on, replace the 3000 in http://localhost:3000 with the port you're using instead. If you're running Next.js from a directory other than root (for example, if you're using Turborepo) then you need to add cwd to the server-side and full stack debugging tasks. For example, \"cwd\": \"${workspaceFolder}/apps/web\". Now go to the Debug panel (Ctrl+Shift+D on Windows/Linux, ⇧+⌘+D on macOS), select a launch configuration, then press F5 or select Debug: Start Debugging from the Command Palette to start your debugging session. Using the Debugger in Jetbrains WebStorm Click the drop down menu listing the runtime configuration, and click Edit Configurations.... Create a JavaScript Debug debug configuration with http://localhost:3000 as the URL. Customize to your liking (e.g. Browser for debugging, store as project file), and click OK. Run this debug configuration, and the selected browser should automatically open. At this point, you should have 2 applications in debug mode: the NextJS node application, and the client/browser application. Debugging with Browser DevTools Client-side code Start your development server as usual by running next dev, npm run dev, or yarn dev. Once the server starts, open http://localhost:3000 (or your alternate URL) in your preferred browser. For Chrome: - Open Chrome's Developer Tools (Ctrl+Shift+J on Windows/Linux, ⌥+⌘+I on macOS) - Go to the Sources tab For Firefox: - Open Firefox's Developer Tools (Ctrl+Shift+I on Windows/Linux, ⌥+⌘+I on macOS) - Go to the Debugger tab In either browser, any time your client-side code reaches a debugger statement, code execution will pause and that file will appear in the debug area. You can also search for files to set breakpoints manually: - In Chrome: Press Ctrl+P on Windows/Linux or ⌘+P on macOS - In Firefox: Press Ctrl+P on Windows/Linux or ⌘+P on macOS, or use the file tree in the left panel Note that when searching, your source files will have paths starting with webpack://NE/./. React Developer Tools For React-specific debugging, install the React Developer Tools browser extension. This essential tool helps you: - Inspect React components - Edit props and state - Identify performance problems Server-side code To debug server-side Next.js code with browser DevTools, you need to pass the --inspect flag: The value of --inspect is passed to the underlying Node.js process. Check out the --inspect docs for advanced use cases. > Good to know: Use --inspect=0.0.0.0 to allow remote debugging access outside localhost, such as when running the app in a Docker container. Launching the Next.js dev server with the --inspect flag will look something like this: For Chrome: 1. Open a new tab and visit chrome://inspect 1. Look for your Next.js application in the Remote Target section 1. Click inspect to open a separate DevTools window 1. Go to the Sources tab For Firefox: 1. Open a new tab and visit about:debugging 1. Click This Firefox in the left sidebar 1. Under Remote Targets, find your Next.js application 1. Click Inspect to open the debugger 1. Go to the Debugger tab Debugging server-side code works similarly to client-side debugging. When searching for files (Ctrl+P/⌘+P), your source files will have paths starting with webpack://{application-name}/./ (where {application-name} will be replaced with the name of your application according to your package.json file). To use --inspect-brk or --inspect-wait, you have to specify NODEOPTIONS instead. e.g. NODEOPTIONS=--inspect-brk next dev. Inspect Server Errors with Browser DevTools When you encounter an error, inspecting the source code can help trace the root cause of errors. Next.js will display a Node.js icon underneath the Next.js version indicator on the error overlay. By clicking that icon, the DevTools URL is copied to your clipboard. You can open a new browser tab with that URL to inspect the Next.js server process. Debugging on Windows Ensure Windows Defender is disabled on your machine. This external service will check every file read, which has been reported to greatly increase Fast Refresh time with next dev. This is a known issue, not related to Next.js, but it does affect Next.js development. More information To learn more about how to use a JavaScript debugger, take a look at the following documentation: - Node.js debugging in VS Code: Breakpoints - Chrome DevTools: Debug JavaScript - Firefox DevTools: Debugger",
    "excerpt": "This documentation explains how you can debug your Next.js frontend and backend code with full source maps support using the VS Code debugger, Chrome DevTools, or Firefox DevTools. Any debugger that c...",
    "url": "https://nextjs.org/docs/01-app/02-guides/debugging"
  },
  {
    "id": "01-app-02-guides-draft-mode",
    "path": "01-app\\02-guides\\draft-mode.mdx",
    "title": "How to preview content with Draft Mode in Next.js",
    "description": "Next.js has draft mode to toggle between static and dynamic pages. You can learn how it works with App Router here.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Step 1: Create a Route Handler",
        "slug": "step-1-create-a-route-handler"
      },
      {
        "level": 2,
        "text": "Step 2: Access the Route Handler from your Headless CMS",
        "slug": "step-2-access-the-route-handler-from-your-headless-cms"
      },
      {
        "level": 2,
        "text": "Step 3: Preview the Draft Content",
        "slug": "step-3-preview-the-draft-content"
      }
    ],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "export async function GET(request: Request) {\r\n  return new Response('')\r\n}",
        "context": "filename=\"app/api/draft/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export async function GET() {\r\n  return new Response('')\r\n}",
        "context": "filename=\"app/api/draft/route.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { draftMode } from 'next/headers'\r\n\r\nexport async function GET(request: Request) {\r\n  const draft = await draftMode()\r\n  draft.enable()\r\n  return new Response('Draft mode is enabled')\r\n}",
        "context": "filename=\"app/api/draft/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { draftMode } from 'next/headers'\r\n\r\nexport async function GET(request) {\r\n  const draft = await draftMode()\r\n  draft.enable()\r\n  return new Response('Draft mode is enabled')\r\n}",
        "context": "filename=\"app/api/draft/route.js\" switcher"
      },
      {
        "language": "bash",
        "code": "https://<your-site>/api/draft?secret=<token>&slug=<path>",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "ts",
        "code": "import { draftMode } from 'next/headers'\r\nimport { redirect } from 'next/navigation'\r\n\r\nexport async function GET(request: Request) {\r\n  // Parse query string parameters\r\n  const { searchParams } = new URL(request.url)\r\n  const secret = searchParams.get('secret')\r\n  const slug = searchParams.get('slug')\r\n\r\n  // Check the secret and next parameters\r\n  // This secret should only be known to this Route Handler and the CMS\r\n  if (secret !== 'MY_SECRET_TOKEN' || !slug) {\r\n    return new Response('Invalid token', { status: 401 })\r\n  }\r\n\r\n  // Fetch the headless CMS to check if the provided `slug` exists\r\n  // getPostBySlug would implement the required fetching logic to the headless CMS\r\n  const post = await getPostBySlug(slug)\r\n\r\n  // If the slug doesn't exist prevent draft mode from being enabled\r\n  if (!post) {\r\n    return new Response('Invalid slug', { status: 401 })\r\n  }\r\n\r\n  // Enable Draft Mode by setting the cookie\r\n  const draft = await draftMode()\r\n  draft.enable()\r\n\r\n  // Redirect to the path from the fetched post\r\n  // We don't redirect to searchParams.slug as that might lead to open redirect vulnerabilities\r\n  redirect(post.slug)\r\n}",
        "context": "filename=\"app/api/draft/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { draftMode } from 'next/headers'\r\nimport { redirect } from 'next/navigation'\r\n\r\nexport async function GET(request) {\r\n  // Parse query string parameters\r\n  const { searchParams } = new URL(request.url)\r\n  const secret = searchParams.get('secret')\r\n  const slug = searchParams.get('slug')\r\n\r\n  // Check the secret and next parameters\r\n  // This secret should only be known to this Route Handler and the CMS\r\n  if (secret !== 'MY_SECRET_TOKEN' || !slug) {\r\n    return new Response('Invalid token', { status: 401 })\r\n  }\r\n\r\n  // Fetch the headless CMS to check if the provided `slug` exists\r\n  // getPostBySlug would implement the required fetching logic to the headless CMS\r\n  const post = await getPostBySlug(slug)\r\n\r\n  // If the slug doesn't exist prevent draft mode from being enabled\r\n  if (!post) {\r\n    return new Response('Invalid slug', { status: 401 })\r\n  }\r\n\r\n  // Enable Draft Mode by setting the cookie\r\n  const draft = await draftMode()\r\n  draft.enable()\r\n\r\n  // Redirect to the path from the fetched post\r\n  // We don't redirect to searchParams.slug as that might lead to open redirect vulnerabilities\r\n  redirect(post.slug)\r\n}",
        "context": "filename=\"app/api/draft/route.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "// page that fetches data\r\nimport { draftMode } from 'next/headers'\r\n\r\nasync function getData() {\r\n  const { isEnabled } = await draftMode()\r\n\r\n  const url = isEnabled\r\n    ? 'https://draft.example.com'\r\n    : 'https://production.example.com'\r\n\r\n  const res = await fetch(url)\r\n\r\n  return res.json()\r\n}\r\n\r\nexport default async function Page() {\r\n  const { title, desc } = await getData()\r\n\r\n  return (\r\n    <main>\r\n      <h1>{title}</h1>\r\n      <p>{desc}</p>\r\n    </main>\r\n  )\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "// page that fetches data\r\nimport { draftMode } from 'next/headers'\r\n\r\nasync function getData() {\r\n  const { isEnabled } = await draftMode()\r\n\r\n  const url = isEnabled\r\n    ? 'https://draft.example.com'\r\n    : 'https://production.example.com'\r\n\r\n  const res = await fetch(url)\r\n\r\n  return res.json()\r\n}\r\n\r\nexport default async function Page() {\r\n  const { title, desc } = await getData()\r\n\r\n  return (\r\n    <main>\r\n      <h1>{title}</h1>\r\n      <p>{desc}</p>\r\n    </main>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      }
    ],
    "content": "Draft Mode allows you to preview draft content from your headless CMS in your Next.js application. This is useful for static pages that are generated at build time as it allows you to switch to dynamic rendering and see the draft changes without having to rebuild your entire site. This page walks through how to enable and use Draft Mode. Step 1: Create a Route Handler Create a Route Handler. It can have any name, for example, app/api/draft/route.ts. Then, import the draftMode function and call the enable() method. This will set a cookie to enable draft mode. Subsequent requests containing this cookie will trigger draft mode and change the behavior of statically generated pages. You can test this manually by visiting /api/draft and looking at your browser’s developer tools. Notice the Set-Cookie response header with a cookie named prerenderbypass. Step 2: Access the Route Handler from your Headless CMS > These steps assume that the headless CMS you’re using supports setting custom draft URLs. If it doesn’t, you can still use this method to secure your draft URLs, but you’ll need to construct and access the draft URL manually. The specific steps will vary depending on which headless CMS you’re using. To securely access the Route Handler from your headless CMS: 1. Create a secret token string using a token generator of your choice. This secret will only be known by your Next.js app and your headless CMS. 2. If your headless CMS supports setting custom draft URLs, specify a draft URL (this assumes that your Route Handler is located at app/api/draft/route.ts). For example: > - should be your deployment domain. > - should be replaced with the secret token you generated. > - should be the path for the page that you want to view. If you want to view /posts/one, then you should use &slug=/posts/one. > > Your headless CMS might allow you to include a variable in the draft URL so that can be set dynamically based on the CMS’s data like so: &slug=/posts/{entry.fields.slug} 3. In your Route Handler, check that the secret matches and that the slug parameter exists (if not, the request should fail), call draftMode.enable() to set the cookie. Then, redirect the browser to the path specified by slug: If it succeeds, then the browser will be redirected to the path you want to view with the draft mode cookie. Step 3: Preview the Draft Content The next step is to update your page to check the value of draftMode().isEnabled. If you request a page which has the cookie set, then data will be fetched at request time (instead of at build time). Furthermore, the value of isEnabled will be true. If you access the draft Route Handler (with secret and slug) from your headless CMS or manually using the URL, you should now be able to see the draft content. And, if you update your draft without publishing, you should be able to view the draft.",
    "excerpt": "Draft Mode allows you to preview draft content from your headless CMS in your Next.js application. This is useful for static pages that are generated at build time as it allows you to switch to dynami...",
    "url": "https://nextjs.org/docs/01-app/02-guides/draft-mode"
  },
  {
    "id": "01-app-02-guides-environment-variables",
    "path": "01-app\\02-guides\\environment-variables.mdx",
    "title": "How to use environment variables in Next.js",
    "description": "Learn to add and access environment variables in your Next.js application.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Loading Environment Variables",
        "slug": "loading-environment-variables"
      },
      {
        "level": 3,
        "text": "Loading Environment Variables with ",
        "slug": "loading-environment-variables-with-"
      },
      {
        "level": 3,
        "text": "Referencing Other Variables",
        "slug": "referencing-other-variables"
      },
      {
        "level": 2,
        "text": "Bundling Environment Variables for the Browser",
        "slug": "bundling-environment-variables-for-the-browser"
      },
      {
        "level": 3,
        "text": "Runtime Environment Variables",
        "slug": "runtime-environment-variables"
      },
      {
        "level": 2,
        "text": "Test Environment Variables",
        "slug": "test-environment-variables"
      },
      {
        "level": 2,
        "text": "Environment Variable Load Order",
        "slug": "environment-variable-load-order"
      },
      {
        "level": 2,
        "text": "Good to know",
        "slug": "good-to-know"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "txt",
        "code": "DB_HOST=localhost\r\nDB_USER=myuser\r\nDB_PASS=mypassword",
        "context": "filename=\".env\""
      },
      {
        "language": "js",
        "code": "export async function getStaticProps() {\r\n  const db = await myDB.connect({\r\n    host: process.env.DB_HOST,\r\n    username: process.env.DB_USER,\r\n    password: process.env.DB_PASS,\r\n  })\r\n  // ...\r\n}",
        "context": "filename=\"pages/index.js\""
      },
      {
        "language": "bash",
        "code": "# .env\r\n\r\n# you can write with line breaks\r\nPRIVATE_KEY=\"-----BEGIN RSA PRIVATE KEY-----\r\n...\r\nKh9NV...\r\n...\r\n-----END DSA PRIVATE KEY-----\"\r\n\r\n# or with `\\n` inside double quotes\r\nPRIVATE_KEY=\"-----BEGIN RSA PRIVATE KEY-----\\nKh9NV...\\n-----END DSA PRIVATE KEY-----\\n\"",
        "context": ""
      },
      {
        "language": "js",
        "code": "export async function GET() {\r\n  const db = await myDB.connect({\r\n    host: process.env.DB_HOST,\r\n    username: process.env.DB_USER,\r\n    password: process.env.DB_PASS,\r\n  })\r\n  // ...\r\n}",
        "context": "filename=\"app/api/route.js\""
      },
      {
        "language": "bash",
        "code": "npm install @next/env",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "import { loadEnvConfig } from '@next/env'\r\n\r\nconst projectDir = process.cwd()\r\nloadEnvConfig(projectDir)",
        "context": "filename=\"envConfig.ts\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { loadEnvConfig } from '@next/env'\r\n\r\nconst projectDir = process.cwd()\r\nloadEnvConfig(projectDir)",
        "context": "filename=\"envConfig.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import './envConfig.ts'\r\n\r\nexport default defineConfig({\r\n  dbCredentials: {\r\n    connectionString: process.env.DATABASE_URL!,\r\n  },\r\n})",
        "context": "filename=\"orm.config.ts\" switcher"
      },
      {
        "language": "jsx",
        "code": "import './envConfig.js'\r\n\r\nexport default defineConfig({\r\n  dbCredentials: {\r\n    connectionString: process.env.DATABASE_URL,\r\n  },\r\n})",
        "context": "filename=\"orm.config.js\" switcher"
      },
      {
        "language": "txt",
        "code": "TWITTER_USER=nextjs\r\nTWITTER_URL=https://x.com/$TWITTER_USER",
        "context": "filename=\".env\""
      },
      {
        "language": "txt",
        "code": "NEXT_PUBLIC_ANALYTICS_ID=abcdefghijk",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "js",
        "code": "import setupAnalyticsService from '../lib/my-analytics-service'\r\n\r\n// 'NEXT_PUBLIC_ANALYTICS_ID' can be used here as it's prefixed by 'NEXT_PUBLIC_'.\r\n// It will be transformed at build time to `setupAnalyticsService('abcdefghijk')`.\r\nsetupAnalyticsService(process.env.NEXT_PUBLIC_ANALYTICS_ID)\r\n\r\nfunction HomePage() {\r\n  return <h1>Hello World</h1>\r\n}\r\n\r\nexport default HomePage",
        "context": "filename=\"pages/index.js\""
      },
      {
        "language": "js",
        "code": "// This will NOT be inlined, because it uses a variable\r\nconst varName = 'NEXT_PUBLIC_ANALYTICS_ID'\r\nsetupAnalyticsService(process.env[varName])\r\n\r\n// This will NOT be inlined, because it uses a variable\r\nconst env = process.env\r\nsetupAnalyticsService(env.NEXT_PUBLIC_ANALYTICS_ID)",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "import { connection } from 'next/server'\r\n\r\nexport default async function Component() {\r\n  await connection()\r\n  // cookies, headers, and other Dynamic APIs\r\n  // will also opt into dynamic rendering, meaning\r\n  // this env variable is evaluated at runtime\r\n  const value = process.env.MY_VALUE\r\n  // ...\r\n}",
        "context": "filename=\"app/page.ts\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { connection } from 'next/server'\r\n\r\nexport default async function Component() {\r\n  await connection()\r\n  // cookies, headers, and other Dynamic APIs\r\n  // will also opt into dynamic rendering, meaning\r\n  // this env variable is evaluated at runtime\r\n  const value = process.env.MY_VALUE\r\n  // ...\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "js",
        "code": "// The below can be used in a Jest global setup file or similar for your testing set-up\r\nimport { loadEnvConfig } from '@next/env'\r\n\r\nexport default async () => {\r\n  const projectDir = process.cwd()\r\n  loadEnvConfig(projectDir)\r\n}",
        "context": ""
      }
    ],
    "content": "Next.js comes with built-in support for environment variables, which allows you to do the following: - Use .env to load environment variables - Bundle environment variables for the browser by prefixing with NEXTPUBLIC > Warning: The default create-next-app template ensures all .env files are added to your .gitignore. You almost never want to commit these files to your repository. Loading Environment Variables Next.js has built-in support for loading environment variables from .env files into process.env. This loads process.env.DBHOST, process.env.DBUSER, and process.env.DBPASS into the Node.js environment automatically allowing you to use them in Next.js data fetching methods and API routes. For example, using getStaticProps: > Note: Next.js also supports multiline variables inside of your .env files: > > > Note: If you are using a /src folder, please note that Next.js will load the .env files only from the parent folder and not from the /src folder. > This loads process.env.DBHOST, process.env.DBUSER, and process.env.DBPASS into the Node.js environment automatically allowing you to use them in Route Handlers. For example: Loading Environment Variables with @next/env If you need to load environment variables outside of the Next.js runtime, such as in a root config file for an ORM or test runner, you can use the @next/env package. This package is used internally by Next.js to load environment variables from .env files. To use it, install the package and use the loadEnvConfig function to load the environment variables: Then, you can import the configuration where needed. For example: Referencing Other Variables Next.js will automatically expand variables that use $ to reference other variables e.g. $VARIABLE inside of your .env files. This allows you to reference other secrets. For example: In the above example, process.env.TWITTERURL would be set to https://x.com/nextjs. > Good to know: If you need to use variable with a $ in the actual value, it needs to be escaped e.g. \\$. Bundling Environment Variables for the Browser Non-NEXTPUBLIC environment variables are only available in the Node.js environment, meaning they aren't accessible to the browser (the client runs in a different environment). In order to make the value of an environment variable accessible in the browser, Next.js can \"inline\" a value, at build time, into the js bundle that is delivered to the client, replacing all references to process.env.[variable] with a hard-coded value. To tell it to do this, you just have to prefix the variable with NEXTPUBLIC. For example: This will tell Next.js to replace all references to process.env.NEXTPUBLICANALYTICSID in the Node.js environment with the value from the environment in which you run next build, allowing you to use it anywhere in your code. It will be inlined into any JavaScript sent to the browser. > Note: After being built, your app will no longer respond to changes to these environment variables. For instance, if you use a Heroku pipeline to promote slugs built in one environment to another environment, or if you build and deploy a single Docker image to multiple environments, all NEXTPUBLIC variables will be frozen with the value evaluated at build time, so these values need to be set appropriately when the project is built. If you need access to runtime environment values, you'll have to setup your own API to provide them to the client (either on demand or during initialization). Note that dynamic lookups will not be inlined, such as: Runtime Environment Variables Next.js can support both build time and runtime environment variables. By default, environment variables are only available on the server. To expose an environment variable to the browser, it must be prefixed with NEXTPUBLIC. However, these public environment variables will be inlined into the JavaScript bundle during next build. To read runtime environment variables, we recommend using getServerSideProps or incrementally adopting the App Router. You can safely read environment variables on the server during dynamic rendering: This allows you to use a singular Docker image that can be promoted through multiple environments with different values. Good to know: - You can run code on server startup using the register function. Test Environment Variables Apart from development and production environments, there is a 3rd option available: test. In the same way you can set defaults for development or production environments, you can do the same with a .env.test file for the testing environment (though this one is not as common as the previous two). Next.js will not load environment variables from .env.development or .env.production in the testing environment. This one is useful when running tests with tools like jest or cypress where you need to set specific environment vars only for testing purposes. Test default values will be loaded if NODEENV is set to test, though you usually don't need to do this manually as testing tools will address it for you. There is a small difference between test environment, and both development and production that you need to bear in mind: .env.local won't be loaded, as you expect tests to produce the same results for everyone. This way every test execution will use the same env defaults across different executions by ignoring your .env.local (which is intended to override the default set). > Good to know: similar to Default Environment Variables, .env.test file should be included in your repository, but .env.test.local shouldn't, as .env.local are intended to be ignored through .gitignore. While running unit tests you can make sure to load your environment variables the same way Next.js does by leveraging the loadEnvConfig function from the @next/env package. Environment Variable Load Order Environment variables are looked up in the following places, in order, stopping once the variable is found. 1. process.env 1. .env.$(NODEENV).local 1. .env.local (Not checked when NODEENV is test.) 1. .env.$(NODEENV) 1. .env For example, if NODEENV is development and you define a variable in both .env.development.local and .env, the value in .env.development.local will be used. > Good to know: The allowed values for NODEENV are production, development and test. Good to know - If you are using a /src directory, .env. files should remain in the root of your project. - If the environment variable NODEENV is unassigned, Next.js automatically assigns development when running the next dev command, or production for all other commands. Version History | Version | Changes | | -------- | --------------------------------------------- | | v9.4.0 | Support .env and NEXTPUBLIC introduced. |",
    "excerpt": "Next.js comes with built-in support for environment variables, which allows you to do the following: - Use .env to load environment variables - Bundle environment variables for the browser by prefixin...",
    "url": "https://nextjs.org/docs/01-app/02-guides/environment-variables"
  },
  {
    "id": "01-app-02-guides-forms",
    "path": "01-app\\02-guides\\forms.mdx",
    "title": "How to create forms with Server Actions",
    "description": "Learn how to create forms in Next.js with React Server Actions.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "How it works",
        "slug": "how-it-works"
      },
      {
        "level": 2,
        "text": "Passing additional arguments",
        "slug": "passing-additional-arguments"
      },
      {
        "level": 2,
        "text": "Form validation",
        "slug": "form-validation"
      },
      {
        "level": 2,
        "text": "Validation errors",
        "slug": "validation-errors"
      },
      {
        "level": 2,
        "text": "Pending states",
        "slug": "pending-states"
      },
      {
        "level": 2,
        "text": "Optimistic updates",
        "slug": "optimistic-updates"
      },
      {
        "level": 2,
        "text": "Nested form elements",
        "slug": "nested-form-elements"
      },
      {
        "level": 2,
        "text": "Programmatic form submission",
        "slug": "programmatic-form-submission"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "export default function Page() {\r\n  async function createInvoice(formData: FormData) {\r\n    'use server'\r\n\r\n    const rawFormData = {\r\n      customerId: formData.get('customerId'),\r\n      amount: formData.get('amount'),\r\n      status: formData.get('status'),\r\n    }\r\n\r\n    // mutate data\r\n    // revalidate the cache\r\n  }\r\n\r\n  return <form action={createInvoice}>...</form>\r\n}",
        "context": "filename=\"app/invoices/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function Page() {\r\n  async function createInvoice(formData) {\r\n    'use server'\r\n\r\n    const rawFormData = {\r\n      customerId: formData.get('customerId'),\r\n      amount: formData.get('amount'),\r\n      status: formData.get('status'),\r\n    }\r\n\r\n    // mutate data\r\n    // revalidate the cache\r\n  }\r\n\r\n  return <form action={createInvoice}>...</form>\r\n}",
        "context": "filename=\"app/invoices/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { updateUser } from './actions'\r\n\r\nexport function UserProfile({ userId }: { userId: string }) {\r\n  const updateUserWithId = updateUser.bind(null, userId)\r\n\r\n  return (\r\n    <form action={updateUserWithId}>\r\n      <input type=\"text\" name=\"name\" />\r\n      <button type=\"submit\">Update User Name</button>\r\n    </form>\r\n  )\r\n}",
        "context": "filename=\"app/client-component.tsx\" highlight={6} switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { updateUser } from './actions'\r\n\r\nexport function UserProfile({ userId }) {\r\n  const updateUserWithId = updateUser.bind(null, userId)\r\n\r\n  return (\r\n    <form action={updateUserWithId}>\r\n      <input type=\"text\" name=\"name\" />\r\n      <button type=\"submit\">Update User Name</button>\r\n    </form>\r\n  )\r\n}",
        "context": "filename=\"app/client-component.js\" highlight={6} switcher"
      },
      {
        "language": "ts",
        "code": "'use server'\r\n\r\nexport async function updateUser(userId: string, formData: FormData) {}",
        "context": "filename=\"app/actions.ts\" switcher"
      },
      {
        "language": "js",
        "code": "'use server'\r\n\r\nexport async function updateUser(userId, formData) {}",
        "context": "filename=\"app/actions.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use server'\r\n\r\nimport { z } from 'zod'\r\n\r\nconst schema = z.object({\r\n  email: z.string({\r\n    invalid_type_error: 'Invalid Email',\r\n  }),\r\n})\r\n\r\nexport default async function createUser(formData: FormData) {\r\n  const validatedFields = schema.safeParse({\r\n    email: formData.get('email'),\r\n  })\r\n\r\n  // Return early if the form data is invalid\r\n  if (!validatedFields.success) {\r\n    return {\r\n      errors: validatedFields.error.flatten().fieldErrors,\r\n    }\r\n  }\r\n\r\n  // Mutate data\r\n}",
        "context": "filename=\"app/actions.ts\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use server'\r\n\r\nimport { z } from 'zod'\r\n\r\nconst schema = z.object({\r\n  email: z.string({\r\n    invalid_type_error: 'Invalid Email',\r\n  }),\r\n})\r\n\r\nexport default async function createsUser(formData) {\r\n  const validatedFields = schema.safeParse({\r\n    email: formData.get('email'),\r\n  })\r\n\r\n  // Return early if the form data is invalid\r\n  if (!validatedFields.success) {\r\n    return {\r\n      errors: validatedFields.error.flatten().fieldErrors,\r\n    }\r\n  }\r\n\r\n  // Mutate data\r\n}",
        "context": "filename=\"app/actions.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use server'\r\n\r\nimport { z } from 'zod'\r\n\r\nexport async function createUser(initialState: any, formData: FormData) {\r\n  const validatedFields = schema.safeParse({\r\n    email: formData.get('email'),\r\n  })\r\n  // ...\r\n}",
        "context": "filename=\"app/actions.ts\" highlight={4} switcher"
      },
      {
        "language": "jsx",
        "code": "'use server'\r\n\r\nimport { z } from 'zod'\r\n\r\n// ...\r\n\r\nexport async function createUser(initialState, formData) {\r\n  const validatedFields = schema.safeParse({\r\n    email: formData.get('email'),\r\n  })\r\n  // ...\r\n}",
        "context": "filename=\"app/actions.ts\" highlight={4} switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { useActionState } from 'react'\r\nimport { createUser } from '@/app/actions'\r\n\r\nconst initialState = {\r\n  message: '',\r\n}\r\n\r\nexport function Signup() {\r\n  const [state, formAction, pending] = useActionState(createUser, initialState)\r\n\r\n  return (\r\n    <form action={formAction}>\r\n      <label htmlFor=\"email\">Email</label>\r\n      <input type=\"text\" id=\"email\" name=\"email\" required />\r\n      {/* ... */}\r\n      <p aria-live=\"polite\">{state?.message}</p>\r\n      <button disabled={pending}>Sign up</button>\r\n    </form>\r\n  )\r\n}",
        "context": "filename=\"app/ui/signup.tsx\" highlight={11,18-20} switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { useActionState } from 'react'\r\nimport { createUser } from '@/app/actions'\r\n\r\nconst initialState = {\r\n  message: '',\r\n}\r\n\r\nexport function Signup() {\r\n  const [state, formAction, pending] = useActionState(createUser, initialState)\r\n\r\n  return (\r\n    <form action={formAction}>\r\n      <label htmlFor=\"email\">Email</label>\r\n      <input type=\"text\" id=\"email\" name=\"email\" required />\r\n      {/* ... */}\r\n      <p aria-live=\"polite\">{state?.message}</p>\r\n      <button disabled={pending}>Sign up</button>\r\n    </form>\r\n  )\r\n}",
        "context": "filename=\"app/ui/signup.js\" highlight={11,18-20} switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { useActionState } from 'react'\r\nimport { createUser } from '@/app/actions'\r\n\r\nexport function Signup() {\r\n  const [state, formAction, pending] = useActionState(createUser, initialState)\r\n\r\n  return (\r\n    <form action={formAction}>\r\n      {/* Other form elements */}\r\n      <button disabled={pending}>Sign up</button>\r\n    </form>\r\n  )\r\n}",
        "context": "filename=\"app/ui/signup.tsx\" highlight={7,12} switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { useActionState } from 'react'\r\nimport { createUser } from '@/app/actions'\r\n\r\nexport function Signup() {\r\n  const [state, formAction, pending] = useActionState(createUser, initialState)\r\n\r\n  return (\r\n    <form action={formAction}>\r\n      {/* Other form elements */}\r\n      <button disabled={pending}>Sign up</button>\r\n    </form>\r\n  )\r\n}",
        "context": "filename=\"app/ui/signup.js\" highlight={7,12} switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { useFormStatus } from 'react-dom'\r\n\r\nexport function SubmitButton() {\r\n  const { pending } = useFormStatus()\r\n\r\n  return (\r\n    <button disabled={pending} type=\"submit\">\r\n      Sign Up\r\n    </button>\r\n  )\r\n}",
        "context": "filename=\"app/ui/button.tsx\" highlight={6} switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { useFormStatus } from 'react-dom'\r\n\r\nexport function SubmitButton() {\r\n  const { pending } = useFormStatus()\r\n\r\n  return (\r\n    <button disabled={pending} type=\"submit\">\r\n      Sign Up\r\n    </button>\r\n  )\r\n}",
        "context": "filename=\"app/ui/button.js\" highlight={6} switcher"
      },
      {
        "language": "tsx",
        "code": "import { SubmitButton } from './button'\r\nimport { createUser } from '@/app/actions'\r\n\r\nexport function Signup() {\r\n  return (\r\n    <form action={createUser}>\r\n      {/* Other form elements */}\r\n      <SubmitButton />\r\n    </form>\r\n  )\r\n}",
        "context": "filename=\"app/ui/signup.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { SubmitButton } from './button'\r\nimport { createUser } from '@/app/actions'\r\n\r\nexport function Signup() {\r\n  return (\r\n    <form action={createUser}>\r\n      {/* Other form elements */}\r\n      <SubmitButton />\r\n    </form>\r\n  )\r\n}",
        "context": "filename=\"app/ui/signup.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { useOptimistic } from 'react'\r\nimport { send } from './actions'\r\n\r\ntype Message = {\r\n  message: string\r\n}\r\n\r\nexport function Thread({ messages }: { messages: Message[] }) {\r\n  const [optimisticMessages, addOptimisticMessage] = useOptimistic<\r\n    Message[],\r\n    string\r\n  >(messages, (state, newMessage) => [...state, { message: newMessage }])\r\n\r\n  const formAction = async (formData: FormData) => {\r\n    const message = formData.get('message') as string\r\n    addOptimisticMessage(message)\r\n    await send(message)\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      {optimisticMessages.map((m, i) => (\r\n        <div key={i}>{m.message}</div>\r\n      ))}\r\n      <form action={formAction}>\r\n        <input type=\"text\" name=\"message\" />\r\n        <button type=\"submit\">Send</button>\r\n      </form>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { useOptimistic } from 'react'\r\nimport { send } from './actions'\r\n\r\nexport function Thread({ messages }) {\r\n  const [optimisticMessages, addOptimisticMessage] = useOptimistic(\r\n    messages,\r\n    (state, newMessage) => [...state, { message: newMessage }]\r\n  )\r\n\r\n  const formAction = async (formData) => {\r\n    const message = formData.get('message')\r\n    addOptimisticMessage(message)\r\n    await send(message)\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      {optimisticMessages.map((m) => (\r\n        <div>{m.message}</div>\r\n      ))}\r\n      <form action={formAction}>\r\n        <input type=\"text\" name=\"message\" />\r\n        <button type=\"submit\">Send</button>\r\n      </form>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nexport function Entry() {\r\n  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {\r\n    if (\r\n      (e.ctrlKey || e.metaKey) &&\r\n      (e.key === 'Enter' || e.key === 'NumpadEnter')\r\n    ) {\r\n      e.preventDefault()\r\n      e.currentTarget.form?.requestSubmit()\r\n    }\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      <textarea name=\"entry\" rows={20} required onKeyDown={handleKeyDown} />\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/entry.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nexport function Entry() {\r\n  const handleKeyDown = (e) => {\r\n    if (\r\n      (e.ctrlKey || e.metaKey) &&\r\n      (e.key === 'Enter' || e.key === 'NumpadEnter')\r\n    ) {\r\n      e.preventDefault()\r\n      e.currentTarget.form?.requestSubmit()\r\n    }\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      <textarea name=\"entry\" rows={20} required onKeyDown={handleKeyDown} />\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/entry.js\" switcher"
      }
    ],
    "content": "React Server Actions are Server Functions that execute on the server. They can be called in Server and Client Components to handle form submissions. This guide will walk you through how to create forms in Next.js with Server Actions. How it works React extends the HTML element to allow Server Actions to be invoked with the action attribute. When used in a form, the function automatically receives the FormData object. You can then extract the data using the native FormData methods: > Good to know: When working with forms that have multiple fields, use JavaScript's Object.fromEntries(). For example: const rawFormData = Object.fromEntries(formData). Note that this object will contain extra properties prefixed with $ACTION. Passing additional arguments Outside of form fields, you can pass additional arguments to a Server Function using the JavaScript bind method. For example, to pass the userId argument to the updateUser Server Function: The Server Function will receive the userId as an additional argument: > Good to know: > > - An alternative is to pass arguments as hidden input fields in the form (e.g. ). However, the value will be part of the rendered HTML and will not be encoded. > - bind works in both Server and Client Components and supports progressive enhancement. Form validation Forms can be validated on the client or server. - For client-side validation, you can use the HTML attributes like required and type=\"email\" for basic validation. - For server-side validation, you can use a library like zod to validate the form fields. For example: Validation errors To display validation errors or messages, turn the component that defines the into a Client Component and use React useActionState. When using useActionState, the Server function signature will change to receive a new prevState or initialState parameter as its first argument. You can then conditionally render the error message based on the state object. Pending states The useActionState hook exposes a pending boolean that can be used to show a loading indicator or disable the submit button while the action is being executed. Alternatively, you can use the useFormStatus hook to show a loading indicator while the action is being executed. When using this hook, you'll need to create a separate component to render the loading indicator. For example, to disable the button when the action is pending: You can then nest the SubmitButton component inside the form: > Good to know: In React 19, useFormStatus includes additional keys on the returned object, like data, method, and action. If you are not using React 19, only the pending key is available. Optimistic updates You can use the React useOptimistic hook to optimistically update the UI before the Server Function finishes executing, rather than waiting for the response: Nested form elements You can call Server Actions in elements nested inside such as , , and . These elements accept the formAction prop or event handlers. This is useful in cases where you want to call multiple Server Actions within a form. For example, you can create a specific element for saving a post draft in addition to publishing it. See the React docs for more information. Programmatic form submission You can trigger a form submission programmatically using the requestSubmit() method. For example, when the user submits a form using the ⌘ + Enter keyboard shortcut, you can listen for the onKeyDown event: This will trigger the submission of the nearest ancestor, which will invoke the Server Function.",
    "excerpt": "React Server Actions are Server Functions that execute on the server. They can be called in Server and Client Components to handle form submissions. This guide will walk you through how to create form...",
    "url": "https://nextjs.org/docs/01-app/02-guides/forms"
  },
  {
    "id": "01-app-02-guides-incremental-static-regeneration",
    "path": "01-app\\02-guides\\incremental-static-regeneration.mdx",
    "title": "How to implement Incremental Static Regeneration (ISR)",
    "description": "Learn how to create or update static pages at runtime with Incremental Static Regeneration.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Reference",
        "slug": "reference"
      },
      {
        "level": 3,
        "text": "Route segment config",
        "slug": "route-segment-config"
      },
      {
        "level": 3,
        "text": "Functions",
        "slug": "functions"
      },
      {
        "level": 3,
        "text": "Functions",
        "slug": "functions"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Time-based revalidation",
        "slug": "time-based-revalidation"
      },
      {
        "level": 3,
        "text": "On-demand revalidation with ",
        "slug": "on-demand-revalidation-with-"
      },
      {
        "level": 3,
        "text": "On-demand revalidation with ",
        "slug": "on-demand-revalidation-with-"
      },
      {
        "level": 3,
        "text": "On-demand validation with ",
        "slug": "on-demand-validation-with-"
      },
      {
        "level": 3,
        "text": "Handling uncaught exceptions",
        "slug": "handling-uncaught-exceptions"
      },
      {
        "level": 3,
        "text": "Customizing the cache location",
        "slug": "customizing-the-cache-location"
      },
      {
        "level": 2,
        "text": "Troubleshooting",
        "slug": "troubleshooting"
      },
      {
        "level": 3,
        "text": "Debugging cached data in local development",
        "slug": "debugging-cached-data-in-local-development"
      },
      {
        "level": 3,
        "text": "Verifying correct production behavior",
        "slug": "verifying-correct-production-behavior"
      },
      {
        "level": 2,
        "text": "Caveats",
        "slug": "caveats"
      },
      {
        "level": 2,
        "text": "Platform Support",
        "slug": "platform-support"
      },
      {
        "level": 2,
        "text": "Version history",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "interface Post {\r\n  id: string\r\n  title: string\r\n  content: string\r\n}\r\n\r\n// Next.js will invalidate the cache when a\r\n// request comes in, at most once every 60 seconds.\r\nexport const revalidate = 60\r\n\r\nexport async function generateStaticParams() {\r\n  const posts: Post[] = await fetch('https://api.vercel.app/blog').then((res) =>\r\n    res.json()\r\n  )\r\n  return posts.map((post) => ({\r\n    id: String(post.id),\r\n  }))\r\n}\r\n\r\nexport default async function Page({\r\n  params,\r\n}: {\r\n  params: Promise<{ id: string }>\r\n}) {\r\n  const { id } = await params\r\n  const post: Post = await fetch(`https://api.vercel.app/blog/${id}`).then(\r\n    (res) => res.json()\r\n  )\r\n  return (\r\n    <main>\r\n      <h1>{post.title}</h1>\r\n      <p>{post.content}</p>\r\n    </main>\r\n  )\r\n}",
        "context": "filename=\"app/blog/[id]/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "// Next.js will invalidate the cache when a\r\n// request comes in, at most once every 60 seconds.\r\nexport const revalidate = 60\r\n\r\nexport async function generateStaticParams() {\r\n  const posts = await fetch('https://api.vercel.app/blog').then((res) =>\r\n    res.json()\r\n  )\r\n  return posts.map((post) => ({\r\n    id: String(post.id),\r\n  }))\r\n}\r\n\r\nexport default async function Page({ params }) {\r\n  const { id } = await params\r\n  const post = await fetch(`https://api.vercel.app/blog/${id}`).then((res) =>\r\n    res.json()\r\n  )\r\n  return (\r\n    <main>\r\n      <h1>{post.title}</h1>\r\n      <p>{post.content}</p>\r\n    </main>\r\n  )\r\n}",
        "context": "filename=\"app/blog/[id]/page.jsx\" switcher"
      },
      {
        "language": "tsx",
        "code": "import type { GetStaticPaths, GetStaticProps } from 'next'\r\n\r\ninterface Post {\r\n  id: string\r\n  title: string\r\n  content: string\r\n}\r\n\r\ninterface Props {\r\n  post: Post\r\n}\r\n\r\nexport const getStaticPaths: GetStaticPaths = async () => {\r\n  const posts = await fetch('https://api.vercel.app/blog').then((res) =>\r\n    res.json()\r\n  )\r\n  const paths = posts.map((post: Post) => ({\r\n    params: { id: String(post.id) },\r\n  }))\r\n\r\n  return { paths, fallback: 'blocking' }\r\n}\r\n\r\nexport const getStaticProps: GetStaticProps<Props> = async ({\r\n  params,\r\n}: {\r\n  params: { id: string }\r\n}) => {\r\n  const post = await fetch(`https://api.vercel.app/blog/${params.id}`).then(\r\n    (res) => res.json()\r\n  )\r\n\r\n  return {\r\n    props: { post },\r\n    // Next.js will invalidate the cache when a\r\n    // request comes in, at most once every 60 seconds.\r\n    revalidate: 60,\r\n  }\r\n}\r\n\r\nexport default function Page({ post }: Props) {\r\n  return (\r\n    <main>\r\n      <h1>{post.title}</h1>\r\n      <p>{post.content}</p>\r\n    </main>\r\n  )\r\n}",
        "context": "filename=\"pages/blog/[id].tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export async function getStaticPaths() {\r\n  const posts = await fetch('https://api.vercel.app/blog').then((res) =>\r\n    res.json()\r\n  )\r\n  const paths = posts.map((post) => ({\r\n    params: { id: post.id },\r\n  }))\r\n\r\n  return { paths, fallback: 'blocking' }\r\n}\r\n\r\nexport async function getStaticProps({ params }) {\r\n  const post = await fetch(`https://api.vercel.app/blog/${params.id}`).then(\r\n    (res) => res.json()\r\n  )\r\n\r\n  return {\r\n    props: { post },\r\n    // Next.js will invalidate the cache when a\r\n    // request comes in, at most once every 60 seconds.\r\n    revalidate: 60,\r\n  }\r\n}\r\n\r\nexport default function Page({ post }) {\r\n  return (\r\n    <main>\r\n      <h1>{post.title}</h1>\r\n      <p>{post.content}</p>\r\n    </main>\r\n  )\r\n}",
        "context": "filename=\"pages/blog/[id].jsx\" switcher"
      },
      {
        "language": "tsx",
        "code": "interface Post {\r\n  id: string\r\n  title: string\r\n  content: string\r\n}\r\n\r\nexport const revalidate = 3600 // invalidate every hour\r\n\r\nexport default async function Page() {\r\n  const data = await fetch('https://api.vercel.app/blog')\r\n  const posts: Post[] = await data.json()\r\n  return (\r\n    <main>\r\n      <h1>Blog Posts</h1>\r\n      <ul>\r\n        {posts.map((post) => (\r\n          <li key={post.id}>{post.title}</li>\r\n        ))}\r\n      </ul>\r\n    </main>\r\n  )\r\n}",
        "context": "filename=\"app/blog/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export const revalidate = 3600 // invalidate every hour\r\n\r\nexport default async function Page() {\r\n  const data = await fetch('https://api.vercel.app/blog')\r\n  const posts = await data.json()\r\n  return (\r\n    <main>\r\n      <h1>Blog Posts</h1>\r\n      <ul>\r\n        {posts.map((post) => (\r\n          <li key={post.id}>{post.title}</li>\r\n        ))}\r\n      </ul>\r\n    </main>\r\n  )\r\n}",
        "context": "filename=\"app/blog/page.js\" switcher"
      },
      {
        "language": "ts",
        "code": "'use server'\r\n\r\nimport { revalidatePath } from 'next/cache'\r\n\r\nexport async function createPost() {\r\n  // Invalidate the cache for the /posts route\r\n  revalidatePath('/posts')\r\n}",
        "context": "filename=\"app/actions.ts\" switcher"
      },
      {
        "language": "js",
        "code": "'use server'\r\n\r\nimport { revalidatePath } from 'next/cache'\r\n\r\nexport async function createPost() {\r\n  // Invalidate the cache for the /posts route\r\n  revalidatePath('/posts')\r\n}",
        "context": "filename=\"app/actions.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default async function Page() {\r\n  const data = await fetch('https://api.vercel.app/blog', {\r\n    next: { tags: ['posts'] },\r\n  })\r\n  const posts = await data.json()\r\n  // ...\r\n}",
        "context": "filename=\"app/blog/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default async function Page() {\r\n  const data = await fetch('https://api.vercel.app/blog', {\r\n    next: { tags: ['posts'] },\r\n  })\r\n  const posts = await data.json()\r\n  // ...\r\n}",
        "context": "filename=\"app/blog/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { unstable_cache } from 'next/cache'\r\nimport { db, posts } from '@/lib/db'\r\n\r\nconst getCachedPosts = unstable_cache(\r\n  async () => {\r\n    return await db.select().from(posts)\r\n  },\r\n  ['posts'],\r\n  { revalidate: 3600, tags: ['posts'] }\r\n)\r\n\r\nexport default async function Page() {\r\n  const posts = getCachedPosts()\r\n  // ...\r\n}",
        "context": "filename=\"app/blog/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { unstable_cache } from 'next/cache'\r\nimport { db, posts } from '@/lib/db'\r\n\r\nconst getCachedPosts = unstable_cache(\r\n  async () => {\r\n    return await db.select().from(posts)\r\n  },\r\n  ['posts'],\r\n  { revalidate: 3600, tags: ['posts'] }\r\n)\r\n\r\nexport default async function Page() {\r\n  const posts = getCachedPosts()\r\n  // ...\r\n}",
        "context": "filename=\"app/blog/page.js\" switcher"
      },
      {
        "language": "ts",
        "code": "'use server'\r\n\r\nimport { revalidateTag } from 'next/cache'\r\n\r\nexport async function createPost() {\r\n  // Invalidate all data tagged with 'posts'\r\n  revalidateTag('posts')\r\n}",
        "context": "filename=\"app/actions.ts\" switcher"
      },
      {
        "language": "js",
        "code": "'use server'\r\n\r\nimport { revalidateTag } from 'next/cache'\r\n\r\nexport async function createPost() {\r\n  // Invalidate all data tagged with 'posts'\r\n  revalidateTag('posts')\r\n}",
        "context": "filename=\"app/actions.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import type { NextApiRequest, NextApiResponse } from 'next'\r\n\r\nexport default async function handler(\r\n  req: NextApiRequest,\r\n  res: NextApiResponse\r\n) {\r\n  // Check for secret to confirm this is a valid request\r\n  if (req.query.secret !== process.env.MY_SECRET_TOKEN) {\r\n    return res.status(401).json({ message: 'Invalid token' })\r\n  }\r\n\r\n  try {\r\n    // This should be the actual path not a rewritten path\r\n    // e.g. for \"/posts/[id]\" this should be \"/posts/1\"\r\n    await res.revalidate('/posts/1')\r\n    return res.json({ revalidated: true })\r\n  } catch (err) {\r\n    // If there was an error, Next.js will continue\r\n    // to show the last successfully generated page\r\n    return res.status(500).send('Error revalidating')\r\n  }\r\n}",
        "context": "filename=\"pages/api/revalidate.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export default async function handler(req, res) {\r\n  // Check for secret to confirm this is a valid request\r\n  if (req.query.secret !== process.env.MY_SECRET_TOKEN) {\r\n    return res.status(401).json({ message: 'Invalid token' })\r\n  }\r\n\r\n  try {\r\n    // This should be the actual path not a rewritten path\r\n    // e.g. for \"/posts/[id]\" this should be \"/posts/1\"\r\n    await res.revalidate('/posts/1')\r\n    return res.json({ revalidated: true })\r\n  } catch (err) {\r\n    // If there was an error, Next.js will continue\r\n    // to show the last successfully generated page\r\n    return res.status(500).send('Error revalidating')\r\n  }\r\n}",
        "context": "filename=\"pages/api/revalidate.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import type { GetStaticProps } from 'next'\r\n\r\ninterface Post {\r\n  id: string\r\n  title: string\r\n  content: string\r\n}\r\n\r\ninterface Props {\r\n  post: Post\r\n}\r\n\r\nexport const getStaticProps: GetStaticProps<Props> = async ({\r\n  params,\r\n}: {\r\n  params: { id: string }\r\n}) => {\r\n  // If this request throws an uncaught error, Next.js will\r\n  // not invalidate the currently shown page and\r\n  // retry getStaticProps on the next request.\r\n  const res = await fetch(`https://api.vercel.app/blog/${params.id}`)\r\n  const post: Post = await res.json()\r\n\r\n  if (!res.ok) {\r\n    // If there is a server error, you might want to\r\n    // throw an error instead of returning so that the cache is not updated\r\n    // until the next successful request.\r\n    throw new Error(`Failed to fetch posts, received status ${res.status}`)\r\n  }\r\n\r\n  return {\r\n    props: { post },\r\n    // Next.js will invalidate the cache when a\r\n    // request comes in, at most once every 60 seconds.\r\n    revalidate: 60,\r\n  }\r\n}",
        "context": "filename=\"pages/blog/[id].tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export async function getStaticProps({ params }) {\r\n  // If this request throws an uncaught error, Next.js will\r\n  // not invalidate the currently shown page and\r\n  // retry getStaticProps on the next request.\r\n  const res = await fetch(`https://api.vercel.app/blog/${params.id}`)\r\n  const post = await res.json()\r\n\r\n  if (!res.ok) {\r\n    // If there is a server error, you might want to\r\n    // throw an error instead of returning so that the cache is not updated\r\n    // until the next successful request.\r\n    throw new Error(`Failed to fetch posts, received status ${res.status}`)\r\n  }\r\n\r\n  return {\r\n    props: { post },\r\n    // Next.js will invalidate the cache when a\r\n    // request comes in, at most once every 60 seconds.\r\n    revalidate: 60,\r\n  }\r\n}",
        "context": "filename=\"pages/blog/[id].jsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "module.exports = {\r\n  logging: {\r\n    fetches: {\r\n      fullUrl: true,\r\n    },\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "bash",
        "code": "NEXT_PRIVATE_DEBUG_CACHE=1",
        "context": "filename=\".env\""
      }
    ],
    "content": "Examples - Next.js Commerce - On-Demand ISR - Next.js Forms Incremental Static Regeneration (ISR) enables you to: - Update static content without rebuilding the entire site - Reduce server load by serving prerendered, static pages for most requests - Ensure proper cache-control headers are automatically added to pages - Handle large amounts of content pages without long next build times Here's a minimal example: Here's how this example works: 1. During next build, all known blog posts are generated 2. All requests made to these pages (e.g. /blog/1) are cached and instantaneous 3. After 60 seconds has passed, the next request will still return the cached (now stale) page 4. The cache is invalidated and a new version of the page begins generating in the background 5. Once generated successfully, the next request will return the updated page and cache it for subsequent requests 6. If /blog/26 is requested, and it exists, the page will be generated on-demand. This behavior can be changed by using a different dynamicParams value. However, if the post does not exist, then 404 is returned. Here's how this example works: 1. During next build, all known blog posts are generated 2. All requests made to these pages (e.g. /blog/1) are cached and instantaneous 3. After 60 seconds has passed, the next request will still return the cached (now stale) page 4. The cache is invalidated and a new version of the page begins generating in the background 5. Once generated successfully, the next request will return the updated page and cache it for subsequent requests 6. If /blog/26 is requested, and it exists, the page will be generated on-demand. This behavior can be changed by using a different fallback value. However, if the post does not exist, then 404 is returned. Reference Route segment config - revalidate - dynamicParams Functions - revalidatePath - revalidateTag Functions - getStaticProps - res.revalidate Examples Time-based revalidation This fetches and displays a list of blog posts on /blog. After an hour has passed, the next visitor will still receive the cached (stale) version of the page immediately for a fast response. Simultaneously, Next.js triggers regeneration of a fresh version in the background. Once the new version is successfully generated, it replaces the cached version, and subsequent visitors will receive the updated content. We recommend setting a high revalidation time. For instance, 1 hour instead of 1 second. If you need more precision, consider using on-demand revalidation. If you need real-time data, consider switching to dynamic rendering. On-demand revalidation with revalidatePath For a more precise method of revalidation, invalidate cached pages on-demand with the revalidatePath function. For example, this Server Action would get called after adding a new post. Regardless of how you retrieve your data in your Server Component, either using fetch or connecting to a database, this will invalidate the cache for the entire route. The next request to that route will trigger regeneration and serve fresh data, which will then be cached for subsequent requests. > Note: revalidatePath invalidates the cache entries but regeneration happens on the next request. If you want to eagerly regenerate the cache entry immediately instead of waiting for the next request, you can use the Pages router res.revalidate method. We're working on adding new methods to provide eager regeneration capabilities for the App Router. View a demo and explore the source code. On-demand revalidation with revalidateTag For most use cases, prefer revalidating entire paths. If you need more granular control, you can use the revalidateTag function. For example, you can tag individual fetch calls: If you are using an ORM or connecting to a database, you can use unstablecache: You can then use revalidateTag in a Server Actions or Route Handler: On-demand validation with res.revalidate() For a more precise method of revalidation, use res.revalidate to generate a new page on-demand from an API Router. For example, this API Route can be called at /api/revalidate?secret= to revalidate a given blog post. Create a secret token only known by your Next.js app. This secret will be used to prevent unauthorized access to the revalidation API Route. If you are using on-demand revalidation, you do not need to specify a revalidate time inside of getStaticProps. Next.js will use the default value of false (no revalidation) and only revalidate the page on-demand when res.revalidate() is called. Handling uncaught exceptions If an error is thrown while attempting to revalidate data, the last successfully generated data will continue to be served from the cache. On the next subsequent request, Next.js will retry revalidating the data. Learn more about error handling. If there is an error inside getStaticProps when handling background regeneration, or you manually throw an error, the last successfully generated page will continue to show. On the next subsequent request, Next.js will retry calling getStaticProps. Customizing the cache location You can configure the Next.js cache location if you want to persist cached pages and data to durable storage, or share the cache across multiple containers or instances of your Next.js application. Learn more. Troubleshooting Debugging cached data in local development If you are using the fetch API, you can add additional logging to understand which requests are cached or uncached. Learn more about the logging option. Verifying correct production behavior To verify your pages are cached and revalidated correctly in production, you can test locally by running next build and then next start to run the production Next.js server. This will allow you to test ISR behavior as it would work in a production environment. For further debugging, add the following environment variable to your .env file: This will make the Next.js server console log ISR cache hits and misses. You can inspect the output to see which pages are generated during next build, as well as how pages are updated as paths are accessed on-demand. Caveats - ISR is only supported when using the Node.js runtime (default). - ISR is not supported when creating a Static Export. - If you have multiple fetch requests in a statically rendered route, and each has a different revalidate frequency, the lowest time will be used for ISR. However, those revalidate frequencies will still be respected by the Data Cache. - If any of the fetch requests used on a route have a revalidate time of 0, or an explicit no-store, the route will be dynamically rendered. - Proxy won't be executed for on-demand ISR requests, meaning any path rewrites or logic in Proxy will not be applied. Ensure you are revalidating the exact path. For example, /post/1 instead of a rewritten /post-1. - ISR is only supported when using the Node.js runtime (default). - ISR is not supported when creating a Static Export. - Proxy won't be executed for on-demand ISR requests, meaning any path rewrites or logic in Proxy will not be applied. Ensure you are revalidating the exact path. For example, /post/1 instead of a rewritten /post-1. Platform Support | Deployment Option | Supported | | ------------------------------------------------------------------- | ----------------- | | Node.js server | Yes | | Docker container | Yes | | Static export | No | | Adapters | Platform-specific | Learn how to configure ISR when self-hosting Next.js. Version history | Version | Changes | | --------- | ----------------------------------------------------------------------------------- | | v14.1.0 | Custom cacheHandler is stable. | | v13.0.0 | App Router is introduced. | | v12.2.0 | Pages Router: On-Demand ISR is stable | | v12.0.0 | Pages Router: Bot-aware ISR fallback added. | | v9.5.0 | Pages Router: Stable ISR introduced. |",
    "excerpt": "Examples - Next.js Commerce - On-Demand ISR - Next.js Forms Incremental Static Regeneration (ISR) enables you to: - Update static content without rebuilding the entire site - Reduce server load by ser...",
    "url": "https://nextjs.org/docs/01-app/02-guides/incremental-static-regeneration"
  },
  {
    "id": "01-app-02-guides-index",
    "path": "01-app\\02-guides\\index.mdx",
    "title": "Guides",
    "description": "Learn how to implement common patterns and real-world use cases using Next.js",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/01-app/02-guides"
  },
  {
    "id": "01-app-02-guides-instrumentation",
    "path": "01-app\\02-guides\\instrumentation.mdx",
    "title": "How to set up instrumentation",
    "description": "Learn how to use instrumentation to run code at server startup in your Next.js app",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Convention",
        "slug": "convention"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Importing files with side effects",
        "slug": "importing-files-with-side-effects"
      },
      {
        "level": 3,
        "text": "Importing runtime-specific code",
        "slug": "importing-runtime-specific-code"
      }
    ],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "import { registerOTel } from '@vercel/otel'\r\n\r\nexport function register() {\r\n  registerOTel('next-app')\r\n}",
        "context": "filename=\"instrumentation.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { registerOTel } from '@vercel/otel'\r\n\r\nexport function register() {\r\n  registerOTel('next-app')\r\n}",
        "context": "filename=\"instrumentation.js\" switcher"
      },
      {
        "language": "ts",
        "code": "export async function register() {\r\n  await import('package-with-side-effect')\r\n}",
        "context": "filename=\"instrumentation.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export async function register() {\r\n  await import('package-with-side-effect')\r\n}",
        "context": "filename=\"instrumentation.js\" switcher"
      },
      {
        "language": "ts",
        "code": "export async function register() {\r\n  if (process.env.NEXT_RUNTIME === 'nodejs') {\r\n    await import('./instrumentation-node')\r\n  }\r\n\r\n  if (process.env.NEXT_RUNTIME === 'edge') {\r\n    await import('./instrumentation-edge')\r\n  }\r\n}",
        "context": "filename=\"instrumentation.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export async function register() {\r\n  if (process.env.NEXT_RUNTIME === 'nodejs') {\r\n    await import('./instrumentation-node')\r\n  }\r\n\r\n  if (process.env.NEXT_RUNTIME === 'edge') {\r\n    await import('./instrumentation-edge')\r\n  }\r\n}",
        "context": "filename=\"instrumentation.js\" switcher"
      }
    ],
    "content": "Instrumentation is the process of using code to integrate monitoring and logging tools into your application. This allows you to track the performance and behavior of your application, and to debug issues in production. Convention To set up instrumentation, create instrumentation.ts|js file in the root directory of your project (or inside the src folder if using one). Then, export a register function in the file. This function will be called once when a new Next.js server instance is initiated. For example, to use Next.js with OpenTelemetry and @vercel/otel: See the Next.js with OpenTelemetry example for a complete implementation. > Good to know: > > - The instrumentation file should be in the root of your project and not inside the app or pages directory. If you're using the src folder, then place the file inside src alongside pages and app. > - If you use the pageExtensions config option to add a suffix, you will also need to update the instrumentation filename to match. Examples Importing files with side effects Sometimes, it may be useful to import a file in your code because of the side effects it will cause. For example, you might import a file that defines a set of global variables, but never explicitly use the imported file in your code. You would still have access to the global variables the package has declared. We recommend importing files using JavaScript import syntax within your register function. The following example demonstrates a basic usage of import in a register function: > Good to know: > > We recommend importing the file from within the register function, rather than at the top of the file. By doing this, you can colocate all of your side effects in one place in your code, and avoid any unintended consequences from importing globally at the top of the file. Importing runtime-specific code Next.js calls register in all environments, so it's important to conditionally import any code that doesn't support specific runtimes (e.g. Edge or Node.js). You can use the NEXTRUNTIME environment variable to get the current environment:",
    "excerpt": "Instrumentation is the process of using code to integrate monitoring and logging tools into your application. This allows you to track the performance and behavior of your application, and to debug is...",
    "url": "https://nextjs.org/docs/01-app/02-guides/instrumentation"
  },
  {
    "id": "01-app-02-guides-internationalization",
    "path": "01-app\\02-guides\\internationalization.mdx",
    "title": "Internationalization",
    "description": "Add support for multiple languages with internationalized routing and localized content.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Terminology",
        "slug": "terminology"
      },
      {
        "level": 2,
        "text": "Routing Overview",
        "slug": "routing-overview"
      },
      {
        "level": 2,
        "text": "Localization",
        "slug": "localization"
      },
      {
        "level": 2,
        "text": "Static Rendering",
        "slug": "static-rendering"
      },
      {
        "level": 2,
        "text": "Resources",
        "slug": "resources"
      }
    ],
    "codeBlocks": [
      {
        "language": "js",
        "code": "import { match } from '@formatjs/intl-localematcher'\r\nimport Negotiator from 'negotiator'\r\n\r\nlet headers = { 'accept-language': 'en-US,en;q=0.5' }\r\nlet languages = new Negotiator({ headers }).languages()\r\nlet locales = ['en-US', 'nl-NL', 'nl']\r\nlet defaultLocale = 'en-US'\r\n\r\nmatch(languages, locales, defaultLocale) // -> 'en-US'",
        "context": "filename=\"proxy.js\""
      },
      {
        "language": "js",
        "code": "import { NextResponse } from \"next/server\";\r\n\r\nlet locales = ['en-US', 'nl-NL', 'nl']\r\n\r\n// Get the preferred locale, similar to the above or using a library\r\nfunction getLocale(request) { ... }\r\n\r\nexport function proxy(request) {\r\n  // Check if there is any supported locale in the pathname\r\n  const { pathname } = request.nextUrl\r\n  const pathnameHasLocale = locales.some(\r\n    (locale) => pathname.startsWith(`/${locale}/`) || pathname === `/${locale}`\r\n  )\r\n\r\n  if (pathnameHasLocale) return\r\n\r\n  // Redirect if there is no locale\r\n  const locale = getLocale(request)\r\n  request.nextUrl.pathname = `/${locale}${pathname}`\r\n  // e.g. incoming request is /products\r\n  // The new URL is now /en-US/products\r\n  return NextResponse.redirect(request.nextUrl)\r\n}\r\n\r\nexport const config = {\r\n  matcher: [\r\n    // Skip all internal paths (_next)\r\n    '/((?!_next).*)',\r\n    // Optional: only run on root (/) URL\r\n    // '/'\r\n  ],\r\n}",
        "context": "filename=\"proxy.js\""
      },
      {
        "language": "tsx",
        "code": "// You now have access to the current locale\r\n// e.g. /en-US/products -> `lang` is \"en-US\"\r\nexport default async function Page({\r\n  params,\r\n}: {\r\n  params: Promise<{ lang: string }>\r\n}) {\r\n  const { lang } = await params\r\n  return ...\r\n}",
        "context": "filename=\"app/[lang]/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "// You now have access to the current locale\r\n// e.g. /en-US/products -> `lang` is \"en-US\"\r\nexport default async function Page({ params }) {\r\n  const { lang } = await params\r\n  return ...\r\n}",
        "context": "filename=\"app/[lang]/page.js\" switcher"
      },
      {
        "language": "json",
        "code": "{\r\n  \"products\": {\r\n    \"cart\": \"Add to Cart\"\r\n  }\r\n}",
        "context": "filename=\"dictionaries/en.json\""
      },
      {
        "language": "json",
        "code": "{\r\n  \"products\": {\r\n    \"cart\": \"Toevoegen aan Winkelwagen\"\r\n  }\r\n}",
        "context": "filename=\"dictionaries/nl.json\""
      },
      {
        "language": "ts",
        "code": "import 'server-only'\r\n\r\nconst dictionaries = {\r\n  en: () => import('./dictionaries/en.json').then((module) => module.default),\r\n  nl: () => import('./dictionaries/nl.json').then((module) => module.default),\r\n}\r\n\r\nexport const getDictionary = async (locale: 'en' | 'nl') =>\r\n  dictionaries[locale]()",
        "context": "filename=\"app/[lang]/dictionaries.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import 'server-only'\r\n\r\nconst dictionaries = {\r\n  en: () => import('./dictionaries/en.json').then((module) => module.default),\r\n  nl: () => import('./dictionaries/nl.json').then((module) => module.default),\r\n}\r\n\r\nexport const getDictionary = async (locale) => dictionaries[locale]()",
        "context": "filename=\"app/[lang]/dictionaries.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { getDictionary } from './dictionaries'\r\n\r\nexport default async function Page({\r\n  params,\r\n}: {\r\n  params: Promise<{ lang: 'en' | 'nl' }>\r\n}) {\r\n  const { lang } = await params\r\n  const dict = await getDictionary(lang) // en\r\n  return <button>{dict.products.cart}</button> // Add to Cart\r\n}",
        "context": "filename=\"app/[lang]/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { getDictionary } from './dictionaries'\r\n\r\nexport default async function Page({ params }) {\r\n  const { lang } = await params\r\n  const dict = await getDictionary(lang) // en\r\n  return <button>{dict.products.cart}</button> // Add to Cart\r\n}",
        "context": "filename=\"app/[lang]/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export async function generateStaticParams() {\r\n  return [{ lang: 'en-US' }, { lang: 'de' }]\r\n}\r\n\r\nexport default async function RootLayout({\r\n  children,\r\n  params,\r\n}: Readonly<{\r\n  children: React.ReactNode\r\n  params: Promise<{ lang: 'en-US' | 'de' }>\r\n}>) {\r\n  return (\r\n    <html lang={(await params).lang}>\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/[lang]/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export async function generateStaticParams() {\r\n  return [{ lang: 'en-US' }, { lang: 'de' }]\r\n}\r\n\r\nexport default async function RootLayout({ children, params }) {\r\n  return (\r\n    <html lang={(await params).lang}>\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/[lang]/layout.js\" switcher"
      }
    ],
    "content": "Next.js enables you to configure the routing and rendering of content to support multiple languages. Making your site adaptive to different locales includes translated content (localization) and internationalized routes. Terminology - Locale: An identifier for a set of language and formatting preferences. This usually includes the preferred language of the user and possibly their geographic region. - en-US: English as spoken in the United States - nl-NL: Dutch as spoken in the Netherlands - nl: Dutch, no specific region Routing Overview It’s recommended to use the user’s language preferences in the browser to select which locale to use. Changing your preferred language will modify the incoming Accept-Language header to your application. For example, using the following libraries, you can look at an incoming Request to determine which locale to select, based on the Headers, locales you plan to support, and the default locale. Routing can be internationalized by either the sub-path (/fr/products) or domain (my-site.fr/products). With this information, you can now redirect the user based on the locale inside Proxy. Finally, ensure all special files inside app/ are nested under app/[lang]. This enables the Next.js router to dynamically handle different locales in the route, and forward the lang parameter to every layout and page. For example: The root layout can also be nested in the new folder (e.g. app/[lang]/layout.js). Localization Changing displayed content based on the user’s preferred locale, or localization, is not something specific to Next.js. The patterns described below would work the same with any web application. Let’s assume we want to support both English and Dutch content inside our application. We might maintain two different “dictionaries”, which are objects that give us a mapping from some key to a localized string. For example: We can then create a getDictionary function to load the translations for the requested locale: Given the currently selected language, we can fetch the dictionary inside of a layout or page. Because all layouts and pages in the app/ directory default to Server Components, we do not need to worry about the size of the translation files affecting our client-side JavaScript bundle size. This code will only run on the server, and only the resulting HTML will be sent to the browser. Static Rendering To generate static routes for a given set of locales, we can use generateStaticParams with any page or layout. This can be global, for example, in the root layout: Resources - Minimal i18n routing and translations - next-intl - next-international - next-i18n-router - paraglide-next - lingui - tolgee - next-intlayer - gt-next",
    "excerpt": "Next.js enables you to configure the routing and rendering of content to support multiple languages. Making your site adaptive to different locales includes translated content (localization) and inter...",
    "url": "https://nextjs.org/docs/01-app/02-guides/internationalization"
  },
  {
    "id": "01-app-02-guides-json-ld",
    "path": "01-app\\02-guides\\json-ld.mdx",
    "title": "How to implement JSON-LD in your Next.js application",
    "description": "Learn how to add JSON-LD to your Next.js application to describe your content to search engines and AI.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "export default async function Page({ params }) {\r\n  const { id } = await params\r\n  const product = await getProduct(id)\r\n\r\n  const jsonLd = {\r\n    '@context': 'https://schema.org',\r\n    '@type': 'Product',\r\n    name: product.name,\r\n    image: product.image,\r\n    description: product.description,\r\n  }\r\n\r\n  return (\r\n    <section>\r\n      {/* Add JSON-LD to your page */}\r\n      <script\r\n        type=\"application/ld+json\"\r\n        dangerouslySetInnerHTML={{\r\n          __html: JSON.stringify(jsonLd).replace(/</g, '\\\\u003c'),\r\n        }}\r\n      />\r\n      {/* ... */}\r\n    </section>\r\n  )\r\n}",
        "context": "filename=\"app/products/[id]/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default async function Page({ params }) {\r\n  const { id } = await params\r\n  const product = await getProduct(id)\r\n\r\n  const jsonLd = {\r\n    '@context': 'https://schema.org',\r\n    '@type': 'Product',\r\n    name: product.name,\r\n    image: product.image,\r\n    description: product.description,\r\n  }\r\n\r\n  return (\r\n    <section>\r\n      {/* Add JSON-LD to your page */}\r\n      <script\r\n        type=\"application/ld+json\"\r\n        dangerouslySetInnerHTML={{\r\n          __html: JSON.stringify(jsonLd).replace(/</g, '\\\\u003c'),\r\n        }}\r\n      />\r\n      {/* ... */}\r\n    </section>\r\n  )\r\n}",
        "context": "filename=\"app/products/[id]/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { Product, WithContext } from 'schema-dts'\r\n\r\nconst jsonLd: WithContext<Product> = {\r\n  '@context': 'https://schema.org',\r\n  '@type': 'Product',\r\n  name: 'Next.js Sticker',\r\n  image: 'https://nextjs.org/imgs/sticker.png',\r\n  description: 'Dynamic at the speed of static.',\r\n}",
        "context": ""
      }
    ],
    "content": "JSON-LD is a format for structured data that can be used by search engines and AI to help them understand the structure of the page beyond pure content. For example, you can use it to describe a person, an event, an organization, a movie, a book, a recipe, and many other types of entities. Our current recommendation for JSON-LD is to render structured data as a tag in your layout.js or page.js components. The following snippet uses JSON.stringify, which does not sanitize malicious strings used in XSS injection. To prevent this type of vulnerability, you can scrub HTML tags from the JSON-LD payload, for example, by replacing the character, <, with its unicode equivalent, \\u003c. Review your organization's recommended approach to sanitize potentially dangerous strings, or use community maintained alternatives for JSON.stringify such as, serialize-javascript. You can validate and test your structured data with the Rich Results Test for Google or the generic Schema Markup Validator. You can type your JSON-LD with TypeScript using community packages like schema-dts:",
    "excerpt": "JSON-LD is a format for structured data that can be used by search engines and AI to help them understand the structure of the page beyond pure content. For example, you can use it to describe a perso...",
    "url": "https://nextjs.org/docs/01-app/02-guides/json-ld"
  },
  {
    "id": "01-app-02-guides-lazy-loading",
    "path": "01-app\\02-guides\\lazy-loading.mdx",
    "title": "How to lazy load Client Components and libraries",
    "description": "Lazy load imported libraries and React Components to improve your application's loading performance.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Importing Client Components",
        "slug": "importing-client-components"
      },
      {
        "level": 3,
        "text": "Skipping SSR",
        "slug": "skipping-ssr"
      },
      {
        "level": 3,
        "text": "Importing Server Components",
        "slug": "importing-server-components"
      },
      {
        "level": 3,
        "text": "Loading External Libraries",
        "slug": "loading-external-libraries"
      },
      {
        "level": 3,
        "text": "Adding a custom loading component",
        "slug": "adding-a-custom-loading-component"
      },
      {
        "level": 3,
        "text": "Importing Named Exports",
        "slug": "importing-named-exports"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "With named exports",
        "slug": "with-named-exports"
      },
      {
        "level": 3,
        "text": "With no SSR",
        "slug": "with-no-ssr"
      },
      {
        "level": 3,
        "text": "With external libraries",
        "slug": "with-external-libraries"
      }
    ],
    "codeBlocks": [
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { useState } from 'react'\r\nimport dynamic from 'next/dynamic'\r\n\r\n// Client Components:\r\nconst ComponentA = dynamic(() => import('../components/A'))\r\nconst ComponentB = dynamic(() => import('../components/B'))\r\nconst ComponentC = dynamic(() => import('../components/C'), { ssr: false })\r\n\r\nexport default function ClientComponentExample() {\r\n  const [showMore, setShowMore] = useState(false)\r\n\r\n  return (\r\n    <div>\r\n      {/* Load immediately, but in a separate client bundle */}\r\n      <ComponentA />\r\n\r\n      {/* Load on demand, only when/if the condition is met */}\r\n      {showMore && <ComponentB />}\r\n      <button onClick={() => setShowMore(!showMore)}>Toggle</button>\r\n\r\n      {/* Load only on the client side */}\r\n      <ComponentC />\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\""
      },
      {
        "language": "jsx",
        "code": "const ComponentC = dynamic(() => import('../components/C'), { ssr: false })",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import dynamic from 'next/dynamic'\r\n\r\n// Server Component:\r\nconst ServerComponent = dynamic(() => import('../components/ServerComponent'))\r\n\r\nexport default function ServerComponentExample() {\r\n  return (\r\n    <div>\r\n      <ServerComponent />\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\""
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { useState } from 'react'\r\n\r\nconst names = ['Tim', 'Joe', 'Bel', 'Lee']\r\n\r\nexport default function Page() {\r\n  const [results, setResults] = useState()\r\n\r\n  return (\r\n    <div>\r\n      <input\r\n        type=\"text\"\r\n        placeholder=\"Search\"\r\n        onChange={async (e) => {\r\n          const { value } = e.currentTarget\r\n          // Dynamically load fuse.js\r\n          const Fuse = (await import('fuse.js')).default\r\n          const fuse = new Fuse(names)\r\n\r\n          setResults(fuse.search(value))\r\n        }}\r\n      />\r\n      <pre>Results: {JSON.stringify(results, null, 2)}</pre>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\""
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport dynamic from 'next/dynamic'\r\n\r\nconst WithCustomLoading = dynamic(\r\n  () => import('../components/WithCustomLoading'),\r\n  {\r\n    loading: () => <p>Loading...</p>,\r\n  }\r\n)\r\n\r\nexport default function Page() {\r\n  return (\r\n    <div>\r\n      {/* The loading component will be rendered while  <WithCustomLoading/> is loading */}\r\n      <WithCustomLoading />\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\""
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nexport function Hello() {\r\n  return <p>Hello!</p>\r\n}",
        "context": "filename=\"components/hello.js\""
      },
      {
        "language": "jsx",
        "code": "import dynamic from 'next/dynamic'\r\n\r\nconst ClientComponent = dynamic(() =>\r\n  import('../components/hello').then((mod) => mod.Hello)\r\n)",
        "context": "filename=\"app/page.js\""
      },
      {
        "language": "jsx",
        "code": "import dynamic from 'next/dynamic'\r\n\r\nconst DynamicHeader = dynamic(() => import('../components/header'), {\r\n  loading: () => <p>Loading...</p>,\r\n})\r\n\r\nexport default function Home() {\r\n  return <DynamicHeader />\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "export function Hello() {\r\n  return <p>Hello!</p>\r\n}\r\n\r\n// pages/index.js\r\nimport dynamic from 'next/dynamic'\r\n\r\nconst DynamicComponent = dynamic(() =>\r\n  import('../components/hello').then((mod) => mod.Hello)\r\n)",
        "context": "filename=\"components/hello.js\""
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport dynamic from 'next/dynamic'\r\n\r\nconst DynamicHeader = dynamic(() => import('../components/header'), {\r\n  ssr: false,\r\n})",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import { useState } from 'react'\r\n\r\nconst names = ['Tim', 'Joe', 'Bel', 'Lee']\r\n\r\nexport default function Page() {\r\n  const [results, setResults] = useState()\r\n\r\n  return (\r\n    <div>\r\n      <input\r\n        type=\"text\"\r\n        placeholder=\"Search\"\r\n        onChange={async (e) => {\r\n          const { value } = e.currentTarget\r\n          // Dynamically load fuse.js\r\n          const Fuse = (await import('fuse.js')).default\r\n          const fuse = new Fuse(names)\r\n\r\n          setResults(fuse.search(value))\r\n        }}\r\n      />\r\n      <pre>Results: {JSON.stringify(results, null, 2)}</pre>\r\n    </div>\r\n  )\r\n}",
        "context": ""
      }
    ],
    "content": "Lazy loading in Next.js helps improve the initial loading performance of an application by decreasing the amount of JavaScript needed to render a route. It allows you to defer loading of Client Components and imported libraries, and only include them in the client bundle when they're needed. For example, you might want to defer loading a modal until a user clicks to open it. There are two ways you can implement lazy loading in Next.js: 1. Using Dynamic Imports with next/dynamic 2. Using React.lazy() with Suspense By default, Server Components are automatically code split, and you can use streaming to progressively send pieces of UI from the server to the client. Lazy loading applies to Client Components. next/dynamic next/dynamic is a composite of React.lazy() and Suspense. It behaves the same way in the app and pages directories to allow for incremental migration. Examples Importing Client Components > Note: When a Server Component dynamically imports a Client Component, automatic code splitting is currently not supported. Skipping SSR When using React.lazy() and Suspense, Client Components will be prerendered (SSR) by default. > Note: ssr: false option will only work for Client Components, move it into Client Components ensure the client code-splitting working properly. If you want to disable pre-rendering for a Client Component, you can use the ssr option set to false: Importing Server Components If you dynamically import a Server Component, only the Client Components that are children of the Server Component will be lazy-loaded - not the Server Component itself. It will also help preload the static assets such as CSS when you're using it in Server Components. > Note: ssr: false option is not supported in Server Components. You will see an error if you try to use it in Server Components. > ssr: false is not allowed with next/dynamic in Server Components. Please move it into a Client Component. Loading External Libraries External libraries can be loaded on demand using the import() function. This example uses the external library fuse.js for fuzzy search. The module is only loaded on the client after the user types in the search input. Adding a custom loading component Importing Named Exports To dynamically import a named export, you can return it from the Promise returned by import() function: next/dynamic next/dynamic is a composite of React.lazy() and Suspense. It behaves the same way in the app and pages directories to allow for incremental migration. In the example below, by using next/dynamic, the header component will not be included in the page's initial JavaScript bundle. The page will render the Suspense fallback first, followed by the Header component when the Suspense boundary is resolved. > Good to know: In import('path/to/component'), the path must be explicitly written. It can't be a template string nor a variable. Furthermore the import() has to be inside the dynamic() call for Next.js to be able to match webpack bundles / module ids to the specific dynamic() call and preload them before rendering. dynamic() can't be used inside of React rendering as it needs to be marked in the top level of the module for preloading to work, similar to React.lazy. Examples With named exports To dynamically import a named export, you can return it from the Promise returned by import(): With no SSR To dynamically load a component on the client side, you can use the ssr option to disable server-rendering. This is useful if an external dependency or component relies on browser APIs like window. With external libraries This example uses the external library fuse.js for fuzzy search. The module is only loaded in the browser after the user types in the search input.",
    "excerpt": "Lazy loading in Next.js helps improve the initial loading performance of an application by decreasing the amount of JavaScript needed to render a route. It allows you to defer loading of Client Compon...",
    "url": "https://nextjs.org/docs/01-app/02-guides/lazy-loading"
  },
  {
    "id": "01-app-02-guides-local-development",
    "path": "01-app\\02-guides\\local-development.mdx",
    "title": "How to optimize your local development environment",
    "description": "Learn how to optimize your local development environment with Next.js.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Local dev vs. production",
        "slug": "local-dev-vs-production"
      },
      {
        "level": 2,
        "text": "Improving local dev performance",
        "slug": "improving-local-dev-performance"
      },
      {
        "level": 3,
        "text": "1. Check your computer's antivirus",
        "slug": "1-check-your-computers-antivirus"
      },
      {
        "level": 3,
        "text": "2. Update Next.js and use Turbopack",
        "slug": "2-update-nextjs-and-use-turbopack"
      },
      {
        "level": 3,
        "text": "3. Check your imports",
        "slug": "3-check-your-imports"
      },
      {
        "level": 4,
        "text": "Icon libraries",
        "slug": "icon-libraries"
      },
      {
        "level": 4,
        "text": "Barrel files",
        "slug": "barrel-files"
      },
      {
        "level": 4,
        "text": "Optimize package imports",
        "slug": "optimize-package-imports"
      },
      {
        "level": 3,
        "text": "4. Check your Tailwind CSS setup",
        "slug": "4-check-your-tailwind-css-setup"
      },
      {
        "level": 3,
        "text": "5. Check custom webpack settings",
        "slug": "5-check-custom-webpack-settings"
      },
      {
        "level": 3,
        "text": "6. Optimize memory usage",
        "slug": "6-optimize-memory-usage"
      },
      {
        "level": 3,
        "text": "7. Server Components and data fetching",
        "slug": "7-server-components-and-data-fetching"
      },
      {
        "level": 3,
        "text": "8. Consider local development over Docker",
        "slug": "8-consider-local-development-over-docker"
      },
      {
        "level": 2,
        "text": "Tools for finding problems",
        "slug": "tools-for-finding-problems"
      },
      {
        "level": 3,
        "text": "Detailed fetch logging",
        "slug": "detailed-fetch-logging"
      },
      {
        "level": 3,
        "text": "Turbopack tracing",
        "slug": "turbopack-tracing"
      },
      {
        "level": 3,
        "text": "Still having problems?",
        "slug": "still-having-problems"
      }
    ],
    "codeBlocks": [
      {
        "language": "bash",
        "code": "npm install next@latest\r\nnpm run dev  # Turbopack is used by default",
        "context": ""
      },
      {
        "language": "bash",
        "code": "npm run dev --webpack",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "// Instead of this:\r\nimport { TriangleIcon } from '@phosphor-icons/react'\r\n\r\n// Do this:\r\nimport { TriangleIcon } from '@phosphor-icons/react/dist/csr/Triangle'",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "module.exports = {\r\n  experimental: {\r\n    optimizePackageImports: ['package-name'],\r\n  },\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "module.exports = {\r\n  content: [\r\n    './src/**/*.{js,ts,jsx,tsx}', // Good\r\n    // This might be too broad\r\n    // It will match `packages/**/node_modules` too\r\n    // '../../packages/**/*.{js,ts,jsx,tsx}',\r\n  ],\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "module.exports = {\r\n  content: [\r\n    // Better - only scans the 'src' folder\r\n    '../../packages/ui/src/**/*.{js,ts,jsx,tsx}',\r\n  ],\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  logging: {\r\n    fetches: {\r\n      fullUrl: true,\r\n    },\r\n  },\r\n}",
        "context": ""
      },
      {
        "language": "bash",
        "code": "NEXT_TURBOPACK_TRACING=1 npm run dev",
        "context": ""
      },
      {
        "language": "bash",
        "code": "npx next internal trace .next/dev/trace-turbopack",
        "context": ""
      },
      {
        "language": "bash",
        "code": "npx next internal turbo-trace-server .next/dev/trace-turbopack",
        "context": ""
      }
    ],
    "content": "Next.js is designed to provide a great developer experience. As your application grows, you might notice slower compilation times during local development. This guide will help you identify and fix common compile-time performance issues. Local dev vs. production The development process with next dev is different than next build and next start. next dev compiles routes in your application as you open or navigate to them. This enables you to start the dev server without waiting for every route in your application to compile, which is both faster and uses less memory. Running a production build applies other optimizations, like minifying files and creating content hashes, which are not needed for local development. Improving local dev performance 1. Check your computer's antivirus Antivirus software can slow down file access. While this is more common on Windows machines, this can be an issue for any system with an antivirus tool installed. On Windows, you can add your project to the Microsoft Defender Antivirus exclusion list. 1. Open the \"Windows Security\" application and then select \"Virus & threat protection\" &rarr; \"Manage settings\" &rarr; \"Add or remove exclusions\". 2. Add a \"Folder\" exclusion. Select your project folder. On macOS, you can disable Gatekeeper inside of your terminal. 1. Run sudo spctl developer-mode enable-terminal in your terminal. 2. Open the \"System Settings\" app and then select \"Privacy & Security\" &rarr; \"Developer Tools\". 3. Ensure your terminal is listed and enabled. If you're using a third-party terminal like iTerm or Ghostty, add that to the list. 4. Restart your terminal. If you or your employer have configured any other Antivirus solutions on your system, you should inspect the relevant settings for those products. 2. Update Next.js and use Turbopack Make sure you're using the latest version of Next.js. Each new version often includes performance improvements. Turbopack is now the default bundler for Next.js development and provides significant performance improvements over webpack. If you need to use Webpack instead of Turbopack, you can opt-in: Learn more about Turbopack. See our upgrade guides and codemods for more information. 3. Check your imports The way you import code can greatly affect compilation and bundling time. Learn more about optimizing package bundling and explore tools like Dependency Cruiser or Madge. Icon libraries Libraries like @material-ui/icons, @phosphor-icons/react, or react-icons can import thousands of icons, even if you only use a few. Try to import only the icons you need: You can often find what import pattern to use in the documentation for the icon library you're using. This example follows @phosphor-icons/react recommendation. Libraries like react-icons includes many different icon sets. Choose one set and stick with that set. For example, if your application uses react-icons and imports all of these: - pi (Phosphor Icons) - md (Material Design Icons) - tb (tabler-icons) - cg (cssgg) Combined they will be tens of thousands of modules that the compiler has to handle, even if you only use a single import from each. Barrel files \"Barrel files\" are files that export many items from other files. They can slow down builds because the compiler has to parse them to find if there are side-effects in the module scope by using the import. Try to import directly from specific files when possible. Learn more about barrel files and the built-in optimizations in Next.js. Optimize package imports Next.js can automatically optimize imports for certain packages. If you are using packages that utilize barrel files, add them to your next.config.js: Turbopack automatically analyzes imports and optimizes them. It does not require this configuration. 4. Check your Tailwind CSS setup If you're using Tailwind CSS, make sure it's set up correctly. A common mistake is configuring your content array in a way which includes nodemodules or other large directories of files that should not be scanned. Tailwind CSS version 3.4.8 or newer will warn you about settings that might slow down your build. 1. In your tailwind.config.js, be specific about which files to scan: 2. Avoid scanning unnecessary files: 5. Check custom webpack settings If you've added custom webpack settings, they might be slowing down compilation. Consider if you really need them for local development. You can optionally only include certain tools for production builds, or explore using the default Turbopack bundler and configuring loaders instead. 6. Optimize memory usage If your app is very large, it might need more memory. Learn more about optimizing memory usage. 7. Server Components and data fetching Changes to Server Components cause the entire page to re-render locally in order to show the new changes, which includes fetching new data for the component. The experimental serverComponentsHmrCache option allows you to cache fetch responses in Server Components across Hot Module Replacement (HMR) refreshes in local development. This results in faster responses and reduced costs for billed API calls. Learn more about the experimental option. 8. Consider local development over Docker If you're using Docker for development on Mac or Windows, you may experience significantly slower performance compared to running Next.js locally. Docker's filesystem access on Mac and Windows can cause Hot Module Replacement (HMR) to take seconds or even minutes, while the same application runs with fast HMR when developed locally. This performance difference is due to how Docker handles filesystem operations outside of Linux environments. For the best development experience: - Use local development (npm run dev or pnpm dev) instead of Docker during development - Reserve Docker for production deployments and testing production builds - If you must use Docker for development, consider using Docker on a Linux machine or VM Learn more about Docker deployment for production use. Tools for finding problems Detailed fetch logging Use the logging.fetches option in your next.config.js file, to see more detailed information about what's happening during development: Learn more about fetch logging. Turbopack tracing Turbopack tracing is a tool that helps you understand the performance of your application during local development. It provides detailed information about the time taken for each module to compile and how they are related. 1. Make sure you have the latest version of Next.js installed. 1. Generate a Turbopack trace file: 1. Navigate around your application or make edits to files to reproduce the problem. 1. Stop the Next.js development server. 1. A file called trace-turbopack will be available in the .next/dev folder. 1. You can interpret the file using npx next internal trace [path-to-file]: On versions where trace is not available, the command was named turbo-trace-server: 1. Once the trace server is running you can view the trace at https://trace.nextjs.org/. 1. By default the trace viewer will aggregate timings, in order to see each individual time you can switch from \"Aggregated in order\" to \"Spans in order\" at the top right of the viewer. > Good to know: The trace file is place under the development server directory, which defaults to .next/dev. This is controllable using the isolatedDevBuild flag in your Next config file. Still having problems? Share the trace file generated in the Turbopack Tracing section and share it on GitHub Discussions or Discord.",
    "excerpt": "Next.js is designed to provide a great developer experience. As your application grows, you might notice slower compilation times during local development. This guide will help you identify and fix co...",
    "url": "https://nextjs.org/docs/01-app/02-guides/local-development"
  },
  {
    "id": "01-app-02-guides-mcp",
    "path": "01-app\\02-guides\\mcp.mdx",
    "title": "Enabling Next.js MCP Server for Coding Agents",
    "description": "Learn how to use Next.js MCP support to allow coding agents access to your application state",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Getting started",
        "slug": "getting-started"
      },
      {
        "level": 2,
        "text": "Capabilities",
        "slug": "capabilities"
      },
      {
        "level": 3,
        "text": "Application Runtime Access",
        "slug": "application-runtime-access"
      },
      {
        "level": 3,
        "text": "Development Tools",
        "slug": "development-tools"
      },
      {
        "level": 2,
        "text": "Development workflow",
        "slug": "development-workflow"
      },
      {
        "level": 3,
        "text": "Available tools",
        "slug": "available-tools"
      },
      {
        "level": 2,
        "text": "Using with agents",
        "slug": "using-with-agents"
      },
      {
        "level": 3,
        "text": "Benefits for agent-assisted development",
        "slug": "benefits-for-agent-assisted-development"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Error detection and diagnosis",
        "slug": "error-detection-and-diagnosis"
      },
      {
        "level": 3,
        "text": "Upgrading and best practices",
        "slug": "upgrading-and-best-practices"
      },
      {
        "level": 2,
        "text": "How it works",
        "slug": "how-it-works"
      },
      {
        "level": 2,
        "text": "Troubleshooting",
        "slug": "troubleshooting"
      },
      {
        "level": 3,
        "text": "MCP server not connecting",
        "slug": "mcp-server-not-connecting"
      }
    ],
    "codeBlocks": [
      {
        "language": "json",
        "code": "{\r\n  \"mcpServers\": {\r\n    \"next-devtools\": {\r\n      \"command\": \"npx\",\r\n      \"args\": [\"-y\", \"next-devtools-mcp@latest\"]\r\n    }\r\n  }\r\n}",
        "context": "filename=\".mcp.json\""
      },
      {
        "language": "bash",
        "code": "npm run dev",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "User: \"What errors are currently in my application?\"",
        "context": ""
      },
      {
        "language": "bash",
        "code": "> fix errors on the page\r\n\r\n⏺ I'll help you fix the errors on the page. Let me first check what errors exist by looking at the\r\n  current state of the project.\r\n\r\n⏺ next-devtools - nextjs_runtime (MCP)(action: \"discover_servers\")\r\n⏺ next-devtools - nextjs_runtime (MCP)(action: \"call_tool\", toolName: \"get_errors\")\r\n\r\n⏺ I found a hydration error on the /about page. The error shows that the server is rendering\r\n  \"server\" but the client is rendering \"client\", causing a mismatch. Let me create a todo list and fix\r\n   this issue.\r\n\r\n⏺ Perfect! Now let me check for errors on the page.           01:14 PM  claude-sonnet-4-5-20250929\r\n\r\n⏺ next-devtools - nextjs_runtime (MCP)(action: \"call_tool\", toolName: \"get_errors\")\r\n  ⎿ {\r\n      \"success\": true,\r\n      \"port\": 3000,\r\n      \"toolName\": \"get_errors\",\r\n      \"result\": {\r\n        \"content\": [\r\n          {\r\n            \"type\": \"text\",\r\n            \"text\": \"# Found errors in 1 browser session(s)\\n\\n## Session: /about\\n\\n**1 error(s)\r\n     found**\\n\\n### Runtime Errors\\n\\n#### Error 1 (Type: recoverable)\\n\\n**Error**: Hydration failed",
        "context": ""
      },
      {
        "language": "bash",
        "code": "User: \"Help me upgrade my Next.js app to version 16\"",
        "context": ""
      },
      {
        "language": "bash",
        "code": "User: \"When should I use 'use client' in App Router?\"",
        "context": ""
      }
    ],
    "content": "The Model Context Protocol (MCP) is an open standard that allows AI agents and coding assistants to interact with your applications through a standardized interface. Next.js 16+ includes MCP support that enables coding agents to access your application's internals in real-time. To use this functionality, install the next-devtools-mcp package. Getting started Requirements: Next.js 16 or above Add next-devtools-mcp to the .mcp.json file at the root of your project: That's it! When you start your development server, next-devtools-mcp will automatically discover and connect to your running Next.js instance. For more configuration options, see the next-devtools-mcp repository. Capabilities next-devtools-mcp provides coding agents with a growing set of capabilities: Application Runtime Access - Error Detection: Retrieve current build errors, runtime errors, and type errors from your dev server - Live State Queries: Access real-time application state and runtime information - Page Metadata: Query page routes, components, and rendering details - Server Actions: Inspect Server Actions and component hierarchies - Development Logs: Access development server logs and console output Development Tools - Next.js Knowledge Base: Query comprehensive Next.js documentation and best practices - Migration and Upgrade Tools: Automated helpers for upgrading to Next.js 16 with codemods - Cache Components Guide: Setup and configuration assistance for Cache Components - Browser Testing: Playwright MCP integration for verifying pages in the browser > Note: The Next.js team is actively expanding these capabilities. New tools and features are added regularly to improve the agent development experience. Development workflow 1. Start your Next.js development server: 2. Your Coding Agent will automatically connect to the running Next.js instance via next-devtools-mcp 3. Open your application in the browser to view pages 4. Query your agent for insights and diagnostics (see examples below) Available tools Through next-devtools-mcp, agents can use the following tools: - geterrors: Retrieve current build errors, runtime errors, and type errors from your dev server - getlogs: Get the path to the development log file containing browser console logs and server output - getpagemetadata: Get metadata about specific pages including routes, components, and rendering information - getprojectmetadata: Retrieve project structure, configuration, and dev server URL - getserveractionbyid: Look up Server Actions by their ID to find the source file and function name Using with agents MCP-compatible Coding Agents can automatically discover and connect to your Next.js development server, providing them with rich context about your project. Benefits for agent-assisted development Agents can: - Make context-aware suggestions: Recommend the right place to add new features based on your existing structure - Query live application state: Check current configuration, routes, and middleware during development - Understand your app router pages layout: Know exactly which page and layout are rendered - Provide accurate implementations: Generate code that follows your project's patterns and conventions Examples Error detection and diagnosis Ask your agent about errors in real-time: The agent will: - Query your running Next.js application via next-devtools-mcp - Retrieve current build errors, runtime errors, and type errors - Analyze the errors and provide actionable fixes Agent response (click to expand) Upgrading and best practices Get help with Next.js concepts and migrations: The agent will analyze your current version, guide you through automated migrations with codemods, and provide step-by-step instructions for handling breaking changes. Ask conceptual questions: The agent will query the Next.js knowledge base and provide documentation-backed explanations with examples from your codebase. How it works Next.js 16+ includes a built-in MCP endpoint at /next/mcp that runs within your development server. The next-devtools-mcp package automatically discovers and communicates with these endpoints, allowing it to: - Connect to multiple Next.js instances running on different ports - Forward tool calls to the appropriate Next.js dev server - Provide a unified interface for coding agents This architecture decouples the agent interface from the internal implementation, enabling next-devtools-mcp to work seamlessly across different Next.js projects. Troubleshooting MCP server not connecting - Ensure you're using Next.js v16 or above - Verify next-devtools-mcp is configured in your .mcp.json - Start your development server: npm run dev - Restart your development server if it was already running - Check that your coding agent has loaded the MCP server configuration",
    "excerpt": "The Model Context Protocol (MCP) is an open standard that allows AI agents and coding assistants to interact with your applications through a standardized interface. Next.js 16+ includes MCP support t...",
    "url": "https://nextjs.org/docs/01-app/02-guides/mcp"
  },
  {
    "id": "01-app-02-guides-mdx",
    "path": "01-app\\02-guides\\mdx.mdx",
    "title": "How to use markdown and MDX in Next.js",
    "description": "Learn how to configure MDX and use it in your Next.js apps.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Install dependencies",
        "slug": "install-dependencies"
      },
      {
        "level": 2,
        "text": "Configure ",
        "slug": "configure-"
      },
      {
        "level": 3,
        "text": "Handling  files",
        "slug": "handling-files"
      },
      {
        "level": 2,
        "text": "Add an  file",
        "slug": "add-an-file"
      },
      {
        "level": 2,
        "text": "Rendering MDX",
        "slug": "rendering-mdx"
      },
      {
        "level": 3,
        "text": "Using file based routing",
        "slug": "using-file-based-routing"
      },
      {
        "level": 3,
        "text": "Using imports",
        "slug": "using-imports"
      },
      {
        "level": 3,
        "text": "Using dynamic imports",
        "slug": "using-dynamic-imports"
      },
      {
        "level": 2,
        "text": "Using custom styles and components",
        "slug": "using-custom-styles-and-components"
      },
      {
        "level": 3,
        "text": "Global styles and components",
        "slug": "global-styles-and-components"
      },
      {
        "level": 3,
        "text": "Local styles and components",
        "slug": "local-styles-and-components"
      },
      {
        "level": 3,
        "text": "Shared layouts",
        "slug": "shared-layouts"
      },
      {
        "level": 3,
        "text": "Using Tailwind typography plugin",
        "slug": "using-tailwind-typography-plugin"
      },
      {
        "level": 2,
        "text": "Frontmatter",
        "slug": "frontmatter"
      },
      {
        "level": 2,
        "text": "remark and rehype Plugins",
        "slug": "remark-and-rehype-plugins"
      },
      {
        "level": 3,
        "text": "Using Plugins with Turbopack",
        "slug": "using-plugins-with-turbopack"
      },
      {
        "level": 2,
        "text": "Remote MDX",
        "slug": "remote-mdx"
      },
      {
        "level": 2,
        "text": "Deep Dive: How do you transform markdown into HTML?",
        "slug": "deep-dive-how-do-you-transform-markdown-into-html"
      },
      {
        "level": 2,
        "text": "Using the Rust-based MDX compiler (experimental)",
        "slug": "using-the-rust-based-mdx-compiler-experimental"
      },
      {
        "level": 2,
        "text": "Helpful Links",
        "slug": "helpful-links"
      }
    ],
    "codeBlocks": [
      {
        "language": "md",
        "code": "I **love** using [Next.js](https://nextjs.org/)",
        "context": ""
      },
      {
        "language": "html",
        "code": "<p>I <strong>love</strong> using <a href=\"https://nextjs.org/\">Next.js</a></p>",
        "context": ""
      },
      {
        "language": "bash",
        "code": "npm install @next/mdx @mdx-js/loader @mdx-js/react @types/mdx",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "js",
        "code": "import createMDX from '@next/mdx'\r\n\r\n/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  // Configure `pageExtensions` to include markdown and MDX files\r\n  pageExtensions: ['js', 'jsx', 'md', 'mdx', 'ts', 'tsx'],\r\n  // Optionally, add any other Next.js config below\r\n}\r\n\r\nconst withMDX = createMDX({\r\n  // Add markdown plugins here, as desired\r\n})\r\n\r\n// Merge MDX config with Next.js config\r\nexport default withMDX(nextConfig)",
        "context": "filename=\"next.config.mjs\""
      },
      {
        "language": "js",
        "code": "const withMDX = createMDX({\r\n  extension: /\\.(md|mdx)$/,\r\n})",
        "context": "filename=\"next.config.mjs\""
      },
      {
        "language": "tsx",
        "code": "import type { MDXComponents } from 'mdx/types'\r\n\r\nconst components: MDXComponents = {}\r\n\r\nexport function useMDXComponents(): MDXComponents {\r\n  return components\r\n}",
        "context": "filename=\"mdx-components.tsx\" switcher"
      },
      {
        "language": "js",
        "code": "const components = {}\r\n\r\nexport function useMDXComponents() {\r\n  return components\r\n}",
        "context": "filename=\"mdx-components.js\" switcher"
      },
      {
        "language": "txt",
        "code": "  my-project\r\n  ├── app\r\n  │   └── mdx-page\r\n  │       └── page.(mdx/md)\r\n  |── mdx-components.(tsx/js)\r\n  └── package.json",
        "context": ""
      },
      {
        "language": "txt",
        "code": "  my-project\r\n  |── mdx-components.(tsx/js)\r\n  ├── pages\r\n  │   └── mdx-page.(mdx/md)\r\n  └── package.json",
        "context": ""
      },
      {
        "language": "mdx",
        "code": "import { MyComponent } from 'my-component'\r\n\r\n# Welcome to my MDX page!\r\n\r\nThis is some **bold** and _italics_ text.\r\n\r\nThis is a list in markdown:\r\n\r\n- One\r\n- Two\r\n- Three\r\n\r\nCheckout my React component:\r\n\r\n<MyComponent />",
        "context": ""
      },
      {
        "language": "txt",
        "code": "  .\r\n  ├── app/\r\n  │   └── mdx-page/\r\n  │       └── page.(tsx/js)\r\n  ├── markdown/\r\n  │   └── welcome.(mdx/md)\r\n  ├── mdx-components.(tsx/js)\r\n  └── package.json",
        "context": ""
      },
      {
        "language": "txt",
        "code": "  .\r\n  ├── markdown/\r\n  │   └── welcome.(mdx/md)\r\n  ├── pages/\r\n  │   └── mdx-page.(tsx/js)\r\n  ├── mdx-components.(tsx/js)\r\n  └── package.json",
        "context": ""
      },
      {
        "language": "mdx",
        "code": "import { MyComponent } from 'my-component'\r\n\r\n# Welcome to my MDX page!\r\n\r\nThis is some **bold** and _italics_ text.\r\n\r\nThis is a list in markdown:\r\n\r\n- One\r\n- Two\r\n- Three\r\n\r\nCheckout my React component:\r\n\r\n<MyComponent />",
        "context": "filename=\"markdown/welcome.mdx\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Welcome from '@/markdown/welcome.mdx'\r\n\r\nexport default function Page() {\r\n  return <Welcome />\r\n}",
        "context": "filename=\"app/mdx-page/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Welcome from '@/markdown/welcome.mdx'\r\n\r\nexport default function Page() {\r\n  return <Welcome />\r\n}",
        "context": "filename=\"app/mdx-page/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Welcome from '@/markdown/welcome.mdx'\r\n\r\nexport default function Page() {\r\n  return <Welcome />\r\n}",
        "context": "filename=\"pages/mdx-page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Welcome from '@/markdown/welcome.mdx'\r\n\r\nexport default function Page() {\r\n  return <Welcome />\r\n}",
        "context": "filename=\"pages/mdx-page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default async function Page({\r\n  params,\r\n}: {\r\n  params: Promise<{ slug: string }>\r\n}) {\r\n  const { slug } = await params\r\n  const { default: Post } = await import(`@/content/${slug}.mdx`)\r\n\r\n  return <Post />\r\n}\r\n\r\nexport function generateStaticParams() {\r\n  return [{ slug: 'welcome' }, { slug: 'about' }]\r\n}\r\n\r\nexport const dynamicParams = false",
        "context": "filename=\"app/blog/[slug]/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default async function Page({ params }) {\r\n  const { slug } = await params\r\n  const { default: Post } = await import(`@/content/${slug}.mdx`)\r\n\r\n  return <Post />\r\n}\r\n\r\nexport function generateStaticParams() {\r\n  return [{ slug: 'welcome' }, { slug: 'about' }]\r\n}\r\n\r\nexport const dynamicParams = false",
        "context": "filename=\"app/blog/[slug]/page.js\" switcher"
      },
      {
        "language": "md",
        "code": "## This is a heading\r\n\r\nThis is a list in markdown:\r\n\r\n- One\r\n- Two\r\n- Three",
        "context": ""
      },
      {
        "language": "html",
        "code": "<h2>This is a heading</h2>\r\n\r\n<p>This is a list in markdown:</p>\r\n\r\n<ul>\r\n  <li>One</li>\r\n  <li>Two</li>\r\n  <li>Three</li>\r\n</ul>",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "import type { MDXComponents } from 'mdx/types'\r\nimport Image, { ImageProps } from 'next/image'\r\n\r\n// This file allows you to provide custom React components\r\n// to be used in MDX files. You can import and use any\r\n// React component you want, including inline styles,\r\n// components from other libraries, and more.\r\n\r\nconst components = {\r\n  // Allows customizing built-in components, e.g. to add styling.\r\n  h1: ({ children }) => (\r\n    <h1 style={{ color: 'red', fontSize: '48px' }}>{children}</h1>\r\n  ),\r\n  img: (props) => (\r\n    <Image\r\n      sizes=\"100vw\"\r\n      style={{ width: '100%', height: 'auto' }}\r\n      {...(props as ImageProps)}\r\n    />\r\n  ),\r\n} satisfies MDXComponents\r\n\r\nexport function useMDXComponents(): MDXComponents {\r\n  return components\r\n}",
        "context": "filename=\"mdx-components.tsx\" switcher"
      },
      {
        "language": "js",
        "code": "import Image from 'next/image'\r\n\r\n// This file allows you to provide custom React components\r\n// to be used in MDX files. You can import and use any\r\n// React component you want, including inline styles,\r\n// components from other libraries, and more.\r\n\r\nconst components = {\r\n  // Allows customizing built-in components, e.g. to add styling.\r\n  h1: ({ children }) => (\r\n    <h1 style={{ color: 'red', fontSize: '48px' }}>{children}</h1>\r\n  ),\r\n  img: (props) => (\r\n    <Image sizes=\"100vw\" style={{ width: '100%', height: 'auto' }} {...props} />\r\n  ),\r\n}\r\n\r\nexport function useMDXComponents() {\r\n  return components\r\n}",
        "context": "filename=\"mdx-components.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Welcome from '@/markdown/welcome.mdx'\r\n\r\nfunction CustomH1({ children }) {\r\n  return <h1 style={{ color: 'blue', fontSize: '100px' }}>{children}</h1>\r\n}\r\n\r\nconst overrideComponents = {\r\n  h1: CustomH1,\r\n}\r\n\r\nexport default function Page() {\r\n  return <Welcome components={overrideComponents} />\r\n}",
        "context": "filename=\"app/mdx-page/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Welcome from '@/markdown/welcome.mdx'\r\n\r\nfunction CustomH1({ children }) {\r\n  return <h1 style={{ color: 'blue', fontSize: '100px' }}>{children}</h1>\r\n}\r\n\r\nconst overrideComponents = {\r\n  h1: CustomH1,\r\n}\r\n\r\nexport default function Page() {\r\n  return <Welcome components={overrideComponents} />\r\n}",
        "context": "filename=\"app/mdx-page/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Welcome from '@/markdown/welcome.mdx'\r\n\r\nfunction CustomH1({ children }) {\r\n  return <h1 style={{ color: 'blue', fontSize: '100px' }}>{children}</h1>\r\n}\r\n\r\nconst overrideComponents = {\r\n  h1: CustomH1,\r\n}\r\n\r\nexport default function Page() {\r\n  return <Welcome components={overrideComponents} />\r\n}",
        "context": "filename=\"pages/mdx-page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Welcome from '@/markdown/welcome.mdx'\r\n\r\nfunction CustomH1({ children }) {\r\n  return <h1 style={{ color: 'blue', fontSize: '100px' }}>{children}</h1>\r\n}\r\n\r\nconst overrideComponents = {\r\n  h1: CustomH1,\r\n}\r\n\r\nexport default function Page() {\r\n  return <Welcome components={overrideComponents} />\r\n}",
        "context": "filename=\"pages/mdx-page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default function MdxLayout({ children }: { children: React.ReactNode }) {\r\n  // Create any shared layout or styles here\r\n  return <div style={{ color: 'blue' }}>{children}</div>\r\n}",
        "context": "filename=\"app/mdx-page/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function MdxLayout({ children }) {\r\n  // Create any shared layout or styles here\r\n  return <div style={{ color: 'blue' }}>{children}</div>\r\n}",
        "context": "filename=\"app/mdx-page/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default function MdxLayout({ children }: { children: React.ReactNode }) {\r\n  // Create any shared layout or styles here\r\n  return <div style={{ color: 'blue' }}>{children}</div>\r\n}",
        "context": "filename=\"components/mdx-layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function MdxLayout({ children }) {\r\n  // Create any shared layout or styles here\r\n  return <div style={{ color: 'blue' }}>{children}</div>\r\n}",
        "context": "filename=\"components/mdx-layout.js\" switcher"
      },
      {
        "language": "mdx",
        "code": "import MdxLayout from '../components/mdx-layout'\r\n\r\n# Welcome to my MDX page!\r\n\r\nexport default function MDXPage({ children }) {\r\n  return <MdxLayout>{children}</MdxLayout>\r\n\r\n}",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "export default function MdxLayout({ children }: { children: React.ReactNode }) {\r\n  // Create any shared layout or styles here\r\n  return (\r\n    <div className=\"prose prose-headings:mt-8 prose-headings:font-semibold prose-headings:text-black prose-h1:text-5xl prose-h2:text-4xl prose-h3:text-3xl prose-h4:text-2xl prose-h5:text-xl prose-h6:text-lg dark:prose-headings:text-white\">\r\n      {children}\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/mdx-page/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function MdxLayout({ children }) {\r\n  // Create any shared layout or styles here\r\n  return (\r\n    <div className=\"prose prose-headings:mt-8 prose-headings:font-semibold prose-headings:text-black prose-h1:text-5xl prose-h2:text-4xl prose-h3:text-3xl prose-h4:text-2xl prose-h5:text-xl prose-h6:text-lg dark:prose-headings:text-white\">\r\n      {children}\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/mdx-page/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default function MdxLayout({ children }: { children: React.ReactNode }) {\r\n  // Create any shared layout or styles here\r\n  return (\r\n    <div className=\"prose prose-headings:mt-8 prose-headings:font-semibold prose-headings:text-black prose-h1:text-5xl prose-h2:text-4xl prose-h3:text-3xl prose-h4:text-2xl prose-h5:text-xl prose-h6:text-lg dark:prose-headings:text-white\">\r\n      {children}\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"components/mdx-layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function MdxLayout({ children }) {\r\n  // Create any shared layout or styles here\r\n  return (\r\n    <div className=\"prose prose-headings:mt-8 prose-headings:font-semibold prose-headings:text-black prose-h1:text-5xl prose-h2:text-4xl prose-h3:text-3xl prose-h4:text-2xl prose-h5:text-xl prose-h6:text-lg dark:prose-headings:text-white\">\r\n      {children}\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"components/mdx-layout.js\" switcher"
      },
      {
        "language": "mdx",
        "code": "import MdxLayout from '../components/mdx-layout'\r\n\r\n# Welcome to my MDX page!\r\n\r\nexport default function MDXPage({ children }) {\r\n  return <MdxLayout>{children}</MdxLayout>\r\n\r\n}",
        "context": ""
      },
      {
        "language": "mdx",
        "code": "export const metadata = {\r\n  author: 'John Doe',\r\n}\r\n\r\n# Blog post",
        "context": "filename=\"content/blog-post.mdx\" switcher"
      },
      {
        "language": "tsx",
        "code": "import BlogPost, { metadata } from '@/content/blog-post.mdx'\r\n\r\nexport default function Page() {\r\n  console.log('metadata: ', metadata)\r\n  //=> { author: 'John Doe' }\r\n  return <BlogPost />\r\n}",
        "context": "filename=\"app/blog/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import BlogPost, { metadata } from '@/content/blog-post.mdx'\r\n\r\nexport default function Page() {\r\n  console.log('metadata: ', metadata)\r\n  //=> { author: 'John Doe' }\r\n  return <BlogPost />\r\n}",
        "context": "filename=\"app/blog/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import BlogPost, { metadata } from '@/content/blog-post.mdx'\r\n\r\nexport default function Page() {\r\n  console.log('metadata: ', metadata)\r\n  //=> { author: 'John Doe' }\r\n  return <BlogPost />\r\n}",
        "context": "filename=\"pages/blog.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import BlogPost, { metadata } from '@/content/blog-post.mdx'\r\n\r\nexport default function Page() {\r\n  console.log('metadata: ', metadata)\r\n  //=> { author: 'John Doe' }\r\n  return <BlogPost />\r\n}",
        "context": "filename=\"pages/blog.js\" switcher"
      },
      {
        "language": "js",
        "code": "import remarkGfm from 'remark-gfm'\r\nimport createMDX from '@next/mdx'\r\n\r\n/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  // Allow .mdx extensions for files\r\n  pageExtensions: ['js', 'jsx', 'md', 'mdx', 'ts', 'tsx'],\r\n  // Optionally, add any other Next.js config below\r\n}\r\n\r\nconst withMDX = createMDX({\r\n  // Add markdown plugins here, as desired\r\n  options: {\r\n    remarkPlugins: [remarkGfm],\r\n    rehypePlugins: [],\r\n  },\r\n})\r\n\r\n// Combine MDX and Next.js config\r\nexport default withMDX(nextConfig)",
        "context": "filename=\"next.config.mjs\""
      },
      {
        "language": "js",
        "code": "import createMDX from '@next/mdx'\r\n\r\n/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  pageExtensions: ['js', 'jsx', 'md', 'mdx', 'ts', 'tsx'],\r\n}\r\n\r\nconst withMDX = createMDX({\r\n  options: {\r\n    remarkPlugins: [\r\n      // Without options\r\n      'remark-gfm',\r\n      // With options\r\n      ['remark-toc', { heading: 'The Table' }],\r\n    ],\r\n    rehypePlugins: [\r\n      // Without options\r\n      'rehype-slug',\r\n      // With options\r\n      ['rehype-katex', { strict: true, throwOnError: true }],\r\n    ],\r\n  },\r\n})\r\n\r\nexport default withMDX(nextConfig)",
        "context": "filename=\"next.config.mjs\""
      },
      {
        "language": "tsx",
        "code": "import { MDXRemote } from 'next-mdx-remote-client/rsc'\r\n\r\nexport default async function RemoteMdxPage() {\r\n  // MDX text - can be from a database, CMS, fetch, anywhere...\r\n  const res = await fetch('https://...')\r\n  const markdown = await res.text()\r\n  return <MDXRemote source={markdown} />\r\n}",
        "context": "filename=\"app/mdx-page-remote/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { MDXRemote } from 'next-mdx-remote-client/rsc'\r\n\r\nexport default async function RemoteMdxPage() {\r\n  // MDX text - can be from a database, CMS, fetch, anywhere...\r\n  const res = await fetch('https://...')\r\n  const markdown = await res.text()\r\n  return <MDXRemote source={markdown} />\r\n}",
        "context": "filename=\"app/mdx-page-remote/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import {\r\n  serialize,\r\n  type SerializeResult,\r\n} from 'next-mdx-remote-client/serialize'\r\nimport { MDXClient } from 'next-mdx-remote-client'\r\n\r\ntype Props = {\r\n  mdxSource: SerializeResult\r\n}\r\n\r\nexport default function RemoteMdxPage({ mdxSource }: Props) {\r\n  if ('error' in mdxSource) {\r\n    // either render error UI or throw `mdxSource.error`\r\n  }\r\n  return <MDXClient {...mdxSource} />\r\n}\r\n\r\nexport async function getStaticProps() {\r\n  // MDX text - can be from a database, CMS, fetch, anywhere...\r\n  const res = await fetch('https:...')\r\n  const mdxText = await res.text()\r\n  const mdxSource = await serialize({ source: mdxText })\r\n  return { props: { mdxSource } }\r\n}",
        "context": "filename=\"pages/mdx-page-remote.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { serialize } from 'next-mdx-remote-client/serialize'\r\nimport { MDXClient } from 'next-mdx-remote-client'\r\n\r\nexport default function RemoteMdxPage({ mdxSource }) {\r\n  if ('error' in mdxSource) {\r\n    // either render error UI or throw `mdxSource.error`\r\n  }\r\n  return <MDXClient {...mdxSource} />\r\n}\r\n\r\nexport async function getStaticProps() {\r\n  // MDX text - can be from a database, CMS, fetch, anywhere...\r\n  const res = await fetch('https:...')\r\n  const mdxText = await res.text()\r\n  const mdxSource = await serialize({ source: mdxText })\r\n  return { props: { mdxSource } }\r\n}",
        "context": "filename=\"pages/mdx-page-remote.js\" switcher"
      },
      {
        "language": "js",
        "code": "import { unified } from 'unified'\r\nimport remarkParse from 'remark-parse'\r\nimport remarkRehype from 'remark-rehype'\r\nimport rehypeSanitize from 'rehype-sanitize'\r\nimport rehypeStringify from 'rehype-stringify'\r\n\r\nmain()\r\n\r\nasync function main() {\r\n  const file = await unified()\r\n    .use(remarkParse) // Convert into markdown AST\r\n    .use(remarkRehype) // Transform to HTML AST\r\n    .use(rehypeSanitize) // Sanitize HTML input\r\n    .use(rehypeStringify) // Convert AST into serialized HTML\r\n    .process('Hello, Next.js!')\r\n\r\n  console.log(String(file)) // <p>Hello, Next.js!</p>\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "module.exports = withMDX({\r\n  experimental: {\r\n    mdxRs: true,\r\n  },\r\n})",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = withMDX({\r\n  experimental: {\r\n    mdxRs: {\r\n      jsxRuntime?: string            // Custom jsx runtime\r\n      jsxImportSource?: string       // Custom jsx import source,\r\n      mdxType?: 'gfm' | 'commonmark' // Configure what kind of mdx syntax will be used to parse & transform\r\n    },\r\n  },\r\n})",
        "context": "filename=\"next.config.js\""
      }
    ],
    "content": "Markdown is a lightweight markup language used to format text. It allows you to write using plain text syntax and convert it to structurally valid HTML. It's commonly used for writing content on websites and blogs. You write... Output: MDX is a superset of markdown that lets you write JSX directly in your markdown files. It is a powerful way to add dynamic interactivity and embed React components within your content. Next.js can support both local MDX content inside your application, as well as remote MDX files fetched dynamically on the server. The Next.js plugin handles transforming markdown and React components into HTML, including support for usage in Server Components (the default in App Router). > Good to know: View the Portfolio Starter Kit template for a complete working example. Install dependencies The @next/mdx package, and related packages, are used to configure Next.js so it can process markdown and MDX. It sources data from local files, allowing you to create pages with a .md or .mdx extension, directly in your /pages or /app directory. Install these packages to render MDX with Next.js: Configure next.config.mjs Update the next.config.mjs file at your project's root to configure it to use MDX: This allows .mdx files to act as pages, routes, or imports in your application. Handling .md files By default, next/mdx only compiles files with the .mdx extension. To handle .md files with webpack, update the extension option: Add an mdx-components.tsx file Create an mdx-components.tsx (or .js) file in the root of your project to define global MDX Components. For example, at the same level as pages or app, or inside src if applicable. > Good to know: > > - mdx-components.tsx is required to use @next/mdx with App Router and will not work without it. > - Learn more about the mdx-components.tsx file convention. > - Learn how to use custom styles and components. Rendering MDX You can render MDX using Next.js's file based routing or by importing MDX files into other pages. Using file based routing When using file based routing, you can use MDX pages like any other page. In App Router apps, that includes being able to use metadata. Create a new MDX page within the /app directory: Create a new MDX page within the /pages directory: You can use MDX in these files, and even import React components, directly inside your MDX page: Navigating to the /mdx-page route should display your rendered MDX page. Using imports Create a new page within the /app directory and an MDX file wherever you'd like: Create a new page within the /pages directory and an MDX file wherever you'd like: You can use MDX in these files, and even import React components, directly inside your MDX page: Import the MDX file inside the page to display the content: Navigating to the /mdx-page route should display your rendered MDX page. Using dynamic imports You can import dynamic MDX components instead of using filesystem routing for MDX files. For example, you can have a dynamic route segment which loads MDX components from a separate directory: generateStaticParams can be used to prerender the provided routes. By marking dynamicParams as false, accessing a route not defined in generateStaticParams will 404. > Good to know: Ensure you specify the .mdx file extension in your import. While it is not required to use module path aliases (e.g., @/content), it does simplify your import path. Using custom styles and components Markdown, when rendered, maps to native HTML elements. For example, writing the following markdown: Generates the following HTML: To style your markdown, you can provide custom components that map to the generated HTML elements. Styles and components can be implemented globally, locally, and with shared layouts. Global styles and components Adding styles and components in mdx-components.tsx will affect all MDX files in your application. Local styles and components You can apply local styles and components to specific pages by passing them into imported MDX components. These will merge with and override global styles and components. Shared layouts To share a layout across MDX pages, you can use the built-in layouts support with the App Router. To share a layout around MDX pages, create a layout component: Then, import the layout component into the MDX page, wrap the MDX content in the layout, and export it: Using Tailwind typography plugin If you are using Tailwind to style your application, using the @tailwindcss/typography plugin will allow you to reuse your Tailwind configuration and styles in your markdown files. The plugin adds a set of prose classes that can be used to add typographic styles to content blocks that come from sources, like markdown. Install Tailwind typography and use with shared layouts to add the prose you want. To share a layout around MDX pages, create a layout component: Then, import the layout component into the MDX page, wrap the MDX content in the layout, and export it: Frontmatter Frontmatter is a YAML like key/value pairing that can be used to store data about a page. @next/mdx does not support frontmatter by default, though there are many solutions for adding frontmatter to your MDX content, such as: - remark-frontmatter - remark-mdx-frontmatter - gray-matter @next/mdx does allow you to use exports like any other JavaScript component: Metadata can now be referenced outside of the MDX file: A common use case for this is when you want to iterate over a collection of MDX and extract data. For example, creating a blog index page from all blog posts. You can use packages like Node's fs module or globby to read a directory of posts and extract the metadata. > Good to know: > > - Using fs, globby, etc. can only be used server-side. > - View the Portfolio Starter Kit template for a complete working example. remark and rehype Plugins You can optionally provide remark and rehype plugins to transform the MDX content. For example, you can use remark-gfm to support GitHub Flavored Markdown. Since the remark and rehype ecosystem is ESM only, you'll need to use next.config.mjs or next.config.ts as the configuration file. Using Plugins with Turbopack To use plugins with Turbopack, upgrade to the latest @next/mdx and specify plugin names using a string: > Good to know: > > remark and rehype plugins without serializable options cannot be used yet with Turbopack, because JavaScript functions can't be passed to Rust. Remote MDX If your MDX files or content lives somewhere else, you can fetch it dynamically on the server. This is useful for content stored in a CMS, database, or anywhere else. A community package for this use is next-mdx-remote-client. > Good to know: Please proceed with caution. MDX compiles to JavaScript and is executed on the server. You should only fetch MDX content from a trusted source, otherwise this can lead to remote code execution (RCE). The following example uses next-mdx-remote-client: Navigating to the /mdx-page-remote route should display your rendered MDX. Deep Dive: How do you transform markdown into HTML? React does not natively understand markdown. The markdown plaintext needs to first be transformed into HTML. This can be accomplished with remark and rehype. remark is an ecosystem of tools around markdown. rehype is the same, but for HTML. For example, the following code snippet transforms markdown into HTML: The remark and rehype ecosystem contains plugins for syntax highlighting, linking headings, generating a table of contents, and more. When using @next/mdx as shown above, you do not need to use remark or rehype directly, as it is handled for you. We're describing it here for a deeper understanding of what the @next/mdx package is doing underneath. Using the Rust-based MDX compiler (experimental) Next.js supports a new MDX compiler written in Rust. This compiler is still experimental and is not recommended for production use. To use the new compiler, you need to configure next.config.js when you pass it to withMDX: mdxRs also accepts an object to configure how to transform mdx files. Helpful Links - MDX - @next/mdx - remark - rehype - Markdoc",
    "excerpt": "Markdown is a lightweight markup language used to format text. It allows you to write using plain text syntax and convert it to structurally valid HTML. It's commonly used for writing content on websi...",
    "url": "https://nextjs.org/docs/01-app/02-guides/mdx"
  },
  {
    "id": "01-app-02-guides-memory-usage",
    "path": "01-app\\02-guides\\memory-usage.mdx",
    "title": "How to optimize memory usage",
    "description": "Optimize memory used by your application in development and production.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Reduce number of dependencies",
        "slug": "reduce-number-of-dependencies"
      },
      {
        "level": 2,
        "text": "Try ",
        "slug": "try-"
      },
      {
        "level": 2,
        "text": "Run  with ",
        "slug": "run-with-"
      },
      {
        "level": 2,
        "text": "Record a heap profile",
        "slug": "record-a-heap-profile"
      },
      {
        "level": 2,
        "text": "Analyze a snapshot of the heap",
        "slug": "analyze-a-snapshot-of-the-heap"
      },
      {
        "level": 2,
        "text": "Webpack build worker",
        "slug": "webpack-build-worker"
      },
      {
        "level": 2,
        "text": "Disable Webpack cache",
        "slug": "disable-webpack-cache"
      },
      {
        "level": 2,
        "text": "Disable static analysis",
        "slug": "disable-static-analysis"
      },
      {
        "level": 2,
        "text": "Disable source maps",
        "slug": "disable-source-maps"
      },
      {
        "level": 2,
        "text": "Edge memory issues",
        "slug": "edge-memory-issues"
      },
      {
        "level": 2,
        "text": "Preloading Entries",
        "slug": "preloading-entries"
      }
    ],
    "codeBlocks": [
      {
        "language": "sh",
        "code": "node --heap-prof node_modules/next/dist/bin/next build",
        "context": ""
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  webpack: (\r\n    config,\r\n    { buildId, dev, isServer, defaultLoaders, nextRuntime, webpack }\r\n  ) => {\r\n    if (config.cache && !dev) {\r\n      config.cache = Object.freeze({\r\n        type: 'memory',\r\n      })\r\n    }\r\n    // Important: return the modified config\r\n    return config\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.mjs\""
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  typescript: {\r\n    // !! WARN !!\r\n    // Dangerously allow production builds to successfully complete even if\r\n    // your project has type errors.\r\n    // !! WARN !!\r\n    ignoreBuildErrors: true,\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.mjs\""
      },
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst config: NextConfig = {\r\n  experimental: {\r\n    preloadEntriesOnStart: false,\r\n  },\r\n}\r\n\r\nexport default config",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst config = {\r\n  experimental: {\r\n    preloadEntriesOnStart: false,\r\n  },\r\n}\r\n\r\nexport default config",
        "context": "filename=\"next.config.mjs\" switcher"
      }
    ],
    "content": "As applications grow and become more feature rich, they can demand more resources when developing locally or creating production builds. Let's explore some strategies and techniques to optimize memory and address common memory issues in Next.js. Reduce number of dependencies Applications with a large amount of dependencies will use more memory. The Bundle Analyzer can help you investigate large dependencies in your application that may be able to be removed to improve performance and memory usage. Try experimental.webpackMemoryOptimizations Starting in v15.0.0, you can add experimental.webpackMemoryOptimizations: true to your next.config.js file to change behavior in Webpack that reduces max memory usage but may increase compilation times by a slight amount. > Good to know: This feature is currently experimental to test on more projects first, but it is considered to be low-risk. Run next build with --experimental-debug-memory-usage Starting in 14.2.0, you can run next build --experimental-debug-memory-usage to run the build in a mode where Next.js will print out information about memory usage continuously throughout the build, such as heap usage and garbage collection statistics. Heap snapshots will also be taken automatically when memory usage gets close to the configured limit. > Good to know: This feature is not compatible with the Webpack build worker option which is auto-enabled unless you have custom webpack config. Record a heap profile To look for memory issues, you can record a heap profile from Node.js and load it in Chrome DevTools to identify potential sources of memory leaks. In your terminal, pass the --heap-prof flag to Node.js when starting your Next.js build: At the end of the build, a .heapprofile file will be created by Node.js. In Chrome DevTools, you can open the Memory tab and click on the \"Load Profile\" button to visualize the file. Analyze a snapshot of the heap You can use an inspector tool to analyze the memory usage of the application. When running the next build or next dev command, add NODEOPTIONS=--inspect to the beginning of the command. This will expose the inspector agent on the default port. If you wish to break before any user code starts, you can pass --inspect-brk instead. While the process is running, you can use a tool such as Chrome DevTools to connect to the debugging port to record and analyze a snapshot of the heap to see what memory is being retained. Starting in 14.2.0, you can also run next build with the --experimental-debug-memory-usage flag to make it easier to take heap snapshots. While running in this mode, you can send a SIGUSR2 signal to the process at any point, and the process will take a heap snapshot. The heap snapshot will be saved to the project root of the Next.js application and can be loaded in any heap analyzer, such as Chrome DevTools, to see what memory is retained. This mode is not yet compatible with Webpack build workers. See how to record and analyze heap snapshots for more information. Webpack build worker The Webpack build worker allows you to run Webpack compilations inside a separate Node.js worker which will decrease memory usage of your application during builds. This option is enabled by default if your application does not have a custom Webpack configuration starting in v14.1.0. If you are using an older version of Next.js or you have a custom Webpack configuration, you can enable this option by setting experimental.webpackBuildWorker: true inside your next.config.js. > Good to know: This feature may not be compatible with all custom Webpack plugins. Disable Webpack cache The Webpack cache saves generated Webpack modules in memory and/or to disk to improve the speed of builds. This can help with performance, but it will also increase the memory usage of your application to store the cached data. You can disable this behavior by adding a custom Webpack configuration to your application: Disable static analysis Typechecking may require a lot of memory, especially in large projects. However, most projects have a dedicated CI runner that already handles these tasks. When the build produces out-of-memory issues during the \"Running TypeScript\" step, you can disable this task during builds: - Ignoring TypeScript Errors Keep in mind that this may produce faulty deploys due to type errors. We strongly recommend only promoting builds to production after static analysis has completed. If you deploy to Vercel, you can check out the guide for staging deployments to learn how to promote builds to production after custom tasks have succeeded. Disable source maps Generating source maps consumes extra memory during the build process. You can disable source map generation by adding productionBrowserSourceMaps: false and experimental.serverSourceMaps: false to your Next.js configuration. When using the cacheComponents feature, Next.js will use source maps by default during the prerender phase of next build. If you consistently encounter memory issues during that phase (after \"Generating static pages\"), you can try disabling source maps in that phase by adding enablePrerenderSourceMaps: false to your Next.js configuration. > Good to know: Some plugins may turn on source maps and may require custom configuration to disable. Edge memory issues Next.js v14.1.3 fixed a memory issue when using the Edge runtime. Please update to this version (or later) to see if it addresses your issue. Preloading Entries When the Next.js server starts, it preloads each page's JavaScript modules into memory, rather than at request time. This optimization allows for faster response times, in exchange for a larger initial memory footprint. To disable this optimization, set the experimental.preloadEntriesOnStart flag to false. Next.js doesn't unload these JavaScript modules, meaning that even with this optimization disabled, the memory footprint of your Next.js server will eventually be the same if all pages are eventually requested.",
    "excerpt": "As applications grow and become more feature rich, they can demand more resources when developing locally or creating production builds. Let's explore some strategies and techniques to optimize memory...",
    "url": "https://nextjs.org/docs/01-app/02-guides/memory-usage"
  },
  {
    "id": "01-app-02-guides-migrating-app-router-migration",
    "path": "01-app\\02-guides\\migrating\\app-router-migration.mdx",
    "title": "How to migrate from Pages to the App Router",
    "description": "Learn how to upgrade your existing Next.js application from the Pages Router to the App Router.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Upgrading",
        "slug": "upgrading"
      },
      {
        "level": 3,
        "text": "Node.js Version",
        "slug": "nodejs-version"
      },
      {
        "level": 3,
        "text": "Next.js Version",
        "slug": "nextjs-version"
      },
      {
        "level": 3,
        "text": "ESLint Version",
        "slug": "eslint-version"
      },
      {
        "level": 2,
        "text": "Next Steps",
        "slug": "next-steps"
      },
      {
        "level": 2,
        "text": "Upgrading New Features",
        "slug": "upgrading-new-features"
      },
      {
        "level": 3,
        "text": " Component",
        "slug": "-component"
      },
      {
        "level": 3,
        "text": " Component",
        "slug": "-component"
      },
      {
        "level": 3,
        "text": " Component",
        "slug": "-component"
      },
      {
        "level": 3,
        "text": "Font Optimization",
        "slug": "font-optimization"
      },
      {
        "level": 2,
        "text": "Migrating from  to ",
        "slug": "migrating-from-to-"
      },
      {
        "level": 3,
        "text": "Step 1: Creating the  directory",
        "slug": "step-1-creating-the-directory"
      },
      {
        "level": 3,
        "text": "Step 2: Creating a Root Layout",
        "slug": "step-2-creating-a-root-layout"
      },
      {
        "level": 4,
        "text": "Migrating  and ",
        "slug": "migrating-and-"
      },
      {
        "level": 4,
        "text": "Migrating the  pattern to Layouts (Optional)",
        "slug": "migrating-the-pattern-to-layouts-optional"
      },
      {
        "level": 3,
        "text": "Step 3: Migrating ",
        "slug": "step-3-migrating-"
      },
      {
        "level": 3,
        "text": "Step 4: Migrating Pages",
        "slug": "step-4-migrating-pages"
      },
      {
        "level": 3,
        "text": "Step 5: Migrating Routing Hooks",
        "slug": "step-5-migrating-routing-hooks"
      },
      {
        "level": 4,
        "text": "Sharing components between  and ",
        "slug": "sharing-components-between-and-"
      },
      {
        "level": 3,
        "text": "Step 6: Migrating Data Fetching Methods",
        "slug": "step-6-migrating-data-fetching-methods"
      },
      {
        "level": 4,
        "text": "Server-side Rendering ()",
        "slug": "server-side-rendering-"
      },
      {
        "level": 4,
        "text": "Accessing Request Object",
        "slug": "accessing-request-object"
      },
      {
        "level": 4,
        "text": "Static Site Generation ()",
        "slug": "static-site-generation-"
      },
      {
        "level": 4,
        "text": "Dynamic paths ()",
        "slug": "dynamic-paths-"
      },
      {
        "level": 4,
        "text": "Replacing ",
        "slug": "replacing-"
      },
      {
        "level": 4,
        "text": "Incremental Static Regeneration ( with )",
        "slug": "incremental-static-regeneration--with-"
      },
      {
        "level": 4,
        "text": "API Routes",
        "slug": "api-routes"
      },
      {
        "level": 4,
        "text": "Single-Page Applications",
        "slug": "single-page-applications"
      },
      {
        "level": 3,
        "text": "Step 7: Styling",
        "slug": "step-7-styling"
      },
      {
        "level": 4,
        "text": "Tailwind CSS",
        "slug": "tailwind-css"
      },
      {
        "level": 2,
        "text": "Using App Router together with Pages Router",
        "slug": "using-app-router-together-with-pages-router"
      },
      {
        "level": 2,
        "text": "Codemods",
        "slug": "codemods"
      }
    ],
    "codeBlocks": [
      {
        "language": "bash",
        "code": "npm install next@latest react@latest react-dom@latest",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "npm install -D eslint-config-next@latest",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\n// Next.js 12: `<a>` has to be nested otherwise it's excluded\r\n<Link href=\"/about\">\r\n  <a>About</a>\r\n</Link>\r\n\r\n// Next.js 13: `<Link>` always renders `<a>` under the hood\r\n<Link href=\"/about\">\r\n  About\r\n</Link>",
        "context": ""
      },
      {
        "language": "bash",
        "code": "npm install next@latest",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "export default function RootLayout({\r\n  // Layouts must accept a children prop.\r\n  // This will be populated with nested layouts or pages\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function RootLayout({\r\n  // Layouts must accept a children prop.\r\n  // This will be populated with nested layouts or pages\r\n  children,\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import type { Metadata } from 'next'\r\n\r\nexport const metadata: Metadata = {\r\n  title: 'Home',\r\n  description: 'Welcome to Next.js',\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  title: 'Home',\r\n  description: 'Welcome to Next.js',\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function DashboardLayout({ children }) {\r\n  return (\r\n    <div>\r\n      <h2>My Dashboard</h2>\r\n      {children}\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"components/DashboardLayout.js\""
      },
      {
        "language": "jsx",
        "code": "import DashboardLayout from '../components/DashboardLayout'\r\n\r\nexport default function Page() {\r\n  return <p>My Page</p>\r\n}\r\n\r\nPage.getLayout = function getLayout(page) {\r\n  return <DashboardLayout>{page}</DashboardLayout>\r\n}",
        "context": "filename=\"pages/dashboard/index.js\""
      },
      {
        "language": "jsx",
        "code": "export default function Page() {\r\n  return <p>My Page</p>\r\n}",
        "context": "filename=\"app/dashboard/page.js\""
      },
      {
        "language": "jsx",
        "code": "'use client' // this directive should be at top of the file, before any imports.\r\n\r\n// This is a Client Component\r\nexport default function DashboardLayout({ children }) {\r\n  return (\r\n    <div>\r\n      <h2>My Dashboard</h2>\r\n      {children}\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/dashboard/DashboardLayout.js\""
      },
      {
        "language": "jsx",
        "code": "import DashboardLayout from './DashboardLayout'\r\n\r\n// This is a Server Component\r\nexport default function Layout({ children }) {\r\n  return <DashboardLayout>{children}</DashboardLayout>\r\n}",
        "context": "filename=\"app/dashboard/layout.js\""
      },
      {
        "language": "tsx",
        "code": "import Head from 'next/head'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <Head>\r\n        <title>My page title</title>\r\n      </Head>\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"pages/index.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Head from 'next/head'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <Head>\r\n        <title>My page title</title>\r\n      </Head>\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"pages/index.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import type { Metadata } from 'next'\r\n\r\nexport const metadata: Metadata = {\r\n  title: 'My Page Title',\r\n}\r\n\r\nexport default function Page() {\r\n  return '...'\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  title: 'My Page Title',\r\n}\r\n\r\nexport default function Page() {\r\n  return '...'\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\n// This is a Client Component (same as components in the `pages` directory)\r\n// It receives data as props, has access to state and effects, and is\r\n// prerendered on the server during the initial page load.\r\nexport default function HomePage({ recentPosts }) {\r\n  return (\r\n    <div>\r\n      {recentPosts.map((post) => (\r\n        <div key={post.id}>{post.title}</div>\r\n      ))}\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/home-page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\n// This is a Client Component. It receives data as props and\r\n// has access to state and effects just like Page components\r\n// in the `pages` directory.\r\nexport default function HomePage({ recentPosts }) {\r\n  return (\r\n    <div>\r\n      {recentPosts.map((post) => (\r\n        <div key={post.id}>{post.title}</div>\r\n      ))}\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/home-page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "// Import your Client Component\r\nimport HomePage from './home-page'\r\n\r\nasync function getPosts() {\r\n  const res = await fetch('https://...')\r\n  const posts = await res.json()\r\n  return posts\r\n}\r\n\r\nexport default async function Page() {\r\n  // Fetch data directly in a Server Component\r\n  const recentPosts = await getPosts()\r\n  // Forward fetched data to your Client Component\r\n  return <HomePage recentPosts={recentPosts} />\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "// Import your Client Component\r\nimport HomePage from './home-page'\r\n\r\nasync function getPosts() {\r\n  const res = await fetch('https://...')\r\n  const posts = await res.json()\r\n  return posts\r\n}\r\n\r\nexport default async function Page() {\r\n  // Fetch data directly in a Server Component\r\n  const recentPosts = await getPosts()\r\n  // Forward fetched data to your Client Component\r\n  return <HomePage recentPosts={recentPosts} />\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { useRouter, usePathname, useSearchParams } from 'next/navigation'\r\n\r\nexport default function ExampleClientComponent() {\r\n  const router = useRouter()\r\n  const pathname = usePathname()\r\n  const searchParams = useSearchParams()\r\n\r\n  // ...\r\n}",
        "context": "filename=\"app/example-client-component.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { useRouter, usePathname, useSearchParams } from 'next/navigation'\r\n\r\nexport default function ExampleClientComponent() {\r\n  const router = useRouter()\r\n  const pathname = usePathname()\r\n  const searchParams = useSearchParams()\r\n\r\n  // ...\r\n}",
        "context": "filename=\"app/example-client-component.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default async function Page() {\r\n  // This request should be cached until manually invalidated.\r\n  // Similar to `getStaticProps`.\r\n  // `force-cache` is the default and can be omitted.\r\n  const staticData = await fetch(`https://...`, { cache: 'force-cache' })\r\n\r\n  // This request should be refetched on every request.\r\n  // Similar to `getServerSideProps`.\r\n  const dynamicData = await fetch(`https://...`, { cache: 'no-store' })\r\n\r\n  // This request should be cached with a lifetime of 10 seconds.\r\n  // Similar to `getStaticProps` with the `revalidate` option.\r\n  const revalidatedData = await fetch(`https://...`, {\r\n    next: { revalidate: 10 },\r\n  })\r\n\r\n  return <div>...</div>\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default async function Page() {\r\n  // This request should be cached until manually invalidated.\r\n  // Similar to `getStaticProps`.\r\n  // `force-cache` is the default and can be omitted.\r\n  const staticData = await fetch(`https://...`, { cache: 'force-cache' })\r\n\r\n  // This request should be refetched on every request.\r\n  // Similar to `getServerSideProps`.\r\n  const dynamicData = await fetch(`https://...`, { cache: 'no-store' })\r\n\r\n  // This request should be cached with a lifetime of 10 seconds.\r\n  // Similar to `getStaticProps` with the `revalidate` option.\r\n  const revalidatedData = await fetch(`https://...`, {\r\n    next: { revalidate: 10 },\r\n  })\r\n\r\n  return <div>...</div>\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "// `pages` directory\r\n\r\nexport async function getServerSideProps() {\r\n  const res = await fetch(`https://...`)\r\n  const projects = await res.json()\r\n\r\n  return { props: { projects } }\r\n}\r\n\r\nexport default function Dashboard({ projects }) {\r\n  return (\r\n    <ul>\r\n      {projects.map((project) => (\r\n        <li key={project.id}>{project.name}</li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}",
        "context": "filename=\"pages/dashboard.js\""
      },
      {
        "language": "tsx",
        "code": "// `app` directory\r\n\r\n// This function can be named anything\r\nasync function getProjects() {\r\n  const res = await fetch(`https://...`, { cache: 'no-store' })\r\n  const projects = await res.json()\r\n\r\n  return projects\r\n}\r\n\r\nexport default async function Dashboard() {\r\n  const projects = await getProjects()\r\n\r\n  return (\r\n    <ul>\r\n      {projects.map((project) => (\r\n        <li key={project.id}>{project.name}</li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}",
        "context": "filename=\"app/dashboard/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "// `app` directory\r\n\r\n// This function can be named anything\r\nasync function getProjects() {\r\n  const res = await fetch(`https://...`, { cache: 'no-store' })\r\n  const projects = await res.json()\r\n\r\n  return projects\r\n}\r\n\r\nexport default async function Dashboard() {\r\n  const projects = await getProjects()\r\n\r\n  return (\r\n    <ul>\r\n      {projects.map((project) => (\r\n        <li key={project.id}>{project.name}</li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}",
        "context": "filename=\"app/dashboard/page.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "// `pages` directory\r\n\r\nexport async function getServerSideProps({ req, query }) {\r\n  const authHeader = req.getHeaders()['authorization'];\r\n  const theme = req.cookies['theme'];\r\n\r\n  return { props: { ... }}\r\n}\r\n\r\nexport default function Page(props) {\r\n  return ...\r\n}",
        "context": "filename=\"pages/index.js\""
      },
      {
        "language": "tsx",
        "code": "// `app` directory\r\nimport { cookies, headers } from 'next/headers'\r\n\r\nasync function getData() {\r\n  const authHeader = (await headers()).get('authorization')\r\n\r\n  return '...'\r\n}\r\n\r\nexport default async function Page() {\r\n  // You can use `cookies` or `headers` inside Server Components\r\n  // directly or in your data fetching function\r\n  const theme = (await cookies()).get('theme')\r\n  const data = await getData()\r\n  return '...'\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "// `app` directory\r\nimport { cookies, headers } from 'next/headers'\r\n\r\nasync function getData() {\r\n  const authHeader = (await headers()).get('authorization')\r\n\r\n  return '...'\r\n}\r\n\r\nexport default async function Page() {\r\n  // You can use `cookies` or `headers` inside Server Components\r\n  // directly or in your data fetching function\r\n  const theme = (await cookies()).get('theme')\r\n  const data = await getData()\r\n  return '...'\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "// `pages` directory\r\n\r\nexport async function getStaticProps() {\r\n  const res = await fetch(`https://...`)\r\n  const projects = await res.json()\r\n\r\n  return { props: { projects } }\r\n}\r\n\r\nexport default function Index({ projects }) {\r\n  return projects.map((project) => <div>{project.name}</div>)\r\n}",
        "context": "filename=\"pages/index.js\""
      },
      {
        "language": "jsx",
        "code": "// `app` directory\r\n\r\n// This function can be named anything\r\nasync function getProjects() {\r\n  const res = await fetch(`https://...`)\r\n  const projects = await res.json()\r\n\r\n  return projects\r\n}\r\n\r\nexport default async function Index() {\r\n  const projects = await getProjects()\r\n\r\n  return projects.map((project) => <div>{project.name}</div>)\r\n}",
        "context": "filename=\"app/page.js\""
      },
      {
        "language": "jsx",
        "code": "// `pages` directory\r\nimport PostLayout from '@/components/post-layout'\r\n\r\nexport async function getStaticPaths() {\r\n  return {\r\n    paths: [{ params: { id: '1' } }, { params: { id: '2' } }],\r\n  }\r\n}\r\n\r\nexport async function getStaticProps({ params }) {\r\n  const res = await fetch(`https://.../posts/${params.id}`)\r\n  const post = await res.json()\r\n\r\n  return { props: { post } }\r\n}\r\n\r\nexport default function Post({ post }) {\r\n  return <PostLayout post={post} />\r\n}",
        "context": "filename=\"pages/posts/[id].js\""
      },
      {
        "language": "jsx",
        "code": "// `app` directory\r\nimport PostLayout from '@/components/post-layout'\r\n\r\nexport async function generateStaticParams() {\r\n  return [{ id: '1' }, { id: '2' }]\r\n}\r\n\r\nasync function getPost(params) {\r\n  const res = await fetch(`https://.../posts/${(await params).id}`)\r\n  const post = await res.json()\r\n\r\n  return post\r\n}\r\n\r\nexport default async function Post({ params }) {\r\n  const post = await getPost(params)\r\n\r\n  return <PostLayout post={post} />\r\n}",
        "context": "filename=\"app/posts/[id]/page.js\""
      },
      {
        "language": "jsx",
        "code": "// `pages` directory\r\n\r\nexport async function getStaticPaths() {\r\n  return {\r\n    paths: [],\r\n    fallback: 'blocking'\r\n  };\r\n}\r\n\r\nexport async function getStaticProps({ params }) {\r\n  ...\r\n}\r\n\r\nexport default function Post({ post }) {\r\n  return ...\r\n}",
        "context": "filename=\"pages/posts/[id].js\""
      },
      {
        "language": "jsx",
        "code": "// `app` directory\r\n\r\nexport const dynamicParams = true;\r\n\r\nexport async function generateStaticParams() {\r\n  return [...]\r\n}\r\n\r\nasync function getPost(params) {\r\n  ...\r\n}\r\n\r\nexport default async function Post({ params }) {\r\n  const post = await getPost(params);\r\n\r\n  return ...\r\n}",
        "context": "filename=\"app/posts/[id]/page.js\""
      },
      {
        "language": "jsx",
        "code": "// `pages` directory\r\n\r\nexport async function getStaticProps() {\r\n  const res = await fetch(`https://.../posts`)\r\n  const posts = await res.json()\r\n\r\n  return {\r\n    props: { posts },\r\n    revalidate: 60,\r\n  }\r\n}\r\n\r\nexport default function Index({ posts }) {\r\n  return (\r\n    <Layout>\r\n      <PostList posts={posts} />\r\n    </Layout>\r\n  )\r\n}",
        "context": "filename=\"pages/index.js\""
      },
      {
        "language": "jsx",
        "code": "// `app` directory\r\n\r\nasync function getPosts() {\r\n  const res = await fetch(`https://.../posts`, { next: { revalidate: 60 } })\r\n  const data = await res.json()\r\n\r\n  return data.posts\r\n}\r\n\r\nexport default async function PostList() {\r\n  const posts = await getPosts()\r\n\r\n  return posts.map((post) => <div>{post.name}</div>)\r\n}",
        "context": "filename=\"app/page.js\""
      },
      {
        "language": "ts",
        "code": "export async function GET(request: Request) {}",
        "context": "filename=\"app/api/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export async function GET(request) {}",
        "context": "filename=\"app/api/route.js\" switcher"
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  content: [\r\n    './app/**/*.{js,ts,jsx,tsx,mdx}', // <-- Add this line\r\n    './pages/**/*.{js,ts,jsx,tsx,mdx}',\r\n    './components/**/*.{js,ts,jsx,tsx,mdx}',\r\n  ],\r\n}",
        "context": "filename=\"tailwind.config.js\""
      },
      {
        "language": "jsx",
        "code": "import '../styles/globals.css'\r\n\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\""
      }
    ],
    "content": "This guide will help you: - Update your Next.js application from version 12 to version 13 - Upgrade features that work in both the pages and the app directories - Incrementally migrate your existing application from pages to app Upgrading Node.js Version The minimum Node.js version is now v18.17. See the Node.js documentation for more information. Next.js Version To update to Next.js version 13, run the following command using your preferred package manager: ESLint Version If you're using ESLint, you need to upgrade your ESLint version: > Good to know: You may need to restart the ESLint server in VS Code for the ESLint changes to take effect. Open the Command Palette (cmd+shift+p on Mac; ctrl+shift+p on Windows) and search for ESLint: Restart ESLint Server. Next Steps After you've updated, see the following sections for next steps: - Upgrade new features: A guide to help you upgrade to new features such as the improved Image and Link Components. - Migrate from the pages to app directory: A step-by-step guide to help you incrementally migrate from the pages to the app directory. Upgrading New Features Next.js 13 introduced the new App Router with new features and conventions. The new Router is available in the app directory and co-exists with the pages directory. Upgrading to Next.js 13 does not require using the App Router. You can continue using pages with new features that work in both directories, such as the updated Image component, Link component, Script component, and Font optimization. Component Next.js 12 introduced new improvements to the Image Component with a temporary import: next/future/image. These improvements included less client-side JavaScript, easier ways to extend and style images, better accessibility, and native browser lazy loading. In version 13, this new behavior is now the default for next/image. There are two codemods to help you migrate to the new Image Component: - next-image-to-legacy-image codemod: Safely and automatically renames next/image imports to next/legacy/image. Existing components will maintain the same behavior. - next-image-experimental codemod: Dangerously adds inline styles and removes unused props. This will change the behavior of existing components to match the new defaults. To use this codemod, you need to run the next-image-to-legacy-image codemod first. Component The Component no longer requires manually adding an tag as a child. This behavior was added as an experimental option in version 12.2 and is now the default. In Next.js 13, always renders and allows you to forward props to the underlying tag. For example: To upgrade your links to Next.js 13, you can use the new-link codemod. Component The behavior of next/script has been updated to support both pages and app, but some changes need to be made to ensure a smooth migration: - Move any beforeInteractive scripts you previously included in document.js to the root layout file (app/layout.tsx). - The experimental worker strategy does not yet work in app and scripts denoted with this strategy will either have to be removed or modified to use a different strategy (e.g. lazyOnload). - onLoad, onReady, and onError handlers will not work in Server Components so make sure to move them to a Client Component or remove them altogether. Font Optimization Previously, Next.js helped you optimize fonts by inlining font CSS. Version 13 introduces the new next/font module which gives you the ability to customize your font loading experience while still ensuring great performance and privacy. next/font is supported in both the pages and app directories. While inlining CSS still works in pages, it does not work in app. You should use next/font instead. See the Font Optimization page to learn how to use next/font. Migrating from pages to app > 🎥 Watch: Learn how to incrementally adopt the App Router → YouTube (16 minutes). Moving to the App Router may be the first time using React features that Next.js builds on top of such as Server Components, Suspense, and more. When combined with new Next.js features such as special files and layouts, migration means new concepts, mental models, and behavioral changes to learn. We recommend reducing the combined complexity of these updates by breaking down your migration into smaller steps. The app directory is intentionally designed to work simultaneously with the pages directory to allow for incremental page-by-page migration. - The app directory supports nested routes and layouts. Learn more. - Use nested folders to define routes and a special page.js file to make a route segment publicly accessible. Learn more. - Special file conventions are used to create UI for each route segment. The most common special files are page.js and layout.js. - Use page.js to define UI unique to a route. - Use layout.js to define UI that is shared across multiple routes. - .js, .jsx, or .tsx file extensions can be used for special files. - You can colocate other files inside the app directory such as components, styles, tests, and more. Learn more. - Data fetching functions like getServerSideProps and getStaticProps have been replaced with a new API inside app. getStaticPaths has been replaced with generateStaticParams. - pages/app.js and pages/document.js have been replaced with a single app/layout.js root layout. Learn more. - pages/error.js has been replaced with more granular error.js special files. Learn more. - pages/404.js has been replaced with the not-found.js file. - pages/api/ API Routes have been replaced with the route.js (Route Handler) special file. Step 1: Creating the app directory Update to the latest Next.js version (requires 13.4 or greater): Then, create a new app directory at the root of your project (or src/ directory). Step 2: Creating a Root Layout Create a new app/layout.tsx file inside the app directory. This is a root layout that will apply to all routes inside app. - The app directory must include a root layout. - The root layout must define , and tags since Next.js does not automatically create them - The root layout replaces the pages/app.tsx and pages/document.tsx files. - .js, .jsx, or .tsx extensions can be used for layout files. To manage HTML elements, you can use the built-in SEO support: Migrating document.js and app.js If you have an existing app or document file, you can copy the contents (e.g. global styles) to the root layout (app/layout.tsx). Styles in app/layout.tsx will not apply to pages/. You should keep app/document while migrating to prevent your pages/ routes from breaking. Once fully migrated, you can then safely delete them. If you are using any React Context providers, they will need to be moved to a Client Component. Migrating the getLayout() pattern to Layouts (Optional) Next.js recommended adding a property to Page components to achieve per-page layouts in the pages directory. This pattern can be replaced with native support for nested layouts in the app directory. See before and after example Before After - Remove the Page.getLayout property from pages/dashboard/index.js and follow the steps for migrating pages to the app directory. - Move the contents of DashboardLayout into a new Client Component to retain pages directory behavior. - Import the DashboardLayout into a new layout.js file inside the app directory. - You can incrementally move non-interactive parts of DashboardLayout.js (Client Component) into layout.js (Server Component) to reduce the amount of component JavaScript you send to the client. Step 3: Migrating next/head In the pages directory, the next/head React component is used to manage HTML elements such as title and meta . In the app directory, next/head is replaced with the new built-in SEO support. Before: After: See all metadata options. Step 4: Migrating Pages - Pages in the app directory are Server Components by default. This is different from the pages directory where pages are Client Components. - Data fetching has changed in app. getServerSideProps, getStaticProps and getInitialProps have been replaced with a simpler API. - The app directory uses nested folders to define routes and a special page.js file to make a route segment publicly accessible. - | pages Directory | app Directory | Route | | ----------------- | --------------------- | -------------- | | index.js | page.js | / | | about.js | about/page.js | /about | | blog/[slug].js | blog/[slug]/page.js | /blog/post-1 | We recommend breaking down the migration of a page into two main steps: - Step 1: Move the default exported Page Component into a new Client Component. - Step 2: Import the new Client Component into a new page.js file inside the app directory. > Good to know: This is the easiest migration path because it has the most comparable behavior to the pages directory. Step 1: Create a new Client Component - Create a new separate file inside the app directory (i.e. app/home-page.tsx or similar) that exports a Client Component. To define Client Components, add the 'use client' directive to the top of the file (before any imports). - Similar to the Pages Router, there is an optimization step to prerender Client Components to static HTML on the initial page load. - Move the default exported page component from pages/index.js to app/home-page.tsx. Step 2: Create a new page - Create a new app/page.tsx file inside the app directory. This is a Server Component by default. - Import the home-page.tsx Client Component into the page. - If you were fetching data in pages/index.js, move the data fetching logic directly into the Server Component using the new data fetching APIs. See the data fetching upgrade guide for more details. - If your previous page used useRouter, you'll need to update to the new routing hooks. Learn more. - Start your development server and visit http://localhost:3000. You should see your existing index route, now served through the app directory. Step 5: Migrating Routing Hooks A new router has been added to support the new behavior in the app directory. In app, you should use the three new hooks imported from next/navigation: useRouter(), usePathname(), and useSearchParams(). - The new useRouter hook is imported from next/navigation and has different behavior to the useRouter hook in pages which is imported from next/router. - The useRouter hook imported from next/router is not supported in the app directory but can continue to be used in the pages directory. - The new useRouter does not return the pathname string. Use the separate usePathname hook instead. - The new useRouter does not return the query object. Search parameters and dynamic route parameters are now separate. Use the useSearchParams and useParams hooks instead. - You can use useSearchParams and usePathname together to listen to page changes. See the Router Events section for more details. - These new hooks are only supported in Client Components. They cannot be used in Server Components. In addition, the new useRouter hook has the following changes: - isFallback has been removed because fallback has been replaced. - The locale, locales, defaultLocales, domainLocales values have been removed because built-in i18n Next.js features are no longer necessary in the app directory. Learn more about i18n. - basePath has been removed. The alternative will not be part of useRouter. It has not yet been implemented. - asPath has been removed because the concept of as has been removed from the new router. - isReady has been removed because it is no longer necessary. During static rendering, any component that uses the useSearchParams() hook will skip the prerendering step and instead be rendered on the client at runtime. - route has been removed. usePathname or useSelectedLayoutSegments() provide an alternative. View the useRouter() API reference. Sharing components between pages and app To keep components compatible between the pages and app routers, refer to the useRouter hook from next/compat/router. This is the useRouter hook from the pages directory, but intended to be used while sharing components between routers. Once you are ready to use it only on the app router, update to the new useRouter from next/navigation. Step 6: Migrating Data Fetching Methods The pages directory uses getServerSideProps and getStaticProps to fetch data for pages. Inside the app directory, these previous data fetching functions are replaced with a simpler API built on top of fetch() and async React Server Components. Server-side Rendering (getServerSideProps) In the pages directory, getServerSideProps is used to fetch data on the server and forward props to the default exported React component in the file. The initial HTML for the page is prerendered from the server, followed by \"hydrating\" the page in the browser (making it interactive). In the App Router, we can colocate our data fetching inside our React components using Server Components. This allows us to send less JavaScript to the client, while maintaining the rendered HTML from the server. By setting the cache option to no-store, we can indicate that the fetched data should never be cached. This is similar to getServerSideProps in the pages directory. Accessing Request Object In the pages directory, you can retrieve request-based data based on the Node.js HTTP API. For example, you can retrieve the req object from getServerSideProps and use it to retrieve the request's cookies and headers. The app directory exposes new read-only functions to retrieve request data: - headers: Based on the Web Headers API, and can be used inside Server Components to retrieve request headers. - cookies: Based on the Web Cookies API, and can be used inside Server Components to retrieve cookies. Static Site Generation (getStaticProps) In the pages directory, the getStaticProps function is used to pre-render a page at build time. This function can be used to fetch data from an external API or directly from a database, and pass this data down to the entire page as it's being generated during the build. In the app directory, data fetching with fetch() will default to cache: 'force-cache', which will cache the request data until manually invalidated. This is similar to getStaticProps in the pages directory. Dynamic paths (getStaticPaths) In the pages directory, the getStaticPaths function is used to define the dynamic paths that should be pre-rendered at build time. In the app directory, getStaticPaths is replaced with generateStaticParams. generateStaticParams behaves similarly to getStaticPaths, but has a simplified API for returning route parameters and can be used inside layouts. The return shape of generateStaticParams is an array of segments instead of an array of nested param objects or a string of resolved paths. Using the name generateStaticParams is more appropriate than getStaticPaths for the new model in the app directory. The get prefix is replaced with a more descriptive generate, which sits better alone now that getStaticProps and getServerSideProps are no longer necessary. The Paths suffix is replaced by Params, which is more appropriate for nested routing with multiple dynamic segments. --- Replacing fallback In the pages directory, the fallback property returned from getStaticPaths is used to define the behavior of a page that isn't pre-rendered at build time. This property can be set to true to show a fallback page while the page is being generated, false to show a 404 page, or blocking to generate the page at request time. In the app directory the config.dynamicParams property controls how params outside of generateStaticParams are handled: - true: (default) Dynamic segments not included in generateStaticParams are generated on demand. - false: Dynamic segments not included in generateStaticParams will return a 404. This replaces the fallback: true | false | 'blocking' option of getStaticPaths in the pages directory. The fallback: 'blocking' option is not included in dynamicParams because the difference between 'blocking' and true is negligible with streaming. With dynamicParams set to true (the default), when a route segment is requested that hasn't been generated, it will be server-rendered and cached. Incremental Static Regeneration (getStaticProps with revalidate) In the pages directory, the getStaticProps function allows you to add a revalidate field to automatically regenerate a page after a certain amount of time. In the app directory, data fetching with fetch() can use revalidate, which will cache the request for the specified amount of seconds. API Routes API Routes continue to work in the pages/api directory without any changes. However, they have been replaced by Route Handlers in the app directory. Route Handlers allow you to create custom request handlers for a given route using the Web Request and Response APIs. > Good to know: If you previously used API routes to call an external API from the client, you can now use Server Components instead to securely fetch data. Learn more about data fetching. Single-Page Applications If you are also migrating to Next.js from a Single-Page Application (SPA) at the same time, see our documentation to learn more. Step 7: Styling In the pages directory, global stylesheets are restricted to only pages/app.js. With the app directory, this restriction has been lifted. Global styles can be added to any layout, page, or component. - CSS Modules - Tailwind CSS - Global Styles - CSS-in-JS - External Stylesheets - Sass Tailwind CSS If you're using Tailwind CSS, you'll need to add the app directory to your tailwind.config.js file: You'll also need to import your global styles in your app/layout.js file: Learn more about styling with Tailwind CSS Using App Router together with Pages Router When navigating between routes served by the different Next.js routers, there will be a hard navigation. Automatic link prefetching with next/link will not prefetch across routers. Instead, you can optimize navigations between App Router and Pages Router to retain the prefetched and fast page transitions. Learn more. Codemods Next.js provides Codemod transformations to help upgrade your codebase when a feature is deprecated. See Codemods for more information.",
    "excerpt": "This guide will help you: - Update your Next.js application from version 12 to version 13 - Upgrade features that work in both the pages and the app directories - Incrementally migrate your existing a...",
    "url": "https://nextjs.org/docs/01-app/02-guides/migrating/app-router-migration"
  },
  {
    "id": "01-app-02-guides-migrating-from-create-react-app",
    "path": "01-app\\02-guides\\migrating\\from-create-react-app.mdx",
    "title": "How to migrate from Create React App to Next.js",
    "description": "Learn how to migrate your existing React application from Create React App to Next.js.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Why Switch?",
        "slug": "why-switch"
      },
      {
        "level": 3,
        "text": "Slow initial page loading time",
        "slug": "slow-initial-page-loading-time"
      },
      {
        "level": 3,
        "text": "No automatic code splitting",
        "slug": "no-automatic-code-splitting"
      },
      {
        "level": 3,
        "text": "Network waterfalls",
        "slug": "network-waterfalls"
      },
      {
        "level": 3,
        "text": "Fast and intentional loading states",
        "slug": "fast-and-intentional-loading-states"
      },
      {
        "level": 3,
        "text": "Choose the data fetching strategy",
        "slug": "choose-the-data-fetching-strategy"
      },
      {
        "level": 3,
        "text": "Proxy",
        "slug": "proxy"
      },
      {
        "level": 3,
        "text": "Built-in Optimizations",
        "slug": "built-in-optimizations"
      },
      {
        "level": 2,
        "text": "Migration Steps",
        "slug": "migration-steps"
      },
      {
        "level": 3,
        "text": "Step 1: Install the Next.js Dependency",
        "slug": "step-1-install-the-nextjs-dependency"
      },
      {
        "level": 3,
        "text": "Step 2: Create the Next.js Configuration File",
        "slug": "step-2-create-the-nextjs-configuration-file"
      },
      {
        "level": 3,
        "text": "Step 3: Create the Root Layout",
        "slug": "step-3-create-the-root-layout"
      },
      {
        "level": 3,
        "text": "Step 4: Metadata",
        "slug": "step-4-metadata"
      },
      {
        "level": 3,
        "text": "Step 5: Styles",
        "slug": "step-5-styles"
      },
      {
        "level": 3,
        "text": "Step 6: Create the Entrypoint Page",
        "slug": "step-6-create-the-entrypoint-page"
      },
      {
        "level": 3,
        "text": "Step 7: Add a Client-Only Entrypoint",
        "slug": "step-7-add-a-client-only-entrypoint"
      },
      {
        "level": 3,
        "text": "Step 8: Update Static Image Imports",
        "slug": "step-8-update-static-image-imports"
      },
      {
        "level": 3,
        "text": "Step 9: Migrate Environment Variables",
        "slug": "step-9-migrate-environment-variables"
      },
      {
        "level": 3,
        "text": "Step 10: Update Scripts in ",
        "slug": "step-10-update-scripts-in-"
      },
      {
        "level": 3,
        "text": "Step 11: Clean Up",
        "slug": "step-11-clean-up"
      },
      {
        "level": 2,
        "text": "Additional Considerations",
        "slug": "additional-considerations"
      },
      {
        "level": 3,
        "text": "Using a Custom  in CRA",
        "slug": "using-a-custom-in-cra"
      },
      {
        "level": 3,
        "text": "Handling a Custom ",
        "slug": "handling-a-custom-"
      },
      {
        "level": 3,
        "text": "Proxying API Requests",
        "slug": "proxying-api-requests"
      },
      {
        "level": 3,
        "text": "Custom Webpack",
        "slug": "custom-webpack"
      },
      {
        "level": 3,
        "text": "TypeScript Setup",
        "slug": "typescript-setup"
      },
      {
        "level": 2,
        "text": "Bundler Compatibility",
        "slug": "bundler-compatibility"
      },
      {
        "level": 2,
        "text": "Next Steps",
        "slug": "next-steps"
      }
    ],
    "codeBlocks": [
      {
        "language": "bash",
        "code": "npm install next@latest",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "js",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  output: 'export', // Outputs a Single-Page Application (SPA)\r\n  distDir: 'build', // Changes the build output directory to `build`\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\""
      },
      {
        "language": "tsx",
        "code": "export default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return '...'\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function RootLayout({ children }) {\r\n  return '...'\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <head>\r\n        <meta charSet=\"UTF-8\" />\r\n        <link rel=\"icon\" href=\"%PUBLIC_URL%/favicon.ico\" />\r\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\r\n        <title>React App</title>\r\n        <meta name=\"description\" content=\"Web site created...\" />\r\n      </head>\r\n      <body>\r\n        <div id=\"root\">{children}</div>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <head>\r\n        <meta charset=\"UTF-8\" />\r\n        <link rel=\"icon\" href=\"%PUBLIC_URL%/favicon.ico\" />\r\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\r\n        <title>React App</title>\r\n        <meta name=\"description\" content=\"Web site created...\" />\r\n      </head>\r\n      <body>\r\n        <div id=\"root\">{children}</div>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <head>\r\n        <link rel=\"icon\" href=\"%PUBLIC_URL%/favicon.ico\" />\r\n        <title>React App</title>\r\n        <meta name=\"description\" content=\"Web site created...\" />\r\n      </head>\r\n      <body>\r\n        <div id=\"root\">{children}</div>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <head>\r\n        <link rel=\"icon\" href=\"%PUBLIC_URL%/favicon.ico\" />\r\n        <title>React App</title>\r\n        <meta name=\"description\" content=\"Web site created...\" />\r\n      </head>\r\n      <body>\r\n        <div id=\"root\">{children}</div>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <head>\r\n        <title>React App</title>\r\n        <meta name=\"description\" content=\"Web site created...\" />\r\n      </head>\r\n      <body>\r\n        <div id=\"root\">{children}</div>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <head>\r\n        <title>React App</title>\r\n        <meta name=\"description\" content=\"Web site created...\" />\r\n      </head>\r\n      <body>\r\n        <div id=\"root\">{children}</div>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import type { Metadata } from 'next'\r\n\r\nexport const metadata: Metadata = {\r\n  title: 'React App',\r\n  description: 'Web site created with Next.js.',\r\n}\r\n\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>\r\n        <div id=\"root\">{children}</div>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  title: 'React App',\r\n  description: 'Web site created with Next.js.',\r\n}\r\n\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>\r\n        <div id=\"root\">{children}</div>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import '../index.css'\r\n\r\nexport const metadata = {\r\n  title: 'React App',\r\n  description: 'Web site created with Next.js.',\r\n}\r\n\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>\r\n        <div id=\"root\">{children}</div>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "bash",
        "code": "app\r\n ┣ [[...slug]]\r\n ┃ ┗ page.tsx\r\n ┣ layout.tsx",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "export function generateStaticParams() {\r\n  return [{ slug: [''] }]\r\n}\r\n\r\nexport default function Page() {\r\n  return '...' // We'll update this\r\n}",
        "context": "filename=\"app/[[...slug]]/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export function generateStaticParams() {\r\n  return [{ slug: [''] }]\r\n}\r\n\r\nexport default function Page() {\r\n  return '...' // We'll update this\r\n}",
        "context": "filename=\"app/[[...slug]]/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport dynamic from 'next/dynamic'\r\n\r\nconst App = dynamic(() => import('../../App'), { ssr: false })\r\n\r\nexport function ClientOnly() {\r\n  return <App />\r\n}",
        "context": "filename=\"app/[[...slug]]/client.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport dynamic from 'next/dynamic'\r\n\r\nconst App = dynamic(() => import('../../App'), { ssr: false })\r\n\r\nexport function ClientOnly() {\r\n  return <App />\r\n}",
        "context": "filename=\"app/[[...slug]]/client.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { ClientOnly } from './client'\r\n\r\nexport function generateStaticParams() {\r\n  return [{ slug: [''] }]\r\n}\r\n\r\nexport default function Page() {\r\n  return <ClientOnly />\r\n}",
        "context": "filename=\"app/[[...slug]]/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { ClientOnly } from './client'\r\n\r\nexport function generateStaticParams() {\r\n  return [{ slug: [''] }]\r\n}\r\n\r\nexport default function Page() {\r\n  return <ClientOnly />\r\n}",
        "context": "filename=\"app/[[...slug]]/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import image from './img.png'\r\n\r\nexport default function App() {\r\n  return <img src={image} />\r\n}",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "// Before\r\nimport logo from '/logo.png'\r\n\r\n// After\r\nimport logo from '../public/logo.png'",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "// Before\r\n<img src={logo} />\r\n\r\n// After\r\n<img src={logo.src} />",
        "context": ""
      },
      {
        "language": "json",
        "code": "{\r\n  \"scripts\": {\r\n    \"dev\": \"next dev\",\r\n    \"build\": \"next build\",\r\n    \"start\": \"npx serve@latest ./build\"\r\n  }\r\n}",
        "context": "filename=\"package.json\""
      },
      {
        "language": "txt",
        "code": "# ...\r\n.next\r\nnext-env.d.ts",
        "context": "filename=\".gitignore\""
      },
      {
        "language": "bash",
        "code": "npm run dev",
        "context": ""
      },
      {
        "language": "ts",
        "code": "import { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  basePath: '/my-subpath',\r\n  // ...\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\""
      },
      {
        "language": "ts",
        "code": "import { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  async rewrites() {\r\n    return [\r\n      {\r\n        source: '/api/:path*',\r\n        destination: 'https://your-backend.com/:path*',\r\n      },\r\n    ]\r\n  },\r\n}",
        "context": "filename=\"next.config.ts\""
      },
      {
        "language": "ts",
        "code": "import { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  webpack: (config, { isServer }) => {\r\n    // Modify the webpack config here\r\n    return config\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\""
      },
      {
        "language": "json",
        "code": "{\r\n  \"include\": [\"next-env.d.ts\", \"app/**/*\", \"src/**/*\"]\r\n}",
        "context": ""
      },
      {
        "language": "bash",
        "code": "next dev  # Uses Turbopack by default",
        "context": ""
      },
      {
        "language": "bash",
        "code": "next dev --webpack",
        "context": ""
      }
    ],
    "content": "This guide will help you migrate an existing Create React App (CRA) site to Next.js. Why Switch? There are several reasons why you might want to switch from Create React App to Next.js: Slow initial page loading time Create React App uses purely client-side rendering. Client-side only applications, also known as single-page applications (SPAs), often experience slow initial page loading time. This happens due to a couple of reasons: 1. The browser needs to wait for the React code and your entire application bundle to download and run before your code is able to send requests to load data. 2. Your application code grows with every new feature and dependency you add. No automatic code splitting The previous issue of slow loading times can be somewhat mitigated with code splitting. However, if you try to do code splitting manually, you can inadvertently introduce network waterfalls. Next.js provides automatic code splitting and tree-shaking built into its router and build pipeline. Network waterfalls A common cause of poor performance occurs when applications make sequential client-server requests to fetch data. One pattern for data fetching in a SPA is to render a placeholder, and then fetch data after the component has mounted. Unfortunately, a child component can only begin fetching data after its parent has finished loading its own data, resulting in a “waterfall” of requests. While client-side data fetching is supported in Next.js, Next.js also lets you move data fetching to the server. This often eliminates client-server waterfalls altogether. Fast and intentional loading states With built-in support for streaming through React Suspense, you can define which parts of your UI load first and in what order, without creating network waterfalls. This enables you to build pages that are faster to load and eliminate layout shifts. Choose the data fetching strategy Depending on your needs, Next.js allows you to choose your data fetching strategy on a page or component-level basis. For example, you could fetch data from your CMS and render blog posts at build time (SSG) for quick load speeds, or fetch data at request time (SSR) when necessary. Proxy Next.js Proxy allows you to run code on the server before a request is completed. For instance, you can avoid a flash of unauthenticated content by redirecting a user to a login page in the proxy for authenticated-only pages. You can also use it for features like A/B testing, experimentation, and internationalization. Built-in Optimizations Images, fonts, and third-party scripts often have a large impact on an application’s performance. Next.js includes specialized components and APIs that automatically optimize them for you. Migration Steps Our goal is to get a working Next.js application as quickly as possible so that you can then adopt Next.js features incrementally. To begin with, we’ll treat your application as a purely client-side application (SPA) without immediately replacing your existing router. This reduces complexity and merge conflicts. > Note: If you are using advanced CRA configurations such as a custom homepage field in your package.json, a custom service worker, or specific Babel/webpack tweaks, please see the Additional Considerations section at the end of this guide for tips on replicating or adapting these features in Next.js. Step 1: Install the Next.js Dependency Install Next.js in your existing project: Step 2: Create the Next.js Configuration File Create a next.config.ts at the root of your project (same level as your package.json). This file holds your Next.js configuration options. > Note: Using output: 'export' means you’re doing a static export. You will not have access to server-side features like SSR or APIs. You can remove this line to leverage Next.js server features. Step 3: Create the Root Layout A Next.js App Router application must include a root layout file, which is a React Server Component that will wrap all your pages. The closest equivalent of the root layout file in a CRA application is public/index.html, which includes your , , and tags. 1. Create a new app directory inside your src folder (or at your project root if you prefer app at the root). 2. Inside the app directory, create a layout.tsx (or layout.js) file: Now copy the content of your old index.html into this component. Replace body divroot (and body noscript) with {children}. > Good to know: Next.js ignores CRA’s public/manifest.json, additional iconography, and testing configuration by default. If you need these, Next.js has support with its Metadata API and Testing setup. Step 4: Metadata Next.js automatically includes the and tags, so you can remove them from : Any metadata files such as favicon.ico, icon.png, robots.txt are automatically added to the application tag as long as you have them placed into the top level of the app directory. After moving all supported files into the app directory you can safely delete their tags: Finally, Next.js can manage your last tags with the Metadata API. Move your final metadata info into an exported metadata object: With the above changes, you shifted from declaring everything in your index.html to using Next.js' convention-based approach built into the framework (Metadata API). This approach enables you to more easily improve your SEO and web shareability of your pages. Step 5: Styles Like CRA, Next.js supports CSS Modules out of the box. It also supports global CSS imports. If you have a global CSS file, import it into your app/layout.tsx: If you're using Tailwind CSS, see our installation docs. Step 6: Create the Entrypoint Page Create React App uses src/index.tsx (or index.js) as the entry point. In Next.js (App Router), each folder inside the app directory corresponds to a route, and each folder should have a page.tsx. Since we want to keep the app as an SPA for now and intercept all routes, we’ll use an optional catch-all route. 1. Create a [[...slug]] directory inside app. 2. Add the following to page.tsx: This tells Next.js to generate a single route for the empty slug (/), effectively mapping all routes to the same page. This page is a Server Component, prerendered into static HTML. Step 7: Add a Client-Only Entrypoint Next, we’ll embed your CRA’s root App component inside a Client Component so that all logic remains client-side. If this is your first time using Next.js, it's worth knowing that clients components (by default) are still prerendered on the server. You can think about them as having the additional capability of running client-side JavaScript. Create a client.tsx (or client.js) in app/[[...slug]]/: - The 'use client' directive makes this file a Client Component. - The dynamic import with ssr: false disables server-side rendering for the component, making it truly client-only (SPA). Now update your page.tsx (or page.js) to use your new component: Step 8: Update Static Image Imports In CRA, importing an image file returns its public URL as a string: With Next.js, static image imports return an object. The object can then be used directly with the Next.js component, or you can use the object's src property with your existing tag. The component has the added benefits of automatic image optimization. The component automatically sets the width and height attributes of the resulting based on the image's dimensions. This prevents layout shifts when the image loads. However, this can cause issues if your app contains images with only one of their dimensions being styled without the other styled to auto. When not styled to auto, the dimension will default to the dimension attribute's value, which can cause the image to appear distorted. Keeping the tag will reduce the amount of changes in your application and prevent the above issues. You can then optionally later migrate to the component to take advantage of optimizing images by configuring a loader, or moving to the default Next.js server which has automatic image optimization. Convert absolute import paths for images imported from /public into relative imports: Pass the image src property instead of the whole image object to your tag: Alternatively, you can reference the public URL for the image asset based on the filename. For example, public/logo.png will serve the image at /logo.png for your application, which would be the src value. > Warning: If you're using TypeScript, you might encounter type errors when accessing the src property. To fix them, you need to add next-env.d.ts to the include array of your tsconfig.json file. Next.js will automatically generate this file when you run your application on step 9. Step 9: Migrate Environment Variables Next.js supports environment variables similarly to CRA but requires a NEXTPUBLIC prefix for any variable you want to expose in the browser. The main difference is the prefix used to expose environment variables on the client-side. Change all environment variables with the REACTAPP prefix to NEXTPUBLIC. Step 10: Update Scripts in package.json Update your package.json scripts to use Next.js commands. Also, add .next and next-env.d.ts to your .gitignore: Now you can run: Open http://localhost:3000. You should see your application now running on Next.js (in SPA mode). Step 11: Clean Up You can now remove artifacts that are specific to Create React App: - public/index.html - src/index.tsx - src/react-app-env.d.ts - The reportWebVitals setup - The react-scripts dependency (uninstall it from package.json) Additional Considerations Using a Custom homepage in CRA If you used the homepage field in your CRA package.json to serve the app under a specific subpath, you can replicate that in Next.js using the basePath configuration in next.config.ts: Handling a Custom Service Worker If you used CRA’s service worker (e.g., serviceWorker.js from create-react-app), you can learn how to create Progressive Web Applications (PWAs) with Next.js. Proxying API Requests If your CRA app used the proxy field in package.json to forward requests to a backend server, you can replicate this with Next.js rewrites in next.config.ts: Custom Webpack If you had a custom webpack or Babel configuration in CRA, you can extend Next.js’s config in next.config.ts: > Note: This will require using Webpack by adding --webpack to your dev script. TypeScript Setup Next.js automatically sets up TypeScript if you have a tsconfig.json. Make sure next-env.d.ts is listed in your tsconfig.json include array: Bundler Compatibility Create React App uses webpack for bundling. Next.js now defaults to Turbopack for faster local development: To use Webpack instead (similar to CRA): You can still provide a custom webpack configuration if you need to migrate advanced webpack settings from CRA. Next Steps If everything worked, you now have a functioning Next.js application running as a single-page application. You aren’t yet leveraging Next.js features like server-side rendering or file-based routing, but you can now do so incrementally: - Migrate from React Router to the Next.js App Router for: - Automatic code splitting - Streaming server rendering - React Server Components - Optimize images with the component - Optimize fonts with next/font - Optimize third-party scripts with the component - Enable ESLint with Next.js recommended rules > Note: Using a static export (output: 'export') does not currently support the useParams hook or other server features. To use all Next.js features, remove output: 'export' from your next.config.ts.",
    "excerpt": "This guide will help you migrate an existing Create React App (CRA) site to Next.js. Why Switch? There are several reasons why you might want to switch from Create React App to Next.js: Slow initial p...",
    "url": "https://nextjs.org/docs/01-app/02-guides/migrating/from-create-react-app"
  },
  {
    "id": "01-app-02-guides-migrating-from-vite",
    "path": "01-app\\02-guides\\migrating\\from-vite.mdx",
    "title": "How to migrate from Vite to Next.js",
    "description": "Learn how to migrate your existing React application from Vite to Next.js.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Why Switch?",
        "slug": "why-switch"
      },
      {
        "level": 3,
        "text": "Slow initial page loading time",
        "slug": "slow-initial-page-loading-time"
      },
      {
        "level": 3,
        "text": "No automatic code splitting",
        "slug": "no-automatic-code-splitting"
      },
      {
        "level": 3,
        "text": "Network waterfalls",
        "slug": "network-waterfalls"
      },
      {
        "level": 3,
        "text": "Fast and intentional loading states",
        "slug": "fast-and-intentional-loading-states"
      },
      {
        "level": 3,
        "text": "Choose the data fetching strategy",
        "slug": "choose-the-data-fetching-strategy"
      },
      {
        "level": 3,
        "text": "Proxy",
        "slug": "proxy"
      },
      {
        "level": 3,
        "text": "Built-in Optimizations",
        "slug": "built-in-optimizations"
      },
      {
        "level": 2,
        "text": "Migration Steps",
        "slug": "migration-steps"
      },
      {
        "level": 3,
        "text": "Step 1: Install the Next.js Dependency",
        "slug": "step-1-install-the-nextjs-dependency"
      },
      {
        "level": 3,
        "text": "Step 2: Create the Next.js Configuration File",
        "slug": "step-2-create-the-nextjs-configuration-file"
      },
      {
        "level": 3,
        "text": "Step 3: Update TypeScript Configuration",
        "slug": "step-3-update-typescript-configuration"
      },
      {
        "level": 3,
        "text": "Step 4: Create the Root Layout",
        "slug": "step-4-create-the-root-layout"
      },
      {
        "level": 3,
        "text": "Step 5: Create the Entrypoint Page",
        "slug": "step-5-create-the-entrypoint-page"
      },
      {
        "level": 3,
        "text": "Step 6: Update Static Image Imports",
        "slug": "step-6-update-static-image-imports"
      },
      {
        "level": 3,
        "text": "Step 7: Migrate the Environment Variables",
        "slug": "step-7-migrate-the-environment-variables"
      },
      {
        "level": 3,
        "text": "Step 8: Update Scripts in ",
        "slug": "step-8-update-scripts-in-"
      },
      {
        "level": 3,
        "text": "Step 9: Clean Up",
        "slug": "step-9-clean-up"
      },
      {
        "level": 2,
        "text": "Next Steps",
        "slug": "next-steps"
      }
    ],
    "codeBlocks": [
      {
        "language": "bash",
        "code": "npm install next@latest",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  output: 'export', // Outputs a Single-Page Application (SPA).\r\n  distDir: './dist', // Changes the build output directory to `./dist/`.\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.mjs\""
      },
      {
        "language": "json",
        "code": "{\r\n  \"compilerOptions\": {\r\n    \"target\": \"ES2020\",\r\n    \"useDefineForClassFields\": true,\r\n    \"lib\": [\"ES2020\", \"DOM\", \"DOM.Iterable\"],\r\n    \"module\": \"ESNext\",\r\n    \"esModuleInterop\": true,\r\n    \"skipLibCheck\": true,\r\n    \"moduleResolution\": \"bundler\",\r\n    \"allowImportingTsExtensions\": true,\r\n    \"resolveJsonModule\": true,\r\n    \"isolatedModules\": true,\r\n    \"noEmit\": true,\r\n    \"jsx\": \"react-jsx\",\r\n    \"strict\": true,\r\n    \"noUnusedLocals\": true,\r\n    \"noUnusedParameters\": true,\r\n    \"noFallthroughCasesInSwitch\": true,\r\n    \"allowJs\": true,\r\n    \"forceConsistentCasingInFileNames\": true,\r\n    \"incremental\": true,\r\n    \"plugins\": [{ \"name\": \"next\" }]\r\n  },\r\n  \"include\": [\"./src\", \"./dist/types/**/*.ts\", \"./next-env.d.ts\"],\r\n  \"exclude\": [\"./node_modules\"]\r\n}",
        "context": "filename=\"tsconfig.json\""
      },
      {
        "language": "tsx",
        "code": "export default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return '...'\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function RootLayout({ children }) {\r\n  return '...'\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <head>\r\n        <meta charset=\"UTF-8\" />\r\n        <link rel=\"icon\" type=\"image/svg+xml\" href=\"/icon.svg\" />\r\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n        <title>My App</title>\r\n        <meta name=\"description\" content=\"My App is a...\" />\r\n      </head>\r\n      <body>\r\n        <div id=\"root\">{children}</div>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <head>\r\n        <meta charset=\"UTF-8\" />\r\n        <link rel=\"icon\" type=\"image/svg+xml\" href=\"/icon.svg\" />\r\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n        <title>My App</title>\r\n        <meta name=\"description\" content=\"My App is a...\" />\r\n      </head>\r\n      <body>\r\n        <div id=\"root\">{children}</div>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <head>\r\n        <link rel=\"icon\" type=\"image/svg+xml\" href=\"/icon.svg\" />\r\n        <title>My App</title>\r\n        <meta name=\"description\" content=\"My App is a...\" />\r\n      </head>\r\n      <body>\r\n        <div id=\"root\">{children}</div>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <head>\r\n        <link rel=\"icon\" type=\"image/svg+xml\" href=\"/icon.svg\" />\r\n        <title>My App</title>\r\n        <meta name=\"description\" content=\"My App is a...\" />\r\n      </head>\r\n      <body>\r\n        <div id=\"root\">{children}</div>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <head>\r\n        <title>My App</title>\r\n        <meta name=\"description\" content=\"My App is a...\" />\r\n      </head>\r\n      <body>\r\n        <div id=\"root\">{children}</div>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <head>\r\n        <title>My App</title>\r\n        <meta name=\"description\" content=\"My App is a...\" />\r\n      </head>\r\n      <body>\r\n        <div id=\"root\">{children}</div>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import type { Metadata } from 'next'\r\n\r\nexport const metadata: Metadata = {\r\n  title: 'My App',\r\n  description: 'My App is a...',\r\n}\r\n\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>\r\n        <div id=\"root\">{children}</div>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  title: 'My App',\r\n  description: 'My App is a...',\r\n}\r\n\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>\r\n        <div id=\"root\">{children}</div>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import '../../index.css'\r\n\r\nexport function generateStaticParams() {\r\n  return [{ slug: [''] }]\r\n}\r\n\r\nexport default function Page() {\r\n  return '...' // We'll update this\r\n}",
        "context": "filename=\"app/[[...slug]]/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import '../../index.css'\r\n\r\nexport function generateStaticParams() {\r\n  return [{ slug: [''] }]\r\n}\r\n\r\nexport default function Page() {\r\n  return '...' // We'll update this\r\n}",
        "context": "filename=\"app/[[...slug]]/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport React from 'react'\r\nimport dynamic from 'next/dynamic'\r\n\r\nconst App = dynamic(() => import('../../App'), { ssr: false })\r\n\r\nexport function ClientOnly() {\r\n  return <App />\r\n}",
        "context": "filename=\"app/[[...slug]]/client.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport React from 'react'\r\nimport dynamic from 'next/dynamic'\r\n\r\nconst App = dynamic(() => import('../../App'), { ssr: false })\r\n\r\nexport function ClientOnly() {\r\n  return <App />\r\n}",
        "context": "filename=\"app/[[...slug]]/client.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "const App = dynamic(() => import('../../App'), { ssr: false })",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "import '../../index.css'\r\nimport { ClientOnly } from './client'\r\n\r\nexport function generateStaticParams() {\r\n  return [{ slug: [''] }]\r\n}\r\n\r\nexport default function Page() {\r\n  return <ClientOnly />\r\n}",
        "context": "filename=\"app/[[...slug]]/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import '../../index.css'\r\nimport { ClientOnly } from './client'\r\n\r\nexport function generateStaticParams() {\r\n  return [{ slug: [''] }]\r\n}\r\n\r\nexport default function Page() {\r\n  return <ClientOnly />\r\n}",
        "context": "filename=\"app/[[...slug]]/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import image from './img.png' // `image` will be '/assets/img.2d8efhg.png' in production\r\n\r\nexport default function App() {\r\n  return <img src={image} />\r\n}",
        "context": "filename=\"App.tsx\""
      },
      {
        "language": "tsx",
        "code": "// Before\r\nimport logo from '/logo.png'\r\n\r\n// After\r\nimport logo from '../public/logo.png'",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "// Before\r\n<img src={logo} />\r\n\r\n// After\r\n<img src={logo.src} />",
        "context": ""
      },
      {
        "language": "bash",
        "code": "# ...\r\nNEXT_PUBLIC_BASE_PATH=\"/some-base-path\"",
        "context": "filename=\".env\""
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  output: 'export', // Outputs a Single-Page Application (SPA).\r\n  distDir: './dist', // Changes the build output directory to `./dist/`.\r\n  basePath: process.env.NEXT_PUBLIC_BASE_PATH, // Sets the base path to `/some-base-path`.\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.mjs\""
      },
      {
        "language": "json",
        "code": "{\r\n  \"scripts\": {\r\n    \"dev\": \"next dev\",\r\n    \"build\": \"next build\",\r\n    \"start\": \"next start\"\r\n  }\r\n}",
        "context": "filename=\"package.json\""
      },
      {
        "language": "txt",
        "code": "# ...\r\n.next\r\nnext-env.d.ts\r\ndist",
        "context": "filename=\".gitignore\""
      }
    ],
    "content": "This guide will help you migrate an existing Vite application to Next.js. Why Switch? There are several reasons why you might want to switch from Vite to Next.js: Slow initial page loading time If you have built your application with the default Vite plugin for React, your application is a purely client-side application. Client-side only applications, also known as single-page applications (SPAs), often experience slow initial page loading time. This happens due to a couple of reasons: 1. The browser needs to wait for the React code and your entire application bundle to download and run before your code is able to send requests to load some data. 2. Your application code grows with every new feature and extra dependency you add. No automatic code splitting The previous issue of slow loading times can be somewhat managed with code splitting. However, if you try to do code splitting manually, you'll often make performance worse. It's easy to inadvertently introduce network waterfalls when code-splitting manually. Next.js provides automatic code splitting built into its router. Network waterfalls A common cause of poor performance occurs when applications make sequential client-server requests to fetch data. One common pattern for data fetching in an SPA is to initially render a placeholder, and then fetch data after the component has mounted. Unfortunately, this means that a child component that fetches data can't start fetching until the parent component has finished loading its own data. While fetching data on the client is supported with Next.js, it also gives you the option to shift data fetching to the server, which can eliminate client-server waterfalls. Fast and intentional loading states With built-in support for streaming through React Suspense, you can be more intentional about which parts of your UI you want to load first and in what order without introducing network waterfalls. This enables you to build pages that are faster to load and eliminate layout shifts. Choose the data fetching strategy Depending on your needs, Next.js allows you to choose your data fetching strategy on a page and component basis. You can decide to fetch at build time, at request time on the server, or on the client. For example, you can fetch data from your CMS and render your blog posts at build time, which can then be efficiently cached on a CDN. Proxy Next.js Proxy allows you to run code on the server before a request is completed. This is especially useful to avoid having a flash of unauthenticated content when the user visits an authenticated-only page by redirecting the user to a login page. The proxy is also useful for experimentation and internationalization. Built-in Optimizations Images, fonts, and third-party scripts often have significant impact on an application's performance. Next.js comes with built-in components that automatically optimize those for you. Migration Steps Our goal with this migration is to get a working Next.js application as quickly as possible, so that you can then adopt Next.js features incrementally. To begin with, we'll keep it as a purely client-side application (SPA) without migrating your existing router. This helps minimize the chances of encountering issues during the migration process and reduces merge conflicts. Step 1: Install the Next.js Dependency The first thing you need to do is to install next as a dependency: Step 2: Create the Next.js Configuration File Create a next.config.mjs at the root of your project. This file will hold your Next.js configuration options. > Good to know: You can use either .js or .mjs for your Next.js configuration file. Step 3: Update TypeScript Configuration If you're using TypeScript, you need to update your tsconfig.json file with the following changes to make it compatible with Next.js. If you're not using TypeScript, you can skip this step. 1. Remove the project reference to tsconfig.node.json 2. Add ./dist/types//.ts and ./next-env.d.ts to the include array 3. Add ./nodemodules to the exclude array 4. Add { \"name\": \"next\" } to the plugins array in compilerOptions: \"plugins\": [{ \"name\": \"next\" }] 5. Set esModuleInterop to true: \"esModuleInterop\": true 6. Set jsx to react-jsx: \"jsx\": \"react-jsx\" 7. Set allowJs to true: \"allowJs\": true 8. Set forceConsistentCasingInFileNames to true: \"forceConsistentCasingInFileNames\": true 9. Set incremental to true: \"incremental\": true Here's an example of a working tsconfig.json with those changes: You can find more information about configuring TypeScript on the Next.js docs. Step 4: Create the Root Layout A Next.js App Router application must include a root layout file, which is a React Server Component that will wrap all pages in your application. This file is defined at the top level of the app directory. The closest equivalent to the root layout file in a Vite application is the index.html file, which contains your , , and tags. In this step, you'll convert your index.html file into a root layout file: 1. Create a new app directory in your src folder. 2. Create a new layout.tsx file inside that app directory: > Good to know: .js, .jsx, or .tsx extensions can be used for Layout files. 3. Copy the content of your index.html file into the previously created component while replacing the body.divroot and body.script tags with {children}: 4. Next.js already includes by default the meta charset and meta viewport tags, so you can safely remove those from your : 5. Any metadata files such as favicon.ico, icon.png, robots.txt are automatically added to the application tag as long as you have them placed into the top level of the app directory. After moving all supported files into the app directory you can safely delete their tags: 6. Finally, Next.js can manage your last tags with the Metadata API. Move your final metadata info into an exported metadata object: With the above changes, you shifted from declaring everything in your index.html to using Next.js' convention-based approach built into the framework (Metadata API). This approach enables you to more easily improve your SEO and web shareability of your pages. Step 5: Create the Entrypoint Page On Next.js you declare an entrypoint for your application by creating a page.tsx file. The closest equivalent of this file on Vite is your main.tsx file. In this step, you’ll set up the entrypoint of your application. 1. Create a [[...slug]] directory in your app directory. Since in this guide we're aiming first to set up our Next.js as an SPA (Single Page Application), you need your page entrypoint to catch all possible routes of your application. For that, create a new [[...slug]] directory in your app directory. This directory is what is called an optional catch-all route segment. Next.js uses a file-system based router where folders are used to define routes. This special directory will make sure that all routes of your application will be directed to its containing page.tsx file. 2. Create a new page.tsx file inside the app/[[...slug]] directory with the following content: > Good to know: .js, .jsx, or .tsx extensions can be used for Page files. This file is a Server Component. When you run next build, the file is prerendered into a static asset. It does not require any dynamic code. This file imports our global CSS and tells generateStaticParams we are only going to generate one route, the index route at /. Now, let's move the rest of our Vite application which will run client-only. This file is a Client Component, defined by the 'use client' directive. Client Components are still prerendered to HTML on the server before being sent to the client. Since we want a client-only application to start, we can configure Next.js to disable prerendering from the App component down. Now, update your entrypoint page to use the new component: Step 6: Update Static Image Imports Next.js handles static image imports slightly different from Vite. With Vite, importing an image file will return its public URL as a string: With Next.js, static image imports return an object. The object can then be used directly with the Next.js component, or you can use the object's src property with your existing tag. The component has the added benefits of automatic image optimization. The component automatically sets the width and height attributes of the resulting based on the image's dimensions. This prevents layout shifts when the image loads. However, this can cause issues if your app contains images with only one of their dimensions being styled without the other styled to auto. When not styled to auto, the dimension will default to the dimension attribute's value, which can cause the image to appear distorted. Keeping the tag will reduce the amount of changes in your application and prevent the above issues. You can then optionally later migrate to the component to take advantage of optimizing images by configuring a loader, or moving to the default Next.js server which has automatic image optimization. 1. Convert absolute import paths for images imported from /public into relative imports: 2. Pass the image src property instead of the whole image object to your tag: Alternatively, you can reference the public URL for the image asset based on the filename. For example, public/logo.png will serve the image at /logo.png for your application, which would be the src value. > Warning: If you're using TypeScript, you might encounter type errors when accessing the src > property. You can safely ignore those for now. They will be fixed by the end of this guide. Step 7: Migrate the Environment Variables Next.js has support for .env environment variables similar to Vite. The main difference is the prefix used to expose environment variables on the client-side. - Change all environment variables with the VITE prefix to NEXTPUBLIC. Vite exposes a few built-in environment variables on the special import.meta.env object which aren’t supported by Next.js. You need to update their usage as follows: - import.meta.env.MODE ⇒ process.env.NODEENV - import.meta.env.PROD ⇒ process.env.NODEENV === 'production' - import.meta.env.DEV ⇒ process.env.NODEENV !== 'production' - import.meta.env.SSR ⇒ typeof window !== 'undefined' Next.js also doesn't provide a built-in BASEURL environment variable. However, you can still configure one, if you need it: 1. Add the following to your .env file: 2. Set basePath to process.env.NEXTPUBLICBASEPATH in your next.config.mjs file: 3. Update import.meta.env.BASEURL usages to process.env.NEXTPUBLICBASEPATH Step 8: Update Scripts in package.json You should now be able to run your application to test if you successfully migrated to Next.js. But before that, you need to update your scripts in your package.json with Next.js related commands, and add .next and next-env.d.ts to your .gitignore: Now run npm run dev, and open http://localhost:3000. You should see your application now running on Next.js. > Example: Check out this pull request for a > working example of a Vite application migrated to Next.js. Step 9: Clean Up You can now clean up your codebase from Vite related artifacts: - Delete main.tsx - Delete index.html - Delete vite-env.d.ts - Delete tsconfig.node.json - Delete vite.config.ts - Uninstall Vite dependencies Next Steps If everything went according to plan, you now have a functioning Next.js application running as a single-page application. However, you aren't yet taking advantage of most of Next.js' benefits, but you can now start making incremental changes to reap all the benefits. Here's what you might want to do next: - Migrate from React Router to the Next.js App Router to get: - Automatic code splitting - Streaming Server-Rendering - React Server Components - Optimize images with the component - Optimize fonts with next/font - Optimize third-party scripts with the component - Update your ESLint configuration to support Next.js rules",
    "excerpt": "This guide will help you migrate an existing Vite application to Next.js. Why Switch? There are several reasons why you might want to switch from Vite to Next.js: Slow initial page loading time If you...",
    "url": "https://nextjs.org/docs/01-app/02-guides/migrating/from-vite"
  },
  {
    "id": "01-app-02-guides-migrating-index",
    "path": "01-app\\02-guides\\migrating\\index.mdx",
    "title": "Migrating",
    "description": "Learn how to migrate from popular frameworks to Next.js",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/01-app/02-guides/migrating"
  },
  {
    "id": "01-app-02-guides-multi-tenant",
    "path": "01-app\\02-guides\\multi-tenant.mdx",
    "title": "How to build multi-tenant apps in Next.js",
    "description": "Learn how to build multi-tenant apps with the App Router.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "If you are looking to build a single Next.js application that serves multiple tenants, we have built an example showing our recommended architecture.",
    "excerpt": "If you are looking to build a single Next.js application that serves multiple tenants, we have built an example showing our recommended architecture.",
    "url": "https://nextjs.org/docs/01-app/02-guides/multi-tenant"
  },
  {
    "id": "01-app-02-guides-multi-zones",
    "path": "01-app\\02-guides\\multi-zones.mdx",
    "title": "How to build micro-frontends using multi-zones and Next.js",
    "description": "Learn how to build micro-frontends using Next.js Multi-Zones to deploy multiple Next.js apps under a single domain.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "How to define a zone",
        "slug": "how-to-define-a-zone"
      },
      {
        "level": 2,
        "text": "How to route requests to the right zone",
        "slug": "how-to-route-requests-to-the-right-zone"
      },
      {
        "level": 3,
        "text": "Routing requests using proxy",
        "slug": "routing-requests-using-proxy"
      },
      {
        "level": 2,
        "text": "Linking between zones",
        "slug": "linking-between-zones"
      },
      {
        "level": 2,
        "text": "Sharing code",
        "slug": "sharing-code"
      },
      {
        "level": 2,
        "text": "Server Actions",
        "slug": "server-actions"
      }
    ],
    "codeBlocks": [
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  assetPrefix: '/blog-static',\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  assetPrefix: '/blog-static',\r\n  async rewrites() {\r\n    return {\r\n      beforeFiles: [\r\n        {\r\n          source: '/blog-static/_next/:path+',\r\n          destination: '/_next/:path+',\r\n        },\r\n      ],\r\n    }\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "async rewrites() {\r\n    return [\r\n        {\r\n            source: '/blog',\r\n            destination: `${process.env.BLOG_DOMAIN}/blog`,\r\n        },\r\n        {\r\n            source: '/blog/:path+',\r\n            destination: `${process.env.BLOG_DOMAIN}/blog/:path+`,\r\n        },\r\n        {\r\n            source: '/blog-static/:path+',\r\n            destination: `${process.env.BLOG_DOMAIN}/blog-static/:path+`,\r\n        }\r\n    ];\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "export async function proxy(request) {\r\n  const { pathname, search } = req.nextUrl;\r\n  if (pathname === '/your-path' && myFeatureFlag.isEnabled()) {\r\n    return NextResponse.rewrite(`${rewriteDomain}${pathname}${search});\r\n  }\r\n}",
        "context": "filename=\"proxy.js\""
      },
      {
        "language": "js",
        "code": "const nextConfig = {\r\n  experimental: {\r\n    serverActions: {\r\n      allowedOrigins: ['your-production-domain.com'],\r\n    },\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      }
    ],
    "content": "Examples - With Zones Multi-Zones are an approach to micro-frontends that separate a large application on a domain into smaller Next.js applications that each serve a set of paths. This is useful when there are collections of pages unrelated to the other pages in the application. By moving those pages to a separate zone (i.e., a separate application), you can reduce the size of each application which improves build times and removes code that is only necessary for one of the zones. Since applications are decoupled, Multi-Zones also allows other applications on the domain to use their own choice of framework. For example, let's say you have the following set of pages that you would like to split up: - /blog/ for all blog posts - /dashboard/ for all pages when the user is logged-in to the dashboard - / for the rest of your website not covered by other zones With Multi-Zones support, you can create three applications that all are served on the same domain and look the same to the user, but you can develop and deploy each of the applications independently. Navigating between pages in the same zone will perform soft navigations, a navigation that does not require reloading the page. For example, in this diagram, navigating from / to /products will be a soft navigation. Navigating from a page in one zone to a page in another zone, such as from / to /dashboard, will perform a hard navigation, unloading the resources of the current page and loading the resources of the new page. Pages that are frequently visited together should live in the same zone to avoid hard navigations. How to define a zone A zone is a normal Next.js application where you also configure an assetPrefix to avoid conflicts with pages and static files in other zones. Next.js assets, such as JavaScript and CSS, will be prefixed with assetPrefix to make sure that they don't conflict with assets from other zones. These assets will be served under /assetPrefix/next/... for each of the zones. The default application handling all paths not routed to another more specific zone does not need an assetPrefix. In versions older than Next.js 15, you may also need an additional rewrite to handle the static assets. This is no longer necessary in Next.js 15. How to route requests to the right zone With the Multi Zones set-up, you need to route the paths to the correct zone since they are served by different applications. You can use any HTTP proxy to do this, but one of the Next.js applications can also be used to route requests for the entire domain. To route to the correct zone using a Next.js application, you can use rewrites. For each path served by a different zone, you would add a rewrite rule to send that path to the domain of the other zone, and you also need to rewrite the requests for the static assets. For example: destination should be a URL that is served by the zone, including scheme and domain. This should point to the zone's production domain, but it can also be used to route requests to localhost in local development. > Good to know: URL paths should be unique to a zone. For example, two zones trying to serve /blog would create a routing conflict. Routing requests using proxy Routing requests through rewrites is recommended to minimize latency overhead for the requests, but proxy can also be used when there is a need for a dynamic decision when routing. For example, if you are using a feature flag to decide where a path should be routed such as during a migration, you can use proxy. Linking between zones Links to paths in a different zone should use an a tag instead of the Next.js component. This is because Next.js will try to prefetch and soft navigate to any relative path in component, which will not work across zones. Sharing code The Next.js applications that make up the different zones can live in any repository. However, it is often convenient to put these zones in a monorepo to more easily share code. For zones that live in different repositories, code can also be shared using public or private NPM packages. Since the pages in different zones may be released at different times, feature flags can be useful for enabling or disabling features in unison across the different zones. Server Actions When using Server Actions with Multi-Zones, you must explicitly allow the user-facing origin since your user facing domain may serve multiple applications. In your next.config.js file, add the following lines: See serverActions.allowedOrigins for more information.",
    "excerpt": "Examples - With Zones Multi-Zones are an approach to micro-frontends that separate a large application on a domain into smaller Next.js applications that each serve a set of paths. This is useful when...",
    "url": "https://nextjs.org/docs/01-app/02-guides/multi-zones"
  },
  {
    "id": "01-app-02-guides-open-telemetry",
    "path": "01-app\\02-guides\\open-telemetry.mdx",
    "title": "How to set up instrumentation with OpenTelemetry",
    "description": "Learn how to instrument your Next.js app with OpenTelemetry.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Getting Started",
        "slug": "getting-started"
      },
      {
        "level": 3,
        "text": "Using ",
        "slug": "using-"
      },
      {
        "level": 3,
        "text": "Manual OpenTelemetry configuration",
        "slug": "manual-opentelemetry-configuration"
      },
      {
        "level": 2,
        "text": "Testing your instrumentation",
        "slug": "testing-your-instrumentation"
      },
      {
        "level": 2,
        "text": "Deployment",
        "slug": "deployment"
      },
      {
        "level": 3,
        "text": "Using OpenTelemetry Collector",
        "slug": "using-opentelemetry-collector"
      },
      {
        "level": 4,
        "text": "Deploying on Vercel",
        "slug": "deploying-on-vercel"
      },
      {
        "level": 4,
        "text": "Self-hosting",
        "slug": "self-hosting"
      },
      {
        "level": 3,
        "text": "Custom Exporters",
        "slug": "custom-exporters"
      },
      {
        "level": 2,
        "text": "Custom Spans",
        "slug": "custom-spans"
      },
      {
        "level": 2,
        "text": "Default Spans in Next.js",
        "slug": "default-spans-in-nextjs"
      }
    ],
    "codeBlocks": [
      {
        "language": "bash",
        "code": "npm install @vercel/otel @opentelemetry/sdk-logs @opentelemetry/api-logs @opentelemetry/instrumentation",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "ts",
        "code": "import { registerOTel } from '@vercel/otel'\r\n\r\nexport function register() {\r\n  registerOTel({ serviceName: 'next-app' })\r\n}",
        "context": "filename=\"your-project/instrumentation.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { registerOTel } from '@vercel/otel'\r\n\r\nexport function register() {\r\n  registerOTel({ serviceName: 'next-app' })\r\n}",
        "context": "filename=\"your-project/instrumentation.js\" switcher"
      },
      {
        "language": "bash",
        "code": "npm install @opentelemetry/sdk-node @opentelemetry/resources @opentelemetry/semantic-conventions @opentelemetry/sdk-trace-node @opentelemetry/exporter-trace-otlp-http",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "ts",
        "code": "export async function register() {\r\n  if (process.env.NEXT_RUNTIME === 'nodejs') {\r\n    await import('./instrumentation.node.ts')\r\n  }\r\n}",
        "context": "filename=\"instrumentation.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export async function register() {\r\n  if (process.env.NEXT_RUNTIME === 'nodejs') {\r\n    await import('./instrumentation.node.js')\r\n  }\r\n}",
        "context": "filename=\"instrumentation.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http'\r\nimport { resourceFromAttributes } from '@opentelemetry/resources'\r\nimport { NodeSDK } from '@opentelemetry/sdk-node'\r\nimport { SimpleSpanProcessor } from '@opentelemetry/sdk-trace-node'\r\nimport { ATTR_SERVICE_NAME } from '@opentelemetry/semantic-conventions'\r\n\r\nconst sdk = new NodeSDK({\r\n  resource: resourceFromAttributes({\r\n    [ATTR_SERVICE_NAME]: 'next-app',\r\n  }),\r\n  spanProcessor: new SimpleSpanProcessor(new OTLPTraceExporter()),\r\n})\r\nsdk.start()",
        "context": "filename=\"instrumentation.node.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http'\r\nimport { resourceFromAttributes } from '@opentelemetry/resources'\r\nimport { NodeSDK } from '@opentelemetry/sdk-node'\r\nimport { SimpleSpanProcessor } from '@opentelemetry/sdk-trace-node'\r\nimport { ATTR_SERVICE_NAME } from '@opentelemetry/semantic-conventions'\r\n\r\nconst sdk = new NodeSDK({\r\n  resource: resourceFromAttributes({\r\n    [ATTR_SERVICE_NAME]: 'next-app',\r\n  }),\r\n  spanProcessor: new SimpleSpanProcessor(new OTLPTraceExporter()),\r\n})\r\nsdk.start()",
        "context": "filename=\"instrumentation.node.js\" switcher"
      },
      {
        "language": "bash",
        "code": "npm install @opentelemetry/api",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "ts",
        "code": "import { trace } from '@opentelemetry/api'\r\n\r\nexport async function fetchGithubStars() {\r\n  return await trace\r\n    .getTracer('nextjs-example')\r\n    .startActiveSpan('fetchGithubStars', async (span) => {\r\n      try {\r\n        return await getValue()\r\n      } finally {\r\n        span.end()\r\n      }\r\n    })\r\n}",
        "context": ""
      }
    ],
    "content": "Observability is crucial for understanding and optimizing the behavior and performance of your Next.js app. As applications become more complex, it becomes increasingly difficult to identify and diagnose issues that may arise. By leveraging observability tools, such as logging and metrics, developers can gain insights into their application's behavior and identify areas for optimization. With observability, developers can proactively address issues before they become major problems and provide a better user experience. Therefore, it is highly recommended to use observability in your Next.js applications to improve performance, optimize resources, and enhance user experience. We recommend using OpenTelemetry for instrumenting your apps. It's a platform-agnostic way to instrument apps that allows you to change your observability provider without changing your code. Read Official OpenTelemetry docs for more information about OpenTelemetry and how it works. This documentation uses terms like Span, Trace or Exporter throughout this doc, all of which can be found in the OpenTelemetry Observability Primer. Next.js supports OpenTelemetry instrumentation out of the box, which means that we already instrumented Next.js itself. When you enable OpenTelemetry we will automatically wrap all your code like getStaticProps in spans with helpful attributes. Getting Started OpenTelemetry is extensible but setting it up properly can be quite verbose. That's why we prepared a package @vercel/otel that helps you get started quickly. Using @vercel/otel To get started, install the following packages: Next, create a custom instrumentation.ts (or .js) file in the root directory of the project (or inside src folder if using one): Next, create a custom instrumentation.ts (or .js) file in the root directory of the project (or inside src folder if using one): See the @vercel/otel documentation for additional configuration options. > Good to know: > > - The instrumentation file should be in the root of your project and not inside the app or pages directory. If you're using the src folder, then place the file inside src alongside pages and app. > - If you use the pageExtensions config option to add a suffix, you will also need to update the instrumentation filename to match. > - We have created a basic with-opentelemetry example that you can use. > Good to know: > > - The instrumentation file should be in the root of your project and not inside the app or pages directory. If you're using the src folder, then place the file inside src alongside pages and app. > - If you use the pageExtensions config option to add a suffix, you will also need to update the instrumentation filename to match. > - We have created a basic with-opentelemetry example that you can use. Manual OpenTelemetry configuration The @vercel/otel package provides many configuration options and should serve most of common use cases. But if it doesn't suit your needs, you can configure OpenTelemetry manually. Firstly you need to install OpenTelemetry packages: Now you can initialize NodeSDK in your instrumentation.ts. Unlike @vercel/otel, NodeSDK is not compatible with edge runtime, so you need to make sure that you are importing them only when process.env.NEXTRUNTIME === 'nodejs'. We recommend creating a new file instrumentation.node.ts which you conditionally import only when using node: Doing this is equivalent to using @vercel/otel, but it's possible to modify and extend some features that are not exposed by the @vercel/otel. If edge runtime support is necessary, you will have to use @vercel/otel. Testing your instrumentation You need an OpenTelemetry collector with a compatible backend to test OpenTelemetry traces locally. We recommend using our OpenTelemetry dev environment. If everything works well you should be able to see the root server span labeled as GET /requested/pathname. All other spans from that particular trace will be nested under it. Next.js traces more spans than are emitted by default. To see more spans, you must set NEXTOTELVERBOSE=1. Deployment Using OpenTelemetry Collector When you are deploying with OpenTelemetry Collector, you can use @vercel/otel. It will work both on Vercel and when self-hosted. Deploying on Vercel We made sure that OpenTelemetry works out of the box on Vercel. Follow Vercel documentation to connect your project to an observability provider. Self-hosting Deploying to other platforms is also straightforward. You will need to spin up your own OpenTelemetry Collector to receive and process the telemetry data from your Next.js app. To do this, follow the OpenTelemetry Collector Getting Started guide, which will walk you through setting up the collector and configuring it to receive data from your Next.js app. Once you have your collector up and running, you can deploy your Next.js app to your chosen platform following their respective deployment guides. Custom Exporters OpenTelemetry Collector is not necessary. You can use a custom OpenTelemetry exporter with @vercel/otel or manual OpenTelemetry configuration. Custom Spans You can add a custom span with OpenTelemetry APIs. The following example demonstrates a function that fetches GitHub stars and adds a custom fetchGithubStars span to track the fetch request's result: The register function will execute before your code runs in a new environment. You can start creating new spans, and they should be correctly added to the exported trace. Default Spans in Next.js Next.js automatically instruments several spans for you to provide useful insights into your application's performance. Attributes on spans follow OpenTelemetry semantic conventions. We also add some custom attributes under the next namespace: - next.spanname - duplicates span name - next.spantype - each span type has a unique identifier - next.route - The route pattern of the request (e.g., /[param]/user). - next.rsc (true/false) - Whether the request is an RSC request, such as prefetch. - next.page - This is an internal value used by an app router. - You can think about it as a route to a special file (like page.ts, layout.ts, loading.ts and others) - It can be used as a unique identifier only when paired with next.route because /layout can be used to identify both /(groupA)/layout.ts and /(groupB)/layout.ts [http.method] [next.route] - next.spantype: BaseServer.handleRequest This span represents the root span for each incoming request to your Next.js application. It tracks the HTTP method, route, target, and status code of the request. Attributes: - Common HTTP attributes - http.method - http.statuscode - Server HTTP attributes - http.route - http.target - next.spanname - next.spantype - next.route render route (app) [next.route] - next.spantype: AppRender.getBodyResult. This span represents the process of rendering a route in the app router. Attributes: - next.spanname - next.spantype - next.route fetch [http.method] [http.url] - next.spantype: AppRender.fetch This span represents the fetch request executed in your code. Attributes: - Common HTTP attributes - http.method - Client HTTP attributes - http.url - net.peer.name - net.peer.port (only if specified) - next.spanname - next.spantype This span can be turned off by setting NEXTOTELFETCHDISABLED=1 in your environment. This is useful when you want to use a custom fetch instrumentation library. executing api route (app) [next.route] - next.spantype: AppRouteRouteHandlers.runHandler. This span represents the execution of an API Route Handler in the app router. Attributes: - next.spanname - next.spantype - next.route getServerSideProps [next.route] - next.spantype: Render.getServerSideProps. This span represents the execution of getServerSideProps for a specific route. Attributes: - next.spanname - next.spantype - next.route getStaticProps [next.route] - next.spantype: Render.getStaticProps. This span represents the execution of getStaticProps for a specific route. Attributes: - next.spanname - next.spantype - next.route render route (pages) [next.route] - next.spantype: Render.renderDocument. This span represents the process of rendering the document for a specific route. Attributes: - next.spanname - next.spantype - next.route generateMetadata [next.page] - next.spantype: ResolveMetadata.generateMetadata. This span represents the process of generating metadata for a specific page (a single route can have multiple of these spans). Attributes: - next.spanname - next.spantype - next.page resolve page components - next.spantype: NextNodeServer.findPageComponents. This span represents the process of resolving page components for a specific page. Attributes: - next.spanname - next.spantype - next.route resolve segment modules - next.spantype: NextNodeServer.getLayoutOrPageModule. This span represents loading of code modules for a layout or a page. Attributes: - next.spanname - next.spantype - next.segment start response - next.spantype: NextNodeServer.startResponse. This zero-length span represents the time when the first byte has been sent in the response.",
    "excerpt": "Observability is crucial for understanding and optimizing the behavior and performance of your Next.js app. As applications become more complex, it becomes increasingly difficult to identify and diagn...",
    "url": "https://nextjs.org/docs/01-app/02-guides/open-telemetry"
  },
  {
    "id": "01-app-02-guides-package-bundling",
    "path": "01-app\\02-guides\\package-bundling.mdx",
    "title": "How to optimize package bundling",
    "description": "Learn how to optimize your application's server and client bundles.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Analyzing JavaScript bundles",
        "slug": "analyzing-javascript-bundles"
      },
      {
        "level": 3,
        "text": "Installation",
        "slug": "installation"
      },
      {
        "level": 3,
        "text": "Generating a report",
        "slug": "generating-a-report"
      },
      {
        "level": 2,
        "text": "Optimizing package imports",
        "slug": "optimizing-package-imports"
      },
      {
        "level": 2,
        "text": "Bundling specific packages",
        "slug": "bundling-specific-packages"
      },
      {
        "level": 2,
        "text": "Bundling all packages",
        "slug": "bundling-all-packages"
      },
      {
        "level": 2,
        "text": "Opting specific packages out of bundling",
        "slug": "opting-specific-packages-out-of-bundling"
      },
      {
        "level": 2,
        "text": "Opting specific packages out of bundling",
        "slug": "opting-specific-packages-out-of-bundling"
      }
    ],
    "codeBlocks": [
      {
        "language": "bash",
        "code": "npm i @next/bundle-analyzer\r\n# or\r\nyarn add @next/bundle-analyzer\r\n# or\r\npnpm add @next/bundle-analyzer",
        "context": ""
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {}\r\n\r\nconst withBundleAnalyzer = require('@next/bundle-analyzer')({\r\n  enabled: process.env.ANALYZE === 'true',\r\n})\r\n\r\nmodule.exports = withBundleAnalyzer(nextConfig)",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "bash",
        "code": "ANALYZE=true npm run build\r\n# or\r\nANALYZE=true yarn build\r\n# or\r\nANALYZE=true pnpm build",
        "context": ""
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  experimental: {\r\n    optimizePackageImports: ['icon-library'],\r\n  },\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  transpilePackages: ['package-name'],\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  bundlePagesRouterDependencies: true,\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  // Automatically bundle external packages in the Pages Router:\r\n  bundlePagesRouterDependencies: true,\r\n  // Opt specific packages out of bundling for both App and Pages Router:\r\n  serverExternalPackages: ['package-name'],\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  serverExternalPackages: ['package-name'],\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\""
      }
    ],
    "content": "Bundling external packages can significantly improve the performance of your application. By default, packages imported inside Server Components and Route Handlers are automatically bundled by Next.js. This page will guide you through how to analyze and further optimize package bundling. By default, packages imported into your application are not bundled. This can impact performance or might not work if external packages are not pre-bundled, for example, if imported from a monorepo or nodemodules. This page will guide you through how to analyze and configure package bundling. Analyzing JavaScript bundles @next/bundle-analyzer is a plugin for Next.js that helps you manage the size of your application bundles. It generates a visual report of the size of each package and their dependencies. You can use the information to remove large dependencies, split, or lazy-load your code. Installation Install the plugin by running the following command: Then, add the bundle analyzer's settings to your next.config.js. Generating a report Run the following command to analyze your bundles: The report will open three new tabs in your browser, which you can inspect. Periodically evaluating your application's bundles can help you maintain application performance over time. Optimizing package imports Some packages, such as icon libraries, can export hundreds of modules, which can cause performance issues in development and production. You can optimize how these packages are imported by adding the optimizePackageImports option to your next.config.js. This option will only load the modules you actually use, while still giving you the convenience of writing import statements with many named exports. Next.js also optimizes some libraries automatically, thus they do not need to be included in the optimizePackageImports list. See the full list. Bundling specific packages To bundle specific packages, you can use the transpilePackages option in your next.config.js. This option is useful for bundling external packages that are not pre-bundled, for example, in a monorepo or imported from nodemodules. Bundling all packages To automatically bundle all packages (default behavior in the App Router), you can use the bundlePagesRouterDependencies option in your next.config.js. Opting specific packages out of bundling If you have the bundlePagesRouterDependencies option enabled, you can opt specific packages out of automatic bundling using the serverExternalPackages option in your next.config.js: Opting specific packages out of bundling Since packages imported inside Server Components and Route Handlers are automatically bundled by Next.js, you can opt specific packages out of bundling using the serverExternalPackages option in your next.config.js. Next.js includes a list of popular packages that currently are working on compatibility and automatically opt-ed out. See the full list.",
    "excerpt": "Bundling external packages can significantly improve the performance of your application. By default, packages imported inside Server Components and Route Handlers are automatically bundled by Next.js...",
    "url": "https://nextjs.org/docs/01-app/02-guides/package-bundling"
  },
  {
    "id": "01-app-02-guides-prefetching",
    "path": "01-app\\02-guides\\prefetching.mdx",
    "title": "Prefetching",
    "description": "Learn how to configure prefetching in Next.js",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "How does prefetching work?",
        "slug": "how-does-prefetching-work"
      },
      {
        "level": 2,
        "text": "Prefetching static vs. dynamic routes",
        "slug": "prefetching-static-vs-dynamic-routes"
      },
      {
        "level": 2,
        "text": "Automatic prefetch",
        "slug": "automatic-prefetch"
      },
      {
        "level": 2,
        "text": "Manual prefetch",
        "slug": "manual-prefetch"
      },
      {
        "level": 2,
        "text": "Hover-triggered prefetch",
        "slug": "hover-triggered-prefetch"
      },
      {
        "level": 2,
        "text": "Extending or ejecting link",
        "slug": "extending-or-ejecting-link"
      },
      {
        "level": 2,
        "text": "Disabled prefetch",
        "slug": "disabled-prefetch"
      },
      {
        "level": 2,
        "text": "Prefetching optimizations",
        "slug": "prefetching-optimizations"
      },
      {
        "level": 3,
        "text": "Client cache",
        "slug": "client-cache"
      },
      {
        "level": 3,
        "text": "Prefetch scheduling",
        "slug": "prefetch-scheduling"
      },
      {
        "level": 3,
        "text": "Partial Prerendering (PPR)",
        "slug": "partial-prerendering-ppr"
      },
      {
        "level": 2,
        "text": "Troubleshooting",
        "slug": "troubleshooting"
      },
      {
        "level": 3,
        "text": "Triggering unwanted side-effects during prefetching",
        "slug": "triggering-unwanted-side-effects-during-prefetching"
      },
      {
        "level": 3,
        "text": "Preventing too many prefetches",
        "slug": "preventing-too-many-prefetches"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function NavLink() {\r\n  return <Link href=\"/about\">About</Link>\r\n}",
        "context": "filename=\"app/ui/nav-link.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function NavLink() {\r\n  return <Link href=\"/about\">About</Link>\r\n}",
        "context": "filename=\"app/ui/nav-link.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { useRouter } from 'next/navigation'\r\nimport { CustomLink } from '@components/link'\r\n\r\nexport function PricingCard() {\r\n  const router = useRouter()\r\n\r\n  return (\r\n    <div onMouseEnter={() => router.prefetch('/pricing')}>\r\n      {/* other UI elements */}\r\n      <CustomLink href=\"/pricing\">View Pricing</CustomLink>\r\n    </div>\r\n  )\r\n}",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport Link from 'next/link'\r\nimport { useState } from 'react'\r\n\r\nexport function HoverPrefetchLink({\r\n  href,\r\n  children,\r\n}: {\r\n  href: string\r\n  children: React.ReactNode\r\n}) {\r\n  const [active, setActive] = useState(false)\r\n\r\n  return (\r\n    <Link\r\n      href={href}\r\n      prefetch={active ? null : false}\r\n      onMouseEnter={() => setActive(true)}\r\n    >\r\n      {children}\r\n    </Link>\r\n  )\r\n}",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { useRouter } from 'next/navigation'\r\nimport { useEffect } from 'react'\r\n\r\nfunction ManualPrefetchLink({\r\n  href,\r\n  children,\r\n}: {\r\n  href: string\r\n  children: React.ReactNode\r\n}) {\r\n  const router = useRouter()\r\n\r\n  useEffect(() => {\r\n    let cancelled = false\r\n    const poll = () => {\r\n      if (!cancelled) router.prefetch(href, { onInvalidate: poll })\r\n    }\r\n    poll()\r\n    return () => {\r\n      cancelled = true\r\n    }\r\n  }, [href, router])\r\n\r\n  return (\r\n    <a\r\n      href={href}\r\n      onClick={(event) => {\r\n        event.preventDefault()\r\n        router.push(href)\r\n      }}\r\n    >\r\n      {children}\r\n    </a>\r\n  )\r\n}",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport Link, { LinkProps } from 'next/link'\r\n\r\nfunction NoPrefetchLink({\r\n  prefetch,\r\n  ...rest\r\n}: LinkProps & { children: React.ReactNode }) {\r\n  return <Link {...rest} prefetch={false} />\r\n}",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "import { trackPageView } from '@/lib/analytics'\r\n\r\nexport default function Layout({ children }: { children: React.ReactNode }) {\r\n  // This runs during prefetch\r\n  trackPageView()\r\n\r\n  return <div>{children}</div>\r\n}",
        "context": "filename=\"app/dashboard/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { trackPageView } from '@/lib/analytics'\r\n\r\nexport default function Layout({ children }) {\r\n  // This runs during prefetch\r\n  trackPageView()\r\n\r\n  return <div>{children}</div>\r\n}",
        "context": "filename=\"app/dashboard/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { useEffect } from 'react'\r\nimport { trackPageView } from '@/lib/analytics'\r\n\r\nexport function AnalyticsTracker() {\r\n  useEffect(() => {\r\n    trackPageView()\r\n  }, [])\r\n\r\n  return null\r\n}",
        "context": "filename=\"app/ui/analytics-tracker.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { useEffect } from 'react'\r\nimport { trackPageView } from '@/lib/analytics'\r\n\r\nexport function AnalyticsTracker() {\r\n  useEffect(() => {\r\n    trackPageView()\r\n  }, [])\r\n\r\n  return null\r\n}",
        "context": "filename=\"app/ui/analytics-tracker.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { AnalyticsTracker } from '@/app/ui/analytics-tracker'\r\n\r\nexport default function Layout({ children }: { children: React.ReactNode }) {\r\n  return (\r\n    <div>\r\n      <AnalyticsTracker />\r\n      {children}\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/dashboard/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { AnalyticsTracker } from '@/app/ui/analytics-tracker'\r\n\r\nexport default function Layout({ children }) {\r\n  return (\r\n    <div>\r\n      <AnalyticsTracker />\r\n      {children}\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/dashboard/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "<Link prefetch={false} href={`/blog/${post.id}`}>\r\n  {post.title}\r\n</Link>",
        "context": "filename=\"app/ui/no-prefetch-link.tsx\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport Link from 'next/link'\r\nimport { useState } from 'react'\r\n\r\nexport function HoverPrefetchLink({\r\n  href,\r\n  children,\r\n}: {\r\n  href: string\r\n  children: React.ReactNode\r\n}) {\r\n  const [active, setActive] = useState(false)\r\n\r\n  return (\r\n    <Link\r\n      href={href}\r\n      prefetch={active ? null : false}\r\n      onMouseEnter={() => setActive(true)}\r\n    >\r\n      {children}\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"app/ui/hover-prefetch-link.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport Link from 'next/link'\r\nimport { useState } from 'react'\r\n\r\nexport function HoverPrefetchLink({ href, children }) {\r\n  const [active, setActive] = useState(false)\r\n\r\n  return (\r\n    <Link\r\n      href={href}\r\n      prefetch={active ? null : false}\r\n      onMouseEnter={() => setActive(true)}\r\n    >\r\n      {children}\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"app/ui/hover-prefetch-link.js\" switcher"
      }
    ],
    "content": "Prefetching makes navigating between different routes in your application feel instant. Next.js tries to intelligently prefetch by default, based on the links used in your application code. This guide will explain how prefetching works and show common implementation patterns: - Automatic prefetch - Manual prefetch - Hover-triggered prefetch - Extending or ejecting link - Disabled prefetch How does prefetching work? When navigating between routes, the browser requests assets for the page like HTML and JavaScript files. Prefetching is the process of fetching these resources ahead of time, before you navigate to a new route. Next.js automatically splits your application into smaller JavaScript chunks based on routes. Instead of loading all the code upfront like traditional SPAs, only the code needed for the current route is loaded. This reduces the initial load time while other parts of the app are loaded in the background. By the time you click the link, the resources for the new route have already been loaded into the browser cache. When navigating to the new page, there's no full page reload or browser loading spinner. Instead, Next.js performs a client-side transition, making the page navigation feel instant. Prefetching static vs. dynamic routes | | Static page | Dynamic page | | ----------------------------------------------------------------- | --------------- | ------------------------------------------------------------------------------- | | Prefetched | Yes, full route | No, unless loading.js | | Client Cache TTL | 5 min (default) | Off, unless enabled | | Server roundtrip on click | No | Yes, streamed after shell | > Good to know: During the initial navigation, the browser fetches the HTML, JavaScript, and React Server Components (RSC) Payload. For subsequent navigations, the browser will fetch the RSC Payload for Server Components and JS bundle for Client Components. Automatic prefetch | Context | Prefetched payload | Client Cache TTL | | ----------------- | -------------------------------- | ------------------------------------------------------------------------------ | | No loading.js | Entire page | Until app reload | | With loading.js | Layout to first loading boundary | 30s (configurable) | Automatic prefetching runs only in production. Disable with prefetch={false} or use the wrapper in Disabled Prefetch. Manual prefetch To do manual prefetching, import the useRouter hook from next/navigation, and call router.prefetch() to warm routes outside the viewport or in response to analytics, hover, scroll, etc. If the intent is to prefetch a URL when a component loads, see the extending or rejecting a link [example]. Hover-triggered prefetch > Proceed with caution: Extending Link opts you into maintaining prefetching, cache invalidation, and accessibility concerns. Proceed only if defaults are insufficient. Next.js tries to do the right prefetching by default, but power users can eject and modify based on their needs. You have the control between performance and resource consumption. For example, you might have to only trigger prefetches on hover, instead of when entering the viewport (the default behavior): prefetch={null} restores default (static) prefetching once the user shows intent. Extending or ejecting link You can extend the component to create your own custom prefetching strategy. For example, using the ForesightJS library which prefetches links by predicting the direction of the user's cursor. Alternatively, you can use useRouter to recreate some of the native behavior. However, be aware this opts you into maintaining prefetching and cache invalidation. onInvalidate is invoked when Next.js suspects cached data is stale, allowing you to refresh the prefetch. > Good to know: Using an a tag will cause a full page navigation to the destination route, you can use onClick to prevent the full page navigation, and then invoke router.push to navigate to the destination. Disabled prefetch You can fully disable prefetching for certain routes for more fine-grained control over resource consumption. For example, you may still want to have consistent usage of in your application, but links in your footer might not need to be prefetched when entering the viewport. Prefetching optimizations Client cache Next.js stores prefetched React Server Component payloads in memory, keyed by route segments. When navigating between sibling routes (e.g. /dashboard/settings → /dashboard/analytics), it reuses the parent layout and only fetches the updated leaf page. This reduces network traffic and improves navigation speed. Prefetch scheduling Next.js maintains a small task queue, which prefetches in the following order: 1. Links in the viewport 2. Links showing user intent (hover or touch) 3. Newer links replace older ones 4. Links scrolled off-screen are discarded The scheduler prioritizes likely navigations while minimizing unused downloads. Partial Prerendering (PPR) When PPR is enabled, a page is divided into a static shell and a streamed dynamic section: - The shell, which can be prefetched, streams immediately - Dynamic data streams when ready - Data invalidations (revalidateTag, revalidatePath) silently refresh associated prefetches Troubleshooting Triggering unwanted side-effects during prefetching If your layouts or pages are not pure and have side-effects (e.g. tracking analytics), these might be triggered when the route is prefetched, not when the user visits the page. To avoid this, you should move side-effects to a useEffect hook or a Server Action triggered from a Client Component. Before: After: Preventing too many prefetches Next.js automatically prefetches links in the viewport when using the component. There may be cases where you want to prevent this to avoid unnecessary usage of resources, such as when rendering a large list of links (e.g. an infinite scroll table). You can disable prefetching by setting the prefetch prop of the component to false. However, this means static routes will only be fetched on click, and dynamic routes will wait for the server to render before navigating. To reduce resource usage without disabling prefetch entirely, you can defer prefetching until the user hovers over a link. This targets only links the user is likely to visit.",
    "excerpt": "Prefetching makes navigating between different routes in your application feel instant. Next.js tries to intelligently prefetch by default, based on the links used in your application code. This guide...",
    "url": "https://nextjs.org/docs/01-app/02-guides/prefetching"
  },
  {
    "id": "01-app-02-guides-production-checklist",
    "path": "01-app\\02-guides\\production-checklist.mdx",
    "title": "How to optimize your Next.js application for production",
    "description": "Recommendations to ensure the best performance and user experience before taking your Next.js application to production.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Automatic optimizations",
        "slug": "automatic-optimizations"
      },
      {
        "level": 2,
        "text": "During development",
        "slug": "during-development"
      },
      {
        "level": 3,
        "text": "Routing and rendering",
        "slug": "routing-and-rendering"
      },
      {
        "level": 3,
        "text": "Data fetching and caching",
        "slug": "data-fetching-and-caching"
      },
      {
        "level": 3,
        "text": "UI and accessibility",
        "slug": "ui-and-accessibility"
      },
      {
        "level": 3,
        "text": "Security",
        "slug": "security"
      },
      {
        "level": 3,
        "text": "Metadata and SEO",
        "slug": "metadata-and-seo"
      },
      {
        "level": 3,
        "text": "Type safety",
        "slug": "type-safety"
      },
      {
        "level": 2,
        "text": "Before going to production",
        "slug": "before-going-to-production"
      },
      {
        "level": 3,
        "text": "Core Web Vitals",
        "slug": "core-web-vitals"
      },
      {
        "level": 3,
        "text": "Analyzing bundles",
        "slug": "analyzing-bundles"
      }
    ],
    "codeBlocks": [],
    "content": "Before taking your Next.js application to production, there are some optimizations and patterns you should consider implementing for the best user experience, performance, and security. This page provides best practices that you can use as a reference when building your application and before going to production, as well as the automatic Next.js optimizations you should be aware of. Automatic optimizations These Next.js optimizations are enabled by default and require no configuration: - Server Components: Next.js uses Server Components by default. Server Components run on the server, and don't require JavaScript to render on the client. As such, they have no impact on the size of your client-side JavaScript bundles. You can then use Client Components as needed for interactivity. - Code-splitting: Server Components enable automatic code-splitting by route segments. You may also consider lazy loading Client Components and third-party libraries, where appropriate. - Prefetching: When a link to a new route enters the user's viewport, Next.js prefetches the route in background. This makes navigation to new routes almost instant. You can opt out of prefetching, where appropriate. - Static Rendering: Next.js statically renders Server and Client Components on the server at build time and caches the rendered result to improve your application's performance. You can opt into Dynamic Rendering for specific routes, where appropriate. - Caching: Next.js caches data requests, the rendered result of Server and Client Components, static assets, and more, to reduce the number of network requests to your server, database, and backend services. You may opt out of caching, where appropriate. - Code-splitting: Next.js automatically code-splits your application code by pages. This means only the code needed for the current page is loaded on navigation. You may also consider lazy loading third-party libraries, where appropriate. - Prefetching: When a link to a new route enters the user's viewport, Next.js prefetches the route in background. This makes navigation to new routes almost instant. You can opt out of prefetching, where appropriate. - Automatic Static Optimization: Next.js automatically determines that a page is static (can be pre-rendered) if it has no blocking data requirements. Optimized pages can be cached, and served to the end-user from multiple CDN locations. You may opt into Server-side Rendering, where appropriate. These defaults aim to improve your application's performance, and reduce the cost and amount of data transferred on each network request. During development While building your application, we recommend using the following features to ensure the best performance and user experience: Routing and rendering - Layouts: Use layouts to share UI across pages and enable partial rendering on navigation. - component: Use the component for client-side navigation and prefetching. - Error Handling: Gracefully handle catch-all errors and 404 errors in production by creating custom error pages. - Client and Server Components: Follow the recommended composition patterns for Server and Client Components, and check the placement of your \"use client\" boundaries to avoid unnecessarily increasing your client-side JavaScript bundle. - Dynamic APIs: Be aware that Dynamic APIs like cookies and the searchParams prop will opt the entire route into Dynamic Rendering (or your whole application if used in the Root Layout). Ensure Dynamic API usage is intentional and wrap them in boundaries where appropriate. > Good to know: Partial Prerendering (experimental) will allow parts of a route to be dynamic without opting the whole route into dynamic rendering. - component: Use the component for client-side navigation and prefetching. - Custom Errors: Gracefully handle 500 and 404 errors Data fetching and caching - Server Components: Leverage the benefits of fetching data on the server using Server Components. - Route Handlers: Use Route Handlers to access your backend resources from Client Components. But do not call Route Handlers from Server Components to avoid an additional server request. - Streaming: Use Loading UI and React Suspense to progressively send UI from the server to the client, and prevent the whole route from blocking while data is being fetched. - Parallel Data Fetching: Reduce network waterfalls by fetching data in parallel, where appropriate. Also, consider preloading data where appropriate. - Data Caching: Verify whether your data requests are being cached or not, and opt into caching, where appropriate. Ensure requests that don't use fetch are cached. - Static Images: Use the public directory to automatically cache your application's static assets, e.g. images. - API Routes: Use Route Handlers to access your backend resources, and prevent sensitive secrets from being exposed to the client. - Data Caching: Verify whether your data requests are being cached or not, and opt into caching, where appropriate. Ensure requests that don't use getStaticProps are cached where appropriate. - Incremental Static Regeneration: Use Incremental Static Regeneration to update static pages after they've been built, without rebuilding your entire site. - Static Images: Use the public directory to automatically cache your application's static assets, e.g. images. UI and accessibility - Forms and Validation: Use Server Actions to handle form submissions, server-side validation, and handle errors. - Global Error UI: Add app/global-error.tsx to provide consistent, accessible fallback UI and recovery for uncaught errors across your app. - Global 404: Add app/global-not-found.tsx to serve an accessible 404 for unmatched routes across your app. - Font Module: Optimize fonts by using the Font Module, which automatically hosts your font files with other static assets, removes external network requests, and reduces layout shift. - Component: Optimize images by using the Image Component, which automatically optimizes images, prevents layout shift, and serves them in modern formats like WebP. - Component: Optimize third-party scripts by using the Script Component, which automatically defers scripts and prevents them from blocking the main thread. - ESLint: Use the built-in eslint-plugin-jsx-a11y plugin to catch accessibility issues early. Security - Tainting: Prevent sensitive data from being exposed to the client by tainting data objects and/or specific values. - Server Actions: Ensure users are authorized to call Server Actions. Review the recommended security practices. - Environment Variables: Ensure your .env. files are added to .gitignore and only public variables are prefixed with NEXTPUBLIC. - Content Security Policy: Consider adding a Content Security Policy to protect your application against various security threats such as cross-site scripting, clickjacking, and other code injection attacks. Metadata and SEO - Metadata API: Use the Metadata API to improve your application's Search Engine Optimization (SEO) by adding page titles, descriptions, and more. - Open Graph (OG) images: Create OG images to prepare your application for social sharing. - Sitemaps and Robots: Help Search Engines crawl and index your pages by generating sitemaps and robots files. - Component: Use the next/head component to add page titles, descriptions, and more. Type safety - TypeScript and TS Plugin: Use TypeScript and the TypeScript plugin for better type-safety, and to help you catch errors early. Before going to production Before going to production, you can run next build to build your application locally and catch any build errors, then run next start to measure the performance of your application in a production-like environment. Core Web Vitals - Lighthouse: Run lighthouse in incognito to gain a better understanding of how your users will experience your site, and to identify areas for improvement. This is a simulated test and should be paired with looking at field data (such as Core Web Vitals). - useReportWebVitals hook: Use this hook to send Core Web Vitals data to analytics tools. Analyzing bundles Use the @next/bundle-analyzer plugin to analyze the size of your JavaScript bundles and identify large modules and dependencies that might be impacting your application's performance. Additionally, the following tools can help you understand the impact of adding new dependencies to your application: - Import Cost - Package Phobia - Bundle Phobia - bundlejs",
    "excerpt": "Before taking your Next.js application to production, there are some optimizations and patterns you should consider implementing for the best user experience, performance, and security. This page prov...",
    "url": "https://nextjs.org/docs/01-app/02-guides/production-checklist"
  },
  {
    "id": "01-app-02-guides-progressive-web-apps",
    "path": "01-app\\02-guides\\progressive-web-apps.mdx",
    "title": "How to build a Progressive Web Application (PWA) with Next.js",
    "description": "Learn how to build a Progressive Web Application (PWA) with Next.js.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Creating a PWA with Next.js",
        "slug": "creating-a-pwa-with-nextjs"
      },
      {
        "level": 3,
        "text": "1. Creating the Web App Manifest",
        "slug": "1-creating-the-web-app-manifest"
      },
      {
        "level": 3,
        "text": "2. Implementing Web Push Notifications",
        "slug": "2-implementing-web-push-notifications"
      },
      {
        "level": 3,
        "text": "3. Implementing Server Actions",
        "slug": "3-implementing-server-actions"
      },
      {
        "level": 3,
        "text": "4. Generating VAPID Keys",
        "slug": "4-generating-vapid-keys"
      },
      {
        "level": 3,
        "text": "5. Creating a Service Worker",
        "slug": "5-creating-a-service-worker"
      },
      {
        "level": 3,
        "text": "6. Adding to Home Screen",
        "slug": "6-adding-to-home-screen"
      },
      {
        "level": 3,
        "text": "7. Testing Locally",
        "slug": "7-testing-locally"
      },
      {
        "level": 3,
        "text": "8. Securing your application",
        "slug": "8-securing-your-application"
      },
      {
        "level": 2,
        "text": "Extending your PWA",
        "slug": "extending-your-pwa"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "import type { MetadataRoute } from 'next'\r\n\r\nexport default function manifest(): MetadataRoute.Manifest {\r\n  return {\r\n    name: 'Next.js PWA',\r\n    short_name: 'NextPWA',\r\n    description: 'A Progressive Web App built with Next.js',\r\n    start_url: '/',\r\n    display: 'standalone',\r\n    background_color: '#ffffff',\r\n    theme_color: '#000000',\r\n    icons: [\r\n      {\r\n        src: '/icon-192x192.png',\r\n        sizes: '192x192',\r\n        type: 'image/png',\r\n      },\r\n      {\r\n        src: '/icon-512x512.png',\r\n        sizes: '512x512',\r\n        type: 'image/png',\r\n      },\r\n    ],\r\n  }\r\n}",
        "context": "filename=\"app/manifest.ts\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function manifest() {\r\n  return {\r\n    name: 'Next.js PWA',\r\n    short_name: 'NextPWA',\r\n    description: 'A Progressive Web App built with Next.js',\r\n    start_url: '/',\r\n    display: 'standalone',\r\n    background_color: '#ffffff',\r\n    theme_color: '#000000',\r\n    icons: [\r\n      {\r\n        src: '/icon-192x192.png',\r\n        sizes: '192x192',\r\n        type: 'image/png',\r\n      },\r\n      {\r\n        src: '/icon-512x512.png',\r\n        sizes: '512x512',\r\n        type: 'image/png',\r\n      },\r\n    ],\r\n  }\r\n}",
        "context": "filename=\"app/manifest.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { useState, useEffect } from 'react'\r\nimport { subscribeUser, unsubscribeUser, sendNotification } from './actions'\r\n\r\nfunction urlBase64ToUint8Array(base64String: string) {\r\n  const padding = '='.repeat((4 - (base64String.length % 4)) % 4)\r\n  const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/')\r\n\r\n  const rawData = window.atob(base64)\r\n  const outputArray = new Uint8Array(rawData.length)\r\n\r\n  for (let i = 0; i < rawData.length; ++i) {\r\n    outputArray[i] = rawData.charCodeAt(i)\r\n  }\r\n  return outputArray\r\n}",
        "context": "switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { useState, useEffect } from 'react'\r\nimport { subscribeUser, unsubscribeUser, sendNotification } from './actions'\r\n\r\nfunction urlBase64ToUint8Array(base64String) {\r\n  const padding = '='.repeat((4 - (base64String.length % 4)) % 4)\r\n  const base64 = (base64String + padding)\r\n    .replace(/\\\\-/g, '+')\r\n    .replace(/_/g, '/')\r\n\r\n  const rawData = window.atob(base64)\r\n  const outputArray = new Uint8Array(rawData.length)\r\n\r\n  for (let i = 0; i < rawData.length; ++i) {\r\n    outputArray[i] = rawData.charCodeAt(i)\r\n  }\r\n  return outputArray\r\n}",
        "context": "switcher"
      },
      {
        "language": "tsx",
        "code": "function PushNotificationManager() {\r\n  const [isSupported, setIsSupported] = useState(false)\r\n  const [subscription, setSubscription] = useState<PushSubscription | null>(\r\n    null\r\n  )\r\n  const [message, setMessage] = useState('')\r\n\r\n  useEffect(() => {\r\n    if ('serviceWorker' in navigator && 'PushManager' in window) {\r\n      setIsSupported(true)\r\n      registerServiceWorker()\r\n    }\r\n  }, [])\r\n\r\n  async function registerServiceWorker() {\r\n    const registration = await navigator.serviceWorker.register('/sw.js', {\r\n      scope: '/',\r\n      updateViaCache: 'none',\r\n    })\r\n    const sub = await registration.pushManager.getSubscription()\r\n    setSubscription(sub)\r\n  }\r\n\r\n  async function subscribeToPush() {\r\n    const registration = await navigator.serviceWorker.ready\r\n    const sub = await registration.pushManager.subscribe({\r\n      userVisibleOnly: true,\r\n      applicationServerKey: urlBase64ToUint8Array(\r\n        process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY!\r\n      ),\r\n    })\r\n    setSubscription(sub)\r\n    const serializedSub = JSON.parse(JSON.stringify(sub))\r\n    await subscribeUser(serializedSub)\r\n  }\r\n\r\n  async function unsubscribeFromPush() {\r\n    await subscription?.unsubscribe()\r\n    setSubscription(null)\r\n    await unsubscribeUser()\r\n  }\r\n\r\n  async function sendTestNotification() {\r\n    if (subscription) {\r\n      await sendNotification(message)\r\n      setMessage('')\r\n    }\r\n  }\r\n\r\n  if (!isSupported) {\r\n    return <p>Push notifications are not supported in this browser.</p>\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      <h3>Push Notifications</h3>\r\n      {subscription ? (\r\n        <>\r\n          <p>You are subscribed to push notifications.</p>\r\n          <button onClick={unsubscribeFromPush}>Unsubscribe</button>\r\n          <input\r\n            type=\"text\"\r\n            placeholder=\"Enter notification message\"\r\n            value={message}\r\n            onChange={(e) => setMessage(e.target.value)}\r\n          />\r\n          <button onClick={sendTestNotification}>Send Test</button>\r\n        </>\r\n      ) : (\r\n        <>\r\n          <p>You are not subscribed to push notifications.</p>\r\n          <button onClick={subscribeToPush}>Subscribe</button>\r\n        </>\r\n      )}\r\n    </div>\r\n  )\r\n}",
        "context": "switcher"
      },
      {
        "language": "jsx",
        "code": "function PushNotificationManager() {\r\n  const [isSupported, setIsSupported] = useState(false);\r\n  const [subscription, setSubscription] = useState(null);\r\n  const [message, setMessage] = useState('');\r\n\r\n  useEffect(() => {\r\n    if ('serviceWorker' in navigator && 'PushManager' in window) {\r\n      setIsSupported(true);\r\n      registerServiceWorker();\r\n    }\r\n  }, []);\r\n\r\n  async function registerServiceWorker() {\r\n    const registration = await navigator.serviceWorker.register('/sw.js', {\r\n      scope: '/',\r\n      updateViaCache: 'none',\r\n    });\r\n    const sub = await registration.pushManager.getSubscription();\r\n    setSubscription(sub);\r\n  }\r\n\r\n  async function subscribeToPush() {\r\n    const registration = await navigator.serviceWorker.ready;\r\n    const sub = await registration.pushManager.subscribe({\r\n      userVisibleOnly: true,\r\n      applicationServerKey: urlBase64ToUint8Array(\r\n        process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY!\r\n      ),\r\n    });\r\n    setSubscription(sub);\r\n    await subscribeUser(sub);\r\n  }\r\n\r\n  async function unsubscribeFromPush() {\r\n    await subscription?.unsubscribe();\r\n    setSubscription(null);\r\n    await unsubscribeUser();\r\n  }\r\n\r\n  async function sendTestNotification() {\r\n    if (subscription) {\r\n      await sendNotification(message);\r\n      setMessage('');\r\n    }\r\n  }\r\n\r\n  if (!isSupported) {\r\n    return <p>Push notifications are not supported in this browser.</p>;\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      <h3>Push Notifications</h3>\r\n      {subscription ? (\r\n        <>\r\n          <p>You are subscribed to push notifications.</p>\r\n          <button onClick={unsubscribeFromPush}>Unsubscribe</button>\r\n          <input\r\n            type=\"text\"\r\n            placeholder=\"Enter notification message\"\r\n            value={message}\r\n            onChange={(e) => setMessage(e.target.value)}\r\n          />\r\n          <button onClick={sendTestNotification}>Send Test</button>\r\n        </>\r\n      ) : (\r\n        <>\r\n          <p>You are not subscribed to push notifications.</p>\r\n          <button onClick={subscribeToPush}>Subscribe</button>\r\n        </>\r\n      )}\r\n    </div>\r\n  );\r\n}",
        "context": "switcher"
      },
      {
        "language": "tsx",
        "code": "function InstallPrompt() {\r\n  const [isIOS, setIsIOS] = useState(false)\r\n  const [isStandalone, setIsStandalone] = useState(false)\r\n\r\n  useEffect(() => {\r\n    setIsIOS(\r\n      /iPad|iPhone|iPod/.test(navigator.userAgent) && !(window as any).MSStream\r\n    )\r\n\r\n    setIsStandalone(window.matchMedia('(display-mode: standalone)').matches)\r\n  }, [])\r\n\r\n  if (isStandalone) {\r\n    return null // Don't show install button if already installed\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      <h3>Install App</h3>\r\n      <button>Add to Home Screen</button>\r\n      {isIOS && (\r\n        <p>\r\n          To install this app on your iOS device, tap the share button\r\n          <span role=\"img\" aria-label=\"share icon\">\r\n            {' '}\r\n            ⎋{' '}\r\n          </span>\r\n          and then \"Add to Home Screen\"\r\n          <span role=\"img\" aria-label=\"plus icon\">\r\n            {' '}\r\n            ➕{' '}\r\n          </span>\r\n          .\r\n        </p>\r\n      )}\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default function Page() {\r\n  return (\r\n    <div>\r\n      <PushNotificationManager />\r\n      <InstallPrompt />\r\n    </div>\r\n  )\r\n}",
        "context": "switcher"
      },
      {
        "language": "jsx",
        "code": "function InstallPrompt() {\r\n  const [isIOS, setIsIOS] = useState(false);\r\n  const [isStandalone, setIsStandalone] = useState(false);\r\n\r\n  useEffect(() => {\r\n    setIsIOS(\r\n      /iPad|iPhone|iPod/.test(navigator.userAgent) && !(window as any).MSStream\r\n    );\r\n\r\n    setIsStandalone(window.matchMedia('(display-mode: standalone)').matches);\r\n  }, []);\r\n\r\n  if (isStandalone) {\r\n    return null; // Don't show install button if already installed\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      <h3>Install App</h3>\r\n      <button>Add to Home Screen</button>\r\n      {isIOS && (\r\n        <p>\r\n          To install this app on your iOS device, tap the share button\r\n          <span role=\"img\" aria-label=\"share icon\">\r\n            {' '}\r\n            ⎋{' '}\r\n          </span>\r\n          and then \"Add to Home Screen\"\r\n          <span role=\"img\" aria-label=\"plus icon\">\r\n            {' '}\r\n            ➕{' '}\r\n          </span>\r\n          .\r\n        </p>\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default function Page() {\r\n  return (\r\n    <div>\r\n      <PushNotificationManager />\r\n      <InstallPrompt />\r\n    </div>\r\n  );\r\n}",
        "context": "switcher"
      },
      {
        "language": "tsx",
        "code": "'use server'\r\n\r\nimport webpush from 'web-push'\r\n\r\nwebpush.setVapidDetails(\r\n  '<mailto:your-email@example.com>',\r\n  process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY!,\r\n  process.env.VAPID_PRIVATE_KEY!\r\n)\r\n\r\nlet subscription: PushSubscription | null = null\r\n\r\nexport async function subscribeUser(sub: PushSubscription) {\r\n  subscription = sub\r\n  // In a production environment, you would want to store the subscription in a database\r\n  // For example: await db.subscriptions.create({ data: sub })\r\n  return { success: true }\r\n}\r\n\r\nexport async function unsubscribeUser() {\r\n  subscription = null\r\n  // In a production environment, you would want to remove the subscription from the database\r\n  // For example: await db.subscriptions.delete({ where: { ... } })\r\n  return { success: true }\r\n}\r\n\r\nexport async function sendNotification(message: string) {\r\n  if (!subscription) {\r\n    throw new Error('No subscription available')\r\n  }\r\n\r\n  try {\r\n    await webpush.sendNotification(\r\n      subscription,\r\n      JSON.stringify({\r\n        title: 'Test Notification',\r\n        body: message,\r\n        icon: '/icon.png',\r\n      })\r\n    )\r\n    return { success: true }\r\n  } catch (error) {\r\n    console.error('Error sending push notification:', error)\r\n    return { success: false, error: 'Failed to send notification' }\r\n  }\r\n}",
        "context": "filename=\"app/actions.ts\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use server';\r\n\r\nimport webpush from 'web-push';\r\n\r\nwebpush.setVapidDetails(\r\n  '<mailto:your-email@example.com>',\r\n  process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY!,\r\n  process.env.VAPID_PRIVATE_KEY!\r\n);\r\n\r\nlet subscription= null;\r\n\r\nexport async function subscribeUser(sub) {\r\n  subscription = sub;\r\n  // In a production environment, you would want to store the subscription in a database\r\n  // For example: await db.subscriptions.create({ data: sub })\r\n  return { success: true };\r\n}\r\n\r\nexport async function unsubscribeUser() {\r\n  subscription = null;\r\n  // In a production environment, you would want to remove the subscription from the database\r\n  // For example: await db.subscriptions.delete({ where: { ... } })\r\n  return { success: true };\r\n}\r\n\r\nexport async function sendNotification(message) {\r\n  if (!subscription) {\r\n    throw new Error('No subscription available');\r\n  }\r\n\r\n  try {\r\n    await webpush.sendNotification(\r\n      subscription,\r\n      JSON.stringify({\r\n        title: 'Test Notification',\r\n        body: message,\r\n        icon: '/icon.png',\r\n      })\r\n    );\r\n    return { success: true };\r\n  } catch (error) {\r\n    console.error('Error sending push notification:', error);\r\n    return { success: false, error: 'Failed to send notification' };\r\n  }\r\n}",
        "context": "filename=\"app/actions.js\" switcher"
      },
      {
        "language": "bash",
        "code": "npm install -g web-push",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "web-push generate-vapid-keys",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "text",
        "code": "NEXT_PUBLIC_VAPID_PUBLIC_KEY=your_public_key_here\r\nVAPID_PRIVATE_KEY=your_private_key_here",
        "context": ""
      },
      {
        "language": "js",
        "code": "self.addEventListener('push', function (event) {\r\n  if (event.data) {\r\n    const data = event.data.json()\r\n    const options = {\r\n      body: data.body,\r\n      icon: data.icon || '/icon.png',\r\n      badge: '/badge.png',\r\n      vibrate: [100, 50, 100],\r\n      data: {\r\n        dateOfArrival: Date.now(),\r\n        primaryKey: '2',\r\n      },\r\n    }\r\n    event.waitUntil(self.registration.showNotification(data.title, options))\r\n  }\r\n})\r\n\r\nself.addEventListener('notificationclick', function (event) {\r\n  console.log('Notification click received.')\r\n  event.notification.close()\r\n  event.waitUntil(clients.openWindow('<https://your-website.com>'))\r\n})",
        "context": "filename=\"public/sw.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  async headers() {\r\n    return [\r\n      {\r\n        source: '/(.*)',\r\n        headers: [\r\n          {\r\n            key: 'X-Content-Type-Options',\r\n            value: 'nosniff',\r\n          },\r\n          {\r\n            key: 'X-Frame-Options',\r\n            value: 'DENY',\r\n          },\r\n          {\r\n            key: 'Referrer-Policy',\r\n            value: 'strict-origin-when-cross-origin',\r\n          },\r\n        ],\r\n      },\r\n      {\r\n        source: '/sw.js',\r\n        headers: [\r\n          {\r\n            key: 'Content-Type',\r\n            value: 'application/javascript; charset=utf-8',\r\n          },\r\n          {\r\n            key: 'Cache-Control',\r\n            value: 'no-cache, no-store, must-revalidate',\r\n          },\r\n          {\r\n            key: 'Content-Security-Policy',\r\n            value: \"default-src 'self'; script-src 'self'\",\r\n          },\r\n        ],\r\n      },\r\n    ]\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      }
    ],
    "content": "Progressive Web Applications (PWAs) offer the reach and accessibility of web applications combined with the features and user experience of native mobile apps. With Next.js, you can create PWAs that provide a seamless, app-like experience across all platforms without the need for multiple codebases or app store approvals. PWAs allow you to: - Deploy updates instantly without waiting for app store approval - Create cross-platform applications with a single codebase - Provide native-like features such as home screen installation and push notifications Creating a PWA with Next.js 1. Creating the Web App Manifest Next.js provides built-in support for creating a web app manifest using the App Router. You can create either a static or dynamic manifest file: For example, create a app/manifest.ts or app/manifest.json file: This file should contain information about the name, icons, and how it should be displayed as an icon on the user's device. This will allow users to install your PWA on their home screen, providing a native app-like experience. You can use tools like favicon generators to create the different icon sets and place the generated files in your public/ folder. 2. Implementing Web Push Notifications Web Push Notifications are supported with all modern browsers, including: - iOS 16.4+ for applications installed to the home screen - Safari 16 for macOS 13 or later - Chromium based browsers - Firefox This makes PWAs a viable alternative to native apps. Notably, you can trigger install prompts without needing offline support. Web Push Notifications allow you to re-engage users even when they're not actively using your app. Here's how to implement them in a Next.js application: First, let's create the main page component in app/page.tsx. We'll break it down into smaller parts for better understanding. First, we’ll add some of the imports and utilities we’ll need. It’s okay that the referenced Server Actions do not yet exist: Let’s now add a component to manage subscribing, unsubscribing, and sending push notifications. Finally, let’s create a component to show a message for iOS devices to instruct them to install to their home screen, and only show this if the app is not already installed. Now, let’s create the Server Actions which this file calls. 3. Implementing Server Actions Create a new file to contain your actions at app/actions.ts. This file will handle creating subscriptions, deleting subscriptions, and sending notifications. Sending a notification will be handled by our service worker, created in step 5. In a production environment, you would want to store the subscription in a database for persistence across server restarts and to manage multiple users' subscriptions. 4. Generating VAPID Keys To use the Web Push API, you need to generate VAPID keys. The simplest way is to use the web-push CLI directly: First, install web-push globally: Generate the VAPID keys by running: Copy the output and paste the keys into your .env file: 5. Creating a Service Worker Create a public/sw.js file for your service worker: This service worker supports custom images and notifications. It handles incoming push events and notification clicks. - You can set custom icons for notifications using the icon and badge properties. - The vibrate pattern can be adjusted to create custom vibration alerts on supported devices. - Additional data can be attached to the notification using the data property. Remember to test your service worker thoroughly to ensure it behaves as expected across different devices and browsers. Also, make sure to update the 'https://your-website.com' link in the notificationclick event listener to the appropriate URL for your application. 6. Adding to Home Screen The InstallPrompt component defined in step 2 shows a message for iOS devices to instruct them to install to their home screen. To ensure your application can be installed to a mobile home screen, you must have: 1. A valid web app manifest (created in step 1) 2. The website served over HTTPS Modern browsers will automatically show an installation prompt to users when these criteria are met. You can provide a custom installation button with beforeinstallprompt, however, we do not recommend this as it is not cross browser and platform (does not work on Safari iOS). 7. Testing Locally To ensure you can view notifications locally, ensure that: - You are running locally with HTTPS - Use next dev --experimental-https for testing - Your browser (Chrome, Safari, Firefox) has notifications enabled - When prompted locally, accept permissions to use notifications - Ensure notifications are not disabled globally for the entire browser - If you are still not seeing notifications, try using another browser to debug 8. Securing your application Security is a crucial aspect of any web application, especially for PWAs. Next.js allows you to configure security headers using the next.config.js file. For example: Let’s go over each of these options: 1. Global Headers (applied to all routes): 1. X-Content-Type-Options: nosniff: Prevents MIME type sniffing, reducing the risk of malicious file uploads. 2. X-Frame-Options: DENY: Protects against clickjacking attacks by preventing your site from being embedded in iframes. 3. Referrer-Policy: strict-origin-when-cross-origin: Controls how much referrer information is included with requests, balancing security and functionality. 2. Service Worker Specific Headers: 1. Content-Type: application/javascript; charset=utf-8: Ensures the service worker is interpreted correctly as JavaScript. 2. Cache-Control: no-cache, no-store, must-revalidate: Prevents caching of the service worker, ensuring users always get the latest version. 3. Content-Security-Policy: default-src 'self'; script-src 'self': Implements a strict Content Security Policy for the service worker, only allowing scripts from the same origin. Learn more about defining Content Security Policies with Next.js. Extending your PWA 1. Exploring PWA Capabilities: PWAs can leverage various web APIs to provide advanced functionality. Consider exploring features like background sync, periodic background sync, or the File System Access API to enhance your application. For inspiration and up-to-date information on PWA capabilities, you can refer to resources like What PWA Can Do Today. 2. Static Exports: If your application requires not running a server, and instead using a static export of files, you can update the Next.js configuration to enable this change. Learn more in the Next.js Static Export documentation. However, you will need to move from Server Actions to calling an external API, as well as moving your defined headers to your proxy. 3. Offline Support: To provide offline functionality, one option is Serwist with Next.js. You can find an example of how to integrate Serwist with Next.js in their documentation. Note: this plugin currently requires webpack configuration. 4. Security Considerations: Ensure that your service worker is properly secured. This includes using HTTPS, validating the source of push messages, and implementing proper error handling. 5. User Experience: Consider implementing progressive enhancement techniques to ensure your app works well even when certain PWA features are not supported by the user's browser.",
    "excerpt": "Progressive Web Applications (PWAs) offer the reach and accessibility of web applications combined with the features and user experience of native mobile apps. With Next.js, you can create PWAs that p...",
    "url": "https://nextjs.org/docs/01-app/02-guides/progressive-web-apps"
  },
  {
    "id": "01-app-02-guides-redirecting",
    "path": "01-app\\02-guides\\redirecting.mdx",
    "title": "How to handle redirects in Next.js",
    "description": "Learn the different ways to handle redirects in Next.js.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": " function",
        "slug": "-function"
      },
      {
        "level": 2,
        "text": " function",
        "slug": "-function"
      },
      {
        "level": 2,
        "text": " hook",
        "slug": "-hook"
      },
      {
        "level": 2,
        "text": " in ",
        "slug": "-in-"
      },
      {
        "level": 2,
        "text": " in Proxy",
        "slug": "-in-proxy"
      },
      {
        "level": 2,
        "text": "Managing redirects at scale (advanced)",
        "slug": "managing-redirects-at-scale-advanced"
      },
      {
        "level": 3,
        "text": "1. Creating and storing a redirect map",
        "slug": "1-creating-and-storing-a-redirect-map"
      },
      {
        "level": 3,
        "text": "2. Optimizing data lookup performance",
        "slug": "2-optimizing-data-lookup-performance"
      }
    ],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "'use server'\r\n\r\nimport { redirect } from 'next/navigation'\r\nimport { revalidatePath } from 'next/cache'\r\n\r\nexport async function createPost(id: string) {\r\n  try {\r\n    // Call database\r\n  } catch (error) {\r\n    // Handle errors\r\n  }\r\n\r\n  revalidatePath('/posts') // Update cached posts\r\n  redirect(`/post/${id}`) // Navigate to the new post page\r\n}",
        "context": "filename=\"app/actions.ts\" switcher"
      },
      {
        "language": "js",
        "code": "'use server'\r\n\r\nimport { redirect } from 'next/navigation'\r\nimport { revalidatePath } from 'next/cache'\r\n\r\nexport async function createPost(id) {\r\n  try {\r\n    // Call database\r\n  } catch (error) {\r\n    // Handle errors\r\n  }\r\n\r\n  revalidatePath('/posts') // Update cached posts\r\n  redirect(`/post/${id}`) // Navigate to the new post page\r\n}",
        "context": "filename=\"app/actions.js\" switcher"
      },
      {
        "language": "ts",
        "code": "'use server'\r\n\r\nimport { permanentRedirect } from 'next/navigation'\r\nimport { revalidateTag } from 'next/cache'\r\n\r\nexport async function updateUsername(username: string, formData: FormData) {\r\n  try {\r\n    // Call database\r\n  } catch (error) {\r\n    // Handle errors\r\n  }\r\n\r\n  revalidateTag('username') // Update all references to the username\r\n  permanentRedirect(`/profile/${username}`) // Navigate to the new user profile\r\n}",
        "context": "filename=\"app/actions.ts\" switcher"
      },
      {
        "language": "js",
        "code": "'use server'\r\n\r\nimport { permanentRedirect } from 'next/navigation'\r\nimport { revalidateTag } from 'next/cache'\r\n\r\nexport async function updateUsername(username, formData) {\r\n  try {\r\n    // Call database\r\n  } catch (error) {\r\n    // Handle errors\r\n  }\r\n\r\n  revalidateTag('username') // Update all references to the username\r\n  permanentRedirect(`/profile/${username}`) // Navigate to the new user profile\r\n}",
        "context": "filename=\"app/actions.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { useRouter } from 'next/navigation'\r\n\r\nexport default function Page() {\r\n  const router = useRouter()\r\n\r\n  return (\r\n    <button type=\"button\" onClick={() => router.push('/dashboard')}>\r\n      Dashboard\r\n    </button>\r\n  )\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { useRouter } from 'next/navigation'\r\n\r\nexport default function Page() {\r\n  const router = useRouter()\r\n\r\n  return (\r\n    <button type=\"button\" onClick={() => router.push('/dashboard')}>\r\n      Dashboard\r\n    </button>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { useRouter } from 'next/router'\r\n\r\nexport default function Page() {\r\n  const router = useRouter()\r\n\r\n  return (\r\n    <button type=\"button\" onClick={() => router.push('/dashboard')}>\r\n      Dashboard\r\n    </button>\r\n  )\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { useRouter } from 'next/router'\r\n\r\nexport default function Page() {\r\n  const router = useRouter()\r\n\r\n  return (\r\n    <button type=\"button\" onClick={() => router.push('/dashboard')}>\r\n      Dashboard\r\n    </button>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  async redirects() {\r\n    return [\r\n      // Basic redirect\r\n      {\r\n        source: '/about',\r\n        destination: '/',\r\n        permanent: true,\r\n      },\r\n      // Wildcard path matching\r\n      {\r\n        source: '/blog/:slug',\r\n        destination: '/news/:slug',\r\n        permanent: true,\r\n      },\r\n    ]\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  async redirects() {\r\n    return [\r\n      // Basic redirect\r\n      {\r\n        source: '/about',\r\n        destination: '/',\r\n        permanent: true,\r\n      },\r\n      // Wildcard path matching\r\n      {\r\n        source: '/blog/:slug',\r\n        destination: '/news/:slug',\r\n        permanent: true,\r\n      },\r\n    ]\r\n  },\r\n}",
        "context": "filename=\"next.config.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { NextResponse, NextRequest } from 'next/server'\r\nimport { authenticate } from 'auth-provider'\r\n\r\nexport function proxy(request: NextRequest) {\r\n  const isAuthenticated = authenticate(request)\r\n\r\n  // If the user is authenticated, continue as normal\r\n  if (isAuthenticated) {\r\n    return NextResponse.next()\r\n  }\r\n\r\n  // Redirect to login page if not authenticated\r\n  return NextResponse.redirect(new URL('/login', request.url))\r\n}\r\n\r\nexport const config = {\r\n  matcher: '/dashboard/:path*',\r\n}",
        "context": "filename=\"proxy.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { NextResponse } from 'next/server'\r\nimport { authenticate } from 'auth-provider'\r\n\r\nexport function proxy(request) {\r\n  const isAuthenticated = authenticate(request)\r\n\r\n  // If the user is authenticated, continue as normal\r\n  if (isAuthenticated) {\r\n    return NextResponse.next()\r\n  }\r\n\r\n  // Redirect to login page if not authenticated\r\n  return NextResponse.redirect(new URL('/login', request.url))\r\n}\r\n\r\nexport const config = {\r\n  matcher: '/dashboard/:path*',\r\n}",
        "context": "filename=\"proxy.js\" switcher"
      },
      {
        "language": "json",
        "code": "{\r\n  \"/old\": {\r\n    \"destination\": \"/new\",\r\n    \"permanent\": true\r\n  },\r\n  \"/blog/post-old\": {\r\n    \"destination\": \"/blog/post-new\",\r\n    \"permanent\": true\r\n  }\r\n}",
        "context": ""
      },
      {
        "language": "ts",
        "code": "import { NextResponse, NextRequest } from 'next/server'\r\nimport { get } from '@vercel/edge-config'\r\n\r\ntype RedirectEntry = {\r\n  destination: string\r\n  permanent: boolean\r\n}\r\n\r\nexport async function proxy(request: NextRequest) {\r\n  const pathname = request.nextUrl.pathname\r\n  const redirectData = await get(pathname)\r\n\r\n  if (redirectData && typeof redirectData === 'string') {\r\n    const redirectEntry: RedirectEntry = JSON.parse(redirectData)\r\n    const statusCode = redirectEntry.permanent ? 308 : 307\r\n    return NextResponse.redirect(redirectEntry.destination, statusCode)\r\n  }\r\n\r\n  // No redirect found, continue without redirecting\r\n  return NextResponse.next()\r\n}",
        "context": "filename=\"proxy.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { NextResponse } from 'next/server'\r\nimport { get } from '@vercel/edge-config'\r\n\r\nexport async function proxy(request) {\r\n  const pathname = request.nextUrl.pathname\r\n  const redirectData = await get(pathname)\r\n\r\n  if (redirectData) {\r\n    const redirectEntry = JSON.parse(redirectData)\r\n    const statusCode = redirectEntry.permanent ? 308 : 307\r\n    return NextResponse.redirect(redirectEntry.destination, statusCode)\r\n  }\r\n\r\n  // No redirect found, continue without redirecting\r\n  return NextResponse.next()\r\n}",
        "context": "filename=\"proxy.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { NextResponse, NextRequest } from 'next/server'\r\nimport { ScalableBloomFilter } from 'bloom-filters'\r\nimport GeneratedBloomFilter from './redirects/bloom-filter.json'\r\n\r\ntype RedirectEntry = {\r\n  destination: string\r\n  permanent: boolean\r\n}\r\n\r\n// Initialize bloom filter from a generated JSON file\r\nconst bloomFilter = ScalableBloomFilter.fromJSON(GeneratedBloomFilter as any)\r\n\r\nexport async function proxy(request: NextRequest) {\r\n  // Get the path for the incoming request\r\n  const pathname = request.nextUrl.pathname\r\n\r\n  // Check if the path is in the bloom filter\r\n  if (bloomFilter.has(pathname)) {\r\n    // Forward the pathname to the Route Handler\r\n    const api = new URL(\r\n      `/api/redirects?pathname=${encodeURIComponent(request.nextUrl.pathname)}`,\r\n      request.nextUrl.origin\r\n    )\r\n\r\n    try {\r\n      // Fetch redirect data from the Route Handler\r\n      const redirectData = await fetch(api)\r\n\r\n      if (redirectData.ok) {\r\n        const redirectEntry: RedirectEntry | undefined =\r\n          await redirectData.json()\r\n\r\n        if (redirectEntry) {\r\n          // Determine the status code\r\n          const statusCode = redirectEntry.permanent ? 308 : 307\r\n\r\n          // Redirect to the destination\r\n          return NextResponse.redirect(redirectEntry.destination, statusCode)\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error(error)\r\n    }\r\n  }\r\n\r\n  // No redirect found, continue the request without redirecting\r\n  return NextResponse.next()\r\n}",
        "context": "filename=\"proxy.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { NextResponse } from 'next/server'\r\nimport { ScalableBloomFilter } from 'bloom-filters'\r\nimport GeneratedBloomFilter from './redirects/bloom-filter.json'\r\n\r\n// Initialize bloom filter from a generated JSON file\r\nconst bloomFilter = ScalableBloomFilter.fromJSON(GeneratedBloomFilter)\r\n\r\nexport async function proxy(request) {\r\n  // Get the path for the incoming request\r\n  const pathname = request.nextUrl.pathname\r\n\r\n  // Check if the path is in the bloom filter\r\n  if (bloomFilter.has(pathname)) {\r\n    // Forward the pathname to the Route Handler\r\n    const api = new URL(\r\n      `/api/redirects?pathname=${encodeURIComponent(request.nextUrl.pathname)}`,\r\n      request.nextUrl.origin\r\n    )\r\n\r\n    try {\r\n      // Fetch redirect data from the Route Handler\r\n      const redirectData = await fetch(api)\r\n\r\n      if (redirectData.ok) {\r\n        const redirectEntry = await redirectData.json()\r\n\r\n        if (redirectEntry) {\r\n          // Determine the status code\r\n          const statusCode = redirectEntry.permanent ? 308 : 307\r\n\r\n          // Redirect to the destination\r\n          return NextResponse.redirect(redirectEntry.destination, statusCode)\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error(error)\r\n    }\r\n  }\r\n\r\n  // No redirect found, continue the request without redirecting\r\n  return NextResponse.next()\r\n}",
        "context": "filename=\"proxy.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { NextRequest, NextResponse } from 'next/server'\r\nimport redirects from '@/app/redirects/redirects.json'\r\n\r\ntype RedirectEntry = {\r\n  destination: string\r\n  permanent: boolean\r\n}\r\n\r\nexport function GET(request: NextRequest) {\r\n  const pathname = request.nextUrl.searchParams.get('pathname')\r\n  if (!pathname) {\r\n    return new Response('Bad Request', { status: 400 })\r\n  }\r\n\r\n  // Get the redirect entry from the redirects.json file\r\n  const redirect = (redirects as Record<string, RedirectEntry>)[pathname]\r\n\r\n  // Account for bloom filter false positives\r\n  if (!redirect) {\r\n    return new Response('No redirect', { status: 400 })\r\n  }\r\n\r\n  // Return the redirect entry\r\n  return NextResponse.json(redirect)\r\n}",
        "context": "filename=\"app/api/redirects/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { NextResponse } from 'next/server'\r\nimport redirects from '@/app/redirects/redirects.json'\r\n\r\nexport function GET(request) {\r\n  const pathname = request.nextUrl.searchParams.get('pathname')\r\n  if (!pathname) {\r\n    return new Response('Bad Request', { status: 400 })\r\n  }\r\n\r\n  // Get the redirect entry from the redirects.json file\r\n  const redirect = redirects[pathname]\r\n\r\n  // Account for bloom filter false positives\r\n  if (!redirect) {\r\n    return new Response('No redirect', { status: 400 })\r\n  }\r\n\r\n  // Return the redirect entry\r\n  return NextResponse.json(redirect)\r\n}",
        "context": "filename=\"app/api/redirects/route.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import type { NextApiRequest, NextApiResponse } from 'next'\r\nimport redirects from '@/app/redirects/redirects.json'\r\n\r\ntype RedirectEntry = {\r\n  destination: string\r\n  permanent: boolean\r\n}\r\n\r\nexport default function handler(req: NextApiRequest, res: NextApiResponse) {\r\n  const pathname = req.query.pathname\r\n  if (!pathname) {\r\n    return res.status(400).json({ message: 'Bad Request' })\r\n  }\r\n\r\n  // Get the redirect entry from the redirects.json file\r\n  const redirect = (redirects as Record<string, RedirectEntry>)[pathname]\r\n\r\n  // Account for bloom filter false positives\r\n  if (!redirect) {\r\n    return res.status(400).json({ message: 'No redirect' })\r\n  }\r\n\r\n  // Return the redirect entry\r\n  return res.json(redirect)\r\n}",
        "context": "filename=\"pages/api/redirects.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import redirects from '@/app/redirects/redirects.json'\r\n\r\nexport default function handler(req, res) {\r\n  const pathname = req.query.pathname\r\n  if (!pathname) {\r\n    return res.status(400).json({ message: 'Bad Request' })\r\n  }\r\n\r\n  // Get the redirect entry from the redirects.json file\r\n  const redirect = redirects[pathname]\r\n\r\n  // Account for bloom filter false positives\r\n  if (!redirect) {\r\n    return res.status(400).json({ message: 'No redirect' })\r\n  }\r\n\r\n  // Return the redirect entry\r\n  return res.json(redirect)\r\n}",
        "context": "filename=\"pages/api/redirects.js\" switcher"
      }
    ],
    "content": "There are a few ways you can handle redirects in Next.js. This page will go through each available option, use cases, and how to manage large numbers of redirects. | API | Purpose | Where | Status Code | | ------------------------------------------------------------- | ------------------------------------------------- | ------------------------------------------------- | -------------------------------------- | | redirect | Redirect user after a mutation or event | Server Components, Server Actions, Route Handlers | 307 (Temporary) or 303 (Server Action) | | permanentRedirect | Redirect user after a mutation or event | Server Components, Server Actions, Route Handlers | 308 (Permanent) | | useRouter | Perform a client-side navigation | Event Handlers in Client Components | N/A | | redirects in next.config.js | Redirect an incoming request based on a path | next.config.js file | 307 (Temporary) or 308 (Permanent) | | NextResponse.redirect | Redirect an incoming request based on a condition | Proxy | Any | | API | Purpose | Where | Status Code | | ------------------------------------------------------------- | ------------------------------------------------- | --------------------- | ---------------------------------- | | useRouter | Perform a client-side navigation | Components | N/A | | redirects in next.config.js | Redirect an incoming request based on a path | next.config.js file | 307 (Temporary) or 308 (Permanent) | | NextResponse.redirect | Redirect an incoming request based on a condition | Proxy | Any | redirect function The redirect function allows you to redirect the user to another URL. You can call redirect in Server Components, Route Handlers, and Server Actions. redirect is often used after a mutation or event. For example, creating a post: > Good to know: > > - redirect returns a 307 (Temporary Redirect) status code by default. When used in a Server Action, it returns a 303 (See Other), which is commonly used for redirecting to a success page as a result of a POST request. > - redirect throws an error so it should be called outside the try block when using try/catch statements. > - redirect can be called in Client Components during the rendering process but not in event handlers. You can use the useRouter hook instead. > - redirect also accepts absolute URLs and can be used to redirect to external links. > - If you'd like to redirect before the render process, use next.config.js or Proxy. See the redirect API reference for more information. permanentRedirect function The permanentRedirect function allows you to permanently redirect the user to another URL. You can call permanentRedirect in Server Components, Route Handlers, and Server Actions. permanentRedirect is often used after a mutation or event that changes an entity's canonical URL, such as updating a user's profile URL after they change their username: > Good to know: > > - permanentRedirect returns a 308 (permanent redirect) status code by default. > - permanentRedirect also accepts absolute URLs and can be used to redirect to external links. > - If you'd like to redirect before the render process, use next.config.js or Proxy. See the permanentRedirect API reference for more information. useRouter() hook If you need to redirect inside an event handler in a Client Component, you can use the push method from the useRouter hook. For example: If you need to redirect inside a component, you can use the push method from the useRouter hook. For example: > Good to know: > > - If you don't need to programmatically navigate a user, you should use a component. See the useRouter API reference for more information. See the useRouter API reference for more information. redirects in next.config.js The redirects option in the next.config.js file allows you to redirect an incoming request path to a different destination path. This is useful when you change the URL structure of pages or have a list of redirects that are known ahead of time. redirects supports path, header, cookie, and query matching, giving you the flexibility to redirect users based on an incoming request. To use redirects, add the option to your next.config.js file: See the redirects API reference for more information. > Good to know: > > - redirects can return a 307 (Temporary Redirect) or 308 (Permanent Redirect) status code with the permanent option. > - redirects may have a limit on platforms. For example, on Vercel, there's a limit of 1,024 redirects. To manage a large number of redirects (1000+), consider creating a custom solution using Proxy. See managing redirects at scale for more. > - redirects runs before Proxy. NextResponse.redirect in Proxy Proxy allows you to run code before a request is completed. Then, based on the incoming request, redirect to a different URL using NextResponse.redirect. This is useful if you want to redirect users based on a condition (e.g. authentication, session management, etc) or have a large number of redirects. For example, to redirect the user to a /login page if they are not authenticated: > Good to know: > > - Proxy runs after redirects in next.config.js and before rendering. See the Proxy documentation for more information. Managing redirects at scale (advanced) To manage a large number of redirects (1000+), you may consider creating a custom solution using Proxy. This allows you to handle redirects programmatically without having to redeploy your application. To do this, you'll need to consider: 1. Creating and storing a redirect map. 2. Optimizing data lookup performance. > Next.js Example: See our Proxy with Bloom filter example for an implementation of the recommendations below. 1. Creating and storing a redirect map A redirect map is a list of redirects that you can store in a database (usually a key-value store) or JSON file. Consider the following data structure: In Proxy, you can read from a database such as Vercel's Edge Config or Redis, and redirect the user based on the incoming request: 2. Optimizing data lookup performance Reading a large dataset for every incoming request can be slow and expensive. There are two ways you can optimize data lookup performance: - Use a database that is optimized for fast reads - Use a data lookup strategy such as a Bloom filter to efficiently check if a redirect exists before reading the larger redirects file or database. Considering the previous example, you can import a generated bloom filter file into Proxy, then, check if the incoming request pathname exists in the bloom filter. If it does, forward the request to a Route Handler API Routes which will check the actual file and redirect the user to the appropriate URL. This avoids importing a large redirects file into Proxy, which can slow down every incoming request. Then, in the Route Handler: Then, in the API Route: > Good to know: > > - To generate a bloom filter, you can use a library like bloom-filters. > - You should validate requests made to your Route Handler to prevent malicious requests.",
    "excerpt": "There are a few ways you can handle redirects in Next.js. This page will go through each available option, use cases, and how to manage large numbers of redirects. | API | Purpose | Where | Status Cod...",
    "url": "https://nextjs.org/docs/01-app/02-guides/redirecting"
  },
  {
    "id": "01-app-02-guides-sass",
    "path": "01-app\\02-guides\\sass.mdx",
    "title": "How to use Sass",
    "description": "Style your Next.js application using Sass.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 3,
        "text": "Customizing Sass Options",
        "slug": "customizing-sass-options"
      },
      {
        "level": 4,
        "text": "Implementation",
        "slug": "implementation"
      },
      {
        "level": 3,
        "text": "Sass Variables",
        "slug": "sass-variables"
      }
    ],
    "codeBlocks": [
      {
        "language": "bash",
        "code": "npm install --save-dev sass",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  sassOptions: {\r\n    additionalData: `$var: red;`,\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\n\r\nconst nextConfig = {\r\n  sassOptions: {\r\n    additionalData: `$var: red;`,\r\n  },\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  sassOptions: {\r\n    implementation: 'sass-embedded',\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\n\r\nconst nextConfig = {\r\n  sassOptions: {\r\n    implementation: 'sass-embedded',\r\n  },\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\" switcher"
      },
      {
        "language": "scss",
        "code": "$primary-color: #64ff00;\r\n\r\n:export {\r\n  primaryColor: $primary-color;\r\n}",
        "context": "filename=\"app/variables.module.scss\""
      },
      {
        "language": "jsx",
        "code": "// maps to root `/` URL\r\n\r\nimport variables from './variables.module.scss'\r\n\r\nexport default function Page() {\r\n  return <h1 style={{ color: variables.primaryColor }}>Hello, Next.js!</h1>\r\n}",
        "context": "filename=\"app/page.js\""
      },
      {
        "language": "jsx",
        "code": "import variables from '../styles/variables.module.scss'\r\n\r\nexport default function MyApp({ Component, pageProps }) {\r\n  return (\r\n    <Layout color={variables.primaryColor}>\r\n      <Component {...pageProps} />\r\n    </Layout>\r\n  )\r\n}",
        "context": "filename=\"pages/_app.js\""
      }
    ],
    "content": "Next.js has built-in support for integrating with Sass after the package is installed using both the .scss and .sass extensions. You can use component-level Sass via CSS Modules and the .module.scssor .module.sass extension. First, install sass: > Good to know: > > Sass supports two different syntaxes, each with their own extension. > The .scss extension requires you use the SCSS syntax, > while the .sass extension requires you use the Indented Syntax (\"Sass\"). > > If you're not sure which to choose, start with the .scss extension which is a superset of CSS, and doesn't require you learn the > Indented Syntax (\"Sass\"). Customizing Sass Options If you want to configure your Sass options, use sassOptions in next.config. Implementation You can use the implementation property to specify the Sass implementation to use. By default, Next.js uses the sass package. Sass Variables Next.js supports Sass variables exported from CSS Module files. For example, using the exported primaryColor Sass variable:",
    "excerpt": "Next.js has built-in support for integrating with Sass after the package is installed using both the .scss and .sass extensions. You can use component-level Sass via CSS Modules and the .module.scssor...",
    "url": "https://nextjs.org/docs/01-app/02-guides/sass"
  },
  {
    "id": "01-app-02-guides-scripts",
    "path": "01-app\\02-guides\\scripts.mdx",
    "title": "How to load and optimize scripts",
    "description": "Optimize 3rd party scripts with the built-in Script component.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 3,
        "text": "Layout Scripts",
        "slug": "layout-scripts"
      },
      {
        "level": 3,
        "text": "Application Scripts",
        "slug": "application-scripts"
      },
      {
        "level": 3,
        "text": "Strategy",
        "slug": "strategy"
      },
      {
        "level": 3,
        "text": "Offloading Scripts To A Web Worker (experimental)",
        "slug": "offloading-scripts-to-a-web-worker-experimental"
      },
      {
        "level": 4,
        "text": "Using custom Partytown configuration",
        "slug": "using-custom-partytown-configuration"
      },
      {
        "level": 3,
        "text": "Inline Scripts",
        "slug": "inline-scripts"
      },
      {
        "level": 3,
        "text": "Executing Additional Code",
        "slug": "executing-additional-code"
      },
      {
        "level": 3,
        "text": "Additional Attributes",
        "slug": "additional-attributes"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "import Script from 'next/script'\r\n\r\nexport default function DashboardLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <>\r\n      <section>{children}</section>\r\n      <Script src=\"https://example.com/script.js\" />\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/dashboard/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Script from 'next/script'\r\n\r\nexport default function DashboardLayout({ children }) {\r\n  return (\r\n    <>\r\n      <section>{children}</section>\r\n      <Script src=\"https://example.com/script.js\" />\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/dashboard/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Script from 'next/script'\r\n\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>{children}</body>\r\n      <Script src=\"https://example.com/script.js\" />\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Script from 'next/script'\r\n\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>{children}</body>\r\n      <Script src=\"https://example.com/script.js\" />\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Script from 'next/script'\r\n\r\nexport default function MyApp({ Component, pageProps }) {\r\n  return (\r\n    <>\r\n      <Component {...pageProps} />\r\n      <Script src=\"https://example.com/script.js\" />\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"pages/_app.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  experimental: {\r\n    nextScriptWorkers: true,\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "bash",
        "code": "npm run dev",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "tsx",
        "code": "import Script from 'next/script'\r\n\r\nexport default function Home() {\r\n  return (\r\n    <>\r\n      <Script src=\"https://example.com/script.js\" strategy=\"worker\" />\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"pages/home.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Script from 'next/script'\r\n\r\nexport default function Home() {\r\n  return (\r\n    <>\r\n      <Script src=\"https://example.com/script.js\" strategy=\"worker\" />\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"pages/home.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { Html, Head, Main, NextScript } from 'next/document'\r\n\r\nexport default function Document() {\r\n  return (\r\n    <Html>\r\n      <Head>\r\n        <script\r\n          data-partytown-config\r\n          dangerouslySetInnerHTML={{\r\n            __html: `\r\n              partytown = {\r\n                lib: \"/_next/static/~partytown/\",\r\n                debug: true\r\n              };\r\n            `,\r\n          }}\r\n        />\r\n      </Head>\r\n      <body>\r\n        <Main />\r\n        <NextScript />\r\n      </body>\r\n    </Html>\r\n  )\r\n}",
        "context": "filename=\"_pages/document.jsx\""
      },
      {
        "language": "jsx",
        "code": "<Script id=\"show-banner\">\r\n  {`document.getElementById('banner').classList.remove('hidden')`}\r\n</Script>",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "<Script\r\n  id=\"show-banner\"\r\n  dangerouslySetInnerHTML={{\r\n    __html: `document.getElementById('banner').classList.remove('hidden')`,\r\n  }}\r\n/>",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport Script from 'next/script'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <Script\r\n        src=\"https://example.com/script.js\"\r\n        onLoad={() => {\r\n          console.log('Script has loaded')\r\n        }}\r\n      />\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport Script from 'next/script'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <Script\r\n        src=\"https://example.com/script.js\"\r\n        onLoad={() => {\r\n          console.log('Script has loaded')\r\n        }}\r\n      />\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Script from 'next/script'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <Script\r\n        src=\"https://example.com/script.js\"\r\n        onLoad={() => {\r\n          console.log('Script has loaded')\r\n        }}\r\n      />\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"pages/index.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Script from 'next/script'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <Script\r\n        src=\"https://example.com/script.js\"\r\n        onLoad={() => {\r\n          console.log('Script has loaded')\r\n        }}\r\n      />\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"pages/index.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Script from 'next/script'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <Script\r\n        src=\"https://example.com/script.js\"\r\n        id=\"example-script\"\r\n        nonce=\"XUENAJFW\"\r\n        data-test=\"script\"\r\n      />\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Script from 'next/script'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <Script\r\n        src=\"https://example.com/script.js\"\r\n        id=\"example-script\"\r\n        nonce=\"XUENAJFW\"\r\n        data-test=\"script\"\r\n      />\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Script from 'next/script'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <Script\r\n        src=\"https://example.com/script.js\"\r\n        id=\"example-script\"\r\n        nonce=\"XUENAJFW\"\r\n        data-test=\"script\"\r\n      />\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"pages/index.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Script from 'next/script'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <Script\r\n        src=\"https://example.com/script.js\"\r\n        id=\"example-script\"\r\n        nonce=\"XUENAJFW\"\r\n        data-test=\"script\"\r\n      />\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"pages/index.js\" switcher"
      }
    ],
    "content": "Layout Scripts To load a third-party script for multiple routes, import next/script and include the script directly in your layout component: The third-party script is fetched when the folder route (e.g. dashboard/page.js) or any nested route (e.g. dashboard/settings/page.js) is accessed by the user. Next.js will ensure the script will only load once, even if a user navigates between multiple routes in the same layout. Application Scripts To load a third-party script for all routes, import next/script and include the script directly in your root layout: To load a third-party script for all routes, import next/script and include the script directly in your custom app: This script will load and execute when any route in your application is accessed. Next.js will ensure the script will only load once, even if a user navigates between multiple pages. > Recommendation: We recommend only including third-party scripts in specific pages or layouts in order to minimize any unnecessary impact to performance. Strategy Although the default behavior of next/script allows you to load third-party scripts in any page or layout, you can fine-tune its loading behavior by using the strategy property: - beforeInteractive: Load the script before any Next.js code and before any page hydration occurs. - afterInteractive: (default) Load the script early but after some hydration on the page occurs. - lazyOnload: Load the script later during browser idle time. - worker: (experimental) Load the script in a web worker. Refer to the next/script API reference documentation to learn more about each strategy and their use cases. Offloading Scripts To A Web Worker (experimental) > Warning: The worker strategy is not yet stable and does not yet work with the App Router. Use with caution. Scripts that use the worker strategy are offloaded and executed in a web worker with Partytown. This can improve the performance of your site by dedicating the main thread to the rest of your application code. This strategy is still experimental and can only be used if the nextScriptWorkers flag is enabled in next.config.js: Then, run next (normally npm run dev or yarn dev) and Next.js will guide you through the installation of the required packages to finish the setup: You'll see instructions like these: Please install Partytown by running npm install @builder.io/partytown Once setup is complete, defining strategy=\"worker\" will automatically instantiate Partytown in your application and offload the script to a web worker. There are a number of trade-offs that need to be considered when loading a third-party script in a web worker. Please see Partytown's tradeoffs documentation for more information. Using custom Partytown configuration Although the worker strategy does not require any additional configuration to work, Partytown supports the use of a config object to modify some of its settings, including enabling debug mode and forwarding events and triggers. If you would like to add additional configuration options, you can include it within the component used in a custom document.js: In order to modify Partytown's configuration, the following conditions must be met: 1. The data-partytown-config attribute must be used in order to overwrite the default configuration used by Next.js 2. Unless you decide to save Partytown's library files in a separate directory, the lib: \"/next/static/~partytown/\" property and value must be included in the configuration object in order to let Partytown know where Next.js stores the necessary static files. > Note: If you are using an asset prefix and would like to modify Partytown's default configuration, you must include it as part of the lib path. Take a look at Partytown's configuration options to see the full list of other properties that can be added. Inline Scripts Inline scripts, or scripts not loaded from an external file, are also supported by the Script component. They can be written by placing the JavaScript within curly braces: Or by using the dangerouslySetInnerHTML property: > Warning: An id property must be assigned for inline scripts in order for Next.js to track and optimize the script. Executing Additional Code Event handlers can be used with the Script component to execute additional code after a certain event occurs: - onLoad: Execute code after the script has finished loading. - onReady: Execute code after the script has finished loading and every time the component is mounted. - onError: Execute code if the script fails to load. These handlers will only work when next/script is imported and used inside of a Client Component where \"use client\" is defined as the first line of code: Refer to the next/script API reference to learn more about each event handler and view examples. These handlers will only work when next/script is imported and used inside of a Client Component where \"use client\" is defined as the first line of code: Refer to the next/script API reference to learn more about each event handler and view examples. Additional Attributes There are many DOM attributes that can be assigned to a element that are not used by the Script component, like nonce or custom data attributes. Including any additional attributes will automatically forward it to the final, optimized element that is included in the HTML.",
    "excerpt": "Layout Scripts To load a third-party script for multiple routes, import next/script and include the script directly in your layout component: The third-party script is fetched when the folder route (e...",
    "url": "https://nextjs.org/docs/01-app/02-guides/scripts"
  },
  {
    "id": "01-app-02-guides-self-hosting",
    "path": "01-app\\02-guides\\self-hosting.mdx",
    "title": "How to self-host your Next.js application",
    "description": "Learn how to self-host your Next.js application on a Node.js server, Docker image, or static HTML files (static exports).",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Image Optimization",
        "slug": "image-optimization"
      },
      {
        "level": 2,
        "text": "Proxy",
        "slug": "proxy"
      },
      {
        "level": 2,
        "text": "Environment Variables",
        "slug": "environment-variables"
      },
      {
        "level": 2,
        "text": "Caching and ISR",
        "slug": "caching-and-isr"
      },
      {
        "level": 3,
        "text": "Automatic Caching",
        "slug": "automatic-caching"
      },
      {
        "level": 3,
        "text": "Static Assets",
        "slug": "static-assets"
      },
      {
        "level": 3,
        "text": "Configuring Caching",
        "slug": "configuring-caching"
      },
      {
        "level": 2,
        "text": "Build Cache",
        "slug": "build-cache"
      },
      {
        "level": 2,
        "text": "Version Skew",
        "slug": "version-skew"
      },
      {
        "level": 2,
        "text": "Streaming and Suspense",
        "slug": "streaming-and-suspense"
      },
      {
        "level": 2,
        "text": "Cache Components",
        "slug": "cache-components"
      },
      {
        "level": 2,
        "text": "Usage with CDNs",
        "slug": "usage-with-cdns"
      },
      {
        "level": 2,
        "text": "Manual Graceful Shutdowns",
        "slug": "manual-graceful-shutdowns"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "import { connection } from 'next/server'\r\n\r\nexport default async function Component() {\r\n  await connection()\r\n  // cookies, headers, and other Dynamic APIs\r\n  // will also opt into dynamic rendering, meaning\r\n  // this env variable is evaluated at runtime\r\n  const value = process.env.MY_VALUE\r\n  // ...\r\n}",
        "context": "filename=\"app/page.ts\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { connection } from 'next/server'\r\n\r\nexport default async function Component() {\r\n  await connection()\r\n  // cookies, headers, and other Dynamic APIs\r\n  // will also opt into dynamic rendering, meaning\r\n  // this env variable is evaluated at runtime\r\n  const value = process.env.MY_VALUE\r\n  // ...\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "module.exports = {\r\n  cacheHandler: require.resolve('./cache-handler.js'),\r\n  cacheMaxMemorySize: 0, // disable default in-memory caching\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "jsx",
        "code": "const cache = new Map()\r\n\r\nmodule.exports = class CacheHandler {\r\n  constructor(options) {\r\n    this.options = options\r\n  }\r\n\r\n  async get(key) {\r\n    // This could be stored anywhere, like durable storage\r\n    return cache.get(key)\r\n  }\r\n\r\n  async set(key, data, ctx) {\r\n    // This could be stored anywhere, like durable storage\r\n    cache.set(key, {\r\n      value: data,\r\n      lastModified: Date.now(),\r\n      tags: ctx.tags,\r\n    })\r\n  }\r\n\r\n  async revalidateTag(tags) {\r\n    // tags is either a string or an array of strings\r\n    tags = [tags].flat()\r\n    // Iterate over all entries in the cache\r\n    for (let [key, value] of cache) {\r\n      // If the value's tags include the specified tag, delete this entry\r\n      if (value.tags.some((tag) => tags.includes(tag))) {\r\n        cache.delete(key)\r\n      }\r\n    }\r\n  }\r\n\r\n  // If you want to have temporary in memory cache for a single request that is reset\r\n  // before the next request you can leverage this method\r\n  resetRequestCache() {}\r\n}",
        "context": "filename=\"cache-handler.js\""
      },
      {
        "language": "jsx",
        "code": "module.exports = {\r\n  generateBuildId: async () => {\r\n    // This could be anything, using the latest git hash\r\n    return process.env.GIT_HASH\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  async headers() {\r\n    return [\r\n      {\r\n        source: '/:path*{/}?',\r\n        headers: [\r\n          {\r\n            key: 'X-Accel-Buffering',\r\n            value: 'no',\r\n          },\r\n        ],\r\n      },\r\n    ]\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "json",
        "code": "{\r\n  \"scripts\": {\r\n    \"dev\": \"next dev\",\r\n    \"build\": \"next build\",\r\n    \"start\": \"NEXT_MANUAL_SIG_HANDLE=true next start\"\r\n  }\r\n}",
        "context": "filename=\"package.json\""
      },
      {
        "language": "js",
        "code": "if (process.env.NEXT_MANUAL_SIG_HANDLE) {\r\n  process.on('SIGTERM', () => {\r\n    console.log('Received SIGTERM: cleaning up')\r\n    process.exit(0)\r\n  })\r\n  process.on('SIGINT', () => {\r\n    console.log('Received SIGINT: cleaning up')\r\n    process.exit(0)\r\n  })\r\n}",
        "context": "filename=\"pages/_document.js\""
      }
    ],
    "content": "When deploying your Next.js app, you may want to configure how different features are handled based on your infrastructure. > 🎥 Watch: Learn more about self-hosting Next.js → YouTube (45 minutes). Image Optimization Image Optimization through next/image works self-hosted with zero configuration when deploying using next start. If you would prefer to have a separate service to optimize images, you can configure an image loader. Image Optimization can be used with a static export by defining a custom image loader in next.config.js. Note that images are optimized at runtime, not during the build. > Good to know: > > - On glibc-based Linux systems, Image Optimization may require additional configuration to prevent excessive memory usage. > - Learn more about the caching behavior of optimized images and how to configure the TTL. > - You can also disable Image Optimization and still retain other benefits of using next/image if you prefer. For example, if you are optimizing images yourself separately. Proxy Proxy works self-hosted with zero configuration when deploying using next start. Since it requires access to the incoming request, it is not supported when using a static export. Proxy uses the Edge runtime, a subset of all available Node.js APIs to help ensure low latency, since it may run in front of every route or asset in your application. If you do not want this, you can use the full Node.js runtime to run Proxy. If you are looking to add logic (or use an external package) that requires all Node.js APIs, you might be able to move this logic to a layout as a Server Component. For example, checking headers and redirecting. You can also use headers, cookies, or query parameters to redirect or rewrite through next.config.js. If that does not work, you can also use a custom server. Environment Variables Next.js can support both build time and runtime environment variables. By default, environment variables are only available on the server. To expose an environment variable to the browser, it must be prefixed with NEXTPUBLIC. However, these public environment variables will be inlined into the JavaScript bundle during next build. To read runtime environment variables, we recommend using getServerSideProps or incrementally adopting the App Router. You safely read environment variables on the server during dynamic rendering. This allows you to use a singular Docker image that can be promoted through multiple environments with different values. > Good to know: > > - You can run code on server startup using the register function. Caching and ISR Next.js can cache responses, generated static pages, build outputs, and other static assets like images, fonts, and scripts. Caching and revalidating pages (with Incremental Static Regeneration) use the same shared cache. By default, this cache is stored to the filesystem (on disk) on your Next.js server. This works automatically when self-hosting using both the Pages and App Router. You can configure the Next.js cache location if you want to persist cached pages and data to durable storage, or share the cache across multiple containers or instances of your Next.js application. Automatic Caching - Next.js sets the Cache-Control header of public, max-age=31536000, immutable to truly immutable assets. It cannot be overridden. These immutable files contain a SHA-hash in the file name, so they can be safely cached indefinitely. For example, Static Image Imports. You can configure the TTL for images. - Incremental Static Regeneration (ISR) sets the Cache-Control header of s-maxage: , stale-while-revalidate. This revalidation time is defined in your getStaticProps function in seconds. If you set revalidate: false, it will default to a one-year cache duration. - Dynamically rendered pages set a Cache-Control header of private, no-cache, no-store, max-age=0, must-revalidate to prevent user-specific data from being cached. This applies to both the App Router and Pages Router. This also includes Draft Mode. Static Assets If you want to host static assets on a different domain or CDN, you can use the assetPrefix configuration in next.config.js. Next.js will use this asset prefix when retrieving JavaScript or CSS files. Separating your assets to a different domain does come with the downside of extra time spent on DNS and TLS resolution. Learn more about assetPrefix. Configuring Caching By default, generated cache assets will be stored in memory (defaults to 50mb) and on disk. If you are hosting Next.js using a container orchestration platform like Kubernetes, each pod will have a copy of the cache. To prevent stale data from being shown since the cache is not shared between pods by default, you can configure the Next.js cache to provide a cache handler and disable in-memory caching. To configure the ISR/Data Cache location when self-hosting, you can configure a custom handler in your next.config.js file: Then, create cache-handler.js in the root of your project, for example: Using a custom cache handler will allow you to ensure consistency across all pods hosting your Next.js application. For instance, you can save the cached values anywhere, like Redis or AWS S3. > Good to know: > > - revalidatePath is a convenience layer on top of cache tags. Calling revalidatePath will call the revalidateTag function with a special default tag for the provided page. Build Cache Next.js generates an ID during next build to identify which version of your application is being served. The same build should be used and boot up multiple containers. If you are rebuilding for each stage of your environment, you will need to generate a consistent build ID to use between containers. Use the generateBuildId command in next.config.js: Version Skew Next.js will automatically mitigate most instances of version skew and automatically reload the application to retrieve new assets when detected. For example, if there is a mismatch in the deploymentId, transitions between pages will perform a hard navigation versus using a prefetched value. When the application is reloaded, there may be a loss of application state if it's not designed to persist between page navigations. For example, using URL state or local storage would persist state after a page refresh. However, component state like useState would be lost in such navigations. Streaming and Suspense The Next.js App Router supports streaming responses when self-hosting. If you are using Nginx or a similar proxy, you will need to configure it to disable buffering to enable streaming. For example, you can disable buffering in Nginx by setting X-Accel-Buffering to no: Cache Components Cache Components works by default with Next.js and is not a CDN-only feature. This includes deployment as a Node.js server (through next start) and when used with a Docker container. Usage with CDNs When using a CDN in front on your Next.js application, the page will include Cache-Control: private response header when dynamic APIs are accessed. This ensures that the resulting HTML page is marked as non-cacheable. If the page is fully prerendered to static, it will include Cache-Control: public to allow the page to be cached on the CDN. If you don't need a mix of both static and dynamic components, you can make your entire route static and cache the output HTML on a CDN. This Automatic Static Optimization is the default behavior when running next build if dynamic APIs are not used. As Partial Prerendering moves to stable, we will provide support through the Deployment Adapters API. after after is fully supported when self-hosting with next start. When stopping the server, ensure a graceful shutdown by sending SIGINT or SIGTERM signals and waiting. This allows the Next.js server to wait until after pending callback functions or promises used inside after have finished. Manual Graceful Shutdowns When self-hosting, you might want to run code when the server shuts down on SIGTERM or SIGINT signals. You can set the env variable NEXTMANUALSIGHANDLE to true and then register a handler for that signal inside your document.js file. You will need to register the environment variable directly in the package.json script, and not in the .env file. > Good to know: Manual signal handling is not available in next dev.",
    "excerpt": "When deploying your Next.js app, you may want to configure how different features are handled based on your infrastructure. > 🎥 Watch: Learn more about self-hosting Next.js → YouTube (45 minutes). Im...",
    "url": "https://nextjs.org/docs/01-app/02-guides/self-hosting"
  },
  {
    "id": "01-app-02-guides-single-page-applications",
    "path": "01-app\\02-guides\\single-page-applications.mdx",
    "title": "How to build single-page applications with Next.js",
    "description": "Next.js fully supports building Single-Page Applications (SPAs).",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "What is a Single-Page Application?",
        "slug": "what-is-a-single-page-application"
      },
      {
        "level": 2,
        "text": "Why use Next.js for SPAs?",
        "slug": "why-use-nextjs-for-spas"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Using React’s  within a Context Provider",
        "slug": "using-reacts-within-a-context-provider"
      },
      {
        "level": 3,
        "text": "SPAs with SWR",
        "slug": "spas-with-swr"
      },
      {
        "level": 3,
        "text": "SPAs with React Query",
        "slug": "spas-with-react-query"
      },
      {
        "level": 3,
        "text": "Rendering components only in the browser",
        "slug": "rendering-components-only-in-the-browser"
      },
      {
        "level": 3,
        "text": "Shallow routing on the client",
        "slug": "shallow-routing-on-the-client"
      },
      {
        "level": 3,
        "text": "Using Server Actions in Client Components",
        "slug": "using-server-actions-in-client-components"
      },
      {
        "level": 2,
        "text": "Static export (optional)",
        "slug": "static-export-optional"
      },
      {
        "level": 2,
        "text": "Migrating existing projects to Next.js",
        "slug": "migrating-existing-projects-to-nextjs"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "import { UserProvider } from './user-provider'\r\nimport { getUser } from './user' // some server-side function\r\n\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  let userPromise = getUser() // do NOT await\r\n\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>\r\n        <UserProvider userPromise={userPromise}>{children}</UserProvider>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { UserProvider } from './user-provider'\r\nimport { getUser } from './user' // some server-side function\r\n\r\nexport default function RootLayout({ children }) {\r\n  let userPromise = getUser() // do NOT await\r\n\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>\r\n        <UserProvider userPromise={userPromise}>{children}</UserProvider>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "ts",
        "code": "'use client';\r\n\r\nimport { createContext, useContext, ReactNode } from 'react';\r\n\r\ntype User = any;\r\ntype UserContextType = {\r\n  userPromise: Promise<User | null>;\r\n};\r\n\r\nconst UserContext = createContext<UserContextType | null>(null);\r\n\r\nexport function useUser(): UserContextType {\r\n  let context = useContext(UserContext);\r\n  if (context === null) {\r\n    throw new Error('useUser must be used within a UserProvider');\r\n  }\r\n  return context;\r\n}\r\n\r\nexport function UserProvider({\r\n  children,\r\n  userPromise\r\n}: {\r\n  children: ReactNode;\r\n  userPromise: Promise<User | null>;\r\n}) {\r\n  return (\r\n    <UserContext.Provider value={{ userPromise }}>\r\n      {children}\r\n    </UserContext.Provider>\r\n  );\r\n}",
        "context": "filename=\"app/user-provider.ts\" switcher"
      },
      {
        "language": "js",
        "code": "'use client'\r\n\r\nimport { createContext, useContext, ReactNode } from 'react'\r\n\r\nconst UserContext = createContext(null)\r\n\r\nexport function useUser() {\r\n  let context = useContext(UserContext)\r\n  if (context === null) {\r\n    throw new Error('useUser must be used within a UserProvider')\r\n  }\r\n  return context\r\n}\r\n\r\nexport function UserProvider({ children, userPromise }) {\r\n  return (\r\n    <UserContext.Provider value={{ userPromise }}>\r\n      {children}\r\n    </UserContext.Provider>\r\n  )\r\n}",
        "context": "filename=\"app/user-provider.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { use } from 'react'\r\nimport { useUser } from './user-provider'\r\n\r\nexport function Profile() {\r\n  const { userPromise } = useUser()\r\n  const user = use(userPromise)\r\n\r\n  return '...'\r\n}",
        "context": "filename=\"app/profile.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { use } from 'react'\r\nimport { useUser } from './user-provider'\r\n\r\nexport function Profile() {\r\n  const { userPromise } = useUser()\r\n  const user = use(userPromise)\r\n\r\n  return '...'\r\n}",
        "context": "filename=\"app/profile.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { SWRConfig } from 'swr'\r\nimport { getUser } from './user' // some server-side function\r\n\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <SWRConfig\r\n      value={{\r\n        fallback: {\r\n          // We do NOT await getUser() here\r\n          // Only components that read this data will suspend\r\n          '/api/user': getUser(),\r\n        },\r\n      }}\r\n    >\r\n      {children}\r\n    </SWRConfig>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "js",
        "code": "import { SWRConfig } from 'swr'\r\nimport { getUser } from './user' // some server-side function\r\n\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <SWRConfig\r\n      value={{\r\n        fallback: {\r\n          // We do NOT await getUser() here\r\n          // Only components that read this data will suspend\r\n          '/api/user': getUser(),\r\n        },\r\n      }}\r\n    >\r\n      {children}\r\n    </SWRConfig>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport useSWR from 'swr'\r\n\r\nexport function Profile() {\r\n  const fetcher = (url) => fetch(url).then((res) => res.json())\r\n  // The same SWR pattern you already know\r\n  const { data, error } = useSWR('/api/user', fetcher)\r\n\r\n  return '...'\r\n}",
        "context": "filename=\"app/profile.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport useSWR from 'swr'\r\n\r\nexport function Profile() {\r\n  const fetcher = (url) => fetch(url).then((res) => res.json())\r\n  // The same SWR pattern you already know\r\n  const { data, error } = useSWR('/api/user', fetcher)\r\n\r\n  return '...'\r\n}",
        "context": "filename=\"app/profile.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "import dynamic from 'next/dynamic'\r\n\r\nconst ClientOnlyComponent = dynamic(() => import('./component'), {\r\n  ssr: false,\r\n})",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { useSearchParams } from 'next/navigation'\r\n\r\nexport default function SortProducts() {\r\n  const searchParams = useSearchParams()\r\n\r\n  function updateSorting(sortOrder: string) {\r\n    const urlSearchParams = new URLSearchParams(searchParams.toString())\r\n    urlSearchParams.set('sort', sortOrder)\r\n    window.history.pushState(null, '', `?${urlSearchParams.toString()}`)\r\n  }\r\n\r\n  return (\r\n    <>\r\n      <button onClick={() => updateSorting('asc')}>Sort Ascending</button>\r\n      <button onClick={() => updateSorting('desc')}>Sort Descending</button>\r\n    </>\r\n  )\r\n}",
        "context": "fileName=\"app/ui/sort-products.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { useSearchParams } from 'next/navigation'\r\n\r\nexport default function SortProducts() {\r\n  const searchParams = useSearchParams()\r\n\r\n  function updateSorting(sortOrder) {\r\n    const urlSearchParams = new URLSearchParams(searchParams.toString())\r\n    urlSearchParams.set('sort', sortOrder)\r\n    window.history.pushState(null, '', `?${urlSearchParams.toString()}`)\r\n  }\r\n\r\n  return (\r\n    <>\r\n      <button onClick={() => updateSorting('asc')}>Sort Ascending</button>\r\n      <button onClick={() => updateSorting('desc')}>Sort Descending</button>\r\n    </>\r\n  )\r\n}",
        "context": "fileName=\"app/ui/sort-products.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use server'\r\n\r\nexport async function create() {}",
        "context": "filename=\"app/actions.ts\" switcher"
      },
      {
        "language": "js",
        "code": "'use server'\r\n\r\nexport async function create() {}",
        "context": "filename=\"app/actions.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { create } from './actions'\r\n\r\nexport function Button() {\r\n  return <button onClick={() => create()}>Create</button>\r\n}",
        "context": "filename=\"app/button.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { create } from './actions'\r\n\r\nexport function Button() {\r\n  return <button onClick={() => create()}>Create</button>\r\n}",
        "context": "filename=\"app/button.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  output: 'export',\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\""
      }
    ],
    "content": "Next.js fully supports building Single-Page Applications (SPAs). This includes fast route transitions with prefetching, client-side data fetching, using browser APIs, integrating with third-party client libraries, creating static routes, and more. If you have an existing SPA, you can migrate to Next.js without large changes to your code. Next.js then allows you to progressively add server features as needed. What is a Single-Page Application? The definition of a SPA varies. We’ll define a “strict SPA” as: - Client-side rendering (CSR): The app is served by one HTML file (e.g. index.html). Every route, page transition, and data fetch is handled by JavaScript in the browser. - No full-page reloads: Rather than requesting a new document for each route, client-side JavaScript manipulates the current page’s DOM and fetches data as needed. Strict SPAs often require large amounts of JavaScript to load before the page can be interactive. Further, client data waterfalls can be challenging to manage. Building SPAs with Next.js can address these issues. Why use Next.js for SPAs? Next.js can automatically code split your JavaScript bundles, and generate multiple HTML entry points into different routes. This avoids loading unnecessary JavaScript code on the client-side, reducing the bundle size and enabling faster page loads. The next/link component automatically prefetches routes, giving you the fast page transitions of a strict SPA, but with the advantage of persisting application routing state to the URL for linking and sharing. Next.js can start as a static site or even a strict SPA where everything is rendered client-side. If your project grows, Next.js allows you to progressively add more server features (e.g. React Server Components, Server Actions, and more) as needed. Examples Let's explore common patterns used to build SPAs and how Next.js solves them. Using React’s use within a Context Provider We recommend fetching data in a parent component (or layout), returning the Promise, and then unwrapping the value in a Client Component with React’s use hook. Next.js can start data fetching early on the server. In this example, that’s the root layout — the entry point to your application. The server can immediately begin streaming a response to the client. By “hoisting” your data fetching to the root layout, Next.js starts the specified requests on the server early before any other components in your application. This eliminates client waterfalls and prevents having multiple roundtrips between client and server. It can also significantly improve performance, as your server is closer (and ideally colocated) to where your database is located. For example, update your root layout to call the Promise, but do not await it. While you can defer and pass a single Promise as a prop to a Client Component, we generally see this pattern paired with a React context provider. This enables easier access from Client Components with a custom React Hook. You can forward a Promise to the React context provider: Finally, you can call the useUser() custom hook in any Client Component and unwrap the Promise: The component that consumes the Promise (e.g. Profile above) will be suspended. This enables partial hydration. You can see the streamed and prerendered HTML before JavaScript has finished loading. SPAs with SWR SWR is a popular React library for data fetching. With SWR 2.3.0 (and React 19+), you can gradually adopt server features alongside your existing SWR-based client data fetching code. This is an abstraction of the above use() pattern. This means you can move data fetching between the client and server-side, or use both: - Client-only: useSWR(key, fetcher) - Server-only: useSWR(key) + RSC-provided data - Mixed: useSWR(key, fetcher) + RSC-provided data For example, wrap your application with and a fallback: Because this is a Server Component, getUser() can securely read cookies, headers, or talk to your database. No separate API route is needed. Client components below the can call useSWR() with the same key to retrieve the user data. The component code with useSWR does not require any changes from your existing client-fetching solution. The fallback data can be prerendered and included in the initial HTML response, then immediately read in the child components using useSWR. SWR’s polling, revalidation, and caching still run client-side only, so it preserves all the interactivity you rely on for an SPA. Since the initial fallback data is automatically handled by Next.js, you can now delete any conditional logic previously needed to check if data was undefined. When the data is loading, the closest boundary will be suspended. | | SWR | RSC | RSC + SWR | | -------------------- | ------------------- | ------------------- | ------------------- | | SSR data | | | | | Streaming while SSR | | | | | Deduplicate requests | | | | | Client-side features | | | | SPAs with React Query You can use React Query with Next.js on both the client and server. This enables you to build both strict SPAs, as well as take advantage of server features in Next.js paired with React Query. Learn more in the React Query documentation. Rendering components only in the browser Client components are prerendered during next build. If you want to disable prerendering for a Client Component and only load it in the browser environment, you can use next/dynamic: This can be useful for third-party libraries that rely on browser APIs like window or document. You can also add a useEffect that checks for the existence of these APIs, and if they do not exist, return null or a loading state which would be prerendered. Shallow routing on the client If you are migrating from a strict SPA like Create React App or Vite, you might have existing code which shallow routes to update the URL state. This can be useful for manual transitions between views in your application without using the default Next.js file-system routing. Next.js allows you to use the native window.history.pushState and window.history.replaceState methods to update the browser's history stack without reloading the page. pushState and replaceState calls integrate into the Next.js Router, allowing you to sync with usePathname and useSearchParams. Learn more about how routing and navigation work in Next.js. Using Server Actions in Client Components You can progressively adopt Server Actions while still using Client Components. This allows you to remove boilerplate code to call an API route, and instead use React features like useActionState to handle loading and error states. For example, create your first Server Action: You can import and use a Server Action from the client, similar to calling a JavaScript function. You do not need to create an API endpoint manually: Learn more about mutating data with Server Actions. Static export (optional) Next.js also supports generating a fully static site. This has some advantages over strict SPAs: - Automatic code-splitting: Instead of shipping a single index.html, Next.js will generate an HTML file per route, so your visitors get the content faster without waiting for the client JavaScript bundle. - Improved user experience: Instead of a minimal skeleton for all routes, you get fully rendered pages for each route. When users navigate client side, transitions remain instant and SPA-like. To enable a static export, update your configuration: After running next build, Next.js will create an out folder with the HTML/CSS/JS assets for your application. > Note: Next.js server features are not supported with static exports. Learn more. Migrating existing projects to Next.js You can incrementally migrate to Next.js by following our guides: - Migrating from Create React App - Migrating from Vite If you are already using a SPA with the Pages Router, you can learn how to incrementally adopt the App Router.",
    "excerpt": "Next.js fully supports building Single-Page Applications (SPAs). This includes fast route transitions with prefetching, client-side data fetching, using browser APIs, integrating with third-party clie...",
    "url": "https://nextjs.org/docs/01-app/02-guides/single-page-applications"
  },
  {
    "id": "01-app-02-guides-static-exports",
    "path": "01-app\\02-guides\\static-exports.mdx",
    "title": "How to create a static export of your Next.js application",
    "description": "Next.js enables starting as a static site or Single-Page Application (SPA), then later optionally upgrading to use features that require a server.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Configuration",
        "slug": "configuration"
      },
      {
        "level": 2,
        "text": "Supported Features",
        "slug": "supported-features"
      },
      {
        "level": 3,
        "text": "Server Components",
        "slug": "server-components"
      },
      {
        "level": 3,
        "text": "Client Components",
        "slug": "client-components"
      },
      {
        "level": 2,
        "text": "Supported Features",
        "slug": "supported-features"
      },
      {
        "level": 3,
        "text": "Image Optimization",
        "slug": "image-optimization"
      },
      {
        "level": 3,
        "text": "Route Handlers",
        "slug": "route-handlers"
      },
      {
        "level": 3,
        "text": "Browser APIs",
        "slug": "browser-apis"
      },
      {
        "level": 2,
        "text": "Unsupported Features",
        "slug": "unsupported-features"
      },
      {
        "level": 2,
        "text": "Deploying",
        "slug": "deploying"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "js",
        "code": "/**\r\n * @type {import('next').NextConfig}\r\n */\r\nconst nextConfig = {\r\n  output: 'export',\r\n\r\n  // Optional: Change links `/me` -> `/me/` and emit `/me.html` -> `/me/index.html`\r\n  // trailingSlash: true,\r\n\r\n  // Optional: Prevent automatic `/me` -> `/me/`, instead preserve `href`\r\n  // skipTrailingSlashRedirect: true,\r\n\r\n  // Optional: Change the output directory `out` -> `dist`\r\n  // distDir: 'dist',\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\" highlight={5}"
      },
      {
        "language": "tsx",
        "code": "export default async function Page() {\r\n  // This fetch will run on the server during `next build`\r\n  const res = await fetch('https://api.example.com/...')\r\n  const data = await res.json()\r\n\r\n  return <main>...</main>\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport useSWR from 'swr'\r\n\r\nconst fetcher = (url: string) => fetch(url).then((r) => r.json())\r\n\r\nexport default function Page() {\r\n  const { data, error } = useSWR(\r\n    `https://jsonplaceholder.typicode.com/posts/1`,\r\n    fetcher\r\n  )\r\n  if (error) return 'Failed to load'\r\n  if (!data) return 'Loading...'\r\n\r\n  return data.title\r\n}",
        "context": "filename=\"app/other/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport useSWR from 'swr'\r\n\r\nconst fetcher = (url) => fetch(url).then((r) => r.json())\r\n\r\nexport default function Page() {\r\n  const { data, error } = useSWR(\r\n    `https://jsonplaceholder.typicode.com/posts/1`,\r\n    fetcher\r\n  )\r\n  if (error) return 'Failed to load'\r\n  if (!data) return 'Loading...'\r\n\r\n  return data.title\r\n}",
        "context": "filename=\"app/other/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <h1>Index Page</h1>\r\n      <hr />\r\n      <ul>\r\n        <li>\r\n          <Link href=\"/post/1\">Post 1</Link>\r\n        </li>\r\n        <li>\r\n          <Link href=\"/post/2\">Post 2</Link>\r\n        </li>\r\n      </ul>\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <h1>Index Page</h1>\r\n      <p>\r\n        <Link href=\"/other\">Other Page</Link>\r\n      </p>\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  output: 'export',\r\n  images: {\r\n    loader: 'custom',\r\n    loaderFile: './my-loader.ts',\r\n  },\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "ts",
        "code": "export default function cloudinaryLoader({\r\n  src,\r\n  width,\r\n  quality,\r\n}: {\r\n  src: string\r\n  width: number\r\n  quality?: number\r\n}) {\r\n  const params = ['f_auto', 'c_limit', `w_${width}`, `q_${quality || 'auto'}`]\r\n  return `https://res.cloudinary.com/demo/image/upload/${params.join(\r\n    ','\r\n  )}${src}`\r\n}",
        "context": "filename=\"my-loader.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export default function cloudinaryLoader({ src, width, quality }) {\r\n  const params = ['f_auto', 'c_limit', `w_${width}`, `q_${quality || 'auto'}`]\r\n  return `https://res.cloudinary.com/demo/image/upload/${params.join(\r\n    ','\r\n  )}${src}`\r\n}",
        "context": "filename=\"my-loader.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Image from 'next/image'\r\n\r\nexport default function Page() {\r\n  return <Image alt=\"turtles\" src=\"/turtles.jpg\" width={300} height={300} />\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Image from 'next/image'\r\n\r\nexport default function Page() {\r\n  return <Image alt=\"turtles\" src=\"/turtles.jpg\" width={300} height={300} />\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "ts",
        "code": "export async function GET() {\r\n  return Response.json({ name: 'Lee' })\r\n}",
        "context": "filename=\"app/data.json/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export async function GET() {\r\n  return Response.json({ name: 'Lee' })\r\n}",
        "context": "filename=\"app/data.json/route.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client';\r\n\r\nimport { useEffect } from 'react';\r\n\r\nexport default function ClientComponent() {\r\n  useEffect(() => {\r\n    // You now have access to `window`\r\n    console.log(window.innerHeight);\r\n  }, [])\r\n\r\n  return ...;\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "export const dynamic = 'error'",
        "context": ""
      },
      {
        "language": "nginx",
        "code": "server {\r\n  listen 80;\r\n  server_name acme.com;\r\n\r\n  root /var/www/out;\r\n\r\n  location / {\r\n      try_files $uri $uri.html $uri/ =404;\r\n  }\r\n\r\n  # This is necessary when `trailingSlash: false`.\r\n  # You can omit this when `trailingSlash: true`.\r\n  location /blog/ {\r\n      rewrite ^/blog/(.*)$ /blog/$1.html break;\r\n  }\r\n\r\n  error_page 404 /404.html;\r\n  location = /404.html {\r\n      internal;\r\n  }\r\n}",
        "context": "filename=\"nginx.conf\""
      }
    ],
    "content": "Next.js enables starting as a static site or Single-Page Application (SPA), then later optionally upgrading to use features that require a server. When running next build, Next.js generates an HTML file per route. By breaking a strict SPA into individual HTML files, Next.js can avoid loading unnecessary JavaScript code on the client-side, reducing the bundle size and enabling faster page loads. Since Next.js supports this static export, it can be deployed and hosted on any web server that can serve HTML/CSS/JS static assets. Configuration To enable a static export, change the output mode inside next.config.js: After running next build, Next.js will create an out folder with the HTML/CSS/JS assets for your application. You can utilize getStaticProps and getStaticPaths to generate an HTML file for each page in your pages directory (or more for dynamic routes). Supported Features The core of Next.js has been designed to support static exports. Server Components When you run next build to generate a static export, Server Components consumed inside the app directory will run during the build, similar to traditional static-site generation. The resulting component will be rendered into static HTML for the initial page load and a static payload for client navigation between routes. No changes are required for your Server Components when using the static export, unless they consume dynamic server functions. Client Components If you want to perform data fetching on the client, you can use a Client Component with SWR to memoize requests. Since route transitions happen client-side, this behaves like a traditional SPA. For example, the following index route allows you to navigate to different posts on the client: Supported Features The majority of core Next.js features needed to build a static site are supported, including: - Dynamic Routes when using getStaticPaths - Prefetching with next/link - Preloading JavaScript - Dynamic Imports - Any styling options (e.g. CSS Modules, styled-jsx) - Client-side data fetching - getStaticProps - getStaticPaths Image Optimization Image Optimization through next/image can be used with a static export by defining a custom image loader in next.config.js. For example, you can optimize images with a service like Cloudinary: This custom loader will define how to fetch images from a remote source. For example, the following loader will construct the URL for Cloudinary: You can then use next/image in your application, defining relative paths to the image in Cloudinary: Route Handlers Route Handlers will render a static response when running next build. Only the GET HTTP verb is supported. This can be used to generate static HTML, JSON, TXT, or other files from cached or uncached data. For example: The above file app/data.json/route.ts will render to a static file during next build, producing data.json containing { name: 'Lee' }. If you need to read dynamic values from the incoming request, you cannot use a static export. Browser APIs Client Components are pre-rendered to HTML during next build. Because Web APIs like window, localStorage, and navigator are not available on the server, you need to safely access these APIs only when running in the browser. For example: Unsupported Features Features that require a Node.js server, or dynamic logic that cannot be computed during the build process, are not supported: - Dynamic Routes with dynamicParams: true - Dynamic Routes without generateStaticParams() - Route Handlers that rely on Request - Cookies - Rewrites - Redirects - Headers - Proxy - Incremental Static Regeneration - Image Optimization with the default loader - Draft Mode - Server Actions - Intercepting Routes Attempting to use any of these features with next dev will result in an error, similar to setting the dynamic option to error in the root layout. - Internationalized Routing - API Routes - Rewrites - Redirects - Headers - Proxy - Incremental Static Regeneration - Image Optimization with the default loader - Draft Mode - getStaticPaths with fallback: true - getStaticPaths with fallback: 'blocking' - getServerSideProps Deploying With a static export, Next.js can be deployed and hosted on any web server that can serve HTML/CSS/JS static assets. When running next build, Next.js generates the static export into the out folder. For example, let's say you have the following routes: - / - /blog/[id] After running next build, Next.js will generate the following files: - /out/index.html - /out/404.html - /out/blog/post-1.html - /out/blog/post-2.html If you are using a static host like Nginx, you can configure rewrites from incoming requests to the correct files: Version History | Version | Changes | | --------- | -------------------------------------------------------------------------------------------------------------------- | | v14.0.0 | next export has been removed in favor of \"output\": \"export\" | | v13.4.0 | App Router (Stable) adds enhanced static export support, including using React Server Components and Route Handlers. | | v13.3.0 | next export is deprecated and replaced with \"output\": \"export\" |",
    "excerpt": "Next.js enables starting as a static site or Single-Page Application (SPA), then later optionally upgrading to use features that require a server. When running next build, Next.js generates an HTML fi...",
    "url": "https://nextjs.org/docs/01-app/02-guides/static-exports"
  },
  {
    "id": "01-app-02-guides-tailwind-v3-css",
    "path": "01-app\\02-guides\\tailwind-v3-css.mdx",
    "title": "How to install Tailwind CSS v3 in your Next.js application",
    "description": "Style your Next.js Application using Tailwind CSS v3 for broader browser support.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Installing Tailwind v3",
        "slug": "installing-tailwind-v3"
      },
      {
        "level": 2,
        "text": "Configuring Tailwind v3",
        "slug": "configuring-tailwind-v3"
      },
      {
        "level": 2,
        "text": "Using classes",
        "slug": "using-classes"
      },
      {
        "level": 2,
        "text": "Usage with Turbopack",
        "slug": "usage-with-turbopack"
      }
    ],
    "codeBlocks": [
      {
        "language": "bash",
        "code": "pnpm add -D tailwindcss@^3 postcss autoprefixer\r\nnpx tailwindcss init -p",
        "context": "package=\"pnpm\""
      },
      {
        "language": "bash",
        "code": "npm install -D tailwindcss@^3 postcss autoprefixer\r\nnpx tailwindcss init -p",
        "context": "package=\"npm\""
      },
      {
        "language": "bash",
        "code": "yarn add -D tailwindcss@^3 postcss autoprefixer\r\nnpx tailwindcss init -p",
        "context": "package=\"yarn\""
      },
      {
        "language": "bash",
        "code": "bun add -D tailwindcss@^3 postcss autoprefixer\r\nbunx tailwindcss init -p",
        "context": "package=\"bun\""
      },
      {
        "language": "js",
        "code": "/** @type {import('tailwindcss').Config} */\r\nmodule.exports = {\r\n  content: [\r\n    './app/**/*.{js,ts,jsx,tsx,mdx}',\r\n    './pages/**/*.{js,ts,jsx,tsx,mdx}',\r\n    './components/**/*.{js,ts,jsx,tsx,mdx}',\r\n  ],\r\n  theme: {\r\n    extend: {},\r\n  },\r\n  plugins: [],\r\n}",
        "context": "filename=\"tailwind.config.js\""
      },
      {
        "language": "css",
        "code": "@tailwind base;\r\n@tailwind components;\r\n@tailwind utilities;",
        "context": "filename=\"app/globals.css\""
      },
      {
        "language": "tsx",
        "code": "import './globals.css'\r\n\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import './globals.css'\r\n\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "js",
        "code": "/** @type {import('tailwindcss').Config} */\r\nmodule.exports = {\r\n  content: [\r\n    './pages/**/*.{js,ts,jsx,tsx,mdx}',\r\n    './components/**/*.{js,ts,jsx,tsx,mdx}',\r\n    './app/**/*.{js,ts,jsx,tsx,mdx}',\r\n  ],\r\n  theme: {\r\n    extend: {},\r\n  },\r\n  plugins: [],\r\n}",
        "context": "filename=\"tailwind.config.js\""
      },
      {
        "language": "css",
        "code": "@tailwind base;\r\n@tailwind components;\r\n@tailwind utilities;",
        "context": "filename=\"styles/globals.css\""
      },
      {
        "language": "jsx",
        "code": "import '@/styles/globals.css'\r\n\r\nexport default function MyApp({ Component, pageProps }) {\r\n  return <Component {...pageProps} />\r\n}",
        "context": "filename=\"pages/_app.js\""
      },
      {
        "language": "tsx",
        "code": "export default function Page() {\r\n  return <h1 className=\"text-3xl font-bold underline\">Hello, Next.js!</h1>\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function Page() {\r\n  return <h1 className=\"text-3xl font-bold underline\">Hello, Next.js!</h1>\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default function Page() {\r\n  return <h1 className=\"text-3xl font-bold underline\">Hello, Next.js!</h1>\r\n}",
        "context": "filename=\"pages/index.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function Page() {\r\n  return <h1 className=\"text-3xl font-bold underline\">Hello, Next.js!</h1>\r\n}",
        "context": "filename=\"pages/index.js\" switcher"
      }
    ],
    "content": "This guide will walk you through how to install Tailwind CSS v3 in your Next.js application. > Good to know: For the latest Tailwind 4 setup, see the Tailwind CSS setup instructions. Installing Tailwind v3 Install Tailwind CSS and its peer dependencies, then run the init command to generate both tailwind.config.js and postcss.config.js files: Configuring Tailwind v3 Configure your template paths in your tailwind.config.js file: Add the Tailwind directives to your global CSS file: Import the CSS file in your root layout: Add the Tailwind directives to your global CSS file: Import the CSS file in your pages/app.js file: Using classes After installing Tailwind CSS and adding the global styles, you can use Tailwind's utility classes in your application. Usage with Turbopack As of Next.js 13.1, Tailwind CSS and PostCSS are supported with Turbopack.",
    "excerpt": "This guide will walk you through how to install Tailwind CSS v3 in your Next.js application. > Good to know: For the latest Tailwind 4 setup, see the Tailwind CSS setup instructions. Installing Tailwi...",
    "url": "https://nextjs.org/docs/01-app/02-guides/tailwind-v3-css"
  },
  {
    "id": "01-app-02-guides-testing-cypress",
    "path": "01-app\\02-guides\\testing\\cypress.mdx",
    "title": "How to set up Cypress with Next.js",
    "description": "Learn how to set up Cypress with Next.js for End-to-End (E2E) and Component Testing.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Quickstart",
        "slug": "quickstart"
      },
      {
        "level": 2,
        "text": "Manual setup",
        "slug": "manual-setup"
      },
      {
        "level": 2,
        "text": "Creating your first Cypress E2E test",
        "slug": "creating-your-first-cypress-e2e-test"
      },
      {
        "level": 3,
        "text": "Running E2E Tests",
        "slug": "running-e2e-tests"
      },
      {
        "level": 2,
        "text": "Creating your first Cypress component test",
        "slug": "creating-your-first-cypress-component-test"
      },
      {
        "level": 3,
        "text": "Running Component Tests",
        "slug": "running-component-tests"
      },
      {
        "level": 2,
        "text": "Continuous Integration (CI)",
        "slug": "continuous-integration-ci"
      }
    ],
    "codeBlocks": [
      {
        "language": "bash",
        "code": "npx create-next-app@latest --example with-cypress with-cypress-app",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "npm install -D cypress\r\n# or\r\nyarn add -D cypress\r\n# or\r\npnpm install -D cypress",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "json",
        "code": "{\r\n  \"scripts\": {\r\n    \"dev\": \"next dev\",\r\n    \"build\": \"next build\",\r\n    \"start\": \"next start\",\r\n    \"lint\": \"eslint\",\r\n    \"cypress:open\": \"cypress open\"\r\n  }\r\n}",
        "context": "filename=\"package.json\""
      },
      {
        "language": "bash",
        "code": "npm run cypress:open",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "ts",
        "code": "import { defineConfig } from 'cypress'\r\n\r\nexport default defineConfig({\r\n  e2e: {\r\n    setupNodeEvents(on, config) {},\r\n  },\r\n})",
        "context": "filename=\"cypress.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "const { defineConfig } = require('cypress')\r\n\r\nmodule.exports = defineConfig({\r\n  e2e: {\r\n    setupNodeEvents(on, config) {},\r\n  },\r\n})",
        "context": "filename=\"cypress.config.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <div>\r\n      <h1>Home</h1>\r\n      <Link href=\"/about\">About</Link>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\""
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <div>\r\n      <h1>About</h1>\r\n      <Link href=\"/\">Home</Link>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/about/page.js\""
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Home() {\r\n  return (\r\n    <div>\r\n      <h1>Home</h1>\r\n      <Link href=\"/about\">About</Link>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"pages/index.js\""
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function About() {\r\n  return (\r\n    <div>\r\n      <h1>About</h1>\r\n      <Link href=\"/\">Home</Link>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"pages/about.js\""
      },
      {
        "language": "js",
        "code": "describe('Navigation', () => {\r\n  it('should navigate to the about page', () => {\r\n    // Start from the index page\r\n    cy.visit('http://localhost:3000/')\r\n\r\n    // Find a link with an href attribute containing \"about\" and click it\r\n    cy.get('a[href*=\"about\"]').click()\r\n\r\n    // The new url should include \"/about\"\r\n    cy.url().should('include', '/about')\r\n\r\n    // The new page should contain an h1 with \"About\"\r\n    cy.get('h1').contains('About')\r\n  })\r\n})",
        "context": "filename=\"cypress/e2e/app.cy.js\""
      },
      {
        "language": "ts",
        "code": "import { defineConfig } from 'cypress'\r\n\r\nexport default defineConfig({\r\n  component: {\r\n    devServer: {\r\n      framework: 'next',\r\n      bundler: 'webpack',\r\n    },\r\n  },\r\n})",
        "context": "filename=\"cypress.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "const { defineConfig } = require('cypress')\r\n\r\nmodule.exports = defineConfig({\r\n  component: {\r\n    devServer: {\r\n      framework: 'next',\r\n      bundler: 'webpack',\r\n    },\r\n  },\r\n})",
        "context": "filename=\"cypress.config.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Page from '../../app/page'\r\n\r\ndescribe('<Page />', () => {\r\n  it('should render and display expected content', () => {\r\n    // Mount the React component for the Home page\r\n    cy.mount(<Page />)\r\n\r\n    // The new page should contain an h1 with \"Home\"\r\n    cy.get('h1').contains('Home')\r\n\r\n    // Validate that a link with the expected URL is present\r\n    // Following the link is better suited to an E2E test\r\n    cy.get('a[href=\"/about\"]').should('be.visible')\r\n  })\r\n})",
        "context": "filename=\"cypress/component/about.cy.tsx\""
      },
      {
        "language": "jsx",
        "code": "import AboutPage from '../../pages/about'\r\n\r\ndescribe('<AboutPage />', () => {\r\n  it('should render and display expected content', () => {\r\n    // Mount the React component for the About page\r\n    cy.mount(<AboutPage />)\r\n\r\n    // The new page should contain an h1 with \"About page\"\r\n    cy.get('h1').contains('About')\r\n\r\n    // Validate that a link with the expected URL is present\r\n    // *Following* the link is better suited to an E2E test\r\n    cy.get('a[href=\"/\"]').should('be.visible')\r\n  })\r\n})",
        "context": "filename=\"cypress/component/about.cy.js\""
      },
      {
        "language": "json",
        "code": "{\r\n  \"scripts\": {\r\n    //...\r\n    \"e2e\": \"start-server-and-test dev http://localhost:3000 \\\"cypress open --e2e\\\"\",\r\n    \"e2e:headless\": \"start-server-and-test dev http://localhost:3000 \\\"cypress run --e2e\\\"\",\r\n    \"component\": \"cypress open --component\",\r\n    \"component:headless\": \"cypress run --component\"\r\n  }\r\n}",
        "context": "filename=\"package.json\""
      }
    ],
    "content": "Cypress is a test runner used for End-to-End (E2E) and Component Testing. This page will show you how to set up Cypress with Next.js and write your first tests. > Warning: > > - Cypress versions below 13.6.3 do not support TypeScript version 5 with moduleResolution:\"bundler\". However, this issue has been resolved in Cypress version 13.6.3 and later. cypress v13.6.3 Quickstart You can use create-next-app with the with-cypress example to quickly get started. Manual setup To manually set up Cypress, install cypress as a dev dependency: Add the Cypress open command to the package.json scripts field: Run Cypress for the first time to open the Cypress testing suite: You can choose to configure E2E Testing and/or Component Testing. Selecting any of these options will automatically create a cypress.config.js file and a cypress folder in your project. Creating your first Cypress E2E test Ensure your cypress.config file has the following configuration: Then, create two new Next.js files: Add a test to check your navigation is working correctly: Running E2E Tests Cypress will simulate a user navigating your application, this requires your Next.js server to be running. We recommend running your tests against your production code to more closely resemble how your application will behave. Run npm run build && npm run start to build your Next.js application, then run npm run cypress:open in another terminal window to start Cypress and run your E2E Testing suite. > Good to know: > > - You can use cy.visit(\"/\") instead of cy.visit(\"http://localhost:3000/\") by adding baseUrl: 'http://localhost:3000' to the cypress.config.js configuration file. > - Alternatively, you can install the start-server-and-test package to run the Next.js production server in conjunction with Cypress. After installation, add \"test\": \"start-server-and-test start http://localhost:3000 cypress\" to your package.json scripts field. Remember to rebuild your application after new changes. Creating your first Cypress component test Component tests build and mount a specific component without having to bundle your whole application or start a server. Select Component Testing in the Cypress app, then select Next.js as your front-end framework. A cypress/component folder will be created in your project, and a cypress.config.js file will be updated to enable Component Testing. Ensure your cypress.config file has the following configuration: Assuming the same components from the previous section, add a test to validate a component is rendering the expected output: > Good to know: > > - Cypress currently doesn't support Component Testing for async Server Components. We recommend using E2E testing. > - Since component tests do not require a Next.js server, features like that rely on a server being available may not function out-of-the-box. Running Component Tests Run npm run cypress:open in your terminal to start Cypress and run your Component Testing suite. Continuous Integration (CI) In addition to interactive testing, you can also run Cypress headlessly using the cypress run command, which is better suited for CI environments: You can learn more about Cypress and Continuous Integration from these resources: - Next.js with Cypress example - Cypress Continuous Integration Docs - Cypress GitHub Actions Guide - Official Cypress GitHub Action - Cypress Discord",
    "excerpt": "Cypress is a test runner used for End-to-End (E2E) and Component Testing. This page will show you how to set up Cypress with Next.js and write your first tests. > Warning: > > - Cypress versions below...",
    "url": "https://nextjs.org/docs/01-app/02-guides/testing/cypress"
  },
  {
    "id": "01-app-02-guides-testing-index",
    "path": "01-app\\02-guides\\testing\\index.mdx",
    "title": "Testing",
    "description": "Learn how to set up Next.js with four commonly used testing tools — Cypress, Playwright, Vitest, and Jest.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Types of tests",
        "slug": "types-of-tests"
      },
      {
        "level": 2,
        "text": "Async Server Components",
        "slug": "async-server-components"
      },
      {
        "level": 2,
        "text": "Guides",
        "slug": "guides"
      }
    ],
    "codeBlocks": [],
    "content": "In React and Next.js, there are a few different types of tests you can write, each with its own purpose and use cases. This page provides an overview of types and commonly used tools you can use to test your application. Types of tests - Unit Testing involves testing individual units (or blocks of code) in isolation. In React, a unit can be a single function, hook, or component. - Component Testing is a more focused version of unit testing where the primary subject of the tests is React components. This may involve testing how components are rendered, their interaction with props, and their behavior in response to user events. - Integration Testing involves testing how multiple units work together. This can be a combination of components, hooks, and functions. - End-to-End (E2E) Testing involves testing user flows in an environment that simulates real user scenarios, like the browser. This means testing specific tasks (e.g. signup flow) in a production-like environment. - Snapshot Testing involves capturing the rendered output of a component and saving it to a snapshot file. When tests run, the current rendered output of the component is compared against the saved snapshot. Changes in the snapshot are used to indicate unexpected changes in behavior. Async Server Components Since async Server Components are new to the React ecosystem, some tools do not fully support them. In the meantime, we recommend using End-to-End Testing over Unit Testing for async components. Guides See the guides below to learn how to set up Next.js with these commonly used testing tools:",
    "excerpt": "In React and Next.js, there are a few different types of tests you can write, each with its own purpose and use cases. This page provides an overview of types and commonly used tools you can use to te...",
    "url": "https://nextjs.org/docs/01-app/02-guides/testing"
  },
  {
    "id": "01-app-02-guides-testing-jest",
    "path": "01-app\\02-guides\\testing\\jest.mdx",
    "title": "How to set up Jest with Next.js",
    "description": "Learn how to set up Jest with Next.js for Unit Testing and Snapshot Testing.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Quickstart",
        "slug": "quickstart"
      },
      {
        "level": 2,
        "text": "Manual setup",
        "slug": "manual-setup"
      },
      {
        "level": 2,
        "text": "Setting up Jest (with Babel)",
        "slug": "setting-up-jest-with-babel"
      },
      {
        "level": 3,
        "text": "Handling stylesheets and image imports",
        "slug": "handling-stylesheets-and-image-imports"
      },
      {
        "level": 2,
        "text": "Handling Fonts",
        "slug": "handling-fonts"
      },
      {
        "level": 2,
        "text": "Optional: Handling Absolute Imports and Module Path Aliases",
        "slug": "optional-handling-absolute-imports-and-module-path-aliases"
      },
      {
        "level": 2,
        "text": "Optional: Extend Jest with custom matchers",
        "slug": "optional-extend-jest-with-custom-matchers"
      },
      {
        "level": 2,
        "text": "Add a test script to ",
        "slug": "add-a-test-script-to-"
      },
      {
        "level": 3,
        "text": "Creating your first test",
        "slug": "creating-your-first-test"
      },
      {
        "level": 2,
        "text": "Running your tests",
        "slug": "running-your-tests"
      },
      {
        "level": 2,
        "text": "Additional Resources",
        "slug": "additional-resources"
      }
    ],
    "codeBlocks": [
      {
        "language": "bash",
        "code": "npx create-next-app@latest --example with-jest with-jest-app",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "npm install -D jest jest-environment-jsdom @testing-library/react @testing-library/dom @testing-library/jest-dom ts-node @types/jest\r\n# or\r\nyarn add -D jest jest-environment-jsdom @testing-library/react @testing-library/dom @testing-library/jest-dom ts-node @types/jest\r\n# or\r\npnpm install -D jest jest-environment-jsdom @testing-library/react @testing-library/dom @testing-library/jest-dom ts-node @types/jest",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "npm init jest@latest\r\n# or\r\nyarn create jest@latest\r\n# or\r\npnpm create jest@latest",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "ts",
        "code": "import type { Config } from 'jest'\r\nimport nextJest from 'next/jest.js'\r\n\r\nconst createJestConfig = nextJest({\r\n  // Provide the path to your Next.js app to load next.config.js and .env files in your test environment\r\n  dir: './',\r\n})\r\n\r\n// Add any custom config to be passed to Jest\r\nconst config: Config = {\r\n  coverageProvider: 'v8',\r\n  testEnvironment: 'jsdom',\r\n  // Add more setup options before each test is run\r\n  // setupFilesAfterEnv: ['<rootDir>/jest.setup.ts'],\r\n}\r\n\r\n// createJestConfig is exported this way to ensure that next/jest can load the Next.js config which is async\r\nexport default createJestConfig(config)",
        "context": "filename=\"jest.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "const nextJest = require('next/jest')\r\n\r\n/** @type {import('jest').Config} */\r\nconst createJestConfig = nextJest({\r\n  // Provide the path to your Next.js app to load next.config.js and .env files in your test environment\r\n  dir: './',\r\n})\r\n\r\n// Add any custom config to be passed to Jest\r\nconst config = {\r\n  coverageProvider: 'v8',\r\n  testEnvironment: 'jsdom',\r\n  // Add more setup options before each test is run\r\n  // setupFilesAfterEnv: ['<rootDir>/jest.setup.ts'],\r\n}\r\n\r\n// createJestConfig is exported this way to ensure that next/jest can load the Next.js config which is async\r\nmodule.exports = createJestConfig(config)",
        "context": "filename=\"jest.config.js\" switcher"
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  collectCoverage: true,\r\n  // on node 14.x coverage provider v8 offers good speed and more or less good report\r\n  coverageProvider: 'v8',\r\n  collectCoverageFrom: [\r\n    '**/*.{js,jsx,ts,tsx}',\r\n    '!**/*.d.ts',\r\n    '!**/node_modules/**',\r\n    '!<rootDir>/out/**',\r\n    '!<rootDir>/.next/**',\r\n    '!<rootDir>/*.config.js',\r\n    '!<rootDir>/coverage/**',\r\n  ],\r\n  moduleNameMapper: {\r\n    // Handle CSS imports (with CSS modules)\r\n    // https://jestjs.io/docs/webpack#mocking-css-modules\r\n    '^.+\\\\.module\\\\.(css|sass|scss)$': 'identity-obj-proxy',\r\n\r\n    // Handle CSS imports (without CSS modules)\r\n    '^.+\\\\.(css|sass|scss)$': '<rootDir>/__mocks__/styleMock.js',\r\n\r\n    // Handle image imports\r\n    // https://jestjs.io/docs/webpack#handling-static-assets\r\n    '^.+\\\\.(png|jpg|jpeg|gif|webp|avif|ico|bmp|svg)$': `<rootDir>/__mocks__/fileMock.js`,\r\n\r\n    // Handle module aliases\r\n    '^@/components/(.*)$': '<rootDir>/components/$1',\r\n\r\n    // Handle @next/font\r\n    '@next/font/(.*)': `<rootDir>/__mocks__/nextFontMock.js`,\r\n    // Handle next/font\r\n    'next/font/(.*)': `<rootDir>/__mocks__/nextFontMock.js`,\r\n    // Disable server-only\r\n    'server-only': `<rootDir>/__mocks__/empty.js`,\r\n  },\r\n  // Add more setup options before each test is run\r\n  // setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],\r\n  testPathIgnorePatterns: ['<rootDir>/node_modules/', '<rootDir>/.next/'],\r\n  testEnvironment: 'jsdom',\r\n  transform: {\r\n    // Use babel-jest to transpile tests with the next/babel preset\r\n    // https://jestjs.io/docs/configuration#transform-objectstring-pathtotransformer--pathtotransformer-object\r\n    '^.+\\\\.(js|jsx|ts|tsx)$': ['babel-jest', { presets: ['next/babel'] }],\r\n  },\r\n  transformIgnorePatterns: [\r\n    '/node_modules/',\r\n    '^.+\\\\.module\\\\.(css|sass|scss)$',\r\n  ],\r\n}",
        "context": "filename=\"jest.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = 'test-file-stub'",
        "context": "filename=\"__mocks__/fileMock.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {}",
        "context": "filename=\"__mocks__/styleMock.js\""
      },
      {
        "language": "js",
        "code": "module.exports = new Proxy(\r\n  {},\r\n  {\r\n    get: function getter() {\r\n      return () => ({\r\n        className: 'className',\r\n        variable: 'variable',\r\n        style: { fontFamily: 'fontFamily' },\r\n      })\r\n    },\r\n  }\r\n)",
        "context": "filename=\"__mocks__/nextFontMock.js\""
      },
      {
        "language": "json",
        "code": "{\r\n  \"compilerOptions\": {\r\n    \"module\": \"esnext\",\r\n    \"moduleResolution\": \"bundler\",\r\n    \"baseUrl\": \"./\",\r\n    \"paths\": {\r\n      \"@/components/*\": [\"components/*\"]\r\n    }\r\n  }\r\n}",
        "context": "filename=\"tsconfig.json or jsconfig.json\""
      },
      {
        "language": "js",
        "code": "moduleNameMapper: {\r\n  // ...\r\n  '^@/components/(.*)$': '<rootDir>/components/$1',\r\n}",
        "context": "filename=\"jest.config.js\""
      },
      {
        "language": "ts",
        "code": "setupFilesAfterEnv: ['<rootDir>/jest.setup.ts']",
        "context": "filename=\"jest.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "setupFilesAfterEnv: ['<rootDir>/jest.setup.js']",
        "context": "filename=\"jest.config.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import '@testing-library/jest-dom'",
        "context": "filename=\"jest.setup.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import '@testing-library/jest-dom'",
        "context": "filename=\"jest.setup.js\" switcher"
      },
      {
        "language": "json",
        "code": "{\r\n  \"scripts\": {\r\n    \"dev\": \"next dev\",\r\n    \"build\": \"next build\",\r\n    \"start\": \"next start\",\r\n    \"test\": \"jest\",\r\n    \"test:watch\": \"jest --watch\"\r\n  }\r\n}",
        "context": "filename=\"package.json\" highlight={6-7}"
      },
      {
        "language": "jsx",
        "code": "export default function Home() {\r\n  return <h1>Home</h1>\r\n}",
        "context": "filename=\"pages/index.js"
      },
      {
        "language": "jsx",
        "code": "import '@testing-library/jest-dom'\r\nimport { render, screen } from '@testing-library/react'\r\nimport Home from '../pages/index'\r\n\r\ndescribe('Home', () => {\r\n  it('renders a heading', () => {\r\n    render(<Home />)\r\n\r\n    const heading = screen.getByRole('heading', { level: 1 })\r\n\r\n    expect(heading).toBeInTheDocument()\r\n  })\r\n})",
        "context": "filename=\"__tests__/index.test.js\""
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <div>\r\n      <h1>Home</h1>\r\n      <Link href=\"/about\">About</Link>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\""
      },
      {
        "language": "jsx",
        "code": "import '@testing-library/jest-dom'\r\nimport { render, screen } from '@testing-library/react'\r\nimport Page from '../app/page'\r\n\r\ndescribe('Page', () => {\r\n  it('renders a heading', () => {\r\n    render(<Page />)\r\n\r\n    const heading = screen.getByRole('heading', { level: 1 })\r\n\r\n    expect(heading).toBeInTheDocument()\r\n  })\r\n})",
        "context": "filename=\"__tests__/page.test.jsx\""
      },
      {
        "language": "jsx",
        "code": "import { render } from '@testing-library/react'\r\nimport Home from '../pages/index'\r\n\r\nit('renders homepage unchanged', () => {\r\n  const { container } = render(<Home />)\r\n  expect(container).toMatchSnapshot()\r\n})",
        "context": "filename=\"__tests__/snapshot.js\""
      },
      {
        "language": "jsx",
        "code": "import { render } from '@testing-library/react'\r\nimport Page from '../app/page'\r\n\r\nit('renders homepage unchanged', () => {\r\n  const { container } = render(<Page />)\r\n  expect(container).toMatchSnapshot()\r\n})",
        "context": "filename=\"__tests__/snapshot.js\""
      },
      {
        "language": "bash",
        "code": "npm run test\r\n# or\r\nyarn test\r\n# or\r\npnpm test",
        "context": "filename=\"Terminal\""
      }
    ],
    "content": "Jest and React Testing Library are frequently used together for Unit Testing and Snapshot Testing. This guide will show you how to set up Jest with Next.js and write your first tests. > Good to know: Since async Server Components are new to the React ecosystem, Jest currently does not support them. While you can still run unit tests for synchronous Server and Client Components, we recommend using an E2E tests for async components. Quickstart You can use create-next-app with the Next.js with-jest example to quickly get started: Manual setup Since the release of Next.js 12, Next.js now has built-in configuration for Jest. To set up Jest, install jest and the following packages as dev dependencies: Generate a basic Jest configuration file by running the following command: This will take you through a series of prompts to setup Jest for your project, including automatically creating a jest.config.ts|js file. Update your config file to use next/jest. This transformer has all the necessary configuration options for Jest to work with Next.js: Under the hood, next/jest is automatically configuring Jest for you, including: - Setting up transform using the Next.js Compiler. - Auto mocking stylesheets (.css, .module.css, and their scss variants), image imports and next/font. - Loading .env (and all variants) into process.env. - Ignoring nodemodules from test resolving and transforms. - Ignoring .next from test resolving. - Loading next.config.js for flags that enable SWC transforms. > Good to know: To test environment variables directly, load them manually in a separate setup script or in your jest.config.ts file. For more information, please see Test Environment Variables. Setting up Jest (with Babel) If you opt out of the Next.js Compiler and use Babel instead, you will need to manually configure Jest and install babel-jest and identity-obj-proxy in addition to the packages above. Here are the recommended options to configure Jest for Next.js: You can learn more about each configuration option in the Jest docs. We also recommend reviewing next/jest configuration to see how Next.js configures Jest. Handling stylesheets and image imports Stylesheets and images aren't used in the tests but importing them may cause errors, so they will need to be mocked. Create the mock files referenced in the configuration above - fileMock.js and styleMock.js - inside a mocks directory: For more information on handling static assets, please refer to the Jest Docs. Handling Fonts To handle fonts, create the nextFontMock.js file inside the mocks directory, and add the following configuration: Optional: Handling Absolute Imports and Module Path Aliases If your project is using Module Path Aliases, you will need to configure Jest to resolve the imports by matching the paths option in the jsconfig.json file with the moduleNameMapper option in the jest.config.js file. For example: Optional: Extend Jest with custom matchers @testing-library/jest-dom includes a set of convenient custom matchers such as .toBeInTheDocument() making it easier to write tests. You can import the custom matchers for every test by adding the following option to the Jest configuration file: Then, inside jest.setup, add the following import: > Good to know: extend-expect was removed in v6.0, so if you are using @testing-library/jest-dom before version 6, you will need to import @testing-library/jest-dom/extend-expect instead. If you need to add more setup options before each test, you can add them to the jest.setup file above. Add a test script to package.json Finally, add a Jest test script to your package.json file: jest --watch will re-run tests when a file is changed. For more Jest CLI options, please refer to the Jest Docs. Creating your first test Your project is now ready to run tests. Create a folder called tests in your project's root directory. For example, we can add a test to check if the component successfully renders a heading: For example, we can add a test to check if the component successfully renders a heading: Optionally, add a snapshot test to keep track of any unexpected changes in your component: > Good to know: Test files should not be included inside the Pages Router because any files inside the Pages Router are considered routes. Running your tests Then, run the following command to run your tests: Additional Resources For further reading, you may find these resources helpful: - Next.js with Jest example - Jest Docs - React Testing Library Docs - Testing Playground - use good testing practices to match elements.",
    "excerpt": "Jest and React Testing Library are frequently used together for Unit Testing and Snapshot Testing. This guide will show you how to set up Jest with Next.js and write your first tests. > Good to know:...",
    "url": "https://nextjs.org/docs/01-app/02-guides/testing/jest"
  },
  {
    "id": "01-app-02-guides-testing-playwright",
    "path": "01-app\\02-guides\\testing\\playwright.mdx",
    "title": "How to set up Playwright with Next.js",
    "description": "Learn how to set up Playwright with Next.js for End-to-End (E2E) Testing.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Quickstart",
        "slug": "quickstart"
      },
      {
        "level": 2,
        "text": "Manual setup",
        "slug": "manual-setup"
      },
      {
        "level": 2,
        "text": "Creating your first Playwright E2E test",
        "slug": "creating-your-first-playwright-e2e-test"
      },
      {
        "level": 3,
        "text": "Running your Playwright tests",
        "slug": "running-your-playwright-tests"
      },
      {
        "level": 3,
        "text": "Running Playwright on Continuous Integration (CI)",
        "slug": "running-playwright-on-continuous-integration-ci"
      }
    ],
    "codeBlocks": [
      {
        "language": "bash",
        "code": "npx create-next-app@latest --example with-playwright with-playwright-app",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "npm init playwright\r\n# or\r\nyarn create playwright\r\n# or\r\npnpm create playwright",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <div>\r\n      <h1>Home</h1>\r\n      <Link href=\"/about\">About</Link>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/page.tsx\""
      },
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <div>\r\n      <h1>About</h1>\r\n      <Link href=\"/\">Home</Link>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/about/page.tsx\""
      },
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Home() {\r\n  return (\r\n    <div>\r\n      <h1>Home</h1>\r\n      <Link href=\"/about\">About</Link>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"pages/index.ts\""
      },
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function About() {\r\n  return (\r\n    <div>\r\n      <h1>About</h1>\r\n      <Link href=\"/\">Home</Link>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"pages/about.ts\""
      },
      {
        "language": "ts",
        "code": "import { test, expect } from '@playwright/test'\r\n\r\ntest('should navigate to the about page', async ({ page }) => {\r\n  // Start from the index page (the baseURL is set via the webServer in the playwright.config.ts)\r\n  await page.goto('http://localhost:3000/')\r\n  // Find an element with the text 'About' and click on it\r\n  await page.click('text=About')\r\n  // The new URL should be \"/about\" (baseURL is used there)\r\n  await expect(page).toHaveURL('http://localhost:3000/about')\r\n  // The new page should contain an h1 with \"About\"\r\n  await expect(page.locator('h1')).toContainText('About')\r\n})",
        "context": "filename=\"tests/example.spec.ts\""
      }
    ],
    "content": "Playwright is a testing framework that lets you automate Chromium, Firefox, and WebKit with a single API. You can use it to write End-to-End (E2E) testing. This guide will show you how to set up Playwright with Next.js and write your first tests. Quickstart The fastest way to get started is to use create-next-app with the with-playwright example. This will create a Next.js project complete with Playwright configured. Manual setup To install Playwright, run the following command: This will take you through a series of prompts to setup and configure Playwright for your project, including adding a playwright.config.ts file. Please refer to the Playwright installation guide for the step-by-step guide. Creating your first Playwright E2E test Create two new Next.js pages: Then, add a test to verify that your navigation is working correctly: > Good to know: You can use page.goto(\"/\") instead of page.goto(\"http://localhost:3000/\"), if you add \"baseURL\": \"http://localhost:3000\" to the playwright.config.ts configuration file. Running your Playwright tests Playwright will simulate a user navigating your application using three browsers: Chromium, Firefox and Webkit, this requires your Next.js server to be running. We recommend running your tests against your production code to more closely resemble how your application will behave. Run npm run build and npm run start, then run npx playwright test in another terminal window to run the Playwright tests. > Good to know: Alternatively, you can use the webServer feature to let Playwright start the development server and wait until it's fully available. Running Playwright on Continuous Integration (CI) Playwright will by default run your tests in the headless mode. To install all the Playwright dependencies, run npx playwright install-deps. You can learn more about Playwright and Continuous Integration from these resources: - Next.js with Playwright example - Playwright on your CI provider - Playwright Discord",
    "excerpt": "Playwright is a testing framework that lets you automate Chromium, Firefox, and WebKit with a single API. You can use it to write End-to-End (E2E) testing. This guide will show you how to set up Playw...",
    "url": "https://nextjs.org/docs/01-app/02-guides/testing/playwright"
  },
  {
    "id": "01-app-02-guides-testing-vitest",
    "path": "01-app\\02-guides\\testing\\vitest.mdx",
    "title": "How to set up Vitest with Next.js",
    "description": "Learn how to set up Vitest with Next.js for Unit Testing.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Quickstart",
        "slug": "quickstart"
      },
      {
        "level": 2,
        "text": "Manual Setup",
        "slug": "manual-setup"
      },
      {
        "level": 2,
        "text": "Creating your first Vitest Unit Test",
        "slug": "creating-your-first-vitest-unit-test"
      },
      {
        "level": 2,
        "text": "Running your tests",
        "slug": "running-your-tests"
      },
      {
        "level": 2,
        "text": "Additional Resources",
        "slug": "additional-resources"
      }
    ],
    "codeBlocks": [
      {
        "language": "bash",
        "code": "npx create-next-app@latest --example with-vitest with-vitest-app",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "# Using TypeScript\r\nnpm install -D vitest @vitejs/plugin-react jsdom @testing-library/react @testing-library/dom vite-tsconfig-paths\r\n# Using JavaScript\r\nnpm install -D vitest @vitejs/plugin-react jsdom @testing-library/react @testing-library/dom",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "ts",
        "code": "import { defineConfig } from 'vitest/config'\r\nimport react from '@vitejs/plugin-react'\r\nimport tsconfigPaths from 'vite-tsconfig-paths'\r\n\r\nexport default defineConfig({\r\n  plugins: [tsconfigPaths(), react()],\r\n  test: {\r\n    environment: 'jsdom',\r\n  },\r\n})",
        "context": "filename=\"vitest.config.mts\" switcher"
      },
      {
        "language": "js",
        "code": "import { defineConfig } from 'vitest/config'\r\nimport react from '@vitejs/plugin-react'\r\n\r\nexport default defineConfig({\r\n  plugins: [react()],\r\n  test: {\r\n    environment: 'jsdom',\r\n  },\r\n})",
        "context": "filename=\"vitest.config.js\" switcher"
      },
      {
        "language": "json",
        "code": "{\r\n  \"scripts\": {\r\n    \"dev\": \"next dev\",\r\n    \"build\": \"next build\",\r\n    \"start\": \"next start\",\r\n    \"test\": \"vitest\"\r\n  }\r\n}",
        "context": "filename=\"package.json\""
      },
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <div>\r\n      <h1>Home</h1>\r\n      <Link href=\"/about\">About</Link>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <div>\r\n      <h1>Home</h1>\r\n      <Link href=\"/about\">About</Link>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/page.jsx\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { expect, test } from 'vitest'\r\nimport { render, screen } from '@testing-library/react'\r\nimport Page from '../app/page'\r\n\r\ntest('Page', () => {\r\n  render(<Page />)\r\n  expect(screen.getByRole('heading', { level: 1, name: 'Home' })).toBeDefined()\r\n})",
        "context": "filename=\"__tests__/page.test.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { expect, test } from 'vitest'\r\nimport { render, screen } from '@testing-library/react'\r\nimport Page from '../app/page'\r\n\r\ntest('Page', () => {\r\n  render(<Page />)\r\n  expect(screen.getByRole('heading', { level: 1, name: 'Home' })).toBeDefined()\r\n})",
        "context": "filename=\"__tests__/page.test.jsx\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <div>\r\n      <h1>Home</h1>\r\n      <Link href=\"/about\">About</Link>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"pages/index.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <div>\r\n      <h1>Home</h1>\r\n      <Link href=\"/about\">About</Link>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"pages/index.jsx\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { expect, test } from 'vitest'\r\nimport { render, screen } from '@testing-library/react'\r\nimport Page from '../pages/index'\r\n\r\ntest('Page', () => {\r\n  render(<Page />)\r\n  expect(screen.getByRole('heading', { level: 1, name: 'Home' })).toBeDefined()\r\n})",
        "context": "filename=\"__tests__/index.test.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { expect, test } from 'vitest'\r\nimport { render, screen } from '@testing-library/react'\r\nimport Page from '../pages/index'\r\n\r\ntest('Page', () => {\r\n  render(<Page />)\r\n  expect(screen.getByRole('heading', { level: 1, name: 'Home' })).toBeDefined()\r\n})",
        "context": "filename=\"__tests__/index.test.jsx\" switcher"
      },
      {
        "language": "bash",
        "code": "npm run test\r\n# or\r\nyarn test\r\n# or\r\npnpm test\r\n# or\r\nbun test",
        "context": "filename=\"Terminal\""
      }
    ],
    "content": "Vitest and React Testing Library are frequently used together for Unit Testing. This guide will show you how to setup Vitest with Next.js and write your first tests. > Good to know: Since async Server Components are new to the React ecosystem, Vitest currently does not support them. While you can still run unit tests for synchronous Server and Client Components, we recommend using E2E tests for async components. Quickstart You can use create-next-app with the Next.js with-vitest example to quickly get started: Manual Setup To manually set up Vitest, install vitest and the following packages as dev dependencies: Create a vitest.config.mts|js file in the root of your project, and add the following options: For more information on configuring Vitest, please refer to the Vitest Configuration docs. Then, add a test script to your package.json: When you run npm run test, Vitest will watch for changes in your project by default. Creating your first Vitest Unit Test Check that everything is working by creating a test to check if the component successfully renders a heading: > Good to know: The example above uses the common tests convention, but test files can also be colocated inside the app router. Running your tests Then, run the following command to run your tests: Additional Resources You may find these resources helpful: - Next.js with Vitest example - Vitest Docs - React Testing Library Docs",
    "excerpt": "Vitest and React Testing Library are frequently used together for Unit Testing. This guide will show you how to setup Vitest with Next.js and write your first tests. > Good to know: Since async Server...",
    "url": "https://nextjs.org/docs/01-app/02-guides/testing/vitest"
  },
  {
    "id": "01-app-02-guides-third-party-libraries",
    "path": "01-app\\02-guides\\third-party-libraries.mdx",
    "title": "How to optimize third-party libraries",
    "description": "Optimize the performance of third-party libraries in your application with the `@next/third-parties` package.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Getting Started",
        "slug": "getting-started"
      },
      {
        "level": 2,
        "text": "Google Third-Parties",
        "slug": "google-third-parties"
      },
      {
        "level": 3,
        "text": "Google Tag Manager",
        "slug": "google-tag-manager"
      },
      {
        "level": 4,
        "text": "Sending Events",
        "slug": "sending-events"
      },
      {
        "level": 4,
        "text": "Server-side Tagging",
        "slug": "server-side-tagging"
      },
      {
        "level": 4,
        "text": "Options",
        "slug": "options"
      },
      {
        "level": 3,
        "text": "Google Analytics",
        "slug": "google-analytics"
      },
      {
        "level": 4,
        "text": "Sending Events",
        "slug": "sending-events"
      },
      {
        "level": 4,
        "text": "Tracking Pageviews",
        "slug": "tracking-pageviews"
      },
      {
        "level": 4,
        "text": "Options",
        "slug": "options"
      },
      {
        "level": 3,
        "text": "Google Maps Embed",
        "slug": "google-maps-embed"
      },
      {
        "level": 4,
        "text": "Options",
        "slug": "options"
      },
      {
        "level": 3,
        "text": "YouTube Embed",
        "slug": "youtube-embed"
      },
      {
        "level": 4,
        "text": "Options",
        "slug": "options"
      }
    ],
    "codeBlocks": [
      {
        "language": "bash",
        "code": "npm install @next/third-parties@latest next@latest",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "tsx",
        "code": "import { GoogleTagManager } from '@next/third-parties/google'\r\n\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <GoogleTagManager gtmId=\"GTM-XYZ\" />\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { GoogleTagManager } from '@next/third-parties/google'\r\n\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <GoogleTagManager gtmId=\"GTM-XYZ\" />\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { GoogleTagManager } from '@next/third-parties/google'\r\n\r\nexport default function MyApp({ Component, pageProps }) {\r\n  return (\r\n    <>\r\n      <Component {...pageProps} />\r\n      <GoogleTagManager gtmId=\"GTM-XYZ\" />\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"pages/_app.js\""
      },
      {
        "language": "jsx",
        "code": "import { GoogleTagManager } from '@next/third-parties/google'\r\n\r\nexport default function Page() {\r\n  return <GoogleTagManager gtmId=\"GTM-XYZ\" />\r\n}",
        "context": "filename=\"app/page.js\""
      },
      {
        "language": "jsx",
        "code": "import { GoogleTagManager } from '@next/third-parties/google'\r\n\r\nexport default function Page() {\r\n  return <GoogleTagManager gtmId=\"GTM-XYZ\" />\r\n}",
        "context": "filename=\"pages/index.js\""
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { sendGTMEvent } from '@next/third-parties/google'\r\n\r\nexport function EventButton() {\r\n  return (\r\n    <div>\r\n      <button\r\n        onClick={() => sendGTMEvent({ event: 'buttonClicked', value: 'xyz' })}\r\n      >\r\n        Send Event\r\n      </button>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\""
      },
      {
        "language": "jsx",
        "code": "import { sendGTMEvent } from '@next/third-parties/google'\r\n\r\nexport function EventButton() {\r\n  return (\r\n    <div>\r\n      <button\r\n        onClick={() => sendGTMEvent({ event: 'buttonClicked', value: 'xyz' })}\r\n      >\r\n        Send Event\r\n      </button>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"pages/index.js\""
      },
      {
        "language": "tsx",
        "code": "import { GoogleAnalytics } from '@next/third-parties/google'\r\n\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>{children}</body>\r\n      <GoogleAnalytics gaId=\"G-XYZ\" />\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { GoogleAnalytics } from '@next/third-parties/google'\r\n\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>{children}</body>\r\n      <GoogleAnalytics gaId=\"G-XYZ\" />\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { GoogleAnalytics } from '@next/third-parties/google'\r\n\r\nexport default function MyApp({ Component, pageProps }) {\r\n  return (\r\n    <>\r\n      <Component {...pageProps} />\r\n      <GoogleAnalytics gaId=\"G-XYZ\" />\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"pages/_app.js\""
      },
      {
        "language": "jsx",
        "code": "import { GoogleAnalytics } from '@next/third-parties/google'\r\n\r\nexport default function Page() {\r\n  return <GoogleAnalytics gaId=\"G-XYZ\" />\r\n}",
        "context": "filename=\"app/page.js\""
      },
      {
        "language": "jsx",
        "code": "import { GoogleAnalytics } from '@next/third-parties/google'\r\n\r\nexport default function Page() {\r\n  return <GoogleAnalytics gaId=\"G-XYZ\" />\r\n}",
        "context": "filename=\"pages/index.js\""
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { sendGAEvent } from '@next/third-parties/google'\r\n\r\nexport function EventButton() {\r\n  return (\r\n    <div>\r\n      <button\r\n        onClick={() => sendGAEvent('event', 'buttonClicked', { value: 'xyz' })}\r\n      >\r\n        Send Event\r\n      </button>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\""
      },
      {
        "language": "jsx",
        "code": "import { sendGAEvent } from '@next/third-parties/google'\r\n\r\nexport function EventButton() {\r\n  return (\r\n    <div>\r\n      <button\r\n        onClick={() => sendGAEvent('event', 'buttonClicked', { value: 'xyz' })}\r\n      >\r\n        Send Event\r\n      </button>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"pages/index.js\""
      },
      {
        "language": "jsx",
        "code": "import { GoogleMapsEmbed } from '@next/third-parties/google'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <GoogleMapsEmbed\r\n      apiKey=\"XYZ\"\r\n      height={200}\r\n      width=\"100%\"\r\n      mode=\"place\"\r\n      q=\"Brooklyn+Bridge,New+York,NY\"\r\n    />\r\n  )\r\n}",
        "context": "filename=\"app/page.js\""
      },
      {
        "language": "jsx",
        "code": "import { GoogleMapsEmbed } from '@next/third-parties/google'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <GoogleMapsEmbed\r\n      apiKey=\"XYZ\"\r\n      height={200}\r\n      width=\"100%\"\r\n      mode=\"place\"\r\n      q=\"Brooklyn+Bridge,New+York,NY\"\r\n    />\r\n  )\r\n}",
        "context": "filename=\"pages/index.js\""
      },
      {
        "language": "jsx",
        "code": "import { YouTubeEmbed } from '@next/third-parties/google'\r\n\r\nexport default function Page() {\r\n  return <YouTubeEmbed videoid=\"ogfYd705cRs\" height={400} params=\"controls=0\" />\r\n}",
        "context": "filename=\"app/page.js\""
      },
      {
        "language": "jsx",
        "code": "import { YouTubeEmbed } from '@next/third-parties/google'\r\n\r\nexport default function Page() {\r\n  return <YouTubeEmbed videoid=\"ogfYd705cRs\" height={400} params=\"controls=0\" />\r\n}",
        "context": "filename=\"pages/index.js\""
      }
    ],
    "content": "@next/third-parties is a library that provides a collection of components and utilities that improve the performance and developer experience of loading popular third-party libraries in your Next.js application. All third-party integrations provided by @next/third-parties have been optimized for performance and ease of use. Getting Started To get started, install the @next/third-parties library: @next/third-parties is currently an experimental library under active development. We recommend installing it with the latest or canary flags while we work on adding more third-party integrations. Google Third-Parties All supported third-party libraries from Google can be imported from @next/third-parties/google. Google Tag Manager The GoogleTagManager component can be used to instantiate a Google Tag Manager container to your page. By default, it fetches the original inline script after hydration occurs on the page. To load Google Tag Manager for all routes, include the component directly in your root layout and pass in your GTM container ID: To load Google Tag Manager for all routes, include the component directly in your custom app and pass in your GTM container ID: To load Google Tag Manager for a single route, include the component in your page file: Sending Events The sendGTMEvent function can be used to track user interactions on your page by sending events using the dataLayer object. For this function to work, the component must be included in either a parent layout, page, or component, or directly in the same file. Refer to the Tag Manager developer documentation to learn about the different variables and events that can be passed into the function. Server-side Tagging If you're using a server-side tag manager and serving gtm.js scripts from your tagging server you can use gtmScriptUrl option to specify the URL of the script. Options Options to pass to the Google Tag Manager. For a full list of options, read the Google Tag Manager docs. | Name | Type | Description | | --------------- | ---------- | ------------------------------------------------------------------------ | | gtmId | Required\\ | Your GTM container ID. Usually starts with GTM-. | | gtmScriptUrl | Optional\\ | GTM script URL. Defaults to https://www.googletagmanager.com/gtm.js. | | dataLayer | Optional | Data layer object to instantiate the container with. | | dataLayerName | Optional | Name of the data layer. Defaults to dataLayer. | | auth | Optional | Value of authentication parameter (gtmauth) for environment snippets. | | preview | Optional | Value of preview parameter (gtmpreview) for environment snippets. | \\gtmId can be omitted when gtmScriptUrl is provided to support Google tag gateway for advertisers. Google Analytics The GoogleAnalytics component can be used to include Google Analytics 4 to your page via the Google tag (gtag.js). By default, it fetches the original scripts after hydration occurs on the page. > Recommendation: If Google Tag Manager is already included in your application, you can > configure Google Analytics directly using it, rather than including Google Analytics as a separate > component. Refer to the > documentation > to learn more about the differences between Tag Manager and gtag.js. To load Google Analytics for all routes, include the component directly in your root layout and pass in your measurement ID: To load Google Analytics for all routes, include the component directly in your custom app and pass in your measurement ID: To load Google Analytics for a single route, include the component in your page file: Sending Events The sendGAEvent function can be used to measure user interactions on your page by sending events using the dataLayer object. For this function to work, the component must be included in either a parent layout, page, or component, or directly in the same file. Refer to the Google Analytics developer documentation to learn more about event parameters. Tracking Pageviews Google Analytics automatically tracks pageviews when the browser history state changes. This means that client-side navigations between Next.js routes will send pageview data without any configuration. To ensure that client-side navigations are being measured correctly, verify that the “Enhanced Measurement” property is enabled in your Admin panel and the “Page changes based on browser history events” checkbox is selected. > Note: If you decide to manually send pageview events, make sure to disable the default > pageview measurement to avoid having duplicate data. Refer to the Google Analytics developer > documentation > to learn more. Options Options to pass to the component. | Name | Type | Description | | --------------- | -------- | ------------------------------------------------------------------------------------------------------ | | gaId | Required | Your measurement ID. Usually starts with G-. | | dataLayerName | Optional | Name of the data layer. Defaults to dataLayer. | | nonce | Optional | A nonce. | Google Maps Embed The GoogleMapsEmbed component can be used to add a Google Maps Embed to your page. By default, it uses the loading attribute to lazy-load the embed below the fold. Options Options to pass to the Google Maps Embed. For a full list of options, read the Google Map Embed docs. | Name | Type | Description | | ----------------- | -------- | --------------------------------------------------------------------------------------------------- | | apiKey | Required | Your api key. | | mode | Required | Map mode | | height | Optional | Height of the embed. Defaults to auto. | | width | Optional | Width of the embed. Defaults to auto. | | style | Optional | Pass styles to the iframe. | | allowfullscreen | Optional | Property to allow certain map parts to go full screen. | | loading | Optional | Defaults to lazy. Consider changing if you know your embed will be above the fold. | | q | Optional | Defines map marker location. This may be required depending on the map mode. | | center | Optional | Defines the center of the map view. | | zoom | Optional | Sets initial zoom level of the map. | | maptype | Optional | Defines type of map tiles to load. | | language | Optional | Defines the language to use for UI elements and for the display of labels on map tiles. | | region | Optional | Defines the appropriate borders and labels to display, based on geo-political sensitivities. | YouTube Embed The YouTubeEmbed component can be used to load and display a YouTube embed. This component loads faster by using lite-youtube-embed under the hood. Options | Name | Type | Description | | ----------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | | videoid | Required | YouTube video id. | | width | Optional | Width of the video container. Defaults to auto | | height | Optional | Height of the video container. Defaults to auto | | playlabel | Optional | A visually hidden label for the play button for accessibility. | | params | Optional | The video player params defined here. Params are passed as a query param string. Eg: params=\"controls=0&start=10&end=30\" | | style | Optional | Used to apply styles to the video container. |",
    "excerpt": "@next/third-parties is a library that provides a collection of components and utilities that improve the performance and developer experience of loading popular third-party libraries in your Next.js a...",
    "url": "https://nextjs.org/docs/01-app/02-guides/third-party-libraries"
  },
  {
    "id": "01-app-02-guides-upgrading-codemods",
    "path": "01-app\\02-guides\\upgrading\\codemods.mdx",
    "title": "Codemods",
    "description": "Use codemods to upgrade your Next.js codebase when new features are released.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Usage",
        "slug": "usage"
      },
      {
        "level": 2,
        "text": "Codemods",
        "slug": "codemods"
      },
      {
        "level": 3,
        "text": "16.0",
        "slug": "160"
      },
      {
        "level": 4,
        "text": "Remove  Route Segment Config from App Router pages and layouts",
        "slug": "remove-route-segment-config-from-app-router-pages-and-layouts"
      },
      {
        "level": 4,
        "text": "Remove  prefix from stabilized API",
        "slug": "remove-prefix-from-stabilized-api"
      },
      {
        "level": 4,
        "text": "Migrate from deprecated  convention to ",
        "slug": "migrate-from-deprecated-convention-to-"
      },
      {
        "level": 4,
        "text": "Migrate from  to ESLint CLI",
        "slug": "migrate-from-to-eslint-cli"
      },
      {
        "level": 3,
        "text": "15.0",
        "slug": "150"
      },
      {
        "level": 4,
        "text": "Transform App Router Route Segment Config  value from  to ",
        "slug": "transform-app-router-route-segment-config-value-from-to-"
      },
      {
        "level": 4,
        "text": "Migrate to async Dynamic APIs",
        "slug": "migrate-to-async-dynamic-apis"
      },
      {
        "level": 4,
        "text": "Replace  and  properties of  with ",
        "slug": "replace-and-properties-of-with-"
      },
      {
        "level": 3,
        "text": "14.0",
        "slug": "140"
      },
      {
        "level": 4,
        "text": "Migrate  imports",
        "slug": "migrate-imports"
      },
      {
        "level": 4,
        "text": "Use  export",
        "slug": "use-export"
      },
      {
        "level": 3,
        "text": "13.2",
        "slug": "132"
      },
      {
        "level": 4,
        "text": "Use Built-in Font",
        "slug": "use-built-in-font"
      },
      {
        "level": 3,
        "text": "13.0",
        "slug": "130"
      },
      {
        "level": 4,
        "text": "Rename Next Image Imports",
        "slug": "rename-next-image-imports"
      },
      {
        "level": 4,
        "text": "Migrate to the New Image Component",
        "slug": "migrate-to-the-new-image-component"
      },
      {
        "level": 4,
        "text": "Remove  Tags From Link Components",
        "slug": "remove-tags-from-link-components"
      },
      {
        "level": 3,
        "text": "11",
        "slug": "11"
      },
      {
        "level": 4,
        "text": "Migrate from CRA",
        "slug": "migrate-from-cra"
      },
      {
        "level": 3,
        "text": "10",
        "slug": "10"
      },
      {
        "level": 4,
        "text": "Add React imports",
        "slug": "add-react-imports"
      },
      {
        "level": 3,
        "text": "9",
        "slug": "9"
      },
      {
        "level": 4,
        "text": "Transform Anonymous Components into Named Components",
        "slug": "transform-anonymous-components-into-named-components"
      },
      {
        "level": 3,
        "text": "8",
        "slug": "8"
      },
      {
        "level": 4,
        "text": "Transform AMP HOC into page config",
        "slug": "transform-amp-hoc-into-page-config"
      },
      {
        "level": 3,
        "text": "6",
        "slug": "6"
      },
      {
        "level": 4,
        "text": "Use ",
        "slug": "use-"
      }
    ],
    "codeBlocks": [
      {
        "language": "bash",
        "code": "npx @next/codemod <transform> <path>",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "npx @next/codemod@latest remove-experimental-ppr .",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "diff",
        "code": "- export const experimental_ppr = true;",
        "context": "filename=\"app/page.tsx\""
      },
      {
        "language": "bash",
        "code": "npx @next/codemod@latest remove-unstable-prefix .",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "ts",
        "code": "import { unstable_cacheTag as cacheTag } from 'next/cache'\r\n\r\ncacheTag()",
        "context": ""
      },
      {
        "language": "ts",
        "code": "import { cacheTag } from 'next/cache'\r\n\r\ncacheTag()",
        "context": ""
      },
      {
        "language": "bash",
        "code": "npx @next/codemod@latest middleware-to-proxy .",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "ts",
        "code": "import { NextResponse } from 'next/server'\r\n\r\nexport function middleware() {\r\n  return NextResponse.next()\r\n}",
        "context": "filename=\"middleware.ts\""
      },
      {
        "language": "ts",
        "code": "import { NextResponse } from 'next/server'\r\n\r\nexport function proxy() {\r\n  return NextResponse.next()\r\n}",
        "context": "filename=\"proxy.ts\""
      },
      {
        "language": "bash",
        "code": "npx @next/codemod@canary next-lint-to-eslint-cli .",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "json",
        "code": "{\r\n  \"scripts\": {\r\n    \"lint\": \"next lint\"\r\n  }\r\n}",
        "context": "filename=\"package.json\""
      },
      {
        "language": "json",
        "code": "{\r\n  \"scripts\": {\r\n    \"lint\": \"eslint .\"\r\n  }\r\n}",
        "context": "filename=\"package.json\""
      },
      {
        "language": "js",
        "code": "import { dirname } from 'path'\r\nimport { fileURLToPath } from 'url'\r\nimport { FlatCompat } from '@eslint/eslintrc'\r\n\r\nconst __filename = fileURLToPath(import.meta.url)\r\nconst __dirname = dirname(__filename)\r\n\r\nconst compat = new FlatCompat({\r\n  baseDirectory: __dirname,\r\n})\r\n\r\nconst eslintConfig = [\r\n  ...compat.extends('next/core-web-vitals', 'next/typescript'),\r\n  {\r\n    ignores: [\r\n      'node_modules/**',\r\n      '.next/**',\r\n      'out/**',\r\n      'build/**',\r\n      'next-env.d.ts',\r\n    ],\r\n  },\r\n]\r\n\r\nexport default eslintConfig",
        "context": "filename=\"eslint.config.mjs\""
      },
      {
        "language": "bash",
        "code": "npx @next/codemod@latest app-dir-runtime-config-experimental-edge .",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "ts",
        "code": "export const runtime = 'experimental-edge'",
        "context": ""
      },
      {
        "language": "ts",
        "code": "export const runtime = 'edge'",
        "context": ""
      },
      {
        "language": "bash",
        "code": "npx @next/codemod@latest next-async-request-api .",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "tsx",
        "code": "import { cookies, headers } from 'next/headers'\r\nconst token = cookies().get('token')\r\n\r\nfunction useToken() {\r\n  const token = cookies().get('token')\r\n  return token\r\n}\r\n\r\nexport default function Page() {\r\n  const name = cookies().get('name')\r\n}\r\n\r\nfunction getHeader() {\r\n  return headers().get('x-foo')\r\n}",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "import { use } from 'react'\r\nimport {\r\n  cookies,\r\n  headers,\r\n  type UnsafeUnwrappedCookies,\r\n  type UnsafeUnwrappedHeaders,\r\n} from 'next/headers'\r\nconst token = (cookies() as unknown as UnsafeUnwrappedCookies).get('token')\r\n\r\nfunction useToken() {\r\n  const token = use(cookies()).get('token')\r\n  return token\r\n}\r\n\r\nexport default async function Page() {\r\n  const name = (await cookies()).get('name')\r\n}\r\n\r\nfunction getHeader() {\r\n  return (headers() as unknown as UnsafeUnwrappedHeaders).get('x-foo')\r\n}",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "// page.tsx\r\nexport default function Page({\r\n  params,\r\n  searchParams,\r\n}: {\r\n  params: { slug: string }\r\n  searchParams: { [key: string]: string | string[] | undefined }\r\n}) {\r\n  const { value } = searchParams\r\n  if (value === 'foo') {\r\n    // ...\r\n  }\r\n}\r\n\r\nexport function generateMetadata({ params }: { params: { slug: string } }) {\r\n  const { slug } = params\r\n  return {\r\n    title: `My Page - ${slug}`,\r\n  }\r\n}",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "// page.tsx\r\nexport default async function Page(props: {\r\n  params: Promise<{ slug: string }>\r\n  searchParams: Promise<{ [key: string]: string | string[] | undefined }>\r\n}) {\r\n  const searchParams = await props.searchParams\r\n  const { value } = searchParams\r\n  if (value === 'foo') {\r\n    // ...\r\n  }\r\n}\r\n\r\nexport async function generateMetadata(props: {\r\n  params: Promise<{ slug: string }>\r\n}) {\r\n  const params = await props.params\r\n  const { slug } = params\r\n  return {\r\n    title: `My Page - ${slug}`,\r\n  }\r\n}",
        "context": ""
      },
      {
        "language": "bash",
        "code": "npx @next/codemod@latest next-request-geo-ip .",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "ts",
        "code": "import type { NextRequest } from 'next/server'\r\n\r\nexport function GET(req: NextRequest) {\r\n  const { geo, ip } = req\r\n}",
        "context": ""
      },
      {
        "language": "ts",
        "code": "import type { NextRequest } from 'next/server'\r\nimport { geolocation, ipAddress } from '@vercel/functions'\r\n\r\nexport function GET(req: NextRequest) {\r\n  const geo = geolocation(req)\r\n  const ip = ipAddress(req)\r\n}",
        "context": ""
      },
      {
        "language": "bash",
        "code": "npx @next/codemod@latest next-og-import .",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "js",
        "code": "import { ImageResponse } from 'next/server'",
        "context": ""
      },
      {
        "language": "js",
        "code": "import { ImageResponse } from 'next/og'",
        "context": ""
      },
      {
        "language": "bash",
        "code": "npx @next/codemod@latest metadata-to-viewport-export .",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "js",
        "code": "export const metadata = {\r\n  title: 'My App',\r\n  themeColor: 'dark',\r\n  viewport: {\r\n    width: 1,\r\n  },\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "export const metadata = {\r\n  title: 'My App',\r\n}\r\n\r\nexport const viewport = {\r\n  width: 1,\r\n  themeColor: 'dark',\r\n}",
        "context": ""
      },
      {
        "language": "bash",
        "code": "npx @next/codemod@latest built-in-next-font .",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "js",
        "code": "import { Inter } from '@next/font/google'",
        "context": ""
      },
      {
        "language": "js",
        "code": "import { Inter } from 'next/font/google'",
        "context": ""
      },
      {
        "language": "bash",
        "code": "npx @next/codemod@latest next-image-to-legacy-image .",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "jsx",
        "code": "import Image1 from 'next/image'\r\nimport Image2 from 'next/future/image'\r\n\r\nexport default function Home() {\r\n  return (\r\n    <div>\r\n      <Image1 src=\"/test.jpg\" width=\"200\" height=\"300\" />\r\n      <Image2 src=\"/test.png\" width=\"500\" height=\"400\" />\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"pages/index.js\""
      },
      {
        "language": "jsx",
        "code": "// 'next/image' becomes 'next/legacy/image'\r\nimport Image1 from 'next/legacy/image'\r\n// 'next/future/image' becomes 'next/image'\r\nimport Image2 from 'next/image'\r\n\r\nexport default function Home() {\r\n  return (\r\n    <div>\r\n      <Image1 src=\"/test.jpg\" width=\"200\" height=\"300\" />\r\n      <Image2 src=\"/test.png\" width=\"500\" height=\"400\" />\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"pages/index.js\""
      },
      {
        "language": "bash",
        "code": "npx @next/codemod@latest next-image-experimental .",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "npx @next/codemod@latest new-link .",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "jsx",
        "code": "<Link href=\"/about\">\r\n  <a>About</a>\r\n</Link>\r\n// transforms into\r\n<Link href=\"/about\">\r\n  About\r\n</Link>\r\n\r\n<Link href=\"/about\">\r\n  <a onClick={() => console.log('clicked')}>About</a>\r\n</Link>\r\n// transforms into\r\n<Link href=\"/about\" onClick={() => console.log('clicked')}>\r\n  About\r\n</Link>",
        "context": ""
      },
      {
        "language": "bash",
        "code": "npx @next/codemod cra-to-next",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "npx @next/codemod add-missing-react-import",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "jsx",
        "code": "export default class Home extends React.Component {\r\n  render() {\r\n    return <div>Hello World</div>\r\n  }\r\n}",
        "context": "filename=\"my-component.js\""
      },
      {
        "language": "jsx",
        "code": "import React from 'react'\r\nexport default class Home extends React.Component {\r\n  render() {\r\n    return <div>Hello World</div>\r\n  }\r\n}",
        "context": "filename=\"my-component.js\""
      },
      {
        "language": "bash",
        "code": "npx @next/codemod name-default-component",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "jsx",
        "code": "export default function () {\r\n  return <div>Hello World</div>\r\n}",
        "context": "filename=\"my-component.js\""
      },
      {
        "language": "jsx",
        "code": "export default function MyComponent() {\r\n  return <div>Hello World</div>\r\n}",
        "context": "filename=\"my-component.js\""
      },
      {
        "language": "bash",
        "code": "npx @next/codemod withamp-to-config",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "js",
        "code": "// Before\r\nimport { withAmp } from 'next/amp'\r\n\r\nfunction Home() {\r\n  return <h1>My AMP Page</h1>\r\n}\r\n\r\nexport default withAmp(Home)",
        "context": ""
      },
      {
        "language": "js",
        "code": "// After\r\nexport default function Home() {\r\n  return <h1>My AMP Page</h1>\r\n}\r\n\r\nexport const config = {\r\n  amp: true,\r\n}",
        "context": ""
      },
      {
        "language": "bash",
        "code": "npx @next/codemod url-to-withrouter",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "js",
        "code": "import React from 'react'\r\nexport default class extends React.Component {\r\n  render() {\r\n    const { pathname } = this.props.url\r\n    return <div>Current pathname: {pathname}</div>\r\n  }\r\n}",
        "context": "filename=\"From\""
      },
      {
        "language": "js",
        "code": "import React from 'react'\r\nimport { withRouter } from 'next/router'\r\nexport default withRouter(\r\n  class extends React.Component {\r\n    render() {\r\n      const { pathname } = this.props.router\r\n      return <div>Current pathname: {pathname}</div>\r\n    }\r\n  }\r\n)",
        "context": "filename=\"To\""
      }
    ],
    "content": "Codemods are transformations that run on your codebase programmatically. This allows a large number of changes to be programmatically applied without having to manually go through every file. Next.js provides Codemod transformations to help upgrade your Next.js codebase when an API is updated or deprecated. Usage In your terminal, navigate (cd) into your project's folder, then run: Replacing and with appropriate values. - transform - name of transform - path - files or directory to transform - --dry Do a dry-run, no code will be edited - --print Prints the changed output for comparison Codemods 16.0 Remove experimentalppr Route Segment Config from App Router pages and layouts remove-experimental-ppr This codemod removes the experimentalppr Route Segment Config from App Router pages and layouts. Remove unstable prefix from stabilized API remove-unstable-prefix This codemod removes the unstable prefix from stabilized API. For example: Transforms into: Migrate from deprecated middleware convention to proxy middleware-to-proxy This codemod migrates projects from using the deprecated middleware convention to using the proxy convention. It: - Renames middleware. to proxy. (e.g. middleware.ts to proxy.ts) - Renames named export middleware to proxy - Renames Next.js config property experimental.middlewarePrefetch to experimental.proxyPrefetch - Renames Next.js config property experimental.middlewareClientMaxBodySize to experimental.proxyClientMaxBodySize - Renames Next.js config property experimental.externalMiddlewareRewritesResolve to experimental.externalProxyRewritesResolve - Renames Next.js config property skipMiddlewareUrlNormalize to skipProxyUrlNormalize For example: Transforms into: Migrate from next lint to ESLint CLI next-lint-to-eslint-cli This codemod migrates projects from using next lint to using the ESLint CLI with your local ESLint config. It: - Creates an eslint.config.mjs file with Next.js recommended configurations - Updates package.json scripts to use eslint . instead of next lint - Adds necessary ESLint dependencies to package.json - Preserves existing ESLint configurations when found For example: Becomes: And creates: 15.0 Transform App Router Route Segment Config runtime value from experimental-edge to edge app-dir-runtime-config-experimental-edge > Note: This codemod is App Router specific. This codemod transforms Route Segment Config runtime value experimental-edge to edge. For example: Transforms into: Migrate to async Dynamic APIs APIs that opted into dynamic rendering that previously supported synchronous access are now asynchronous. You can read more about this breaking change in the upgrade guide. next-async-request-api This codemod will transform dynamic APIs (cookies(), headers() and draftMode() from next/headers) that are now asynchronous to be properly awaited or wrapped with React.use() if applicable. When an automatic migration isn't possible, the codemod will either add a typecast (if a TypeScript file) or a comment to inform the user that it needs to be manually reviewed & updated. For example: Transforms into: When we detect property access on the params or searchParams props in the page / route entries (page.js, layout.js, route.js, or default.js) or the generateMetadata / generateViewport APIs, it will attempt to transform the callsite from a sync to an async function, and await the property access. If it can't be made async (such as with a Client Component), it will use React.use to unwrap the promise . For example: Transforms into: > Good to know: When this codemod identifies a spot that might require manual intervention, but we aren't able to determine the exact fix, it will add a comment or typecast to the code to inform the user that it needs to be manually updated. These comments are prefixed with @next/codemod, and typecasts are prefixed with UnsafeUnwrapped. > Your build will error until these comments are explicitly removed. Read more. Replace geo and ip properties of NextRequest with @vercel/functions next-request-geo-ip This codemod installs @vercel/functions and transforms geo and ip properties of NextRequest with corresponding @vercel/functions features. For example: Transforms into: 14.0 Migrate ImageResponse imports next-og-import This codemod moves transforms imports from next/server to next/og for usage of Dynamic OG Image Generation. For example: Transforms into: Use viewport export metadata-to-viewport-export This codemod migrates certain viewport metadata to viewport export. For example: Transforms into: 13.2 Use Built-in Font built-in-next-font This codemod uninstalls the @next/font package and transforms @next/font imports into the built-in next/font. For example: Transforms into: 13.0 Rename Next Image Imports next-image-to-legacy-image Safely renames next/image imports in existing Next.js 10, 11, or 12 applications to next/legacy/image in Next.js 13. Also renames next/future/image to next/image. For example: Transforms into: Migrate to the New Image Component next-image-experimental Dangerously migrates from next/legacy/image to the new next/image by adding inline styles and removing unused props. - Removes layout prop and adds style. - Removes objectFit prop and adds style. - Removes objectPosition prop and adds style. - Removes lazyBoundary prop. - Removes lazyRoot prop. Remove Tags From Link Components new-link Remove tags inside Link Components. Remove tags inside Link Components. For example: 11 Migrate from CRA cra-to-next Migrates a Create React App project to Next.js; creating a Pages Router and necessary config to match behavior. Client-side only rendering is leveraged initially to prevent breaking compatibility due to window usage during SSR and can be enabled seamlessly to allow the gradual adoption of Next.js specific features. Please share any feedback related to this transform in this discussion. 10 Add React imports add-missing-react-import Transforms files that do not import React to include the import in order for the new React JSX transform to work. For example: Transforms into: 9 Transform Anonymous Components into Named Components name-default-component Versions 9 and above. Transforms anonymous components into named components to make sure they work with Fast Refresh. For example: Transforms into: The component will have a camel-cased name based on the name of the file, and it also works with arrow functions. 8 > Note: Built-in AMP support and this codemod have been removed in Next.js 16. Transform AMP HOC into page config withamp-to-config Transforms the withAmp HOC into Next.js 9 page configuration. For example: 6 Use withRouter url-to-withrouter Transforms the deprecated automatically injected url property on top level pages to using withRouter and the router property it injects. Read more here: https://nextjs.org/docs/messages/url-deprecated For example: This is one case. All the cases that are transformed (and tested) can be found in the testfixtures directory.",
    "excerpt": "Codemods are transformations that run on your codebase programmatically. This allows a large number of changes to be programmatically applied without having to manually go through every file. Next.js...",
    "url": "https://nextjs.org/docs/01-app/02-guides/upgrading/codemods"
  },
  {
    "id": "01-app-02-guides-upgrading-index",
    "path": "01-app\\02-guides\\upgrading\\index.mdx",
    "title": "Upgrade Guides",
    "description": "Learn how to upgrade to the latest versions of Next.js.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "Learn how to upgrade to the latest versions of Next.js following the versions-specific guides:",
    "excerpt": "Learn how to upgrade to the latest versions of Next.js following the versions-specific guides:",
    "url": "https://nextjs.org/docs/01-app/02-guides/upgrading"
  },
  {
    "id": "01-app-02-guides-upgrading-version-14",
    "path": "01-app\\02-guides\\upgrading\\version-14.mdx",
    "title": "How to upgrade to version 14",
    "description": "Upgrade your Next.js Application from Version 13 to 14.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Upgrading from 13 to 14",
        "slug": "upgrading-from-13-to-14"
      },
      {
        "level": 3,
        "text": "v14 Summary",
        "slug": "v14-summary"
      }
    ],
    "codeBlocks": [
      {
        "language": "bash",
        "code": "npm i next@next-14 react@18 react-dom@18 && npm i eslint-config-next@next-14 -D",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "yarn add next@next-14 react@18 react-dom@18 && yarn add eslint-config-next@next-14 -D",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "pnpm i next@next-14 react@18 react-dom@18 && pnpm i eslint-config-next@next-14 -D",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "bun add next@next-14 react@18 react-dom@18 && bun add eslint-config-next@next-14 -D",
        "context": "filename=\"Terminal\""
      }
    ],
    "content": "Upgrading from 13 to 14 To update to Next.js version 14, run the following command using your preferred package manager: > Good to know: If you are using TypeScript, ensure you also upgrade @types/react and @types/react-dom to their latest versions. v14 Summary - The minimum Node.js version has been bumped from 16.14 to 18.17, since 16.x has reached end-of-life. - The next export command has been removed in favor of output: 'export' config. Please see the docs for more information. - The next/server import for ImageResponse was renamed to next/og. A codemod is available to safely and automatically rename your imports. - The @next/font package has been fully removed in favor of the built-in next/font. A codemod is available to safely and automatically rename your imports. - The WASM target for next-swc has been removed.",
    "excerpt": "Upgrading from 13 to 14 To update to Next.js version 14, run the following command using your preferred package manager: > Good to know: If you are using TypeScript, ensure you also upgrade @types/rea...",
    "url": "https://nextjs.org/docs/01-app/02-guides/upgrading/version-14"
  },
  {
    "id": "01-app-02-guides-upgrading-version-15",
    "path": "01-app\\02-guides\\upgrading\\version-15.mdx",
    "title": "How to upgrade to version 15",
    "description": "Upgrade your Next.js Application from Version 14 to 15.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Upgrading from 14 to 15",
        "slug": "upgrading-from-14-to-15"
      },
      {
        "level": 2,
        "text": "React 19",
        "slug": "react-19"
      },
      {
        "level": 2,
        "text": "Async Request APIs (Breaking change)",
        "slug": "async-request-apis-breaking-change"
      },
      {
        "level": 4,
        "text": "Recommended Async Usage",
        "slug": "recommended-async-usage"
      },
      {
        "level": 4,
        "text": "Temporary Synchronous Usage",
        "slug": "temporary-synchronous-usage"
      },
      {
        "level": 4,
        "text": "Recommended Async Usage",
        "slug": "recommended-async-usage"
      },
      {
        "level": 4,
        "text": "Temporary Synchronous Usage",
        "slug": "temporary-synchronous-usage"
      },
      {
        "level": 4,
        "text": "Recommended Async Usage",
        "slug": "recommended-async-usage"
      },
      {
        "level": 4,
        "text": "Temporary Synchronous Usage",
        "slug": "temporary-synchronous-usage"
      },
      {
        "level": 3,
        "text": " & ",
        "slug": "--"
      },
      {
        "level": 4,
        "text": "Asynchronous Layout",
        "slug": "asynchronous-layout"
      },
      {
        "level": 4,
        "text": "Synchronous Layout",
        "slug": "synchronous-layout"
      },
      {
        "level": 4,
        "text": "Asynchronous Page",
        "slug": "asynchronous-page"
      },
      {
        "level": 4,
        "text": "Synchronous Page",
        "slug": "synchronous-page"
      },
      {
        "level": 4,
        "text": "Route Handlers",
        "slug": "route-handlers"
      },
      {
        "level": 2,
        "text": " configuration (Breaking change)",
        "slug": "-configuration-breaking-change"
      },
      {
        "level": 2,
        "text": " requests",
        "slug": "-requests"
      },
      {
        "level": 2,
        "text": "Route Handlers",
        "slug": "route-handlers"
      },
      {
        "level": 2,
        "text": "Client-side Router Cache",
        "slug": "client-side-router-cache"
      },
      {
        "level": 2,
        "text": "bundlePagesRouterDependencies",
        "slug": "bundlepagesrouterdependencies"
      },
      {
        "level": 2,
        "text": "serverExternalPackages",
        "slug": "serverexternalpackages"
      },
      {
        "level": 2,
        "text": "Speed Insights",
        "slug": "speed-insights"
      },
      {
        "level": 2,
        "text": " Geolocation",
        "slug": "-geolocation"
      }
    ],
    "codeBlocks": [
      {
        "language": "bash",
        "code": "npx @next/codemod@canary upgrade latest",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "npm i next@latest react@latest react-dom@latest eslint-config-next@latest",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "tsx",
        "code": "import { cookies } from 'next/headers'\r\n\r\n// Before\r\nconst cookieStore = cookies()\r\nconst token = cookieStore.get('token')\r\n\r\n// After\r\nconst cookieStore = await cookies()\r\nconst token = cookieStore.get('token')",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "import { cookies, type UnsafeUnwrappedCookies } from 'next/headers'\r\n\r\n// Before\r\nconst cookieStore = cookies()\r\nconst token = cookieStore.get('token')\r\n\r\n// After\r\nconst cookieStore = cookies() as unknown as UnsafeUnwrappedCookies\r\n// will log a warning in dev\r\nconst token = cookieStore.get('token')",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { cookies } from 'next/headers'\r\n\r\n// Before\r\nconst cookieStore = cookies()\r\nconst token = cookieStore.get('token')\r\n\r\n// After\r\nconst cookieStore = cookies()\r\n// will log a warning in dev\r\nconst token = cookieStore.get('token')",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { headers } from 'next/headers'\r\n\r\n// Before\r\nconst headersList = headers()\r\nconst userAgent = headersList.get('user-agent')\r\n\r\n// After\r\nconst headersList = await headers()\r\nconst userAgent = headersList.get('user-agent')",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "import { headers, type UnsafeUnwrappedHeaders } from 'next/headers'\r\n\r\n// Before\r\nconst headersList = headers()\r\nconst userAgent = headersList.get('user-agent')\r\n\r\n// After\r\nconst headersList = headers() as unknown as UnsafeUnwrappedHeaders\r\n// will log a warning in dev\r\nconst userAgent = headersList.get('user-agent')",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { headers } from 'next/headers'\r\n\r\n// Before\r\nconst headersList = headers()\r\nconst userAgent = headersList.get('user-agent')\r\n\r\n// After\r\nconst headersList = headers()\r\n// will log a warning in dev\r\nconst userAgent = headersList.get('user-agent')",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { draftMode } from 'next/headers'\r\n\r\n// Before\r\nconst { isEnabled } = draftMode()\r\n\r\n// After\r\nconst { isEnabled } = await draftMode()",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "import { draftMode, type UnsafeUnwrappedDraftMode } from 'next/headers'\r\n\r\n// Before\r\nconst { isEnabled } = draftMode()\r\n\r\n// After\r\n// will log a warning in dev\r\nconst { isEnabled } = draftMode() as unknown as UnsafeUnwrappedDraftMode",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { draftMode } from 'next/headers'\r\n\r\n// Before\r\nconst { isEnabled } = draftMode()\r\n\r\n// After\r\n// will log a warning in dev\r\nconst { isEnabled } = draftMode()",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "// Before\r\ntype Params = { slug: string }\r\n\r\nexport function generateMetadata({ params }: { params: Params }) {\r\n  const { slug } = params\r\n}\r\n\r\nexport default async function Layout({\r\n  children,\r\n  params,\r\n}: {\r\n  children: React.ReactNode\r\n  params: Params\r\n}) {\r\n  const { slug } = params\r\n}\r\n\r\n// After\r\ntype Params = Promise<{ slug: string }>\r\n\r\nexport async function generateMetadata({ params }: { params: Params }) {\r\n  const { slug } = await params\r\n}\r\n\r\nexport default async function Layout({\r\n  children,\r\n  params,\r\n}: {\r\n  children: React.ReactNode\r\n  params: Params\r\n}) {\r\n  const { slug } = await params\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "// Before\r\nexport function generateMetadata({ params }) {\r\n  const { slug } = params\r\n}\r\n\r\nexport default async function Layout({ children, params }) {\r\n  const { slug } = params\r\n}\r\n\r\n// After\r\nexport async function generateMetadata({ params }) {\r\n  const { slug } = await params\r\n}\r\n\r\nexport default async function Layout({ children, params }) {\r\n  const { slug } = await params\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "// Before\r\ntype Params = { slug: string }\r\n\r\nexport default function Layout({\r\n  children,\r\n  params,\r\n}: {\r\n  children: React.ReactNode\r\n  params: Params\r\n}) {\r\n  const { slug } = params\r\n}\r\n\r\n// After\r\nimport { use } from 'react'\r\n\r\ntype Params = Promise<{ slug: string }>\r\n\r\nexport default function Layout(props: {\r\n  children: React.ReactNode\r\n  params: Params\r\n}) {\r\n  const params = use(props.params)\r\n  const slug = params.slug\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "// Before\r\nexport default function Layout({ children, params }) {\r\n  const { slug } = params\r\n}\r\n\r\n// After\r\nimport { use } from 'react'\r\nexport default async function Layout(props) {\r\n  const params = use(props.params)\r\n  const slug = params.slug\r\n}\r\n",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "// Before\r\ntype Params = { slug: string }\r\ntype SearchParams = { [key: string]: string | string[] | undefined }\r\n\r\nexport function generateMetadata({\r\n  params,\r\n  searchParams,\r\n}: {\r\n  params: Params\r\n  searchParams: SearchParams\r\n}) {\r\n  const { slug } = params\r\n  const { query } = searchParams\r\n}\r\n\r\nexport default async function Page({\r\n  params,\r\n  searchParams,\r\n}: {\r\n  params: Params\r\n  searchParams: SearchParams\r\n}) {\r\n  const { slug } = params\r\n  const { query } = searchParams\r\n}\r\n\r\n// After\r\ntype Params = Promise<{ slug: string }>\r\ntype SearchParams = Promise<{ [key: string]: string | string[] | undefined }>\r\n\r\nexport async function generateMetadata(props: {\r\n  params: Params\r\n  searchParams: SearchParams\r\n}) {\r\n  const params = await props.params\r\n  const searchParams = await props.searchParams\r\n  const slug = params.slug\r\n  const query = searchParams.query\r\n}\r\n\r\nexport default async function Page(props: {\r\n  params: Params\r\n  searchParams: SearchParams\r\n}) {\r\n  const params = await props.params\r\n  const searchParams = await props.searchParams\r\n  const slug = params.slug\r\n  const query = searchParams.query\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "// Before\r\nexport function generateMetadata({ params, searchParams }) {\r\n  const { slug } = params\r\n  const { query } = searchParams\r\n}\r\n\r\nexport default function Page({ params, searchParams }) {\r\n  const { slug } = params\r\n  const { query } = searchParams\r\n}\r\n\r\n// After\r\nexport async function generateMetadata(props) {\r\n  const params = await props.params\r\n  const searchParams = await props.searchParams\r\n  const slug = params.slug\r\n  const query = searchParams.query\r\n}\r\n\r\nexport async function Page(props) {\r\n  const params = await props.params\r\n  const searchParams = await props.searchParams\r\n  const slug = params.slug\r\n  const query = searchParams.query\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\n// Before\r\ntype Params = { slug: string }\r\ntype SearchParams = { [key: string]: string | string[] | undefined }\r\n\r\nexport default function Page({\r\n  params,\r\n  searchParams,\r\n}: {\r\n  params: Params\r\n  searchParams: SearchParams\r\n}) {\r\n  const { slug } = params\r\n  const { query } = searchParams\r\n}\r\n\r\n// After\r\nimport { use } from 'react'\r\n\r\ntype Params = Promise<{ slug: string }>\r\ntype SearchParams = Promise<{ [key: string]: string | string[] | undefined }>\r\n\r\nexport default function Page(props: {\r\n  params: Params\r\n  searchParams: SearchParams\r\n}) {\r\n  const params = use(props.params)\r\n  const searchParams = use(props.searchParams)\r\n  const slug = params.slug\r\n  const query = searchParams.query\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "// Before\r\nexport default function Page({ params, searchParams }) {\r\n  const { slug } = params\r\n  const { query } = searchParams\r\n}\r\n\r\n// After\r\nimport { use } from \"react\"\r\n\r\nexport default function Page(props) {\r\n  const params = use(props.params)\r\n  const searchParams = use(props.searchParams)\r\n  const slug = params.slug\r\n  const query = searchParams.query\r\n}\r\n",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "// Before\r\ntype Params = { slug: string }\r\n\r\nexport async function GET(request: Request, segmentData: { params: Params }) {\r\n  const params = segmentData.params\r\n  const slug = params.slug\r\n}\r\n\r\n// After\r\ntype Params = Promise<{ slug: string }>\r\n\r\nexport async function GET(request: Request, segmentData: { params: Params }) {\r\n  const params = await segmentData.params\r\n  const slug = params.slug\r\n}",
        "context": "filename=\"app/api/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "// Before\r\nexport async function GET(request, segmentData) {\r\n  const params = segmentData.params\r\n  const slug = params.slug\r\n}\r\n\r\n// After\r\nexport async function GET(request, segmentData) {\r\n  const params = await segmentData.params\r\n  const slug = params.slug\r\n}",
        "context": "filename=\"app/api/route.js\" switcher"
      },
      {
        "language": "js",
        "code": "export default async function RootLayout() {\r\n  const a = await fetch('https://...') // Not Cached\r\n  const b = await fetch('https://...', { cache: 'force-cache' }) // Cached\r\n\r\n  // ...\r\n}",
        "context": "filename=\"app/layout.js\""
      },
      {
        "language": "js",
        "code": "// Since this is the root layout, all fetch requests in the app\r\n// that don't set their own cache option will be cached.\r\nexport const fetchCache = 'default-cache'\r\n\r\nexport default async function RootLayout() {\r\n  const a = await fetch('https://...') // Cached\r\n  const b = await fetch('https://...', { cache: 'no-store' }) // Not cached\r\n\r\n  // ...\r\n}",
        "context": "filename=\"app/layout.js\""
      },
      {
        "language": "js",
        "code": "export const dynamic = 'force-static'\r\n\r\nexport async function GET() {}",
        "context": "filename=\"app/api/route.js\""
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  experimental: {\r\n    staleTimes: {\r\n      dynamic: 30,\r\n      static: 180,\r\n    },\r\n  },\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "// Before\r\nimport { Inter } from '@next/font/google'\r\n\r\n// After\r\nimport { Inter } from 'next/font/google'",
        "context": "filename=\"app/layout.js\""
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  // Before\r\n  experimental: {\r\n    bundlePagesExternals: true,\r\n  },\r\n\r\n  // After\r\n  bundlePagesRouterDependencies: true,\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  // Before\r\n  experimental: {\r\n    serverComponentsExternalPackages: ['package-name'],\r\n  },\r\n\r\n  // After\r\n  serverExternalPackages: ['package-name'],\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "ts",
        "code": "import { geolocation } from '@vercel/functions'\r\nimport type { NextRequest } from 'next/server'\r\n\r\nexport function middleware(request: NextRequest) {\r\n  const { city } = geolocation(request)\r\n\r\n  // ...\r\n}",
        "context": "filename=\"middleware.ts\""
      },
      {
        "language": "ts",
        "code": "import { ipAddress } from '@vercel/functions'\r\nimport type { NextRequest } from 'next/server'\r\n\r\nexport function middleware(request: NextRequest) {\r\n  const ip = ipAddress(request)\r\n\r\n  // ...\r\n}",
        "context": "filename=\"middleware.ts\""
      }
    ],
    "content": "Upgrading from 14 to 15 To update to Next.js version 15, you can use the upgrade codemod: If you prefer to do it manually, ensure that you're installing the latest Next & React versions: > Good to know: > > - If you see a peer dependencies warning, you may need to update react and react-dom to the suggested versions, or use the --force or --legacy-peer-deps flag to ignore the warning. This won't be necessary once both Next.js 15 and React 19 are stable. React 19 - The minimum versions of react and react-dom is now 19. - useFormState has been replaced by useActionState. The useFormState hook is still available in React 19, but it is deprecated and will be removed in a future release. useActionState is recommended and includes additional properties like reading the pending state directly. Learn more. - useFormStatus now includes additional keys like data, method, and action. If you are not using React 19, only the pending key is available. Learn more. - Read more in the React 19 upgrade guide. > Good to know: If you are using TypeScript, ensure you also upgrade @types/react and @types/react-dom to their latest versions. Async Request APIs (Breaking change) Previously synchronous Dynamic APIs that rely on runtime information are now asynchronous: - cookies - headers - draftMode - params in layout.js, page.js, route.js, default.js, opengraph-image, twitter-image, icon, and apple-icon. - searchParams in page.js To ease the burden of migration, a codemod is available to automate the process and the APIs can temporarily be accessed synchronously. cookies Recommended Async Usage Temporary Synchronous Usage headers Recommended Async Usage Temporary Synchronous Usage draftMode Recommended Async Usage Temporary Synchronous Usage params & searchParams Asynchronous Layout Synchronous Layout Asynchronous Page Synchronous Page Route Handlers runtime configuration (Breaking change) The runtime segment configuration previously supported a value of experimental-edge in addition to edge. Both configurations refer to the same thing, and to simplify the options, we will now error if experimental-edge is used. To fix this, update your runtime configuration to edge. A codemod is available to automatically do this. fetch requests fetch requests are no longer cached by default. To opt specific fetch requests into caching, you can pass the cache: 'force-cache' option. To opt all fetch requests in a layout or page into caching, you can use the export const fetchCache = 'default-cache' segment config option. If individual fetch requests specify a cache option, that will be used instead. Route Handlers GET functions in Route Handlers are no longer cached by default. To opt GET methods into caching, you can use a route config option such as export const dynamic = 'force-static' in your Route Handler file. Client-side Router Cache When navigating between pages via or useRouter, page segments are no longer reused from the client-side router cache. However, they are still reused during browser backward and forward navigation and for shared layouts. To opt page segments into caching, you can use the staleTimes config option: Layouts and loading states are still cached and reused on navigation. next/font The @next/font package has been removed in favor of the built-in next/font. A codemod is available to safely and automatically rename your imports. bundlePagesRouterDependencies experimental.bundlePagesExternals is now stable and renamed to bundlePagesRouterDependencies. serverExternalPackages experimental.serverComponentsExternalPackages is now stable and renamed to serverExternalPackages. Speed Insights Auto instrumentation for Speed Insights was removed in Next.js 15. To continue using Speed Insights, follow the Vercel Speed Insights Quickstart guide. NextRequest Geolocation The geo and ip properties on NextRequest have been removed as these values are provided by your hosting provider. A codemod is available to automate this migration. If you are using Vercel, you can alternatively use the geolocation and ipAddress functions from @vercel/functions instead:",
    "excerpt": "Upgrading from 14 to 15 To update to Next.js version 15, you can use the upgrade codemod: If you prefer to do it manually, ensure that you're installing the latest Next & React versions: > Good to kno...",
    "url": "https://nextjs.org/docs/01-app/02-guides/upgrading/version-15"
  },
  {
    "id": "01-app-02-guides-upgrading-version-16",
    "path": "01-app\\02-guides\\upgrading\\version-16.mdx",
    "title": "How to upgrade to version 16",
    "description": "Upgrade your Next.js Application from Version 15 to 16.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Upgrading from 15 to 16",
        "slug": "upgrading-from-15-to-16"
      },
      {
        "level": 3,
        "text": "Using AI Agents with Next.js DevTools MCP",
        "slug": "using-ai-agents-with-nextjs-devtools-mcp"
      },
      {
        "level": 4,
        "text": "Setup",
        "slug": "setup"
      },
      {
        "level": 4,
        "text": "Example Prompts",
        "slug": "example-prompts"
      },
      {
        "level": 3,
        "text": "Using the Codemod",
        "slug": "using-the-codemod"
      },
      {
        "level": 2,
        "text": "Node.js runtime and browser support",
        "slug": "nodejs-runtime-and-browser-support"
      },
      {
        "level": 2,
        "text": "Turbopack by default",
        "slug": "turbopack-by-default"
      },
      {
        "level": 3,
        "text": "Opting out of Turbopack",
        "slug": "opting-out-of-turbopack"
      },
      {
        "level": 3,
        "text": "Turbopack configuration location",
        "slug": "turbopack-configuration-location"
      },
      {
        "level": 3,
        "text": "Resolve alias fallback",
        "slug": "resolve-alias-fallback"
      },
      {
        "level": 3,
        "text": "Sass node_modules imports",
        "slug": "sass-node_modules-imports"
      },
      {
        "level": 3,
        "text": "Turbopack File System Caching (beta)",
        "slug": "turbopack-file-system-caching-beta"
      },
      {
        "level": 2,
        "text": "Async Request APIs (Breaking change)",
        "slug": "async-request-apis-breaking-change"
      },
      {
        "level": 3,
        "text": "Migrating types for async Dynamic APIs",
        "slug": "migrating-types-for-async-dynamic-apis"
      },
      {
        "level": 2,
        "text": "Async parameters for icon, and open-graph Image (Breaking change)",
        "slug": "async-parameters-for-icon-and-open-graph-image-breaking-change"
      },
      {
        "level": 2,
        "text": "React 19.2",
        "slug": "react-192"
      },
      {
        "level": 2,
        "text": "React Compiler Support",
        "slug": "react-compiler-support"
      },
      {
        "level": 2,
        "text": "Caching APIs",
        "slug": "caching-apis"
      },
      {
        "level": 3,
        "text": "revalidateTag",
        "slug": "revalidatetag"
      },
      {
        "level": 3,
        "text": "updateTag",
        "slug": "updatetag"
      },
      {
        "level": 3,
        "text": "refresh",
        "slug": "refresh"
      },
      {
        "level": 3,
        "text": "cacheLife and cacheTag",
        "slug": "cachelife-and-cachetag"
      },
      {
        "level": 2,
        "text": "Enhanced Routing and Navigation",
        "slug": "enhanced-routing-and-navigation"
      },
      {
        "level": 2,
        "text": "Partial Pre-Rendering (PPR)",
        "slug": "partial-pre-rendering-ppr"
      },
      {
        "level": 2,
        "text": " to ",
        "slug": "-to-"
      },
      {
        "level": 2,
        "text": " changes",
        "slug": "-changes"
      },
      {
        "level": 3,
        "text": "Local Images with Query Strings (Breaking change)",
        "slug": "local-images-with-query-strings-breaking-change"
      },
      {
        "level": 3,
        "text": " Default (Breaking change)",
        "slug": "-default-breaking-change"
      },
      {
        "level": 3,
        "text": " Default (Breaking change)",
        "slug": "-default-breaking-change"
      },
      {
        "level": 3,
        "text": " Default (Breaking change)",
        "slug": "-default-breaking-change"
      },
      {
        "level": 3,
        "text": "Local IP Restriction (Breaking change)",
        "slug": "local-ip-restriction-breaking-change"
      },
      {
        "level": 3,
        "text": "Maximum Redirects (Breaking change)",
        "slug": "maximum-redirects-breaking-change"
      },
      {
        "level": 3,
        "text": " Component (deprecated)",
        "slug": "-component-deprecated"
      },
      {
        "level": 3,
        "text": " Configuration (deprecated)",
        "slug": "-configuration-deprecated"
      },
      {
        "level": 2,
        "text": "Concurrent  and ",
        "slug": "concurrent-and-"
      },
      {
        "level": 2,
        "text": "Parallel Routes  requirement",
        "slug": "parallel-routes-requirement"
      },
      {
        "level": 2,
        "text": "ESLint Flat Config",
        "slug": "eslint-flat-config"
      },
      {
        "level": 2,
        "text": "Scroll Behavior Override",
        "slug": "scroll-behavior-override"
      },
      {
        "level": 2,
        "text": "Performance Improvements",
        "slug": "performance-improvements"
      },
      {
        "level": 3,
        "text": " config load",
        "slug": "-config-load"
      },
      {
        "level": 2,
        "text": "Build Adapters API (alpha)",
        "slug": "build-adapters-api-alpha"
      },
      {
        "level": 2,
        "text": "Modern Sass API",
        "slug": "modern-sass-api"
      },
      {
        "level": 2,
        "text": "Removals",
        "slug": "removals"
      },
      {
        "level": 3,
        "text": "AMP Support",
        "slug": "amp-support"
      },
      {
        "level": 3,
        "text": " Command",
        "slug": "-command"
      },
      {
        "level": 3,
        "text": "Runtime Configuration",
        "slug": "runtime-configuration"
      },
      {
        "level": 3,
        "text": " Options",
        "slug": "-options"
      }
    ],
    "codeBlocks": [
      {
        "language": "json",
        "code": "{\r\n  \"mcpServers\": {\r\n    \"next-devtools\": {\r\n      \"command\": \"npx\",\r\n      \"args\": [\"-y\", \"next-devtools-mcp@latest\"]\r\n    }\r\n  }\r\n}",
        "context": ""
      },
      {
        "language": "txt",
        "code": "Next Devtools, help me upgrade my Next.js app to version 16",
        "context": ""
      },
      {
        "language": "txt",
        "code": "Next Devtools, migrate my Next.js app to cache components",
        "context": ""
      },
      {
        "language": "bash",
        "code": "npx @next/codemod@canary upgrade latest",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "npm install next@latest react@latest react-dom@latest",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "json",
        "code": "{\r\n  \"scripts\": {\r\n    \"dev\": \"next dev --turbopack\",\r\n    \"build\": \"next build --turbopack\",\r\n    \"start\": \"next start\"\r\n  }\r\n}",
        "context": "filename=\"package.json\""
      },
      {
        "language": "json",
        "code": "{\r\n  \"scripts\": {\r\n    \"dev\": \"next dev\",\r\n    \"build\": \"next build\",\r\n    \"start\": \"next start\"\r\n  }\r\n}",
        "context": "filename=\"package.json\""
      },
      {
        "language": "json",
        "code": "{\r\n  \"scripts\": {\r\n    \"dev\": \"next dev\",\r\n    \"build\": \"next build --webpack\",\r\n    \"start\": \"next start\"\r\n  }\r\n}",
        "context": "filename=\"package.json\""
      },
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\n// Next.js 15 - experimental.turbopack\r\nconst nextConfig: NextConfig = {\r\n  experimental: {\r\n    turbopack: {\r\n      // options\r\n    },\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\""
      },
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\n// Next.js 16 - turbopack at the top level of nextConfig\r\nconst nextConfig: NextConfig = {\r\n  turbopack: {\r\n    // options\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\""
      },
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  turbopack: {\r\n    resolveAlias: {\r\n      fs: {\r\n        browser: './empty.ts', // We recommend to fix code imports before using this method\r\n      },\r\n    },\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\""
      },
      {
        "language": "scss",
        "code": "@import '~bootstrap/dist/css/bootstrap.min.css';",
        "context": "filename=\"styles/globals.scss\""
      },
      {
        "language": "scss",
        "code": "@import 'bootstrap/dist/css/bootstrap.min.css';",
        "context": "filename=\"styles/globals.scss\""
      },
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  turbopack: {\r\n    resolveAlias: {\r\n      '~*': '*',\r\n    },\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\""
      },
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  experimental: {\r\n    turbopackFileSystemCacheForDev: true,\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  experimental: {\r\n    turbopackFileSystemCacheForDev: true,\r\n  },\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default async function Page(props: PageProps<'/blog/[slug]'>) {\r\n  const { slug } = await props.params\r\n  const query = await props.searchParams\r\n  return <h1>Blog Post: {slug}</h1>\r\n}",
        "context": "filename=\"/app/blog/[slug]/page.tsx\""
      },
      {
        "language": "js",
        "code": "// Next.js 15 - synchronous params access\r\nexport function generateImageMetadata({ params }) {\r\n  const { slug } = params\r\n  return [{ id: '1' }, { id: '2' }]\r\n}\r\n\r\n// Next.js 15 - synchronous params and id access\r\nexport default function Image({ params, id }) {\r\n  const slug = params.slug\r\n  const imageId = id // string\r\n  // ...\r\n}",
        "context": "filename=\"app/shop/[slug]/opengraph-image.js\""
      },
      {
        "language": "js",
        "code": "// Next.js 16 - asynchronous params access\r\nexport async function generateImageMetadata({ params }) {\r\n  const { slug } = await params\r\n  return [{ id: '1' }, { id: '2' }]\r\n}\r\n\r\n// Next.js 16 - asynchronous params and id access\r\nexport default async function Image({ params, id }) {\r\n  const { slug } = await params // params now async\r\n  const imageId = await id // id is now Promise<string> when using generateImageMetadata\r\n  // ...\r\n}",
        "context": "filename=\"app/shop/[slug]/opengraph-image.js\""
      },
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  reactCompiler: true,\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  reactCompiler: true,\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\" switcher"
      },
      {
        "language": "bash",
        "code": "npm install -D babel-plugin-react-compiler",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "ts",
        "code": "'use server'\r\n\r\nimport { revalidateTag } from 'next/cache'\r\n\r\nexport async function updateArticle(articleId: string) {\r\n  // Mark article data as stale - article readers see stale data while it revalidates\r\n  revalidateTag(`article-${articleId}`, 'max')\r\n}",
        "context": "filename=\"app/actions.ts\" switcher"
      },
      {
        "language": "js",
        "code": "'use server'\r\n\r\nimport { revalidateTag } from 'next/cache'\r\n\r\nexport async function updateArticle(articleId) {\r\n  // Mark article data as stale - article readers see stale data while it revalidates\r\n  revalidateTag(`article-${articleId}`, 'max')\r\n}",
        "context": "filename=\"app/actions.js\" switcher"
      },
      {
        "language": "ts",
        "code": "'use server'\r\n\r\nimport { updateTag } from 'next/cache'\r\n\r\nexport async function updateUserProfile(userId: string, profile: Profile) {\r\n  await db.users.update(userId, profile)\r\n\r\n  // Expire cache and refresh immediately - user sees their changes right away\r\n  updateTag(`user-${userId}`)\r\n}",
        "context": "filename=\"app/actions.ts\" switcher"
      },
      {
        "language": "js",
        "code": "'use server'\r\n\r\nimport { updateTag } from 'next/cache'\r\n\r\nexport async function updateUserProfile(userId, profile) {\r\n  await db.users.update(userId, profile)\r\n\r\n  // Expire cache and refresh immediately - user sees their changes right away\r\n  updateTag(`user-${userId}`)\r\n}",
        "context": "filename=\"app/actions.js\" switcher"
      },
      {
        "language": "ts",
        "code": "'use server'\r\n\r\nimport { refresh } from 'next/cache'\r\n\r\nexport async function markNotificationAsRead(notificationId: string) {\r\n  // Update the notification in the database\r\n  await db.notifications.markAsRead(notificationId)\r\n\r\n  // Refresh the notification count displayed in the header\r\n  refresh()\r\n}",
        "context": "filename=\"app/actions.ts\" switcher"
      },
      {
        "language": "js",
        "code": "'use server'\r\n\r\nimport { refresh } from 'next/cache'\r\n\r\nexport async function markNotificationAsRead(notificationId) {\r\n  // Update the notification in the database\r\n  await db.notifications.markAsRead(notificationId)\r\n\r\n  // Refresh the notification count displayed in the header\r\n  refresh()\r\n}",
        "context": "filename=\"app/actions.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import {\r\n  unstable_cacheLife as cacheLife,\r\n  unstable_cacheTag as cacheTag,\r\n} from 'next/cache'",
        "context": ""
      },
      {
        "language": "ts",
        "code": "import { cacheLife, cacheTag } from 'next/cache'",
        "context": ""
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  cacheComponents: true,\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  // If you are using PPR today\r\n  // stay in the current Next.js 15 canary\r\n  experimental: {\r\n    ppr: true,\r\n  },\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "bash",
        "code": "# Rename your middleware file\r\nmv middleware.ts proxy.ts\r\n# or\r\nmv middleware.js proxy.js",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "ts",
        "code": "export function proxy(request: Request) {}",
        "context": "filename=\"proxy.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export function proxy(request) {}",
        "context": "filename=\"proxy.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  skipProxyUrlNormalize: true,\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  skipProxyUrlNormalize: true,\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Image from 'next/image'\r\n\r\nexport default function Page() {\r\n  return <Image src=\"/assets/photo?v=1\" alt=\"Photo\" width=\"100\" height=\"100\" />\r\n}",
        "context": "filename=\"app/page.tsx\""
      },
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  images: {\r\n    localPatterns: [\r\n      {\r\n        pathname: '/assets/**',\r\n        search: '?v=1',\r\n      },\r\n    ],\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  images: {\r\n    localPatterns: [\r\n      {\r\n        pathname: '/assets/**',\r\n        search: '?v=1',\r\n      },\r\n    ],\r\n  },\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  images: {\r\n    minimumCacheTTL: 60,\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  images: {\r\n    minimumCacheTTL: 60,\r\n  },\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  images: {\r\n    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  images: {\r\n    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],\r\n  },\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  images: {\r\n    qualities: [50, 75, 100],\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  images: {\r\n    qualities: [50, 75, 100],\r\n  },\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  images: {\r\n    dangerouslyAllowLocalIP: true, // Only for private networks\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  images: {\r\n    dangerouslyAllowLocalIP: true, // Only for private networks\r\n  },\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  images: {\r\n    maximumRedirects: 0, // Disable redirects\r\n    // or\r\n    maximumRedirects: 5, // Increase for edge cases\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  images: {\r\n    maximumRedirects: 0, // Disable redirects\r\n    // or\r\n    maximumRedirects: 5, // Increase for edge cases\r\n  },\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "// Before\r\nimport Image from 'next/legacy/image'\r\n\r\n// After\r\nimport Image from 'next/image'",
        "context": ""
      },
      {
        "language": "js",
        "code": "// image.domains is deprecated\r\nmodule.exports = {\r\n  images: {\r\n    domains: ['example.com'],\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "// Use image.remotePatterns instead\r\nmodule.exports = {\r\n  images: {\r\n    remotePatterns: [\r\n      {\r\n        protocol: 'https',\r\n        hostname: 'example.com',\r\n      },\r\n    ],\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "bash",
        "code": "npx next internal trace .next/dev/trace-turbopack",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "import { notFound } from 'next/navigation'\r\n\r\nexport default function Default() {\r\n  notFound()\r\n}",
        "context": "filename=\"app/@modal/default.tsx\""
      },
      {
        "language": "tsx",
        "code": "export default function Default() {\r\n  return null\r\n}",
        "context": "filename=\"app/@modal/default.tsx\""
      },
      {
        "language": "tsx",
        "code": "export default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\" data-scroll-behavior=\"smooth\">\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\""
      },
      {
        "language": "js",
        "code": "import { startServer } from 'docs-lib/dev-server'\r\n\r\nconst isDev = process.env.NODE_ENV === 'development'\r\n\r\nif (isDev) {\r\n  startServer()\r\n}\r\n\r\nconst nextConfig = {\r\n  /* Your config options */\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "const nextConfig = {\r\n  experimental: {\r\n    adapterPath: require.resolve('./my-adapter.js'),\r\n  },\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "tsx",
        "code": "// Removed\r\nimport { useAmp } from 'next/amp'\r\n\r\n// Removed\r\nexport const config = { amp: true }",
        "context": ""
      },
      {
        "language": "js",
        "code": "const nextConfig = {\r\n  // Removed\r\n  amp: {\r\n    canonicalBase: 'https://example.com',\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "bash",
        "code": "npx @next/codemod@canary next-lint-to-eslint-cli .",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  // No longer supported\r\n  // eslint: {},\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.mjs\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  serverRuntimeConfig: {\r\n    dbUrl: process.env.DATABASE_URL,\r\n  },\r\n  publicRuntimeConfig: {\r\n    apiUrl: '/api',\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "tsx",
        "code": "import getConfig from 'next/config'\r\n\r\nexport default function Page() {\r\n  const { publicRuntimeConfig } = getConfig()\r\n  return <p>API URL: {publicRuntimeConfig.apiUrl}</p>\r\n}",
        "context": "filename=\"pages/index.tsx\""
      },
      {
        "language": "tsx",
        "code": "async function fetchData() {\r\n  const dbUrl = process.env.DATABASE_URL\r\n  // Use for server-side operations only\r\n  return await db.query(dbUrl, 'SELECT * FROM users')\r\n}\r\n\r\nexport default async function Page() {\r\n  const data = await fetchData()\r\n  return <div>{/* render data */}</div>\r\n}",
        "context": "filename=\"app/page.tsx\""
      },
      {
        "language": "bash",
        "code": "NEXT_PUBLIC_API_URL=\"/api\"",
        "context": "filename=\".env.local\""
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nexport default function ClientComponent() {\r\n  const apiUrl = process.env.NEXT_PUBLIC_API_URL\r\n  return <p>API URL: {apiUrl}</p>\r\n}",
        "context": "filename=\"app/components/client-component.tsx\""
      },
      {
        "language": "tsx",
        "code": "import { connection } from 'next/server'\r\n\r\nexport default async function Page() {\r\n  await connection()\r\n  const config = process.env.RUNTIME_CONFIG\r\n  return <p>{config}</p>\r\n}",
        "context": "filename=\"app/page.tsx\""
      },
      {
        "language": "js",
        "code": "// Next.js 15 - experimental.dynamicIO is now removed\r\nmodule.exports = {\r\n  experimental: {\r\n    dynamicIO: true,\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "// Next.js 16 - use cacheComponents instead\r\nmodule.exports = {\r\n  cacheComponents: true,\r\n}",
        "context": "filename=\"next.config.js\""
      }
    ],
    "content": "Upgrading from 15 to 16 Using AI Agents with Next.js DevTools MCP If you're using an AI coding assistant that supports the Model Context Protocol (MCP), you can use the Next.js DevTools MCP to automate the upgrade process and migration tasks. Setup Add the following configuration to your MCP client, example: For more information, visit the next-devtools-mcp package on npm to configure with your MCP client. > Note: Using next-devtools-mcp@latest ensures that your MCP client will always use the latest version of the Next.js DevTools MCP server. Example Prompts Once configured, you can use natural language prompts to upgrade your Next.js app: To upgrade to Next.js 16: Connect to your coding agent and then prompt: To migrate to Cache Components (after upgrading to v16): Connect to your coding agent and then prompt: Learn more in the documentation here. Using the Codemod To update to Next.js version 16, you can use the upgrade codemod: The codemod is able to: - Update next.config.js to use the new turbopack configuration - Migrate from next lint to the ESLint CLI - Migrate from deprecated middleware convention to proxy - Remove unstable prefix from stabilized APIs - Remove experimentalppr Route Segment Config from pages and layouts If you prefer to do it manually, install the latest Next.js and React versions: If you are using TypeScript, ensure you also upgrade @types/react and @types/react-dom to their latest versions. Node.js runtime and browser support | Requirement | Change / Details | | ------------- | ------------------------------------------------------------------ | | Node.js 20.9+ | Minimum version now 20.9.0 (LTS); Node.js 18 no longer supported | | TypeScript 5+ | Minimum version now 5.1.0 | | Browsers | Chrome 111+, Edge 111+, Firefox 111+, Safari 16.4+ | Turbopack by default Starting with Next.js 16, Turbopack is stable and used by default with next dev and next build Previously you had to enable Turbopack using --turbopack, or --turbo. This is no longer necessary. You can update your package.json scripts: If your project has a custom webpack configuration and you run next build (which now uses Turbopack by default), the build will fail to prevent misconfiguration issues. You have a few different ways to address this: - Use Turbopack anyway: Run with next build --turbopack to build using Turbopack and ignore your webpack config. - Switch to Turbopack fully: Migrate your webpack config to Turbopack-compatible options. - Keep using Webpack: Use the --webpack flag to opt out of Turbopack and build with Webpack. > Good to know: If you see failing builds because a webpack configuration was found, but you don't define one yourself, it is likely that a plugin is adding a webpack option Opting out of Turbopack If you need to continue using Webpack, you can opt out with the --webpack flag. For example, to use Turbopack in development but Webpack for production builds: We recommend using Turbopack for development and production. Submit a comment to this thread, if you are unable to switch to Turbopack. Turbopack configuration location The experimental.turbopack configuration is out of experimental. You can use it as a top-level turbopack option: Make sure to review the Turbopack configuration options. Next.js 16 introduces various improvements and new options, for example: - Advanced Webpack loader conditions - debugIds Resolve alias fallback In some projects, client-side code may import files containing Node.js native modules. This will cause Module not found: Can't resolve 'fs' type of errors. When this happens, you should refactor your code so that your client-side bundles do not reference these Node.js native modules. However, in some cases, this might not be possible. In Webpack the resolve.fallback option was typically used to silence the error. Turbopack offers a similar option, using turbopack.resolveAlias. In this case, tell Turbopack to load an empty module when fs is requested for the browser. It is preferable to refactor your modules so that client code doesn't ever import from modules using Node.js native modules. Sass nodemodules imports Turbopack fully supports importing Sass files from nodemodules. Note that while Webpack allowed the legacy tilde (~) prefix, Turbopack does not support this syntax. In Webpack: In Turbopack: If changing the imports is not possible, you can use turbopack.resolveAlias. For example: Turbopack File System Caching (beta) Turbopack now supports filesystem caching in development, storing compiler artifacts on disk between runs for significantly faster compile times across restarts. Enable filesystem caching in your configuration: Async Request APIs (Breaking change) Version 15 introduced Async Request APIs as a breaking change, with temporary synchronous compatibility. Starting with Next.js 16, synchronous access is fully removed. These APIs can only be accessed asynchronously. - cookies - headers - draftMode - params in layout.js, page.js, route.js, default.js, opengraph-image, twitter-image, icon, and apple-icon. - searchParams in page.js Use the codemod to migrate to async Dynamic APIs. Migrating types for async Dynamic APIs To help migrate to async params and searchParams, you can run npx next typegen to automatically generate these globally available types helpers: - PageProps - LayoutProps - RouteContext > Good to know: typegen was introduced in Next.js 15.5 This simplifies type-safe migration to the new async API pattern, and enables you to update your components with full type safety, for example: This approach gives you fully type-safe access to props.params, including the slug, and to searchParams, directly within your page. Async parameters for icon, and open-graph Image (Breaking change) > The props passed to the image generating functions in opengraph-image, twitter-image, icon, and apple-icon, are now Promises. In previous versions, both the Image (image generation function), and the generateImageMetadata received a params object. The id returned by generateImageMetadata was passed as a string to the image generation function. Starting with Next.js 16, to align with the Async Request APIs change, these are also asynchronous. React 19.2 The App Router in Next.js 16 uses the latest React Canary release, which includes the newly released React 19.2 features and other features being incrementally stabilized. Highlights include: - View Transitions: Animate elements that update inside a Transition or navigation - useEffectEvent: Extract non-reactive logic from Effects into reusable Effect Event functions - Activity: Render \"background activity\" by hiding UI with display: none while maintaining state and cleaning up Effects Learn more in the React 19.2 announcement. React Compiler Support Built-in support for the React Compiler is now stable in Next.js 16 following the React Compiler's 1.0 release. The React Compiler automatically memoizes components, reducing unnecessary re-renders with zero manual code changes. The reactCompiler configuration option has been promoted from experimental to stable. It is not enabled by default as we continue gathering build performance data across different application types. Install the latest version of the React Compiler plugin: > Good to know: Expect compile times in development and during builds to be higher when enabling this option as the React Compiler relies on Babel. Caching APIs revalidateTag revalidateTag has a new function signature. You can pass a cacheLife profile as the second argument. Use revalidateTag for content where a slight delay in updates is acceptable, such as blog posts, product catalogs, or documentation. Users receive stale content while fresh data loads in the background. updateTag updateTag is a new Server Actions-only API that provides read-your-writes semantics, where a user makes a change and the UI immediately shows the change, rather than stale data. It does this by expiring and immediately refreshing data within the same request. This ensures interactive features reflect changes immediately. Perfect for forms, user settings, and any workflow where users expect to see their updates instantly. Learn more about when to use updateTag or revalidateTag here. refresh refresh allows you to refresh the client router from within a Server Action. Use it when you need to refresh the client router after performing an action. cacheLife and cacheTag cacheLife and cacheTag are now stable. The unstable prefix is no longer needed. Wherever you had aliased imports like: You can update your imports to: Enhanced Routing and Navigation Next.js 16 includes a complete overhaul of the routing and navigation system, making page transitions leaner and faster. This optimizes how Next.js prefetches and caches navigation data: - Layout deduplication: When prefetching multiple URLs with a shared layout, the layout is downloaded once. - Incremental prefetching: Next.js only prefetches parts not already in cache, rather than entire pages. These changes require no code modifications and are designed to improve performance across all apps. However, you may see more individual prefetch requests with much lower total transfer sizes. We believe this is the right trade-off for nearly all applications. If the increased request count causes issues, please let us know by creating an issue or discussion item. Partial Pre-Rendering (PPR) Next.js 16 removes the experimental Partial Pre-Rendering (PPR) flag and configuration options, including the route level segment experimentalppr. Starting with Next.js 16, you can opt into PPR using the cacheComponents configuration. PPR in Next.js 16 works differently than in Next.js 15 canaries. If you are using PPR today, stay in the current Next.js 15 canary you are using. We will follow up with a guide to migrate to Cache Components. middleware to proxy The middleware filename is deprecated, and has been renamed to proxy to clarify network boundary and routing focus. The edge runtime is NOT supported in proxy. The proxy runtime is nodejs, and it cannot be configured. If you want to continue using the edge runtime, keep using middleware. We will follow up on a minor release with further edge runtime instructions. The named export middleware is also deprecated. Rename your function to proxy. We recommend changing the function name to proxy, even if you are using a default export. Configuration flags that contained the middleware name are also renamed. For example, skipMiddlewareUrlNormalize is now skipProxyUrlNormalize The version 16 codemod is able to update these flags too. next/image changes Local Images with Query Strings (Breaking change) Local image sources with query strings now require images.localPatterns.search configuration to prevent enumeration attacks. If you need to use query strings with local images, add the pattern to your configuration: minimumCacheTTL Default (Breaking change) The default value for images.minimumCacheTTL has changed from 60 seconds to 4 hours (14400 seconds). This reduces revalidation cost for images without cache-control headers. For some Next.js users, image revalidation was happening frequently, often because the upstream source images missed a cache-control header. This caused revalidation to happen every 60 seconds, which increased CPU usage and cost. Since most images do not change often, this short interval is not ideal. Setting the default to 4 hours offers a more durable cache by default, while still allowing images to update a few times per day if needed. If you need the previous behavior, change minimumCacheTTL to a lower value, for example back to 60 seconds: imageSizes Default (Breaking change) The value 16 has been removed from the default images.imageSizes array. We have looked at request analytics and found out that very few projects ever serve 16 pixels width images. Removing this setting reduces the size of the srcset attribute shipped to the browser by next/image. If you need to support 16px images: Rather than lack of developer usage, we believe 16 pixels width images have become less common, because devicePixelRatio: 2 actually fetches a 32px image to prevent blurriness in retina displays. qualities Default (Breaking change) The default value for images.qualities has changed from allowing all qualities to only [75]. If you need to support multiple quality levels: If you specify a quality prop not included in the image.qualities array, the quality will be coerced to the closest value in images.qualities. For example, given the configuration above, a quality prop of 80, is coerced to 75. Local IP Restriction (Breaking change) A new security restriction blocks local IP optimization by default. Set images.dangerouslyAllowLocalIP to true only for private networks. Maximum Redirects (Breaking change) The default for images.maximumRedirects has changed from unlimited to 3 redirects maximum. next/legacy/image Component (deprecated) The next/legacy/image component is deprecated. Use next/image instead: images.domains Configuration (deprecated) The images.domains config is deprecated. Use images.remotePatterns instead for improved security: Concurrent dev and build next dev and next build now use separate output directories, enabling concurrent execution. The next dev command outputs to .next/dev. This is the new default behavior, controlled by isolatedDevBuild. Additionally, a lockfile mechanism prevents multiple next dev or next build instances on the same project. Since the development server outputs to .next/dev, the Turbopack tracing command should be: Parallel Routes default.js requirement All parallel route slots now require explicit default.js files. Builds will fail without them. To maintain previous behavior, create a default.js file that calls notFound() or returns null. Or return null: ESLint Flat Config @next/eslint-plugin-next now defaults to ESLint Flat Config format, aligning with ESLint v10 which will drop legacy config support. Make sure to review our API reference for the @next/eslint-plugin-next plugin. If you're using the legacy .eslintrc format, consider migrating to the flat config format. See the ESLint migration guide for details. Scroll Behavior Override In previous versions of Next.js, if you had set scroll-behavior: smooth globally on your element via CSS, Next.js would override this during SPA route transitions, as follows: 1. Temporarily set scroll-behavior to auto 2. Perform the navigation (causing instant scroll to top) 3. Restore your original scroll-behavior value This ensured that page navigation always felt snappy and instant, even when you had smooth scrolling enabled for in-page navigation. However, this manipulation could be expensive, especially at the start of every navigation. In Next.js 16, this behavior has changed. By default, Next.js will no longer override your scroll-behavior setting during navigation. If you want Next.js to perform this override (the previous default behavior), add the data-scroll-behavior=\"smooth\" attribute to your element: Performance Improvements Significant performance optimizations for next dev and next start commands, along with improved terminal output with clearer formatting, better error messages, and improved performance metrics. Next.js 16 removes the size and First Load JS metrics from the next build output. We found these to be inaccurate in server-driven architectures using React Server Components. Both our Turbopack and Webpack implementations had issues, and disagreed on how to account for Client Components payload. The most effective way to measure actual route performance is through tools such as Chrome Lighthouse or Vercel Analytics, which focus on Core Web Vitals and downloaded resource sizes. next dev config load In previous versions the Next config file was loaded twice during development: - When running the next dev command - When the next dev command started the Next.js server This was inefficient because the next dev command doesn't need the config file to start the Next.js server. A consequence of this change is that, when running next dev checking if process.argv includes 'dev', in your Next.js config file, will return false. > Good to know: The typegen, and build commands, are still visible in process.argv. This is specially important for plugins that trigger side-effects on next dev. If that's the case, it might be enough to check if NODEENV is set to development. Alternatively, use the phase in which the configuration is loaded. Build Adapters API (alpha) Following the Build Adapters RFC, the first alpha version of the Build Adapters API is now available. Build Adapters allow you to create custom adapters that hook into the build process, enabling deployment platforms and custom build integrations to modify Next.js configuration or process build output. Share your feedback in the RFC discussion. Modern Sass API sass-loader has been bumped to v16, which supports modern Sass syntax and new features. Removals These features were previously deprecated and are now removed: AMP Support AMP adoption has declined significantly, and maintaining this feature adds complexity to the framework. All AMP APIs and configurations have been removed: - amp configuration from your Next config file - next/amp hook imports and usage (useAmp) - export const config = { amp: true } from pages Evaluate if AMP is still necessary for your use case. Most performance benefits can now be achieved through Next.js's built-in optimizations and modern web standards. next lint Command The next lint command has been removed. Use Biome or ESLint directly. next build no longer runs linting. A codemod is available to automate migration: The eslint option in the Next.js config file is also removed. Runtime Configuration serverRuntimeConfig and publicRuntimeConfig have been removed. Use environment variables instead. Before (Next.js 15): After (Next.js 16): For server-only values, access environment variables directly in Server Components: > Good to know: Use the taint API to prevent accidentally passing sensitive server values to Client Components. For client-accessible values, use the NEXTPUBLIC prefix: To ensure environment variables are read at runtime (not bundled at build time), use the connection() function before reading from process.env: Learn more about environment variables. devIndicators Options The following options have been removed from devIndicators: - appIsrStatus - buildActivity - buildActivityPosition The indicator itself remains available. experimental.dynamicIO The experimental.dynamicIO flag has been renamed to cacheComponents: Update your Next config file, by removing the dynamicIO flag. Add the cacheComponents flag set to true. unstablerootParams The unstablerootParams function has been removed. We are working on an alternative API that we will ship in an upcoming minor release.",
    "excerpt": "Upgrading from 15 to 16 Using AI Agents with Next.js DevTools MCP If you're using an AI coding assistant that supports the Model Context Protocol (MCP), you can use the Next.js DevTools MCP to automat...",
    "url": "https://nextjs.org/docs/01-app/02-guides/upgrading/version-16"
  },
  {
    "id": "01-app-02-guides-videos",
    "path": "01-app\\02-guides\\videos.mdx",
    "title": "How to use and optimize videos",
    "description": "Recommendations and best practices for optimizing videos in your Next.js application.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Using  and ",
        "slug": "using-and-"
      },
      {
        "level": 3,
        "text": "Common  tag attributes",
        "slug": "common-tag-attributes"
      },
      {
        "level": 3,
        "text": "Video best practices",
        "slug": "video-best-practices"
      },
      {
        "level": 3,
        "text": "Common  tag attributes",
        "slug": "common-tag-attributes"
      },
      {
        "level": 3,
        "text": "Choosing a video embedding method",
        "slug": "choosing-a-video-embedding-method"
      },
      {
        "level": 3,
        "text": "Embedding externally hosted videos",
        "slug": "embedding-externally-hosted-videos"
      },
      {
        "level": 2,
        "text": "Self-hosted videos",
        "slug": "self-hosted-videos"
      },
      {
        "level": 3,
        "text": "Using Vercel Blob for video hosting",
        "slug": "using-vercel-blob-for-video-hosting"
      },
      {
        "level": 3,
        "text": "Adding subtitles to your video",
        "slug": "adding-subtitles-to-your-video"
      },
      {
        "level": 2,
        "text": "Resources",
        "slug": "resources"
      },
      {
        "level": 3,
        "text": "Open source  component",
        "slug": "open-source-component"
      },
      {
        "level": 3,
        "text": "Cloudinary Integration",
        "slug": "cloudinary-integration"
      },
      {
        "level": 3,
        "text": "Mux Video API",
        "slug": "mux-video-api"
      },
      {
        "level": 3,
        "text": "Fastly",
        "slug": "fastly"
      },
      {
        "level": 3,
        "text": "ImageKit.io Integration",
        "slug": "imagekitio-integration"
      }
    ],
    "codeBlocks": [
      {
        "language": "jsx",
        "code": "export function Video() {\r\n  return (\r\n    <video width=\"320\" height=\"240\" controls preload=\"none\">\r\n      <source src=\"/path/to/video.mp4\" type=\"video/mp4\" />\r\n      <track\r\n        src=\"/path/to/captions.vtt\"\r\n        kind=\"subtitles\"\r\n        srcLang=\"en\"\r\n        label=\"English\"\r\n      />\r\n      Your browser does not support the video tag.\r\n    </video>\r\n  )\r\n}",
        "context": "filename=\"app/ui/video.jsx\""
      },
      {
        "language": "jsx",
        "code": "export default function Page() {\r\n  return (\r\n    <iframe src=\"https://www.youtube.com/embed/19g66ezsKAg\" allowFullScreen />\r\n  )\r\n}",
        "context": "filename=\"app/page.jsx\""
      },
      {
        "language": "jsx",
        "code": "export default async function VideoComponent() {\r\n  const src = await getVideoSrc()\r\n\r\n  return <iframe src={src} allowFullScreen />\r\n}",
        "context": "filename=\"app/ui/video-component.jsx\""
      },
      {
        "language": "jsx",
        "code": "import { Suspense } from 'react'\r\nimport VideoComponent from '../ui/VideoComponent.jsx'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <section>\r\n      <Suspense fallback={<p>Loading video...</p>}>\r\n        <VideoComponent />\r\n      </Suspense>\r\n      {/* Other content of the page */}\r\n    </section>\r\n  )\r\n}",
        "context": "filename=\"app/page.jsx\""
      },
      {
        "language": "jsx",
        "code": "import { Suspense } from 'react'\r\nimport VideoComponent from '../ui/VideoComponent.jsx'\r\nimport VideoSkeleton from '../ui/VideoSkeleton.jsx'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <section>\r\n      <Suspense fallback={<VideoSkeleton />}>\r\n        <VideoComponent />\r\n      </Suspense>\r\n      {/* Other content of the page */}\r\n    </section>\r\n  )\r\n}",
        "context": "filename=\"app/page.jsx\""
      },
      {
        "language": "jsx",
        "code": "import { Suspense } from 'react'\r\nimport { list } from '@vercel/blob'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <Suspense fallback={<p>Loading video...</p>}>\r\n      <VideoComponent fileName=\"my-video.mp4\" />\r\n    </Suspense>\r\n  )\r\n}\r\n\r\nasync function VideoComponent({ fileName }) {\r\n  const { blobs } = await list({\r\n    prefix: fileName,\r\n    limit: 1,\r\n  })\r\n  const { url } = blobs[0]\r\n\r\n  return (\r\n    <video controls preload=\"none\" aria-label=\"Video player\">\r\n      <source src={url} type=\"video/mp4\" />\r\n      Your browser does not support the video tag.\r\n    </video>\r\n  )\r\n}",
        "context": "filename=\"app/page.jsx\""
      },
      {
        "language": "jsx",
        "code": "async function VideoComponent({ fileName }) {\r\n  const { blobs } = await list({\r\n    prefix: fileName,\r\n    limit: 2,\r\n  })\r\n  const { url } = blobs[0]\r\n  const { url: captionsUrl } = blobs[1]\r\n\r\n  return (\r\n    <video controls preload=\"none\" aria-label=\"Video player\">\r\n      <source src={url} type=\"video/mp4\" />\r\n      <track src={captionsUrl} kind=\"subtitles\" srcLang=\"en\" label=\"English\" />\r\n      Your browser does not support the video tag.\r\n    </video>\r\n  )\r\n}",
        "context": "filename=\"app/page.jsx\""
      }
    ],
    "content": "This page outlines how to use videos with Next.js applications, showing how to store and display video files without affecting performance. Using and Videos can be embedded on the page using the HTML tag for direct video files and for external platform-hosted videos. The HTML tag can embed self-hosted or directly served video content, allowing full control over the playback and appearance. Common tag attributes | Attribute | Description | Example Value | | ------------- | --------------------------------------------------------------------------------------------------------- | ------------------------------------ | | src | Specifies the source of the video file. | | | width | Sets the width of the video player. | | | height | Sets the height of the video player. | | | controls | If present, it displays the default set of playback controls. | | | autoPlay | Automatically starts playing the video when the page loads. Note: Autoplay policies vary across browsers. | | | loop | Loops the video playback. | | | muted | Mutes the audio by default. Often used with autoPlay. | | | preload | Specifies how the video is preloaded. Values: none, metadata, auto. | | | playsInline | Enables inline playback on iOS devices, often necessary for autoplay to work on iOS Safari. | | > Good to know: When using the autoPlay attribute, it is important to also include the muted attribute to ensure the video plays automatically in most browsers and the playsInline attribute for compatibility with iOS devices. For a comprehensive list of video attributes, refer to the MDN documentation. Video best practices - Fallback Content: When using the tag, include fallback content inside the tag for browsers that do not support video playback. - Subtitles or Captions: Include subtitles or captions for users who are deaf or hard of hearing. Utilize the tag with your elements to specify caption file sources. - Accessible Controls: Standard HTML5 video controls are recommended for keyboard navigation and screen reader compatibility. For advanced needs, consider third-party players like react-player or video.js, which offer accessible controls and consistent browser experience. The HTML tag allows you to embed videos from external platforms like YouTube or Vimeo. Common tag attributes | Attribute | Description | Example Value | | ----------------- | ---------------------------------------------------------------------- | -------------------------------------- | | src | The URL of the page to embed. | | | width | Sets the width of the iframe. | | | height | Sets the height of the iframe. | | | allowFullScreen | Allows the iframe content to be displayed in full-screen mode. | | | sandbox | Enables an extra set of restrictions on the content within the iframe. | | | loading | Optimize loading behavior (e.g., lazy loading). | | | title | Provides a title for the iframe to support accessibility. | | For a comprehensive list of iframe attributes, refer to the MDN documentation. Choosing a video embedding method There are two ways you can embed videos in your Next.js application: - Self-hosted or direct video files: Embed self-hosted videos using the tag for scenarios requiring detailed control over the player's functionality and appearance. This integration method within Next.js allows for customization and control of your video content. - Using video hosting services (YouTube, Vimeo, etc.): For video hosting services like YouTube or Vimeo, you'll embed their iframe-based players using the tag. While this method limits some control over the player, it offers ease of use and features provided by these platforms. Choose the embedding method that aligns with your application's requirements and the user experience you aim to deliver. Embedding externally hosted videos To embed videos from external platforms, you can use Next.js to fetch the video information and React Suspense to handle the fallback state while loading. 1. Create a Server Component for video embedding The first step is to create a Server Component that generates the appropriate iframe for embedding the video. This component will fetch the source URL for the video and render the iframe. 2. Stream the video component using React Suspense After creating the Server Component to embed the video, the next step is to stream the component using React Suspense. > Good to know: When embedding videos from external platforms, consider the following best practices: > > - Ensure the video embeds are responsive. Use CSS to make the iframe or video player adapt to different screen sizes. > - Implement strategies for loading videos based on network conditions, especially for users with limited data plans. This approach results in a better user experience as it prevents the page from blocking, meaning the user can interact with the page while the video component streams in. For a more engaging and informative loading experience, consider using a loading skeleton as the fallback UI. So instead of showing a simple loading message, you can show a skeleton that resembles the video player like this: Self-hosted videos Self-hosting videos may be preferable for several reasons: - Complete control and independence: Self-hosting gives you direct management over your video content, from playback to appearance, ensuring full ownership and control, free from external platform constraints. - Customization for specific needs: Ideal for unique requirements, like dynamic background videos, it allows for tailored customization to align with design and functional needs. - Performance and scalability considerations: Choose storage solutions that are both high-performing and scalable, to support increasing traffic and content size effectively. - Cost and integration: Balance the costs of storage and bandwidth with the need for easy integration into your Next.js framework and broader tech ecosystem. Using Vercel Blob for video hosting Vercel Blob offers an efficient way to host videos, providing a scalable cloud storage solution that works well with Next.js. Here's how you can host a video using Vercel Blob: 1. Uploading a video to Vercel Blob In your Vercel dashboard, navigate to the \"Storage\" tab and select your Vercel Blob store. In the Blob table's upper-right corner, find and click the \"Upload\" button. Then, choose the video file you wish to upload. After the upload completes, the video file will appear in the Blob table. Alternatively, you can upload your video using a server action. For detailed instructions, refer to the Vercel documentation on server-side uploads. Vercel also supports client-side uploads. This method may be preferable for certain use cases. 2. Displaying the video in Next.js Once the video is uploaded and stored, you can display it in your Next.js application. Here's an example of how to do this using the tag and React Suspense: In this approach, the page uses the video's @vercel/blob URL to display the video using the VideoComponent. React Suspense is used to show a fallback until the video URL is fetched and the video is ready to be displayed. Adding subtitles to your video If you have subtitles for your video, you can easily add them using the element inside your tag. You can fetch the subtitle file from Vercel Blob in a similar way as the video file. Here's how you can update the to include subtitles. By following this approach, you can effectively self-host and integrate videos into your Next.js applications. Resources To continue learning more about video optimization and best practices, please refer to the following resources: - Understanding video formats and codecs: Choose the right format and codec, like MP4 for compatibility or WebM for web optimization, for your video needs. For more details, see Mozilla's guide on video codecs. - Video compression: Use tools like FFmpeg to effectively compress videos, balancing quality with file size. Learn about compression techniques at FFmpeg's official website. - Resolution and bitrate adjustment: Adjust resolution and bitrate based on the viewing platform, with lower settings for mobile devices. - Content Delivery Networks (CDNs): Utilize a CDN to enhance video delivery speed and manage high traffic. When using some storage solutions, such as Vercel Blob, CDN functionality is automatically handled for you. Learn more about CDNs and their benefits. Explore these video streaming platforms for integrating video into your Next.js projects: Open source next-video component - Provides a component for Next.js, compatible with various hosting services including Vercel Blob, S3, Backblaze, and Mux. - Detailed documentation for using next-video.dev with different hosting services. Cloudinary Integration - Official documentation and integration guide for using Cloudinary with Next.js. - Includes a component for drop-in video support. - Find examples of integrating Cloudinary with Next.js including Adaptive Bitrate Streaming. - Other Cloudinary libraries including a Node.js SDK are also available. Mux Video API - Mux provides a starter template for creating a video course with Mux and Next.js. - Learn about Mux's recommendations for embedding high-performance video for your Next.js application. - Explore an example project demonstrating Mux with Next.js. Fastly - Learn more about integrating Fastly's solutions for video on demand and streaming media into Next.js. ImageKit.io Integration - Check out the official quick start guide for integrating ImageKit with Next.js. - The integration provides an component, offering seamless video support. - You can also explore other ImageKit libraries, such as the Node.js SDK, which is also available.",
    "excerpt": "This page outlines how to use videos with Next.js applications, showing how to store and display video files without affecting performance. Using and Videos can be embedded on the page using the HTML...",
    "url": "https://nextjs.org/docs/01-app/02-guides/videos"
  },
  {
    "id": "01-app-03-api-reference-01-directives-index",
    "path": "01-app\\03-api-reference\\01-directives\\index.mdx",
    "title": "Directives",
    "description": "Directives are used to modify the behavior of your Next.js application.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "The following directives are available:",
    "excerpt": "The following directives are available:",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/01-directives"
  },
  {
    "id": "01-app-03-api-reference-01-directives-use-cache-private",
    "path": "01-app\\03-api-reference\\01-directives\\use-cache-private.mdx",
    "title": "use cache: private",
    "description": "Learn how to use the `\"use cache: private\"` directive to enable runtime prefetching of personalized content in your Next.js application.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Usage",
        "slug": "usage"
      },
      {
        "level": 3,
        "text": "Basic example",
        "slug": "basic-example"
      },
      {
        "level": 2,
        "text": "Request APIs allowed in private caches",
        "slug": "request-apis-allowed-in-private-caches"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  cacheComponents: true,\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "jsx",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  cacheComponents: true,\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { Suspense } from 'react'\r\nimport { cookies } from 'next/headers'\r\nimport { cacheLife, cacheTag } from 'next/cache'\r\n\r\nexport default async function ProductPage({\r\n  params,\r\n}: {\r\n  params: Promise<{ id: string }>\r\n}) {\r\n  const { id } = await params\r\n\r\n  return (\r\n    <div>\r\n      <ProductDetails id={id} />\r\n      <Suspense fallback={<div>Loading recommendations...</div>}>\r\n        <Recommendations productId={id} />\r\n      </Suspense>\r\n    </div>\r\n  )\r\n}\r\n\r\nasync function Recommendations({ productId }: { productId: string }) {\r\n  const recommendations = await getRecommendations(productId)\r\n\r\n  return (\r\n    <div>\r\n      {recommendations.map((rec) => (\r\n        <ProductCard key={rec.id} product={rec} />\r\n      ))}\r\n    </div>\r\n  )\r\n}\r\n\r\nasync function getRecommendations(productId: string) {\r\n  'use cache: private'\r\n  cacheTag(`recommendations-${productId}`)\r\n  cacheLife({ stale: 60 }) // Minimum 30 seconds required for runtime prefetch\r\n\r\n  // Access cookies within private cache functions\r\n  const sessionId = (await cookies()).get('session-id')?.value || 'guest'\r\n\r\n  return getPersonalizedRecommendations(productId, sessionId)\r\n}",
        "context": "filename=\"app/product/[id]/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { Suspense } from 'react'\r\nimport { cookies } from 'next/headers'\r\nimport { cacheLife, cacheTag } from 'next/cache'\r\n\r\nexport default async function ProductPage({ params }) {\r\n  const { id } = await params\r\n\r\n  return (\r\n    <div>\r\n      <ProductDetails id={id} />\r\n      <Suspense fallback={<div>Loading recommendations...</div>}>\r\n        <Recommendations productId={id} />\r\n      </Suspense>\r\n    </div>\r\n  )\r\n}\r\n\r\nasync function Recommendations({ productId }) {\r\n  const recommendations = await getRecommendations(productId)\r\n\r\n  return (\r\n    <div>\r\n      {recommendations.map((rec) => (\r\n        <ProductCard key={rec.id} product={rec} />\r\n      ))}\r\n    </div>\r\n  )\r\n}\r\n\r\nasync function getRecommendations(productId) {\r\n  'use cache: private'\r\n  cacheTag(`recommendations-${productId}`)\r\n  cacheLife({ stale: 60 }) // Minimum 30 seconds required for runtime prefetch\r\n\r\n  // Access cookies within private cache functions\r\n  const sessionId = (await cookies()).get('session-id')?.value || 'guest'\r\n\r\n  return getPersonalizedRecommendations(productId, sessionId)\r\n}",
        "context": "filename=\"app/product/[id]/page.js\" switcher"
      }
    ],
    "content": "The 'use cache: private' directive works just like use cache, but allows you to use runtime APIs like cookies, headers, or search params. > Good to know: Unlike use cache, private caches are not prerendered statically as they contain personalized data that is not shared between users. Usage To use 'use cache: private', enable the cacheComponents flag in your next.config.ts file: Then add 'use cache: private' to your function along with a cacheLife configuration. Basic example Request APIs allowed in private caches The following request-specific APIs can be used inside 'use cache: private' functions: | API | Allowed in use cache | Allowed in 'use cache: private' | | -------------- | ---------------------- | --------------------------------- | | cookies() | No | Yes | | headers() | No | Yes | | searchParams | No | Yes | | connection() | No | No | > Note: The connection() API is prohibited in both use cache and 'use cache: private' as it provides connection-specific information that cannot be safely cached. Version History | Version | Changes | | --------- | -------------------------------------------------------------------- | | v16.0.0 | \"use cache: private\" is enabled with the Cache Components feature. |",
    "excerpt": "The 'use cache: private' directive works just like use cache, but allows you to use runtime APIs like cookies, headers, or search params. > Good to know: Unlike use cache, private caches are not prere...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/01-directives/use-cache-private"
  },
  {
    "id": "01-app-03-api-reference-01-directives-use-cache-remote",
    "path": "01-app\\03-api-reference\\01-directives\\use-cache-remote.mdx",
    "title": "use cache: remote",
    "description": "Learn how to use the `\"use cache: remote\"` directive to enable caching in dynamic contexts in your Next.js application.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Usage",
        "slug": "usage"
      },
      {
        "level": 3,
        "text": "Basic example",
        "slug": "basic-example"
      },
      {
        "level": 2,
        "text": "How  differs from  and ",
        "slug": "how-differs-from-and-"
      },
      {
        "level": 3,
        "text": "When to use each directive",
        "slug": "when-to-use-each-directive"
      },
      {
        "level": 2,
        "text": "How it works",
        "slug": "how-it-works"
      },
      {
        "level": 3,
        "text": "Dynamic context detection",
        "slug": "dynamic-context-detection"
      },
      {
        "level": 3,
        "text": "Storage behavior",
        "slug": "storage-behavior"
      },
      {
        "level": 3,
        "text": "Dynamic context example",
        "slug": "dynamic-context-example"
      },
      {
        "level": 2,
        "text": "Request APIs and remote caches",
        "slug": "request-apis-and-remote-caches"
      },
      {
        "level": 2,
        "text": "Nesting rules",
        "slug": "nesting-rules"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Per-request database queries",
        "slug": "per-request-database-queries"
      },
      {
        "level": 3,
        "text": "API responses in streaming contexts",
        "slug": "api-responses-in-streaming-contexts"
      },
      {
        "level": 3,
        "text": "Computed data after dynamic checks",
        "slug": "computed-data-after-dynamic-checks"
      },
      {
        "level": 3,
        "text": "Mixed caching strategies",
        "slug": "mixed-caching-strategies"
      },
      {
        "level": 2,
        "text": "Platform Support",
        "slug": "platform-support"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  cacheComponents: true,\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  cacheComponents: true,\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { Suspense } from 'react'\r\nimport { connection } from 'next/server'\r\nimport { cacheTag, cacheLife } from 'next/cache'\r\n\r\nexport default async function ProductPage({\r\n  params,\r\n}: {\r\n  params: Promise<{ id: string }>\r\n}) {\r\n  const { id } = await params\r\n\r\n  return (\r\n    <div>\r\n      <ProductDetails id={id} />\r\n      <Suspense fallback={<div>Loading price...</div>}>\r\n        <ProductPrice productId={id} />\r\n      </Suspense>\r\n    </div>\r\n  )\r\n}\r\n\r\nfunction ProductDetails({ id }: { id: string }) {\r\n  return <div>Product: {id}</div>\r\n}\r\n\r\nasync function ProductPrice({ productId }: { productId: string }) {\r\n  // Calling connection() makes this component dynamic, preventing\r\n  // it from being included in the static shell. This ensures the price\r\n  // is always fetched at request time.\r\n  await connection()\r\n\r\n  // Now we can cache the price in a remote cache handler.\r\n  // Regular 'use cache' would NOT work here because we're in a dynamic context.\r\n  const price = await getProductPrice(productId)\r\n\r\n  return <div>Price: ${price}</div>\r\n}\r\n\r\nasync function getProductPrice(productId: string) {\r\n  'use cache: remote'\r\n  cacheTag(`product-price-${productId}`)\r\n  cacheLife({ expire: 3600 }) // 1 hour\r\n\r\n  // This database query is cached and shared across all users\r\n  return db.products.getPrice(productId)\r\n}",
        "context": "filename=\"app/product/[id]/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { Suspense } from 'react'\r\nimport { connection } from 'next/server'\r\nimport { cacheTag, cacheLife } from 'next/cache'\r\n\r\nexport default async function ProductPage({ params }) {\r\n  const { id } = await params\r\n\r\n  return (\r\n    <div>\r\n      <ProductDetails id={id} />\r\n      <Suspense fallback={<div>Loading price...</div>}>\r\n        <ProductPrice productId={id} />\r\n      </Suspense>\r\n    </div>\r\n  )\r\n}\r\n\r\nfunction ProductDetails({ id }) {\r\n  return <div>Product: {id}</div>\r\n}\r\n\r\nasync function ProductPrice({ productId }) {\r\n  // Calling connection() makes this component dynamic, preventing\r\n  // it from being included in the static shell. This ensures the price\r\n  // is always fetched at request time.\r\n  await connection()\r\n\r\n  // Now we can cache the price in a remote cache handler.\r\n  // Regular 'use cache' would NOT work here because we're in a dynamic context.\r\n  const price = await getProductPrice(productId)\r\n\r\n  return <div>Price: ${price}</div>\r\n}\r\n\r\nasync function getProductPrice(productId) {\r\n  'use cache: remote'\r\n  cacheTag(`product-price-${productId}`)\r\n  cacheLife({ expire: 3600 }) // 1 hour\r\n\r\n  // This database query is cached and shared across all users\r\n  return db.products.getPrice(productId)\r\n}",
        "context": "filename=\"app/product/[id]/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "async function UserDashboard() {\r\n  // Calling connection() makes the context dynamic\r\n  await connection()\r\n\r\n  // Without any caching directive, this runs on every request\r\n  const stats = await getStats()\r\n\r\n  // With 'use cache: remote', this is cached in the remote handler\r\n  const analytics = await getAnalytics()\r\n\r\n  return (\r\n    <div>\r\n      <Stats data={stats} />\r\n      <Analytics data={analytics} />\r\n    </div>\r\n  )\r\n}\r\n\r\nasync function getAnalytics() {\r\n  'use cache: remote'\r\n  cacheLife({ expire: 300 }) // 5 minutes\r\n\r\n  // This expensive operation is cached and shared across all requests\r\n  return fetchAnalyticsData()\r\n}",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "// VALID: Remote inside remote\r\nasync function outerRemote() {\r\n  'use cache: remote'\r\n  const result = await innerRemote()\r\n  return result\r\n}\r\n\r\nasync function innerRemote() {\r\n  'use cache: remote'\r\n  return getData()\r\n}\r\n\r\n// VALID: Remote inside regular cache\r\nasync function outerCache() {\r\n  'use cache'\r\n  // If this is in a dynamic context, the inner remote cache will work\r\n  const result = await innerRemote()\r\n  return result\r\n}\r\n\r\nasync function innerRemote() {\r\n  'use cache: remote'\r\n  return getData()\r\n}\r\n\r\n// INVALID: Remote inside private\r\nasync function outerPrivate() {\r\n  'use cache: private'\r\n  const result = await innerRemote() // Error!\r\n  return result\r\n}\r\n\r\nasync function innerRemote() {\r\n  'use cache: remote'\r\n  return getData()\r\n}\r\n\r\n// INVALID: Private inside remote\r\nasync function outerRemote() {\r\n  'use cache: remote'\r\n  const result = await innerPrivate() // Error!\r\n  return result\r\n}\r\n\r\nasync function innerPrivate() {\r\n  'use cache: private'\r\n  return getData()\r\n}",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "import { connection } from 'next/server'\r\nimport { cacheLife, cacheTag } from 'next/cache'\r\n\r\nexport default async function DashboardPage() {\r\n  // Make context dynamic\r\n  await connection()\r\n\r\n  const stats = await getGlobalStats()\r\n\r\n  return <StatsDisplay stats={stats} />\r\n}\r\n\r\nasync function getGlobalStats() {\r\n  'use cache: remote'\r\n  cacheTag('global-stats')\r\n  cacheLife({ expire: 60 }) // 1 minute\r\n\r\n  // This expensive database query is cached and shared across all users,\r\n  // reducing load on your database\r\n  const stats = await db.analytics.aggregate({\r\n    total_users: 'count',\r\n    active_sessions: 'count',\r\n    revenue: 'sum',\r\n  })\r\n\r\n  return stats\r\n}",
        "context": "filename=\"app/dashboard/page.tsx\""
      },
      {
        "language": "tsx",
        "code": "import { Suspense } from 'react'\r\nimport { connection } from 'next/server'\r\nimport { cacheLife, cacheTag } from 'next/cache'\r\n\r\nexport default async function FeedPage() {\r\n  return (\r\n    <div>\r\n      <Suspense fallback={<Skeleton />}>\r\n        <FeedItems />\r\n      </Suspense>\r\n    </div>\r\n  )\r\n}\r\n\r\nasync function FeedItems() {\r\n  // Dynamic context\r\n  await connection()\r\n\r\n  const items = await getFeedItems()\r\n\r\n  return items.map((item) => <FeedItem key={item.id} item={item} />)\r\n}\r\n\r\nasync function getFeedItems() {\r\n  'use cache: remote'\r\n  cacheTag('feed-items')\r\n  cacheLife({ expire: 120 }) // 2 minutes\r\n\r\n  // This API call is cached, reducing requests to your external service\r\n  const response = await fetch('https://api.example.com/feed')\r\n  return response.json()\r\n}",
        "context": "filename=\"app/feed/page.tsx\""
      },
      {
        "language": "tsx",
        "code": "import { connection } from 'next/server'\r\nimport { cacheLife } from 'next/cache'\r\n\r\nexport default async function ReportsPage() {\r\n  // Dynamic security check\r\n  await connection()\r\n\r\n  const report = await generateReport()\r\n\r\n  return <ReportViewer report={report} />\r\n}\r\n\r\nasync function generateReport() {\r\n  'use cache: remote'\r\n  cacheLife({ expire: 3600 }) // 1 hour\r\n\r\n  // This expensive computation is cached and shared across all authorized users,\r\n  // avoiding repeated calculations\r\n  const data = await db.transactions.findMany()\r\n\r\n  return {\r\n    totalRevenue: calculateRevenue(data),\r\n    topProducts: analyzeProducts(data),\r\n    trends: calculateTrends(data),\r\n  }\r\n}",
        "context": "filename=\"app/reports/page.tsx\""
      },
      {
        "language": "tsx",
        "code": "import { Suspense } from 'react'\r\nimport { connection } from 'next/server'\r\nimport { cookies } from 'next/headers'\r\nimport { cacheLife, cacheTag } from 'next/cache'\r\n\r\n// Static product data - prerendered at build time\r\nasync function getProduct(id: string) {\r\n  'use cache'\r\n  cacheTag(`product-${id}`)\r\n\r\n  // This is cached at build time and shared across all users\r\n  return db.products.find({ where: { id } })\r\n}\r\n\r\n// Shared pricing data - cached at runtime in remote handler\r\nasync function getProductPrice(id: string) {\r\n  'use cache: remote'\r\n  cacheTag(`product-price-${id}`)\r\n  cacheLife({ expire: 300 }) // 5 minutes\r\n\r\n  // This is cached at runtime and shared across all users\r\n  return db.products.getPrice({ where: { id } })\r\n}\r\n\r\n// User-specific recommendations - private cache per user\r\nasync function getRecommendations(productId: string) {\r\n  'use cache: private'\r\n  cacheLife({ expire: 60 }) // 1 minute\r\n\r\n  const sessionId = (await cookies()).get('session-id')?.value\r\n\r\n  // This is cached per-user and never shared\r\n  return db.recommendations.findMany({\r\n    where: { productId, sessionId },\r\n  })\r\n}\r\n\r\nexport default async function ProductPage({ params }) {\r\n  const { id } = await params\r\n\r\n  // Static product data\r\n  const product = await getProduct(id)\r\n\r\n  return (\r\n    <div>\r\n      <ProductDetails product={product} />\r\n\r\n      {/* Dynamic shared price */}\r\n      <Suspense fallback={<PriceSkeleton />}>\r\n        <ProductPriceComponent productId={id} />\r\n      </Suspense>\r\n\r\n      {/* Dynamic personalized recommendations */}\r\n      <Suspense fallback={<RecommendationsSkeleton />}>\r\n        <ProductRecommendations productId={id} />\r\n      </Suspense>\r\n    </div>\r\n  )\r\n}\r\n\r\nfunction ProductDetails({ product }) {\r\n  return (\r\n    <div>\r\n      <h1>{product.name}</h1>\r\n      <p>{product.description}</p>\r\n    </div>\r\n  )\r\n}\r\n\r\nasync function ProductPriceComponent({ productId }) {\r\n  // Make this component dynamic\r\n  await connection()\r\n\r\n  const price = await getProductPrice(productId)\r\n  return <div>Price: ${price}</div>\r\n}\r\n\r\nasync function ProductRecommendations({ productId }) {\r\n  const recommendations = await getRecommendations(productId)\r\n  return <RecommendationsList items={recommendations} />\r\n}\r\n\r\nfunction PriceSkeleton() {\r\n  return <div>Loading price...</div>\r\n}\r\n\r\nfunction RecommendationsSkeleton() {\r\n  return <div>Loading recommendations...</div>\r\n}\r\n\r\nfunction RecommendationsList({ items }) {\r\n  return (\r\n    <ul>\r\n      {items.map((item) => (\r\n        <li key={item.id}>{item.name}</li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}",
        "context": "filename=\"app/product/[id]/page.tsx\""
      }
    ],
    "content": "The 'use cache: remote' directive enables caching of shared data in dynamic contexts where regular use cache would not work, for example after calling await connection(), await cookies() or await headers(). > Good to know: > > - Results are stored in server-side cache handlers and shared across all users. > - For user-specific data that depends on await cookies() or await headers(), use 'use cache: private' instead. Usage To use 'use cache: remote', enable the cacheComponents flag in your next.config.ts file: Then add 'use cache: remote' to your function that needs to cache data in a dynamic context. Basic example Cache product pricing that needs to be fetched at request time but can be shared across all users. Use cacheLife to set the cache lifetime of the price. > Note: Regular use cache will not cache anything when used in a dynamic context (after await connection(), await cookies(), await headers(), etc.). Use 'use cache: remote' to enable runtime caching in these scenarios. How use cache: remote differs from use cache and use cache: private Next.js provides three caching directives, each designed for different use cases: | Feature | use cache | 'use cache: remote' | 'use cache: private' | | -------------------------------- | ----------------------------------- | --------------------------------------------------------- | ----------------------------------- | | Works in dynamic context | No (requires static context) | Yes (designed for dynamic contexts) | Yes | | Access to await cookies() | No | No | Yes | | Access to await headers() | No | No | Yes | | After await connection() | No (won't cache) | No | No | | Stored in cache handler | Yes (server-side) | Yes (server-side) | No (client-side only) | | Cache scope | Global (shared) | Global (shared) | Per-user (isolated) | | Supports runtime prefetching | N/A (pre-rendered at build) | No | Yes (when configured) | | Use case | Static, shared content (build-time) | Dynamic, shared content in runtime contexts (per-request) | Personalized, user-specific content | > Note: While you can't call await cookies() or await headers() inside 'use cache: remote', you can read the values before calling a function that is wrapped by 'use cache: remote' and the arguments will be included in the cache key. Note that this is not recommended as it will dramatically increase the cache size and reduce the cache hit rate. When to use each directive Choose the right caching directive based on your use case: Use use cache when: - Content can be prerendered at build time - Content is shared across all users - Content doesn't depend on request-specific data Use 'use cache: remote' when: - You need caching within dynamic context - Content is shared across users but must be rendered per-request (after await connection()) - You want to cache expensive operations in a server-side cache handler Use 'use cache: private' when: - Content is personalized per-user (depends on cookies, headers) - You need runtime prefetching of user-specific content - Content should never be shared between users How it works The 'use cache: remote' directive enables runtime caching of shared data in dynamic contexts by storing results in server-side cache handlers rather than prerendering at build time. Dynamic context detection When Next.js encounters certain APIs like connection(), cookies(), or headers(), the context becomes \"dynamic\". In a dynamic context: 1. Regular use cache stops working - it won't cache anything 2. 'use cache: remote' continues to work - it is cached by a remote cache handler. 3. Results are stored server-side in a key-value store configured for your deployment 4. Cached data is shared across requests - reducing database load and origin requests > Good to know: Without 'use cache: remote', functions in dynamic contexts would execute on every request, potentially creating performance bottlenecks. Remote caching eliminates this issue by storing results in server-side cache handlers. Storage behavior Remote caches are persisted using server-side cache handlers, which may include: - Distributed key-value stores (in-memory or persistent storage solutions) - File system or in-memory storage (often used in development or for custom deployments) - Environment-specific caches (provided by your hosting infrastructure) - Custom or configured cache handlers (depending on your application's setup) This means: 1. Cached data is shared across all users and requests 2. Cache entries persist beyond a single session 3. Cache invalidation works via cacheTag and revalidateTag 4. Cache expiration is controlled by cacheLife configuration Dynamic context example Request APIs and remote caches While 'use cache: remote' technically allows access to request-specific data by calling API's like cookies() and headers() before calling a function that is wrapped by 'use cache: remote', it's generally not recommended to use them together: | API | Allowed in use cache | Allowed in 'use cache: remote' | Recommended | | ------------------------------------------------------------------------------------- | ---------------------- | -------------------------------- | ------------------------------------------------------------------------------------------ | | cookies() | No | No | Use 'use cache: private' instead | | headers() | No | No | Use 'use cache: private' instead | | connection() | No | No | No - these cannot ever be cached | | searchParams | No | No | Use 'use cache: private' instead | > Important: If you need to cache based on cookies, headers, or search params, use 'use cache: private' instead. Remote caches are shared across all users, so caching user-specific data in them can lead to incorrect results being served to different users. Nesting rules Remote caches have specific nesting rules: - Remote caches can be nested inside other remote caches ('use cache: remote') - Remote caches can be nested inside regular caches ('use cache') - Remote caches cannot be nested inside private caches ('use cache: private') - Private caches cannot be nested inside remote caches Examples The following examples demonstrate common patterns for using 'use cache: remote'. For details about cacheLife parameters (stale, revalidate, expire), see the cacheLife API reference. Per-request database queries Cache expensive database queries that are accessed in dynamic contexts, reducing load on your database: API responses in streaming contexts Cache API responses that are fetched during streaming or after dynamic operations: Computed data after dynamic checks Cache expensive computations that occur after dynamic security or feature checks: Mixed caching strategies Combine static, remote, and private caching for optimal performance: > Good to know: > > - Remote caches are stored in server-side cache handlers and shared across all users > - Remote caches work in dynamic contexts where regular use cache would fail > - Use cacheTag() and revalidateTag() to invalidate remote caches on-demand > - Use cacheLife() to configure cache expiration > - For user-specific data, use 'use cache: private' instead of 'use cache: remote' > - Remote caches reduce origin load by storing computed or fetched data server-side Platform Support | Deployment Option | Supported | | ------------------------------------------------------------------- | --------- | | Node.js server | Yes | | Docker container | Yes | | Static export | No | | Adapters | Yes | Version History | Version | Changes | | --------- | ------------------------------------------------------------------- | | v16.0.0 | \"use cache: remote\" is enabled with the Cache Components feature. |",
    "excerpt": "The 'use cache: remote' directive enables caching of shared data in dynamic contexts where regular use cache would not work, for example after calling await connection(), await cookies() or await head...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/01-directives/use-cache-remote"
  },
  {
    "id": "01-app-03-api-reference-01-directives-use-cache",
    "path": "01-app\\03-api-reference\\01-directives\\use-cache.mdx",
    "title": "use cache",
    "description": "Learn how to use the use cache directive to cache data in your Next.js application.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Usage",
        "slug": "usage"
      },
      {
        "level": 2,
        "text": "How  works",
        "slug": "how-works"
      },
      {
        "level": 3,
        "text": "Cache keys",
        "slug": "cache-keys"
      },
      {
        "level": 2,
        "text": "Non-serializable arguments",
        "slug": "non-serializable-arguments"
      },
      {
        "level": 2,
        "text": "Return values",
        "slug": "return-values"
      },
      {
        "level": 2,
        "text": " at build time",
        "slug": "-at-build-time"
      },
      {
        "level": 2,
        "text": " at runtime",
        "slug": "-at-runtime"
      },
      {
        "level": 2,
        "text": "During revalidation",
        "slug": "during-revalidation"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Caching an entire route with ",
        "slug": "caching-an-entire-route-with-"
      },
      {
        "level": 3,
        "text": "Caching a component's output with ",
        "slug": "caching-a-components-output-with-"
      },
      {
        "level": 3,
        "text": "Caching function output with ",
        "slug": "caching-function-output-with-"
      },
      {
        "level": 3,
        "text": "Interleaving",
        "slug": "interleaving"
      },
      {
        "level": 2,
        "text": "Platform Support",
        "slug": "platform-support"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  cacheComponents: true,\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  cacheComponents: true,\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "// File level\r\n'use cache'\r\n\r\nexport default async function Page() {\r\n  // ...\r\n}\r\n\r\n// Component level\r\nexport async function MyComponent() {\r\n  'use cache'\r\n  return <></>\r\n}\r\n\r\n// Function level\r\nexport async function getData() {\r\n  'use cache'\r\n  const data = await fetch('/api/data')\r\n  return data\r\n}",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "async function CachedComponent({ children }: { children: ReactNode }) {\r\n  'use cache'\r\n  return <div>{children}</div>\r\n}",
        "context": "filename=\"app/ui/cached-component.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "async function CachedComponent({ children }) {\r\n  'use cache'\r\n  return <div>{children}</div>\r\n}",
        "context": "filename=\"app/ui/cached-component.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use cache'\r\n\r\nexport default async function Layout({ children }: { children: ReactNode }) {\r\n  return <div>{children}</div>\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use cache'\r\n\r\nexport default async function Layout({ children }) {\r\n  return <div>{children}</div>\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use cache'\r\n\r\nasync function Users() {\r\n  const users = await fetch('/api/users')\r\n  // loop through users\r\n}\r\n\r\nexport default async function Page() {\r\n  return (\r\n    <main>\r\n      <Users />\r\n    </main>\r\n  )\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use cache'\r\n\r\nasync function Users() {\r\n  const users = await fetch('/api/users')\r\n  // loop through users\r\n}\r\n\r\nexport default async function Page() {\r\n  return (\r\n    <main>\r\n      <Users />\r\n    </main>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export async function Bookings({ type = 'haircut' }: BookingsProps) {\r\n  'use cache'\r\n  async function getBookingsData() {\r\n    const data = await fetch(`/api/bookings?type=${encodeURIComponent(type)}`)\r\n    return data\r\n  }\r\n  return //...\r\n}\r\n\r\ninterface BookingsProps {\r\n  type: string\r\n}",
        "context": "filename=\"app/components/bookings.tsx\" highlight={2} switcher"
      },
      {
        "language": "jsx",
        "code": "export async function Bookings({ type = 'haircut' }) {\r\n  'use cache'\r\n  async function getBookingsData() {\r\n    const data = await fetch(`/api/bookings?type=${encodeURIComponent(type)}`)\r\n    return data\r\n  }\r\n  return //...\r\n}",
        "context": "filename=\"app/components/bookings.js\" highlight={2} switcher"
      },
      {
        "language": "tsx",
        "code": "export async function getData() {\r\n  'use cache'\r\n\r\n  const data = await fetch('/api/data')\r\n  return data\r\n}",
        "context": "filename=\"app/actions.ts\" highlight={2} switcher"
      },
      {
        "language": "jsx",
        "code": "export async function getData() {\r\n  'use cache'\r\n\r\n  const data = await fetch('/api/data')\r\n  return data\r\n}",
        "context": "filename=\"app/actions.js\" highlight={2} switcher"
      },
      {
        "language": "tsx",
        "code": "export default async function Page() {\r\n  const uncachedData = await getData()\r\n  return (\r\n    // Pass compositional slots as props, e.g. header and children\r\n    <CacheComponent header={<h1>Home</h1>}>\r\n      {/* DynamicComponent is provided as the children slot */}\r\n      <DynamicComponent data={uncachedData} />\r\n    </CacheComponent>\r\n  )\r\n}\r\n\r\nasync function CacheComponent({\r\n  header, // header: a compositional slot, injected as a prop\r\n  children, // children: another slot for nested composition\r\n}: {\r\n  header: ReactNode\r\n  children: ReactNode\r\n}) {\r\n  'use cache'\r\n  const cachedData = await fetch('/api/cached-data')\r\n  return (\r\n    <div>\r\n      {header}\r\n      <PrerenderedComponent data={cachedData} />\r\n      {children}\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default async function Page() {\r\n  const uncachedData = await getData()\r\n  return (\r\n    // Pass compositional slots as props, e.g. header and children\r\n    <CacheComponent header={<h1>Home</h1>}>\r\n      {/* DynamicComponent is provided as the children slot */}\r\n      <DynamicComponent data={uncachedData} />\r\n    </CacheComponent>\r\n  )\r\n}\r\n\r\nasync function CacheComponent({\r\n  header, // header: a compositional slot, injected as a prop\r\n  children, // children: another slot for nested composition\r\n}) {\r\n  'use cache'\r\n  const cachedData = await fetch('/api/cached-data')\r\n  return (\r\n    <div>\r\n      {header}\r\n      <PrerenderedComponent data={cachedData} />\r\n      {children}\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import ClientComponent from './ClientComponent'\r\n\r\nexport default async function Page() {\r\n  const performUpdate = async () => {\r\n    'use server'\r\n    // Perform some server-side update\r\n    await db.update(...)\r\n  }\r\n\r\n  return <CacheComponent performUpdate={performUpdate} />\r\n}\r\n\r\nasync function CachedComponent({\r\n  performUpdate,\r\n}: {\r\n  performUpdate: () => Promise<void>\r\n}) {\r\n  'use cache'\r\n  // Do not call performUpdate here\r\n  return <ClientComponent action={performUpdate} />\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import ClientComponent from './ClientComponent'\r\n\r\nexport default async function Page() {\r\n  const performUpdate = async () => {\r\n    'use server'\r\n    // Perform some server-side update\r\n    await db.update(...)\r\n  }\r\n\r\n  return <CacheComponent performUpdate={performUpdate} />\r\n}\r\n\r\nasync function CachedComponent({ performUpdate }) {\r\n  'use cache'\r\n  // Do not call performUpdate here\r\n  return <ClientComponent action={performUpdate} />\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nexport default function ClientComponent({\r\n  action,\r\n}: {\r\n  action: () => Promise<void>\r\n}) {\r\n  return <button onClick={action}>Update</button>\r\n}",
        "context": "filename=\"app/ClientComponent.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nexport default function ClientComponent({ action }) {\r\n  return <button onClick={action}>Update</button>\r\n}",
        "context": "filename=\"app/ClientComponent.js\" switcher"
      }
    ],
    "content": "The use cache directive allows you to mark a route, React component, or a function as cacheable. It can be used at the top of a file to indicate that all exports in the file should be cached, or inline at the top of function or component to cache the return value. > Good to know: For caching user-specific content that requires access to cookies or headers, see 'use cache: private'. Usage use cache is a Cache Components feature. To enable it, add the cacheComponents option to your next.config.ts file: Then, add use cache at the file, component, or function level: How use cache works Cache keys A cache entry's key is generated using a serialized version of its inputs, which includes: - Build ID (generated for each build) - Function ID (a secure identifier unique to the function) - The serializable function arguments (or props). The arguments passed to the cached function, as well as any values it reads from the parent scope automatically become a part of the key. This means, the same cache entry will be reused as long as its inputs are the same. Non-serializable arguments Any non-serializable arguments, props, or closed-over values will turn into references inside the cached function, and can be only passed through and not inspected nor modified. These non-serializable values will be filled in at the request time and won't become a part of the cache key. For example, a cached function can take in JSX as a children prop and return {children}, but it won't be able to introspect the actual children object. This allows you to nest uncached content inside a cached component. Return values The return value of the cacheable function must be serializable props. This ensures that the cached data can be stored and retrieved correctly. > Good to know: The supported types for arguments and the supported types for returned values are not the same. For more details, refer to Serializable Parameters and Return Values for function arguments and Serializable Types for return values. use cache at build time When used at the top of a layout or page, the route segment will be prerendered, allowing it to later be revalidated. This means use cache cannot be used with runtime data like cookies or headers. > Note: If you need to cache content that depends on cookies, headers, or search params, use 'use cache: private' instead. use cache at runtime On the server, the cache entries of individual components or functions will be cached in-memory. Then, on the client, any content returned from the server cache will be stored in the browser's memory for the duration of the session or until revalidated. During revalidation By default, use cache has server-side revalidation period of 15 minutes. While this period may be useful for content that doesn't require frequent updates, you can use the cacheLife and cacheTag APIs to configure when the individual cache entries should be revalidated. - cacheLife: Configure the cache entry lifetime. - cacheTag: Create tags for on-demand revalidation. Both of these APIs integrate across the client and server caching layers, meaning you can configure your caching semantics in one place and have them apply everywhere. See the cacheLife and cacheTag API docs for more information. Examples Caching an entire route with use cache To pre-render an entire route, add use cache to the top of both the layout and page files. Each of these segments are treated as separate entry points in your application, and will be cached independently. Any components imported and nested in page file are part of the cache output associated with the page. > Good to know: > > - If use cache is added only to the layout or the page, only that route segment and any components imported into it will be cached. > - If any of the nested children in the route use Dynamic APIs, then the route will opt out of pre-rendering. Caching a component's output with use cache You can use use cache at the component level to cache any fetches or computations performed within that component. The cache entry will be reused as long as the serialized props produce the same value in each instance. Caching function output with use cache Since you can add use cache to any asynchronous function, you aren't limited to caching components or routes only. You might want to cache a network request, a database query, or a slow computation. Interleaving In React, composition with children or slots is a well-known pattern for building flexible components. When using use cache, you can continue to compose your UI in this way. Anything included as children, or other compositional slots, in the returned JSX will be passed through the cached component without affecting its cache entry. As long as you don't directly reference any of the JSX slots inside the body of the cacheable function itself, their presence in the returned output won't affect the cache entry. You can also pass Server Actions through cached components to Client Components without invoking them inside the cacheable function. Platform Support | Deployment Option | Supported | | ------------------------------------------------------------------- | ----------------- | | Node.js server | Yes | | Docker container | Yes | | Static export | No | | Adapters | Platform-specific | Learn how to configure caching when self-hosting Next.js. Version History | Version | Changes | | --------- | ----------------------------------------------------------- | | v16.0.0 | \"use cache\" is enabled with the Cache Components feature. | | v15.0.0 | \"use cache\" is introduced as an experimental feature. |",
    "excerpt": "The use cache directive allows you to mark a route, React component, or a function as cacheable. It can be used at the top of a file to indicate that all exports in the file should be cached, or inlin...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/01-directives/use-cache"
  },
  {
    "id": "01-app-03-api-reference-01-directives-use-client",
    "path": "01-app\\03-api-reference\\01-directives\\use-client.mdx",
    "title": "use client",
    "description": "Learn how to use the use client directive to render a component on the client.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Usage",
        "slug": "usage"
      },
      {
        "level": 2,
        "text": "Nesting Client Components within Server Components",
        "slug": "nesting-client-components-within-server-components"
      },
      {
        "level": 2,
        "text": "Reference",
        "slug": "reference"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { useState } from 'react'\r\n\r\nexport default function Counter() {\r\n  const [count, setCount] = useState(0)\r\n\r\n  return (\r\n    <div>\r\n      <p>Count: {count}</p>\r\n      <button onClick={() => setCount(count + 1)}>Increment</button>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/components/counter.tsx\" highlight={1} switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { useState } from 'react'\r\n\r\nexport default function Counter() {\r\n  const [count, setCount] = useState(0)\r\n\r\n  return (\r\n    <div>\r\n      <p>Count: {count}</p>\r\n      <button onClick={() => setCount(count + 1)}>Increment</button>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/components/counter.js\" highlight={1} switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nexport default function Counter({\r\n  onClick /* ❌ Function is not serializable */,\r\n}) {\r\n  return (\r\n    <div>\r\n      <button onClick={onClick}>Increment</button>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/components/counter.tsx\" highlight={4} switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nexport default function Counter({\r\n  onClick /* ❌ Function is not serializable */,\r\n}) {\r\n  return (\r\n    <div>\r\n      <button onClick={onClick}>Increment</button>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/components/counter.js\" highlight={4} switcher"
      },
      {
        "language": "tsx",
        "code": "import Header from './header'\r\nimport Counter from './counter' // This is a Client Component\r\n\r\nexport default function Page() {\r\n  return (\r\n    <div>\r\n      <Header />\r\n      <Counter />\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/page.tsx\" highlight={2,8} switcher"
      },
      {
        "language": "jsx",
        "code": "import Header from './header'\r\nimport Counter from './counter' // This is a Client Component\r\n\r\nexport default function Page() {\r\n  return (\r\n    <div>\r\n      <Header />\r\n      <Counter />\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\" highlight={2,8} switcher"
      }
    ],
    "content": "The 'use client' directive declares an entry point for the components to be rendered on the client side and should be used when creating interactive user interfaces (UI) that require client-side JavaScript capabilities, such as state management, event handling, and access to browser APIs. This is a React feature. > Good to know: > > You do not need to add the 'use client' directive to every file that contains Client Components. You only need to add it to the files whose components you want to render directly within Server Components. The 'use client' directive defines the client-server boundary, and the components exported from such a file serve as entry points to the client. Usage To declare an entry point for the Client Components, add the 'use client' directive at the top of the file, before any imports: When using the 'use client' directive, the props of the Client Components must be serializable. This means the props need to be in a format that React can serialize when sending data from the server to the client. Nesting Client Components within Server Components Combining Server and Client Components allows you to build applications that are both performant and interactive: 1. Server Components: Use for static content, data fetching, and SEO-friendly elements. 2. Client Components: Use for interactive elements that require state, effects, or browser APIs. 3. Component composition: Nest Client Components within Server Components as needed for a clear separation of server and client logic. In the following example: - Header is a Server Component handling static content. - Counter is a Client Component enabling interactivity within the page. Reference See the React documentation for more information on 'use client'.",
    "excerpt": "The 'use client' directive declares an entry point for the components to be rendered on the client side and should be used when creating interactive user interfaces (UI) that require client-side JavaS...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/01-directives/use-client"
  },
  {
    "id": "01-app-03-api-reference-01-directives-use-server",
    "path": "01-app\\03-api-reference\\01-directives\\use-server.mdx",
    "title": "use server",
    "description": "Learn how to use the use server directive to execute code on the server.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Using  at the top of a file",
        "slug": "using-at-the-top-of-a-file"
      },
      {
        "level": 3,
        "text": "Using Server Functions in a Client Component",
        "slug": "using-server-functions-in-a-client-component"
      },
      {
        "level": 2,
        "text": "Using  inline",
        "slug": "using-inline"
      },
      {
        "level": 2,
        "text": "Security considerations",
        "slug": "security-considerations"
      },
      {
        "level": 3,
        "text": "Authentication and authorization",
        "slug": "authentication-and-authorization"
      },
      {
        "level": 2,
        "text": "Reference",
        "slug": "reference"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "'use server'\r\nimport { db } from '@/lib/db' // Your database client\r\n\r\nexport async function createUser(data: { name: string; email: string }) {\r\n  const user = await db.user.create({ data })\r\n  return user\r\n}",
        "context": "filename=\"app/actions.ts\" highlight={1} switcher"
      },
      {
        "language": "jsx",
        "code": "'use server'\r\nimport { db } from '@/lib/db' // Your database client\r\n\r\nexport async function createUser(data) {\r\n  const user = await db.user.create({ data })\r\n  return user\r\n}",
        "context": "filename=\"app/actions.js\" highlight={1} switcher"
      },
      {
        "language": "tsx",
        "code": "'use server'\r\nimport { db } from '@/lib/db' // Your database client\r\n\r\nexport async function fetchUsers() {\r\n  const users = await db.user.findMany()\r\n  return users\r\n}",
        "context": "filename=\"app/actions.ts\" highlight={1} switcher"
      },
      {
        "language": "jsx",
        "code": "'use server'\r\nimport { db } from '@/lib/db' // Your database client\r\n\r\nexport async function fetchUsers() {\r\n  const users = await db.user.findMany()\r\n  return users\r\n}",
        "context": "filename=\"app/actions.js\" highlight={1} switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\nimport { fetchUsers } from '../actions'\r\n\r\nexport default function MyButton() {\r\n  return <button onClick={() => fetchUsers()}>Fetch Users</button>\r\n}",
        "context": "filename=\"app/components/my-button.tsx\" highlight={1,2,8} switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\nimport { fetchUsers } from '../actions'\r\n\r\nexport default function MyButton() {\r\n  return <button onClick={() => fetchUsers()}>Fetch Users</button>\r\n}",
        "context": "filename=\"app/components/my-button.js\" highlight={1,2,8} switcher"
      },
      {
        "language": "tsx",
        "code": "import { EditPost } from './edit-post'\r\nimport { revalidatePath } from 'next/cache'\r\n\r\nexport default async function PostPage({ params }: { params: { id: string } }) {\r\n  const post = await getPost(params.id)\r\n\r\n  async function updatePost(formData: FormData) {\r\n    'use server'\r\n    await savePost(params.id, formData)\r\n    revalidatePath(`/posts/${params.id}`)\r\n  }\r\n\r\n  return <EditPost updatePostAction={updatePost} post={post} />\r\n}",
        "context": "filename=\"app/posts/[id]/page.tsx\" switcher highlight={8}"
      },
      {
        "language": "jsx",
        "code": "import { EditPost } from './edit-post'\r\nimport { revalidatePath } from 'next/cache'\r\n\r\nexport default async function PostPage({ params }) {\r\n  const post = await getPost(params.id)\r\n\r\n  async function updatePost(formData) {\r\n    'use server'\r\n    await savePost(params.id, formData)\r\n    revalidatePath(`/posts/${params.id}`)\r\n  }\r\n\r\n  return <EditPost updatePostAction={updatePost} post={post} />\r\n}",
        "context": "filename=\"app/posts/[id]/page.js\" switcher highlight={8}"
      },
      {
        "language": "tsx",
        "code": "'use server'\r\n\r\nimport { db } from '@/lib/db' // Your database client\r\nimport { authenticate } from '@/lib/auth' // Your authentication library\r\n\r\nexport async function createUser(\r\n  data: { name: string; email: string },\r\n  token: string\r\n) {\r\n  const user = authenticate(token)\r\n  if (!user) {\r\n    throw new Error('Unauthorized')\r\n  }\r\n  const newUser = await db.user.create({ data })\r\n  return newUser\r\n}",
        "context": "filename=\"app/actions.ts\" highlight={1,7,8,9,10} switcher"
      },
      {
        "language": "jsx",
        "code": "'use server'\r\n\r\nimport { db } from '@/lib/db' // Your database client\r\nimport { authenticate } from '@/lib/auth' // Your authentication library\r\n\r\nexport async function createUser(data, token) {\r\n  const user = authenticate(token)\r\n  if (!user) {\r\n    throw new Error('Unauthorized')\r\n  }\r\n  const newUser = await db.user.create({ data })\r\n  return newUser\r\n}",
        "context": "filename=\"app/actions.js\" highlight={1,7,8,9,10} switcher"
      }
    ],
    "content": "The use server directive designates a function or file to be executed on the server side. It can be used at the top of a file to indicate that all functions in the file are server-side, or inline at the top of a function to mark the function as a Server Function. This is a React feature. Using use server at the top of a file The following example shows a file with a use server directive at the top. All functions in the file are executed on the server. Using Server Functions in a Client Component To use Server Functions in Client Components you need to create your Server Functions in a dedicated file using the use server directive at the top of the file. These Server Functions can then be imported into Client and Server Components and executed. Assuming you have a fetchUsers Server Function in actions.ts: Then you can import the fetchUsers Server Function into a Client Component and execute it on the client-side. Using use server inline In the following example, use server is used inline at the top of a function to mark it as a Server Function: Security considerations When using the use server directive, it's important to ensure that all server-side logic is secure and that sensitive data remains protected. Authentication and authorization Always authenticate and authorize users before performing sensitive server-side operations. Reference See the React documentation for more information on use server.",
    "excerpt": "The use server directive designates a function or file to be executed on the server side. It can be used at the top of a file to indicate that all functions in the file are server-side, or inline at t...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/01-directives/use-server"
  },
  {
    "id": "01-app-03-api-reference-02-components-font",
    "path": "01-app\\03-api-reference\\02-components\\font.mdx",
    "title": "Font Module",
    "description": "Optimizing loading web fonts with the built-in `next/font` loaders.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Reference",
        "slug": "reference"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 2,
        "text": "Google Fonts",
        "slug": "google-fonts"
      },
      {
        "level": 3,
        "text": "Apply the font in ",
        "slug": "apply-the-font-in-"
      },
      {
        "level": 3,
        "text": "Single page usage",
        "slug": "single-page-usage"
      },
      {
        "level": 3,
        "text": "Specifying a subset",
        "slug": "specifying-a-subset"
      },
      {
        "level": 2,
        "text": "Using Multiple Fonts",
        "slug": "using-multiple-fonts"
      },
      {
        "level": 3,
        "text": "Local Fonts",
        "slug": "local-fonts"
      },
      {
        "level": 3,
        "text": "With Tailwind CSS",
        "slug": "with-tailwind-css"
      },
      {
        "level": 3,
        "text": "Tailwind CSS v3",
        "slug": "tailwind-css-v3"
      },
      {
        "level": 3,
        "text": "Applying Styles",
        "slug": "applying-styles"
      },
      {
        "level": 4,
        "text": "CSS Variables",
        "slug": "css-variables"
      },
      {
        "level": 3,
        "text": "Using a font definitions file",
        "slug": "using-a-font-definitions-file"
      },
      {
        "level": 3,
        "text": "Preloading",
        "slug": "preloading"
      },
      {
        "level": 2,
        "text": "Version Changes",
        "slug": "version-changes"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "import { Inter } from 'next/font/google'\r\n\r\n// If loading a variable font, you don't need to specify the font weight\r\nconst inter = Inter({\r\n  subsets: ['latin'],\r\n  display: 'swap',\r\n})\r\n\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\" className={inter.className}>\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { Inter } from 'next/font/google'\r\n\r\n// If loading a variable font, you don't need to specify the font weight\r\nconst inter = Inter({\r\n  subsets: ['latin'],\r\n  display: 'swap',\r\n})\r\n\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\" className={inter.className}>\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { Inter } from 'next/font/google'\r\n\r\n// If loading a variable font, you don't need to specify the font weight\r\nconst inter = Inter({ subsets: ['latin'] })\r\n\r\nexport default function MyApp({ Component, pageProps }) {\r\n  return (\r\n    <main className={inter.className}>\r\n      <Component {...pageProps} />\r\n    </main>\r\n  )\r\n}",
        "context": "filename=\"pages/_app.js\""
      },
      {
        "language": "tsx",
        "code": "import { Inter } from 'next/font/google'\r\n\r\n// If loading a variable font, you don't need to specify the font weight\r\nconst inter = Inter({\r\n  subsets: ['latin'],\r\n  display: 'swap',\r\n})\r\n\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\" className={inter.className}>\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { Inter } from 'next/font/google'\r\n\r\n// If loading a variable font, you don't need to specify the font weight\r\nconst inter = Inter({\r\n  subsets: ['latin'],\r\n  display: 'swap',\r\n})\r\n\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\" className={inter.className}>\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { Roboto } from 'next/font/google'\r\n\r\nconst roboto = Roboto({\r\n  weight: '400',\r\n  subsets: ['latin'],\r\n  display: 'swap',\r\n})\r\n\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\" className={roboto.className}>\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { Roboto } from 'next/font/google'\r\n\r\nconst roboto = Roboto({\r\n  weight: '400',\r\n  subsets: ['latin'],\r\n  display: 'swap',\r\n})\r\n\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\" className={roboto.className}>\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { Inter } from 'next/font/google'\r\n\r\n// If loading a variable font, you don't need to specify the font weight\r\nconst inter = Inter({ subsets: ['latin'] })\r\n\r\nexport default function MyApp({ Component, pageProps }) {\r\n  return (\r\n    <main className={inter.className}>\r\n      <Component {...pageProps} />\r\n    </main>\r\n  )\r\n}",
        "context": "filename=\"pages/_app.js\""
      },
      {
        "language": "jsx",
        "code": "import { Roboto } from 'next/font/google'\r\n\r\nconst roboto = Roboto({\r\n  weight: '400',\r\n  subsets: ['latin'],\r\n})\r\n\r\nexport default function MyApp({ Component, pageProps }) {\r\n  return (\r\n    <main className={roboto.className}>\r\n      <Component {...pageProps} />\r\n    </main>\r\n  )\r\n}",
        "context": "filename=\"pages/_app.js\""
      },
      {
        "language": "jsx",
        "code": "const roboto = Roboto({\r\n  weight: ['400', '700'],\r\n  style: ['normal', 'italic'],\r\n  subsets: ['latin'],\r\n  display: 'swap',\r\n})",
        "context": "filename=\"app/layout.js\""
      },
      {
        "language": "jsx",
        "code": "import { Inter } from 'next/font/google'\r\n\r\nconst inter = Inter({ subsets: ['latin'] })\r\n\r\nexport default function MyApp({ Component, pageProps }) {\r\n  return (\r\n    <>\r\n      <style jsx global>{`\r\n        html {\r\n          font-family: ${inter.style.fontFamily};\r\n        }\r\n      `}</style>\r\n      <Component {...pageProps} />\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"pages/_app.js\""
      },
      {
        "language": "jsx",
        "code": "import { Inter } from 'next/font/google'\r\n\r\nconst inter = Inter({ subsets: ['latin'] })\r\n\r\nexport default function Home() {\r\n  return (\r\n    <div className={inter.className}>\r\n      <p>Hello World</p>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"pages/index.js\""
      },
      {
        "language": "tsx",
        "code": "const inter = Inter({ subsets: ['latin'] })",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "const inter = Inter({ subsets: ['latin'] })",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "const inter = Inter({ subsets: ['latin'] })",
        "context": "filename=\"pages/_app.js\""
      },
      {
        "language": "ts",
        "code": "import { Inter, Roboto_Mono } from 'next/font/google'\r\n\r\nexport const inter = Inter({\r\n  subsets: ['latin'],\r\n  display: 'swap',\r\n})\r\n\r\nexport const roboto_mono = Roboto_Mono({\r\n  subsets: ['latin'],\r\n  display: 'swap',\r\n})",
        "context": "filename=\"app/fonts.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { Inter, Roboto_Mono } from 'next/font/google'\r\n\r\nexport const inter = Inter({\r\n  subsets: ['latin'],\r\n  display: 'swap',\r\n})\r\n\r\nexport const roboto_mono = Roboto_Mono({\r\n  subsets: ['latin'],\r\n  display: 'swap',\r\n})",
        "context": "filename=\"app/fonts.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { inter } from './fonts'\r\n\r\nexport default function Layout({ children }: { children: React.ReactNode }) {\r\n  return (\r\n    <html lang=\"en\" className={inter.className}>\r\n      <body>\r\n        <div>{children}</div>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { inter } from './fonts'\r\n\r\nexport default function Layout({ children }) {\r\n  return (\r\n    <html lang=\"en\" className={inter.className}>\r\n      <body>\r\n        <div>{children}</div>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { roboto_mono } from './fonts'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <h1 className={roboto_mono.className}>My page</h1>\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { roboto_mono } from './fonts'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <h1 className={roboto_mono.className}>My page</h1>\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { Inter, Roboto_Mono } from 'next/font/google'\r\nimport styles from './global.css'\r\n\r\nconst inter = Inter({\r\n  subsets: ['latin'],\r\n  variable: '--font-inter',\r\n  display: 'swap',\r\n})\r\n\r\nconst roboto_mono = Roboto_Mono({\r\n  subsets: ['latin'],\r\n  variable: '--font-roboto-mono',\r\n  display: 'swap',\r\n})\r\n\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\" className={`${inter.variable} ${roboto_mono.variable}`}>\r\n      <body>\r\n        <h1>My App</h1>\r\n        <div>{children}</div>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { Inter, Roboto_Mono } from 'next/font/google'\r\n\r\nconst inter = Inter({\r\n  subsets: ['latin'],\r\n  variable: '--font-inter',\r\n  display: 'swap',\r\n})\r\n\r\nconst roboto_mono = Roboto_Mono({\r\n  subsets: ['latin'],\r\n  variable: '--font-roboto-mono',\r\n  display: 'swap',\r\n})\r\n\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\" className={`${inter.variable} ${roboto_mono.variable}`}>\r\n      <body>\r\n        <h1>My App</h1>\r\n        <div>{children}</div>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "css",
        "code": "html {\r\n  font-family: var(--font-inter);\r\n}\r\n\r\nh1 {\r\n  font-family: var(--font-roboto-mono);\r\n}",
        "context": "filename=\"app/global.css\""
      },
      {
        "language": "tsx",
        "code": "import localFont from 'next/font/local'\r\n\r\n// Font files can be colocated inside of `app`\r\nconst myFont = localFont({\r\n  src: './my-font.woff2',\r\n  display: 'swap',\r\n})\r\n\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\" className={myFont.className}>\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import localFont from 'next/font/local'\r\n\r\n// Font files can be colocated inside of `app`\r\nconst myFont = localFont({\r\n  src: './my-font.woff2',\r\n  display: 'swap',\r\n})\r\n\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\" className={myFont.className}>\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "import localFont from 'next/font/local'\r\n\r\n// Font files can be colocated inside of `pages`\r\nconst myFont = localFont({ src: './my-font.woff2' })\r\n\r\nexport default function MyApp({ Component, pageProps }) {\r\n  return (\r\n    <main className={myFont.className}>\r\n      <Component {...pageProps} />\r\n    </main>\r\n  )\r\n}",
        "context": "filename=\"pages/_app.js\""
      },
      {
        "language": "js",
        "code": "const roboto = localFont({\r\n  src: [\r\n    {\r\n      path: './Roboto-Regular.woff2',\r\n      weight: '400',\r\n      style: 'normal',\r\n    },\r\n    {\r\n      path: './Roboto-Italic.woff2',\r\n      weight: '400',\r\n      style: 'italic',\r\n    },\r\n    {\r\n      path: './Roboto-Bold.woff2',\r\n      weight: '700',\r\n      style: 'normal',\r\n    },\r\n    {\r\n      path: './Roboto-BoldItalic.woff2',\r\n      weight: '700',\r\n      style: 'italic',\r\n    },\r\n  ],\r\n})",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "import { Inter, Roboto_Mono } from 'next/font/google'\r\n\r\nconst inter = Inter({\r\n  subsets: ['latin'],\r\n  display: 'swap',\r\n  variable: '--font-inter',\r\n})\r\n\r\nconst roboto_mono = Roboto_Mono({\r\n  subsets: ['latin'],\r\n  display: 'swap',\r\n  variable: '--font-roboto-mono',\r\n})\r\n\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html\r\n      lang=\"en\"\r\n      className={`${inter.variable} ${roboto_mono.variable} antialiased`}\r\n    >\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { Inter, Roboto_Mono } from 'next/font/google'\r\n\r\nconst inter = Inter({\r\n  subsets: ['latin'],\r\n  display: 'swap',\r\n  variable: '--font-inter',\r\n})\r\n\r\nconst roboto_mono = Roboto_Mono({\r\n  subsets: ['latin'],\r\n  display: 'swap',\r\n  variable: '--font-roboto-mono',\r\n})\r\n\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html\r\n      lang=\"en\"\r\n      className={`${inter.variable} ${roboto_mono.variable} antialiased`}\r\n    >\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { Inter } from 'next/font/google'\r\n\r\nconst inter = Inter({\r\n  subsets: ['latin'],\r\n  variable: '--font-inter',\r\n})\r\n\r\nconst roboto_mono = Roboto_Mono({\r\n  subsets: ['latin'],\r\n  display: 'swap',\r\n  variable: '--font-roboto-mono',\r\n})\r\n\r\nexport default function MyApp({ Component, pageProps }) {\r\n  return (\r\n    <main className={`${inter.variable} ${roboto_mono.variable} font-sans`}>\r\n      <Component {...pageProps} />\r\n    </main>\r\n  )\r\n}",
        "context": "filename=\"pages/_app.js\""
      },
      {
        "language": "css",
        "code": "@import 'tailwindcss';\r\n\r\n@theme inline {\r\n  --font-sans: var(--font-inter);\r\n  --font-mono: var(--font-roboto-mono);\r\n}",
        "context": "filename=\"global.css\""
      },
      {
        "language": "js",
        "code": "/** @type {import('tailwindcss').Config} */\r\nmodule.exports = {\r\n  content: [\r\n    './pages/**/*.{js,ts,jsx,tsx}',\r\n    './components/**/*.{js,ts,jsx,tsx}',\r\n    './app/**/*.{js,ts,jsx,tsx}',\r\n  ],\r\n  theme: {\r\n    extend: {\r\n      fontFamily: {\r\n        sans: ['var(--font-inter)'],\r\n        mono: ['var(--font-roboto-mono)'],\r\n      },\r\n    },\r\n  },\r\n  plugins: [],\r\n}",
        "context": "filename=\"tailwind.config.js\""
      },
      {
        "language": "html",
        "code": "<p class=\"font-sans ...\">The quick brown fox ...</p>\r\n<p class=\"font-mono ...\">The quick brown fox ...</p>",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "<p className={inter.className}>Hello, Next.js!</p>",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "<p style={inter.style}>Hello World</p>",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "import { Inter } from 'next/font/google'\r\nimport styles from '../styles/component.module.css'\r\n\r\nconst inter = Inter({\r\n  variable: '--font-inter',\r\n})",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { Inter } from 'next/font/google'\r\nimport styles from '../styles/component.module.css'\r\n\r\nconst inter = Inter({\r\n  variable: '--font-inter',\r\n})",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "<main className={inter.variable}>\r\n  <p className={styles.text}>Hello World</p>\r\n</main>",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "<main className={inter.variable}>\r\n  <p className={styles.text}>Hello World</p>\r\n</main>",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "css",
        "code": ".text {\r\n  font-family: var(--font-inter);\r\n  font-weight: 200;\r\n  font-style: italic;\r\n}",
        "context": "filename=\"styles/component.module.css\""
      },
      {
        "language": "ts",
        "code": "import { Inter, Lora, Source_Sans_3 } from 'next/font/google'\r\nimport localFont from 'next/font/local'\r\n\r\n// define your variable fonts\r\nconst inter = Inter()\r\nconst lora = Lora()\r\n// define 2 weights of a non-variable font\r\nconst sourceCodePro400 = Source_Sans_3({ weight: '400' })\r\nconst sourceCodePro700 = Source_Sans_3({ weight: '700' })\r\n// define a custom local font where GreatVibes-Regular.ttf is stored in the styles folder\r\nconst greatVibes = localFont({ src: './GreatVibes-Regular.ttf' })\r\n\r\nexport { inter, lora, sourceCodePro400, sourceCodePro700, greatVibes }",
        "context": "filename=\"styles/fonts.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { Inter, Lora, Source_Sans_3 } from 'next/font/google'\r\nimport localFont from 'next/font/local'\r\n\r\n// define your variable fonts\r\nconst inter = Inter()\r\nconst lora = Lora()\r\n// define 2 weights of a non-variable font\r\nconst sourceCodePro400 = Source_Sans_3({ weight: '400' })\r\nconst sourceCodePro700 = Source_Sans_3({ weight: '700' })\r\n// define a custom local font where GreatVibes-Regular.ttf is stored in the styles folder\r\nconst greatVibes = localFont({ src: './GreatVibes-Regular.ttf' })\r\n\r\nexport { inter, lora, sourceCodePro400, sourceCodePro700, greatVibes }",
        "context": "filename=\"styles/fonts.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { inter, lora, sourceCodePro700, greatVibes } from '../styles/fonts'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <div>\r\n      <p className={inter.className}>Hello world using Inter font</p>\r\n      <p style={lora.style}>Hello world using Lora font</p>\r\n      <p className={sourceCodePro700.className}>\r\n        Hello world using Source_Sans_3 font with weight 700\r\n      </p>\r\n      <p className={greatVibes.className}>My title in Great Vibes font</p>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { inter, lora, sourceCodePro700, greatVibes } from '../styles/fonts'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <div>\r\n      <p className={inter.className}>Hello world using Inter font</p>\r\n      <p style={lora.style}>Hello world using Lora font</p>\r\n      <p className={sourceCodePro700.className}>\r\n        Hello world using Source_Sans_3 font with weight 700\r\n      </p>\r\n      <p className={greatVibes.className}>My title in Great Vibes font</p>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "json",
        "code": "{\r\n  \"compilerOptions\": {\r\n    \"paths\": {\r\n      \"@/fonts\": [\"./styles/fonts\"]\r\n    }\r\n  }\r\n}",
        "context": "filename=\"tsconfig.json\""
      },
      {
        "language": "tsx",
        "code": "import { greatVibes, sourceCodePro400 } from '@/fonts'",
        "context": "filename=\"app/about/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { greatVibes, sourceCodePro400 } from '@/fonts'",
        "context": "filename=\"app/about/page.js\" switcher"
      }
    ],
    "content": "next/font automatically optimizes your fonts (including custom fonts) and removes external network requests for improved privacy and performance. It includes built-in automatic self-hosting for any font file. This means you can optimally load web fonts with no layout shift. You can also conveniently use all Google Fonts. CSS and font files are downloaded at build time and self-hosted with the rest of your static assets. No requests are sent to Google by the browser. To use the font in all your pages, add it to app.js file under /pages as shown below: > 🎥 Watch: Learn more about using next/font → YouTube (6 minutes). Reference | Key | font/google | font/local | Type | Required | | ------------------------------------------- | ------------------- | ------------------- | -------------------------- | ----------------- | | src | | | String or Array of Objects | Yes | | weight | | | String or Array | Required/Optional | | style | | | String or Array | - | | subsets | | | Array of Strings | - | | axes | | | Array of Strings | - | | display | | | String | - | | preload | | | Boolean | - | | fallback | | | Array of Strings | - | | adjustFontFallback | | | Boolean or String | - | | variable | | | String | - | | declarations | | | Array of Objects | - | src The path of the font file as a string or an array of objects (with type Array) relative to the directory where the font loader function is called. Used in next/font/local - Required Examples: - src:'./fonts/my-font.woff2' where my-font.woff2 is placed in a directory named fonts inside the app directory - src:[{path: './inter/Inter-Thin.ttf', weight: '100',},{path: './inter/Inter-Regular.ttf',weight: '400',},{path: './inter/Inter-Bold-Italic.ttf', weight: '700',style: 'italic',},] - if the font loader function is called in app/page.tsx using src:'../styles/fonts/my-font.ttf', then my-font.ttf is placed in styles/fonts at the root of the project weight The font weight with the following possibilities: - A string with possible values of the weights available for the specific font or a range of values if it's a variable font - An array of weight values if the font is not a variable google font. It applies to next/font/google only. Used in next/font/google and next/font/local - Required if the font being used is not variable Examples: - weight: '400': A string for a single weight value - for the font Inter, the possible values are '100', '200', '300', '400', '500', '600', '700', '800', '900' or 'variable' where 'variable' is the default) - weight: '100 900': A string for the range between 100 and 900 for a variable font - weight: ['100','400','900']: An array of 3 possible values for a non variable font style The font style with the following possibilities: - A string value with default value of 'normal' - An array of style values if the font is not a variable google font. It applies to next/font/google only. Used in next/font/google and next/font/local - Optional Examples: - style: 'italic': A string - it can be normal or italic for next/font/google - style: 'oblique': A string - it can take any value for next/font/local but is expected to come from standard font styles - style: ['italic','normal']: An array of 2 values for next/font/google - the values are from normal and italic subsets The font subsets defined by an array of string values with the names of each subset you would like to be preloaded. Fonts specified via subsets will have a link preload tag injected into the head when the preload option is true, which is the default. Used in next/font/google - Optional Examples: - subsets: ['latin']: An array with the subset latin You can find a list of all subsets on the Google Fonts page for your font. axes Some variable fonts have extra axes that can be included. By default, only the font weight is included to keep the file size down. The possible values of axes depend on the specific font. Used in next/font/google - Optional Examples: - axes: ['slnt']: An array with value slnt for the Inter variable font which has slnt as additional axes as shown here. You can find the possible axes values for your font by using the filter on the Google variable fonts page and looking for axes other than wght display The font display with possible string values of 'auto', 'block', 'swap', 'fallback' or 'optional' with default value of 'swap'. Used in next/font/google and next/font/local - Optional Examples: - display: 'optional': A string assigned to the optional value preload A boolean value that specifies whether the font should be preloaded or not. The default is true. Used in next/font/google and next/font/local - Optional Examples: - preload: false fallback The fallback font to use if the font cannot be loaded. An array of strings of fallback fonts with no default. - Optional Used in next/font/google and next/font/local Examples: - fallback: ['system-ui', 'arial']: An array setting the fallback fonts to system-ui or arial adjustFontFallback - For next/font/google: A boolean value that sets whether an automatic fallback font should be used to reduce Cumulative Layout Shift. The default is true. - For next/font/local: A string or boolean false value that sets whether an automatic fallback font should be used to reduce Cumulative Layout Shift. The possible values are 'Arial', 'Times New Roman' or false. The default is 'Arial'. Used in next/font/google and next/font/local - Optional Examples: - adjustFontFallback: false: for next/font/google - adjustFontFallback: 'Times New Roman': for next/font/local variable A string value to define the CSS variable name to be used if the style is applied with the CSS variable method. Used in next/font/google and next/font/local - Optional Examples: - variable: '--my-font': The CSS variable --my-font is declared declarations An array of font face descriptor key-value pairs that define the generated @font-face further. Used in next/font/local - Optional Examples: - declarations: [{ prop: 'ascent-override', value: '90%' }] Examples Google Fonts To use a Google font, import it from next/font/google as a function. We recommend using variable fonts for the best performance and flexibility. If you can't use a variable font, you will need to specify a weight: To use the font in all your pages, add it to app.js file under /pages as shown below: If you can't use a variable font, you will need to specify a weight: You can specify multiple weights and/or styles by using an array: > Good to know: Use an underscore (\\) for font names with multiple words. E.g. Roboto Mono should be imported as RobotoMono. Apply the font in You can also use the font without a wrapper and className by injecting it inside the as follows: Single page usage To use the font on a single page, add it to the specific page as shown below: Specifying a subset Google Fonts are automatically subset. This reduces the size of the font file and improves performance. You'll need to define which of these subsets you want to preload. Failing to specify any subsets while preload is true will result in a warning. This can be done by adding it to the function call: View the Font API Reference for more information. Using Multiple Fonts You can import and use multiple fonts in your application. There are two approaches you can take. The first approach is to create a utility function that exports a font, imports it, and applies its className where needed. This ensures the font is preloaded only when it's rendered: In the example above, Inter will be applied globally, and Roboto Mono can be imported and applied as needed. Alternatively, you can create a CSS variable and use it with your preferred CSS solution: In the example above, Inter will be applied globally, and any tags will be styled with Roboto Mono. > Recommendation: Use multiple fonts conservatively since each new font is an additional resource the client has to download. Local Fonts Import next/font/local and specify the src of your local font file. We recommend using variable fonts for the best performance and flexibility. If you want to use multiple files for a single font family, src can be an array: View the Font API Reference for more information. With Tailwind CSS next/font integrates seamlessly with Tailwind CSS using CSS variables. In the example below, we use the Inter and RobotoMono fonts from next/font/google (you can use any Google Font or Local Font). Use the variable option to define a CSS variable name, such as inter and robotomono for these fonts, respectively. Then, apply inter.variable and robotomono.variable to include the CSS variables in your HTML document. > Good to know: You can add these variables to the or tag, depending on your preference, styling needs or project requirements. Finally, add the CSS variable to your Tailwind CSS config: Tailwind CSS v3 You can now use the font-sans and font-mono utility classes to apply the font to your elements. Applying Styles You can apply the font styles in three ways: - className - style - CSS Variables className Returns a read-only CSS className for the loaded font to be passed to an HTML element. style Returns a read-only CSS style object for the loaded font to be passed to an HTML element, including style.fontFamily to access the font family name and fallback fonts. CSS Variables If you would like to set your styles in an external style sheet and specify additional options there, use the CSS variable method. In addition to importing the font, also import the CSS file where the CSS variable is defined and set the variable option of the font loader object as follows: To use the font, set the className of the parent container of the text you would like to style to the font loader's variable value and the className of the text to the styles property from the external CSS file. Define the text selector class in the component.module.css CSS file as follows: In the example above, the text Hello World is styled using the Inter font and the generated font fallback with font-weight: 200 and font-style: italic. Using a font definitions file Every time you call the localFont or Google font function, that font will be hosted as one instance in your application. Therefore, if you need to use the same font in multiple places, you should load it in one place and import the related font object where you need it. This is done using a font definitions file. For example, create a fonts.ts file in a styles folder at the root of your app directory. Then, specify your font definitions as follows: You can now use these definitions in your code as follows: To make it easier to access the font definitions in your code, you can define a path alias in your tsconfig.json or jsconfig.json files as follows: You can now import any font definition as follows: Preloading When a font function is called on a page of your site, it is not globally available and preloaded on all routes. Rather, the font is only preloaded on the related routes based on the type of file where it is used: - If it's a unique page, it is preloaded on the unique route for that page. - If it's a layout, it is preloaded on all the routes wrapped by the layout. - If it's the root layout, it is preloaded on all routes. When a font function is called on a page of your site, it is not globally available and preloaded on all routes. Rather, the font is only preloaded on the related route/s based on the type of file where it is used: - if it's a unique page, it is preloaded on the unique route for that page - if it's in the custom App, it is preloaded on all the routes of the site under /pages Version Changes | Version | Changes | | --------- | --------------------------------------------------------------------- | | v13.2.0 | @next/font renamed to next/font. Installation no longer required. | | v13.0.0 | @next/font was added. |",
    "excerpt": "next/font automatically optimizes your fonts (including custom fonts) and removes external network requests for improved privacy and performance. It includes built-in automatic self-hosting for any fo...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/02-components/font"
  },
  {
    "id": "01-app-03-api-reference-02-components-form",
    "path": "01-app\\03-api-reference\\02-components\\form.mdx",
    "title": "Form Component",
    "description": "Learn how to use the `<Form>` component to handle form submissions and search params updates with client-side navigation.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Reference",
        "slug": "reference"
      },
      {
        "level": 3,
        "text": " (string) Props",
        "slug": "-string-props"
      },
      {
        "level": 3,
        "text": " (function) Props",
        "slug": "-function-props"
      },
      {
        "level": 3,
        "text": "Caveats",
        "slug": "caveats"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Search form that leads to a search result page",
        "slug": "search-form-that-leads-to-a-search-result-page"
      },
      {
        "level": 3,
        "text": "Mutations with Server Actions",
        "slug": "mutations-with-server-actions"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "import Form from 'next/form'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <Form action=\"/search\">\r\n      {/* On submission, the input value will be appended to\r\n          the URL, e.g. /search?query=abc */}\r\n      <input name=\"query\" />\r\n      <button type=\"submit\">Submit</button>\r\n    </Form>\r\n  )\r\n}",
        "context": "filename=\"/app/ui/search.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Form from 'next/form'\r\n\r\nexport default function Search() {\r\n  return (\r\n    <Form action=\"/search\">\r\n      {/* On submission, the input value will be appended to\r\n          the URL, e.g. /search?query=abc */}\r\n      <input name=\"query\" />\r\n      <button type=\"submit\">Submit</button>\r\n    </Form>\r\n  )\r\n}",
        "context": "filename=\"/app/ui/search.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Form from 'next/form'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <Form action=\"/search\">\r\n      {/* On submission, the input value will be appended to\r\n          the URL, e.g. /search?query=abc */}\r\n      <input name=\"query\" />\r\n      <button type=\"submit\">Submit</button>\r\n    </Form>\r\n  )\r\n}",
        "context": "filename=\"/ui/search.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Form from 'next/form'\r\n\r\nexport default function Search() {\r\n  return (\r\n    <Form action=\"/search\">\r\n      {/* On submission, the input value will be appended to\r\n          the URL, e.g. /search?query=abc */}\r\n      <input name=\"query\" />\r\n      <button type=\"submit\">Submit</button>\r\n    </Form>\r\n  )\r\n}",
        "context": "filename=\"/ui/search.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Form from 'next/form'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <Form action=\"/search\">\r\n      <input name=\"query\" />\r\n      <button type=\"submit\">Submit</button>\r\n    </Form>\r\n  )\r\n}",
        "context": "filename=\"/app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Form from 'next/form'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <Form action=\"/search\">\r\n      <input name=\"query\" />\r\n      <button type=\"submit\">Submit</button>\r\n    </Form>\r\n  )\r\n}",
        "context": "filename=\"/app/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { getSearchResults } from '@/lib/search'\r\n\r\nexport default async function SearchPage({\r\n  searchParams,\r\n}: {\r\n  searchParams: Promise<{ [key: string]: string | string[] | undefined }>\r\n}) {\r\n  const results = await getSearchResults((await searchParams).query)\r\n\r\n  return <div>...</div>\r\n}",
        "context": "filename=\"/app/search/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { getSearchResults } from '@/lib/search'\r\n\r\nexport default async function SearchPage({ searchParams }) {\r\n  const results = await getSearchResults((await searchParams).query)\r\n\r\n  return <div>...</div>\r\n}",
        "context": "filename=\"/app/search/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default function Loading() {\r\n  return <div>Loading...</div>\r\n}",
        "context": "filename=\"/app/search/loading.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function Loading() {\r\n  return <div>Loading...</div>\r\n}",
        "context": "filename=\"/app/search/loading.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\nimport { useFormStatus } from 'react-dom'\r\n\r\nexport default function SearchButton() {\r\n  const status = useFormStatus()\r\n  return (\r\n    <button type=\"submit\">{status.pending ? 'Searching...' : 'Search'}</button>\r\n  )\r\n}",
        "context": "filename=\"/app/ui/search-button.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\nimport { useFormStatus } from 'react-dom'\r\n\r\nexport default function SearchButton() {\r\n  const status = useFormStatus()\r\n  return (\r\n    <button type=\"submit\">{status.pending ? 'Searching...' : 'Search'}</button>\r\n  )\r\n}",
        "context": "filename=\"/app/ui/search-button.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Form from 'next/form'\r\nimport { SearchButton } from '@/ui/search-button'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <Form action=\"/search\">\r\n      <input name=\"query\" />\r\n      <SearchButton />\r\n    </Form>\r\n  )\r\n}",
        "context": "filename=\"/app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Form from 'next/form'\r\nimport { SearchButton } from '@/ui/search-button'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <Form action=\"/search\">\r\n      <input name=\"query\" />\r\n      <SearchButton />\r\n    </Form>\r\n  )\r\n}",
        "context": "filename=\"/app/ui/search-button.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Form from 'next/form'\r\nimport { createPost } from '@/posts/actions'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <Form action={createPost}>\r\n      <input name=\"title\" />\r\n      {/* ... */}\r\n      <button type=\"submit\">Create Post</button>\r\n    </Form>\r\n  )\r\n}",
        "context": "filename=\"/app/posts/create/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Form from 'next/form'\r\nimport { createPost } from '@/posts/actions'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <Form action={createPost}>\r\n      <input name=\"title\" />\r\n      {/* ... */}\r\n      <button type=\"submit\">Create Post</button>\r\n    </Form>\r\n  )\r\n}",
        "context": "filename=\"/app/posts/create/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use server'\r\nimport { redirect } from 'next/navigation'\r\n\r\nexport async function createPost(formData: FormData) {\r\n  // Create a new post\r\n  // ...\r\n\r\n  // Redirect to the new post\r\n  redirect(`/posts/${data.id}`)\r\n}",
        "context": "filename=\"/app/posts/actions.ts\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use server'\r\nimport { redirect } from 'next/navigation'\r\n\r\nexport async function createPost(formData) {\r\n  // Create a new post\r\n  // ...\r\n\r\n  // Redirect to the new post\r\n  redirect(`/posts/${data.id}`)\r\n}",
        "context": "filename=\"/app/posts/actions.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { getPost } from '@/posts/data'\r\n\r\nexport default async function PostPage({\r\n  params,\r\n}: {\r\n  params: Promise<{ id: string }>\r\n}) {\r\n  const { id } = await params\r\n  const data = await getPost(id)\r\n\r\n  return (\r\n    <div>\r\n      <h1>{data.title}</h1>\r\n      {/* ... */}\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"/app/posts/[id]/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { getPost } from '@/posts/data'\r\n\r\nexport default async function PostPage({ params }) {\r\n  const { id } = await params\r\n  const data = await getPost(id)\r\n\r\n  return (\r\n    <div>\r\n      <h1>{data.title}</h1>\r\n      {/* ... */}\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"/app/posts/[id]/page.js\" switcher"
      }
    ],
    "content": "The component extends the HTML element to provide prefetching of loading UI, client-side navigation on submission, and progressive enhancement. It's useful for forms that update URL search params as it reduces the boilerplate code needed to achieve the above. Basic usage: Reference The behavior of the component depends on whether the action prop is passed a string or function. - When action is a string, the behaves like a native HTML form that uses a GET method. The form data is encoded into the URL as search params, and when the form is submitted, it navigates to the specified URL. In addition, Next.js: - Prefetches the path when the form becomes visible, this preloads shared UI (e.g. layout.js and loading.js), resulting in faster navigation. - Performs a client-side navigation instead of a full page reload when the form is submitted. This retains shared UI and client-side state. - When action is a function (Server Action), behaves like a React form, executing the action when the form is submitted. - When action is a string, the behaves like a native HTML form that uses a GET method. The form data is encoded into the URL as search params, and when the form is submitted, it navigates to the specified URL. In addition, Next.js: - Performs a client-side navigation instead of a full page reload when the form is submitted. This retains shared UI and client-side state. action (string) Props When action is a string, the component supports the following props: | Prop | Example | Type | Required | | --------- | ------------------ | ------------------------------- | -------- | | action | action=\"/search\" | string (URL or relative path) | Yes | | replace | replace={false} | boolean | - | | scroll | scroll={true} | boolean | - | - action: The URL or path to navigate to when the form is submitted. - An empty string \"\" will navigate to the same route with updated search params. - replace: Replaces the current history state instead of pushing a new one to the browser's history stack. Default is false. - scroll: Controls the scroll behavior during navigation. Defaults to true, this means it will scroll to the top of the new route, and maintain the scroll position for backwards and forwards navigation. When action is a string, the component supports the following props: | Prop | Example | Type | Required | | ---------- | ------------------ | ------------------------------- | -------- | | action | action=\"/search\" | string (URL or relative path) | Yes | | replace | replace={false} | boolean | - | | scroll | scroll={true} | boolean | - | | prefetch | prefetch={true} | boolean | - | - action: The URL or path to navigate to when the form is submitted. - An empty string \"\" will navigate to the same route with updated search params. - replace: Replaces the current history state instead of pushing a new one to the browser's history stack. Default is false. - scroll: Controls the scroll behavior during navigation. Defaults to true, this means it will scroll to the top of the new route, and maintain the scroll position for backwards and forwards navigation. - prefetch: Controls whether the path should be prefetched when the form becomes visible in the user's viewport. Defaults to true. action (function) Props When action is a function, the component supports the following prop: | Prop | Example | Type | Required | | -------- | ------------------- | -------------------------- | -------- | | action | action={myAction} | function (Server Action) | Yes | - action: The Server Action to be called when the form is submitted. See the React docs for more. > Good to know: When action is a function, the replace and scroll props are ignored. Caveats - formAction: Can be used in a or fields to override the action prop. Next.js will perform a client-side navigation, however, this approach doesn't support prefetching. - When using basePath, you must also include it in the formAction path. e.g. formAction=\"/base-path/search\". - key: Passing a key prop to a string action is not supported. If you'd like to trigger a re-render or perform a mutation, consider using a function action instead. - onSubmit: Can be used to handle form submission logic. However, calling event.preventDefault() will override behavior such as navigating to the specified URL. - method, encType, target: Are not supported as they override behavior. - Similarly, formMethod, formEncType, and formTarget can be used to override the method, encType, and target props respectively, and using them will fallback to native browser behavior. - If you need to use these props, use the HTML element instead. - : Using this input type when the action is a string will match browser behavior by submitting the filename instead of the file object. Examples Search form that leads to a search result page You can create a search form that navigates to a search results page by passing the path as an action: When the user updates the query input field and submits the form, the form data will be encoded into the URL as search params, e.g. /search?query=abc. > Good to know: If you pass an empty string \"\" to action, the form will navigate to the same route with updated search params. On the results page, you can access the query using the searchParams page.js prop and use it to fetch data from an external source. When the becomes visible in the user's viewport, shared UI (such as layout.js and loading.js) on the /search page will be prefetched. On submission, the form will immediately navigate to the new route and show loading UI while the results are being fetched. You can design the fallback UI using loading.js: To cover cases when shared UI hasn't yet loaded, you can show instant feedback to the user using useFormStatus. First, create a component that displays a loading state when the form is pending: Then, update the search form page to use the SearchButton component: Mutations with Server Actions You can perform mutations by passing a function to the action prop. After a mutation, it's common to redirect to the new resource. You can use the redirect function from next/navigation to navigate to the new post page. > Good to know: Since the \"destination\" of the form submission is not known until the action is executed, cannot automatically prefetch shared UI. Then, in the new page, you can fetch data using the params prop: See the Server Actions docs for more examples.",
    "excerpt": "The component extends the HTML element to provide prefetching of loading UI, client-side navigation on submission, and progressive enhancement. It's useful for forms that update URL search params as i...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/02-components/form"
  },
  {
    "id": "01-app-03-api-reference-02-components-image",
    "path": "01-app\\03-api-reference\\02-components\\image.mdx",
    "title": "Image Component",
    "description": "Optimize Images in your Next.js Application using the built-in `next/image` Component.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Reference",
        "slug": "reference"
      },
      {
        "level": 3,
        "text": "Props",
        "slug": "props"
      },
      {
        "level": 4,
        "text": " and ",
        "slug": "-and-"
      },
      {
        "level": 3,
        "text": "Other Props",
        "slug": "other-props"
      },
      {
        "level": 3,
        "text": "Deprecated props",
        "slug": "deprecated-props"
      },
      {
        "level": 3,
        "text": "Configuration options",
        "slug": "configuration-options"
      },
      {
        "level": 3,
        "text": "Deprecated configuration options",
        "slug": "deprecated-configuration-options"
      },
      {
        "level": 2,
        "text": "Functions",
        "slug": "functions"
      },
      {
        "level": 2,
        "text": "Known browser bugs",
        "slug": "known-browser-bugs"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Styling images",
        "slug": "styling-images"
      },
      {
        "level": 3,
        "text": "Responsive images with a static export",
        "slug": "responsive-images-with-a-static-export"
      },
      {
        "level": 3,
        "text": "Responsive images with a remote URL",
        "slug": "responsive-images-with-a-remote-url"
      },
      {
        "level": 3,
        "text": "Responsive image with ",
        "slug": "responsive-image-with-"
      },
      {
        "level": 3,
        "text": "Background Image",
        "slug": "background-image"
      },
      {
        "level": 3,
        "text": "Remote images",
        "slug": "remote-images"
      },
      {
        "level": 3,
        "text": "Theme detection",
        "slug": "theme-detection"
      },
      {
        "level": 3,
        "text": "Art direction",
        "slug": "art-direction"
      },
      {
        "level": 3,
        "text": "Background CSS",
        "slug": "background-css"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "jsx",
        "code": "import Image from 'next/image'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <Image\r\n      src=\"/profile.png\"\r\n      width={500}\r\n      height={500}\r\n      alt=\"Picture of the author\"\r\n    />\r\n  )\r\n}",
        "context": "filename=\"app/page.js\""
      },
      {
        "language": "jsx",
        "code": "<Image src=\"/profile.png\" />",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "<Image src=\"https://example.com/profile.png\" />",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import profile from './profile.png'\r\n\r\nexport default function Page() {\r\n  return <Image src={profile} />\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "<Image src=\"/profile.png\" width={500} height={500} />",
        "context": ""
      },
      {
        "language": "js",
        "code": "<Image src=\"/profile.png\" fill={true} />",
        "context": ""
      },
      {
        "language": "js",
        "code": "'use client'\r\n\r\nimport Image from 'next/image'\r\n\r\nconst imageLoader = ({ src, width, quality }) => {\r\n  return `https://example.com/${src}?w=${width}&q=${quality || 75}`\r\n}\r\n\r\nexport default function Page() {\r\n  return (\r\n    <Image\r\n      loader={imageLoader}\r\n      src=\"me.png\"\r\n      alt=\"Picture of the author\"\r\n      width={500}\r\n      height={500}\r\n    />\r\n  )\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "import Image from 'next/image'\r\n\r\nconst imageLoader = ({ src, width, quality }) => {\r\n  return `https://example.com/${src}?w=${width}&q=${quality || 75}`\r\n}\r\n\r\nexport default function Page() {\r\n  return (\r\n    <Image\r\n      loader={imageLoader}\r\n      src=\"me.png\"\r\n      alt=\"Picture of the author\"\r\n      width={500}\r\n      height={500}\r\n    />\r\n  )\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import Image from 'next/image'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <div className=\"grid-element\">\r\n      <Image\r\n        fill\r\n        src=\"/example.png\"\r\n        sizes=\"(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw\"\r\n      />\r\n    </div>\r\n  )\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "// Default quality is 75\r\n<Image quality={75} />",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "const imageStyle = {\r\n  borderRadius: '50%',\r\n  border: '1px solid #fff',\r\n  width: '100px',\r\n  height: 'auto',\r\n}\r\n\r\nexport default function ProfileImage() {\r\n  return <Image src=\"...\" style={imageStyle} />\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "// Default preload is false\r\n<Image preload={false} />",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "// Defaults to lazy\r\n<Image loading=\"lazy\" />",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "// defaults to empty\r\n<Image placeholder=\"empty\" />",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "<Image placeholder=\"blur\" blurDataURL=\"...\" />",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "<Image onLoad={(e) => console.log(e.target.naturalWidth)} />",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "<Image onError={(e) => console.error(e.target.id)} />",
        "context": ""
      },
      {
        "language": "js",
        "code": "import Image from 'next/image'\r\n\r\nconst UnoptimizedImage = (props) => {\r\n  // Default is false\r\n  return <Image {...props} unoptimized />\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    unoptimized: true,\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "jsx",
        "code": "<Image src=\"/profile.jpg\" />",
        "context": "filename=\"input.js\""
      },
      {
        "language": "html",
        "code": "<img\r\n  srcset=\"\r\n    /_next/image?url=%2Fprofile.jpg&w=640&q=75 1x,\r\n    /_next/image?url=%2Fprofile.jpg&w=828&q=75 2x\r\n  \"\r\n  src=\"/_next/image?url=%2Fprofile.jpg&w=828&q=75\"\r\n/>",
        "context": "filename=\"output.html\""
      },
      {
        "language": "jsx",
        "code": "<Image src=\"/profile.jpg\" overrideSrc=\"/override.jpg\" />",
        "context": "filename=\"input.js\""
      },
      {
        "language": "html",
        "code": "<img\r\n  srcset=\"\r\n    /_next/image?url=%2Fprofile.jpg&w=640&q=75 1x,\r\n    /_next/image?url=%2Fprofile.jpg&w=828&q=75 2x\r\n  \"\r\n  src=\"/override.jpg\"\r\n/>",
        "context": "filename=\"output.html\""
      },
      {
        "language": "jsx",
        "code": "// Default is async\r\n<Image decoding=\"async\" />",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\n<Image onLoadingComplete={(img) => console.log(img.naturalWidth)} />",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "<Image onLoadingComplete={(img) => console.log(img.naturalWidth)} />",
        "context": ""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    localPatterns: [\r\n      {\r\n        pathname: '/assets/images/**',\r\n        search: '',\r\n      },\r\n    ],\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    remotePatterns: [new URL('https://example.com/account123/**')],\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    remotePatterns: [\r\n      {\r\n        protocol: 'https',\r\n        hostname: 'example.com',\r\n        port: '',\r\n        pathname: '/account123/**',\r\n        search: '',\r\n      },\r\n    ],\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    remotePatterns: [\r\n      {\r\n        protocol: 'https',\r\n        hostname: '**.example.com',\r\n        port: '',\r\n        search: '',\r\n      },\r\n    ],\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    remotePatterns: [\r\n      {\r\n        protocol: 'https',\r\n        hostname: 'assets.example.com',\r\n        search: '?v=1727111025337',\r\n      },\r\n    ],\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    loader: 'custom',\r\n    loaderFile: './my/image/loader.js',\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "'use client'\r\n\r\nexport default function myImageLoader({ src, width, quality }) {\r\n  return `https://example.com/${src}?w=${width}&q=${quality || 75}`\r\n}",
        "context": "filename=\"my/image/loader.js\""
      },
      {
        "language": "js",
        "code": "export default function myImageLoader({ src, width, quality }) {\r\n  return `https://example.com/${src}?w=${width}&q=${quality || 75}`\r\n}",
        "context": "filename=\"my/image/loader.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    path: '/my-prefix/_next/image',\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    imageSizes: [32, 48, 64, 96, 128, 256, 384],\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    qualities: [75],\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    qualities: [25, 50, 75, 100],\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    // Default\r\n    formats: ['image/webp'],\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    formats: ['image/avif'],\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    minimumCacheTTL: 14400, // 4 hours\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    minimumCacheTTL: 2678400, // 31 days\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    disableStaticImages: true,\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    maximumRedirects: 3,\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    maximumRedirects: 0,\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    dangerouslyAllowLocalIP: false,\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    dangerouslyAllowLocalIP: true,\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    dangerouslyAllowSVG: true,\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "jsx",
        "code": "<Image src=\"/my-image.svg\" unoptimized />",
        "context": ""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    dangerouslyAllowSVG: true,\r\n    contentDispositionType: 'attachment',\r\n    contentSecurityPolicy: \"default-src 'self'; script-src 'none'; sandbox;\",\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    contentDispositionType: 'inline',\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    contentSecurityPolicy: \"default-src 'self'; script-src 'none'; sandbox;\",\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    domains: ['assets.acme.com'],\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "jsx",
        "code": "import { getImageProps } from 'next/image'\r\n\r\nconst { props } = getImageProps({\r\n  src: 'https://example.com/image.jpg',\r\n  alt: 'A scenic mountain view',\r\n  width: 1200,\r\n  height: 800,\r\n})\r\n\r\nfunction ImageWithCaption() {\r\n  return (\r\n    <figure>\r\n      <img {...props} />\r\n      <figcaption>A scenic mountain view</figcaption>\r\n    </figure>\r\n  )\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import styles from './styles.module.css'\r\n\r\nexport default function MyImage() {\r\n  return <Image className={styles.image} src=\"/my-image.png\" alt=\"My Image\" />\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "export default function MyImage() {\r\n  return (\r\n    <Image style={{ borderRadius: '8px' }} src=\"/my-image.png\" alt=\"My Image\" />\r\n  )\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "<div style={{ position: 'relative' }}>\r\n  <Image fill src=\"/my-image.png\" alt=\"My Image\" />\r\n</div>",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import Image from 'next/image'\r\nimport mountains from '../public/mountains.jpg'\r\n\r\nexport default function Responsive() {\r\n  return (\r\n    <div style={{ display: 'flex', flexDirection: 'column' }}>\r\n      <Image\r\n        alt=\"Mountains\"\r\n        // Importing an image will\r\n        // automatically set the width and height\r\n        src={mountains}\r\n        sizes=\"100vw\"\r\n        // Make the image display full width\r\n        // and preserve its aspect ratio\r\n        style={{\r\n          width: '100%',\r\n          height: 'auto',\r\n        }}\r\n      />\r\n    </div>\r\n  )\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import Image from 'next/image'\r\n\r\nexport default function Page({ photoUrl }) {\r\n  return (\r\n    <Image\r\n      src={photoUrl}\r\n      alt=\"Picture of the author\"\r\n      sizes=\"100vw\"\r\n      style={{\r\n        width: '100%',\r\n        height: 'auto',\r\n      }}\r\n      width={500}\r\n      height={300}\r\n    />\r\n  )\r\n}",
        "context": "filename=\"components/page.js\""
      },
      {
        "language": "jsx",
        "code": "import Image from 'next/image'\r\nimport mountains from '../public/mountains.jpg'\r\n\r\nexport default function Fill() {\r\n  return (\r\n    <div\r\n      style={{\r\n        display: 'grid',\r\n        gridGap: '8px',\r\n        gridTemplateColumns: 'repeat(auto-fit, minmax(400px, auto))',\r\n      }}\r\n    >\r\n      <div style={{ position: 'relative', width: '400px' }}>\r\n        <Image\r\n          alt=\"Mountains\"\r\n          src={mountains}\r\n          fill\r\n          sizes=\"(min-width: 808px) 50vw, 100vw\"\r\n          style={{\r\n            objectFit: 'cover', // cover, contain, none\r\n          }}\r\n        />\r\n      </div>\r\n      {/* And more images in the grid... */}\r\n    </div>\r\n  )\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import Image from 'next/image'\r\nimport mountains from '../public/mountains.jpg'\r\n\r\nexport default function Background() {\r\n  return (\r\n    <Image\r\n      alt=\"Mountains\"\r\n      src={mountains}\r\n      placeholder=\"blur\"\r\n      quality={100}\r\n      fill\r\n      sizes=\"100vw\"\r\n      style={{\r\n        objectFit: 'cover',\r\n      }}\r\n    />\r\n  )\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import Image from 'next/image'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <Image\r\n      src=\"https://s3.amazonaws.com/my-bucket/profile.png\"\r\n      alt=\"Picture of the author\"\r\n      width={500}\r\n      height={500}\r\n    />\r\n  )\r\n}",
        "context": "filename=\"app/page.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    remotePatterns: [\r\n      {\r\n        protocol: 'https',\r\n        hostname: 's3.amazonaws.com',\r\n        port: '',\r\n        pathname: '/my-bucket/**',\r\n        search: '',\r\n      },\r\n    ],\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "css",
        "code": ".imgDark {\r\n  display: none;\r\n}\r\n\r\n@media (prefers-color-scheme: dark) {\r\n  .imgLight {\r\n    display: none;\r\n  }\r\n  .imgDark {\r\n    display: unset;\r\n  }\r\n}",
        "context": "filename=\"components/theme-image.module.css\""
      },
      {
        "language": "tsx",
        "code": "import styles from './theme-image.module.css'\r\nimport Image, { ImageProps } from 'next/image'\r\n\r\ntype Props = Omit<ImageProps, 'src' | 'preload' | 'loading'> & {\r\n  srcLight: string\r\n  srcDark: string\r\n}\r\n\r\nconst ThemeImage = (props: Props) => {\r\n  const { srcLight, srcDark, ...rest } = props\r\n\r\n  return (\r\n    <>\r\n      <Image {...rest} src={srcLight} className={styles.imgLight} />\r\n      <Image {...rest} src={srcDark} className={styles.imgDark} />\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"components/theme-image.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import styles from './theme-image.module.css'\r\nimport Image from 'next/image'\r\n\r\nconst ThemeImage = (props) => {\r\n  const { srcLight, srcDark, ...rest } = props\r\n\r\n  return (\r\n    <>\r\n      <Image {...rest} src={srcLight} className={styles.imgLight} />\r\n      <Image {...rest} src={srcDark} className={styles.imgDark} />\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"components/theme-image.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { getImageProps } from 'next/image'\r\n\r\nexport default function Home() {\r\n  const common = { alt: 'Art Direction Example', sizes: '100vw' }\r\n  const {\r\n    props: { srcSet: desktop },\r\n  } = getImageProps({\r\n    ...common,\r\n    width: 1440,\r\n    height: 875,\r\n    quality: 80,\r\n    src: '/desktop.jpg',\r\n  })\r\n  const {\r\n    props: { srcSet: mobile, ...rest },\r\n  } = getImageProps({\r\n    ...common,\r\n    width: 750,\r\n    height: 1334,\r\n    quality: 70,\r\n    src: '/mobile.jpg',\r\n  })\r\n\r\n  return (\r\n    <picture>\r\n      <source media=\"(min-width: 1000px)\" srcSet={desktop} />\r\n      <source media=\"(min-width: 500px)\" srcSet={mobile} />\r\n      <img {...rest} style={{ width: '100%', height: 'auto' }} />\r\n    </picture>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\""
      },
      {
        "language": "jsx",
        "code": "import { getImageProps } from 'next/image'\r\n\r\nfunction getBackgroundImage(srcSet = '') {\r\n  const imageSet = srcSet\r\n    .split(', ')\r\n    .map((str) => {\r\n      const [url, dpi] = str.split(' ')\r\n      return `url(\"${url}\") ${dpi}`\r\n    })\r\n    .join(', ')\r\n  return `image-set(${imageSet})`\r\n}\r\n\r\nexport default function Home() {\r\n  const {\r\n    props: { srcSet },\r\n  } = getImageProps({ alt: '', width: 128, height: 128, src: '/img.png' })\r\n  const backgroundImage = getBackgroundImage(srcSet)\r\n  const style = { height: '100vh', width: '100vw', backgroundImage }\r\n\r\n  return (\r\n    <main style={style}>\r\n      <h1>Hello World</h1>\r\n    </main>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\""
      }
    ],
    "content": "The Next.js Image component extends the HTML element for automatic image optimization. > Good to know: If you are using a version of Next.js prior to 13, you'll want to use the next/legacy/image documentation since the component was renamed. Reference Props The following props are available: | Prop | Example | Type | Status | | ----------------------------------------- | ---------------------------------------- | --------------- | ---------- | | src | src=\"/profile.png\" | String | Required | | alt | alt=\"Picture of the author\" | String | Required | | width | width={500} | Integer (px) | - | | height | height={500} | Integer (px) | - | | fill | fill={true} | Boolean | - | | loader | loader={imageLoader} | Function | - | | sizes | sizes=\"(max-width: 768px) 100vw, 33vw\" | String | - | | quality | quality={80} | Integer (1-100) | - | | preload | preload={true} | Boolean | - | | placeholder | placeholder=\"blur\" | String | - | | style | style={{objectFit: \"contain\"}} | Object | - | | onLoadingComplete | onLoadingComplete={img => done())} | Function | Deprecated | | onLoad | onLoad={event => done())} | Function | - | | onError | onError(event => fail()} | Function | - | | loading | loading=\"lazy\" | String | - | | blurDataURL | blurDataURL=\"data:image/jpeg...\" | String | - | | unoptimized | unoptimized={true} | Boolean | - | | overrideSrc | overrideSrc=\"/seo.png\" | String | - | | decoding | decoding=\"async\" | String | - | src The source of the image. Can be one of the following: An internal path string. An absolute external URL (must be configured with remotePatterns). A static import. > Good to know: For security reasons, the Image Optimization API using the default loader will not forward headers when fetching the src image. > If the src image requires authentication, consider using the unoptimized property to disable Image Optimization. alt The alt property is used to describe the image for screen readers and search engines. It is also the fallback text if images have been disabled or an error occurs while loading the image. It should contain text that could replace the image without changing the meaning of the page. It is not meant to supplement the image and should not repeat information that is already provided in the captions above or below the image. If the image is purely decorative or not intended for the user, the alt property should be an empty string (alt=\"\"). > Learn more about image accessibility guidelines. width and height The width and height properties represent the intrinsic image size in pixels. This property is used to infer the correct aspect ratio used by browsers to reserve space for the image and avoid layout shift during loading. It does not determine the rendered size of the image, which is controlled by CSS. You must set both width and height properties unless: - The image is statically imported. - The image has the fill property If the height and width are unknown, we recommend using the fill property. fill A boolean that causes the image to expand to the size of the parent element. Positioning: - The parent element must assign position: \"relative\", \"fixed\", \"absolute\". - By default, the element uses position: \"absolute\". Object Fit: If no styles are applied to the image, the image will stretch to fit the container. You can use objectFit to control cropping and scaling. - \"contain\": The image will be scaled down to fit the container and preserve aspect ratio. - \"cover\": The image will fill the container and be cropped. > Learn more about position and object-fit. loader A custom function used to generate the image URL. The function receives the following parameters, and returns a URL string for the image: - src - width - quality > Good to know: Using props like onLoad, which accept a function, requires using Client Components to serialize the provided function. Alternatively, you can use the loaderFile configuration in next.config.js to configure every instance of next/image in your application, without passing a prop. sizes Define the sizes of the image at different breakpoints. Used by the browser to choose the most appropriate size from the generated srcset. sizes should be used when: - The image is using the fill prop - CSS is used to make the image responsive If sizes is missing, the browser assumes the image will be as wide as the viewport (100vw). This can cause unnecessarily large images to be downloaded. In addition, sizes affects how srcset is generated: - Without sizes: Next.js generates a limited srcset (e.g. 1x, 2x), suitable for fixed-size images. - With sizes: Next.js generates a full srcset (e.g. 640w, 750w, etc.), optimized for responsive layouts. > Learn more about srcset and sizes on web.dev and mdn. quality An integer between 1 and 100 that sets the quality of the optimized image. Higher values increase file size and visual fidelity. Lower values reduce file size but may affect sharpness. If you’ve configured qualities in next.config.js, the value must match one of the allowed entries. > Good to know: If the original image is already low quality, setting a high quality value will increase the file size without improving appearance. style Allows passing CSS styles to the underlying image element. > Good to know: If you’re using the style prop to set a custom width, be sure to also set height: 'auto' to preserve the image’s aspect ratio. preload A boolean that indicates if the image should be preloaded. - true: Preloads the image by inserting a in the . - false: Does not preload the image. When to use it: - The image is the Largest Contentful Paint (LCP) element. - The image is above the fold, typically the hero image. - You want to begin loading the image in the , before its discovered later in the . When not to use it: - When you have multiple images that could be considered the Largest Contentful Paint (LCP) element depending on the viewport. - When the loading property is used. - When the fetchPriority property is used. In most cases, you should use loading=\"eager\" or fetchPriority=\"high\" instead of preload. priority Starting with Next.js 16, the priority property has been deprecated in favor of the preload property in order to make the behavior clear. loading Controls when the image should start loading. - lazy: Defer loading the image until it reaches a calculated distance from the viewport. - eager: Load the image immediately, regardless of its position in the page. Use eager only when you want to ensure the image is loaded immediately. > Learn more about the loading attribute. placeholder Specifies a placeholder to use while the image is loading, improving the perceived loading performance. - empty: No placeholder while the image is loading. - blur: Use a blurred version of the image as a placeholder. Must be used with the blurDataURL property. - data:image/...: Uses the Data URL as the placeholder. Examples: - blur placeholder - Shimmer effect with data URL placeholder prop - Color effect with blurDataURL prop > Learn more about the placeholder attribute. blurDataURL A Data URL to be used as a placeholder image before the image successfully loads. Can be automatically set or used with the placeholder=\"blur\" property. The image is automatically enlarged and blurred, so a very small image (10px or less) is recommended. Automatic If src is a static import of a jpg, png, webp, or avif file, blurDataURL is added automatically—unless the image is animated. Manually set If the image is dynamic or remote, you must provide blurDataURL yourself. To generate one, you can use: - A online tool like png-pixel.com - A library like Plaiceholder A large blurDataURL may hurt performance. Keep it small and simple. Examples: - Default blurDataURL prop - Color effect with blurDataURL prop onLoad A callback function that is invoked once the image is completely loaded and the placeholder has been removed. The callback function will be called with one argument, the event which has a target that references the underlying element. > Good to know: Using props like onLoad, which accept a function, requires using Client Components to serialize the provided function. onError A callback function that is invoked if the image fails to load. > Good to know: Using props like onError, which accept a function, requires using Client Components to serialize the provided function. unoptimized A boolean that indicates if the image should be optimized. This is useful for images that do not benefit from optimization such as small images (less than 1KB), vector images (SVG), or animated images (GIF). - true: The source image will be served as-is from the src instead of changing quality, size, or format. - false: The source image will be optimized. Since Next.js 12.3.0, this prop can be assigned to all images by updating next.config.js with the following configuration: overrideSrc When providing the src prop to the component, both the srcset and src attributes are generated automatically for the resulting . In some cases, it is not desirable to have the src attribute generated and you may wish to override it using the overrideSrc prop. For example, when upgrading an existing website from to , you may wish to maintain the same src attribute for SEO purposes such as image ranking or avoiding recrawl. decoding A hint to the browser indicating if it should wait for the image to be decoded before presenting other content updates or not. - async: Asynchronously decode the image and allow other content to be rendered before it completes. - sync: Synchronously decode the image for atomic presentation with other content. - auto: No preference. The browser chooses the best approach. > Learn more about the decoding attribute. Other Props Other properties on the component will be passed to the underlying img element with the exception of the following: - srcSet: Use Device Sizes instead. Deprecated props onLoadingComplete > Warning: Deprecated in Next.js 14, use onLoad instead. A callback function that is invoked once the image is completely loaded and the placeholder has been removed. The callback function will be called with one argument, a reference to the underlying element. > Good to know: Using props like onLoadingComplete, which accept a function, requires using Client Components to serialize the provided function. Configuration options You can configure the Image Component in next.config.js. The following options are available: localPatterns Use localPatterns in your next.config.js file to allow images from specific local paths to be optimized and block all others. The example above will ensure the src property of next/image must start with /assets/images/ and must not have a query string. Attempting to optimize any other path will respond with 400 Bad Request error. > Good to know: Omitting the search property allows all search parameters which could allow malicious actors to optimize URLs you did not intend. Try using a specific value like search: '?v=2' to ensure an exact match. remotePatterns Use remotePatterns in your next.config.js file to allow images from specific external paths and block all others. This ensures that only external images from your account can be served. You can also configure remotePatterns using the object: The example above will ensure the src property of next/image must start with https://example.com/account123/ and must not have a query string. Any other protocol, hostname, port, or unmatched path will respond with 400 Bad Request. Wildcard Patterns: Wildcard patterns can be used for both pathname and hostname and have the following syntax: - match a single path segment or subdomain - match any number of path segments at the end or subdomains at the beginning. This syntax does not work in the middle of the pattern. This allows subdomains like image.example.com. Query strings and custom ports are still blocked. > Good to know: When omitting protocol, port, pathname, or search then the wildcard is implied. This is not recommended because it may allow malicious actors to optimize urls you did not intend. Query Strings: You can also restrict query strings using the search property: The example above will ensure the src property of next/image must start with https://assets.example.com and must have the exact query string ?v=1727111025337. Any other protocol or query string will respond with 400 Bad Request. loaderFile loaderFiles allows you to use a custom image optimization service instead of Next.js. The path must be relative to the project root. The file must export a default function that returns a URL string: Example: - Custom Image Loader Configuration > Alternatively, you can use the loader prop to configure each instance of next/image. path If you want to change or prefix the default path for the Image Optimization API, you can do so with the path property. The default value for path is /next/image. deviceSizes deviceSizes allows you to specify a list of device width breakpoints. These widths are used when the next/image component uses sizes prop to ensure the correct image is served for the user's device. If no configuration is provided, the default below is used: imageSizes imageSizes allows you to specify a list of image widths. These widths are concatenated with the array of device sizes to form the full array of sizes used to generate image srcset. If no configuration is provided, the default below is used: imageSizes is only used for images which provide a sizes prop, which indicates that the image is less than the full width of the screen. Therefore, the sizes in imageSizes should all be smaller than the smallest size in deviceSizes. qualities qualities allows you to specify a list of image quality values. If not configuration is provided, the default below is used: > Good to know: This field is required starting with Next.js 16 because unrestricted access could allow malicious actors to optimize more qualities than you intended. You can add more image qualities to the allowlist, such as the following: In the example above, only four qualities are allowed: 25, 50, 75, and 100. If the quality prop does not match a value in this array, the closest allowed value will be used. If the REST API is visited directly with a quality that does not match a value in this array, the server will return a 400 Bad Request response. formats formats allows you to specify a list of image formats to be used. Next.js automatically detects the browser's supported image formats via the request's Accept header in order to determine the best output format. If the Accept header matches more than one of the configured formats, the first match in the array is used. Therefore, the array order matters. If there is no match (or the source image is animated), it will use the original image's format. You can enable AVIF support, which will fallback to the original format of the src image if the browser does not support AVIF: > Good to know: > > - We still recommend using WebP for most use cases. > - AVIF generally takes 50% longer to encode but it compresses 20% smaller compared to WebP. This means that the first time an image is requested, it will typically be slower, but subsequent requests that are cached will be faster. > - If you self-host with a Proxy/CDN in front of Next.js, you must configure the Proxy to forward the Accept header. minimumCacheTTL minimumCacheTTL allows you to configure the Time to Live (TTL) in seconds for cached optimized images. In many cases, it's better to use a Static Image Import which will automatically hash the file contents and cache the image forever with a Cache-Control header of immutable. If no configuration is provided, the default below is used. You can increase the TTL to reduce the number of revalidations and potentially lower cost: The expiration (or rather Max Age) of the optimized image is defined by either the minimumCacheTTL or the upstream image Cache-Control header, whichever is larger. If you need to change the caching behavior per image, you can configure headers to set the Cache-Control header on the upstream image (e.g. /some-asset.jpg, not /next/image itself). There is no mechanism to invalidate the cache at this time, so its best to keep minimumCacheTTL low. Otherwise you may need to manually change the src prop or delete the cached file /cache/images. disableStaticImages disableStaticImages allows you to disable static image imports. The default behavior allows you to import static files such as import icon from './icon.png' and then pass that to the src property. In some cases, you may wish to disable this feature if it conflicts with other plugins that expect the import to behave differently. You can disable static image imports inside your next.config.js: maximumRedirects The default image optimization loader will follow HTTP redirects when fetching remote images up to 3 times. You can configure the number of redirects to follow when fetching remote images. Setting the value to 0 will disable following redirects. dangerouslyAllowLocalIP In rare cases when self-hosting Next.js on a private network, you may want to allow optimizing images from local IP addresses on the same network. This is not recommended for most users because it could allow malicious users to access content on your internal network. By default, the value is false. If you need to optimize remote images hosted elsewhere in your local network, you can set the value to true. dangerouslyAllowSVG dangerouslyAllowSVG allows you to serve SVG images. By default, Next.js does not optimize SVG images for a few reasons: - SVG is a vector format meaning it can be resized losslessly. - SVG has many of the same features as HTML/CSS, which can lead to vulnerabilities without proper Content Security Policy (CSP) headers. We recommend using the unoptimized prop when the src prop is known to be SVG. This happens automatically when src ends with \".svg\". In addition, it is strongly recommended to also set contentDispositionType to force the browser to download the image, as well as contentSecurityPolicy to prevent scripts embedded in the image from executing. contentDispositionType contentDispositionType allows you to configure the Content-Disposition header. contentSecurityPolicy contentSecurityPolicy allows you to configure the Content-Security-Policy header for images. This is particularly important when using dangerouslyAllowSVG to prevent scripts embedded in the image from executing. By default, the loader sets the Content-Disposition header to attachment for added protection since the API can serve arbitrary remote images. The default value is attachment which forces the browser to download the image when visiting directly. This is particularly important when dangerouslyAllowSVG is true. You can optionally configure inline to allow the browser to render the image when visiting directly, without downloading it. Deprecated configuration options domains > Warning: Deprecated since Next.js 14 in favor of strict remotePatterns in order to protect your application from malicious users. Similar to remotePatterns, the domains configuration can be used to provide a list of allowed hostnames for external images. However, the domains configuration does not support wildcard pattern matching and it cannot restrict protocol, port, or pathname. Since most remote image servers are shared between multiple tenants, it's safer to use remotePatterns to ensure only the intended images are optimized. Below is an example of the domains property in the next.config.js file: Functions getImageProps The getImageProps function can be used to get the props that would be passed to the underlying element, and instead pass them to another component, style, canvas, etc. This also avoid calling React useState() so it can lead to better performance, but it cannot be used with the placeholder prop because the placeholder will never be removed. Known browser bugs This next/image component uses browser native lazy loading, which may fallback to eager loading for older browsers before Safari 15.4. When using the blur-up placeholder, older browsers before Safari 12 will fallback to empty placeholder. When using styles with width/height of auto, it is possible to cause Layout Shift on older browsers before Safari 15 that don't preserve the aspect ratio. For more details, see this MDN video. - Safari 15 - 16.3 display a gray border while loading. Safari 16.4 fixed this issue. Possible solutions: - Use CSS @supports (font: -apple-system-body) and (-webkit-appearance: none) { img[loading=\"lazy\"] { clip-path: inset(0.6px) } } - Use loading=\"eager\" if the image is above the fold - Firefox 67+ displays a white background while loading. Possible solutions: - Enable AVIF formats - Use placeholder Examples Styling images Styling the Image component is similar to styling a normal element, but there are a few guidelines to keep in mind: Use className or style, not styled-jsx. In most cases, we recommend using the className prop. This can be an imported CSS Module, a global stylesheet, etc. You can also use the style prop to assign inline styles. When using fill, the parent element must have position: relative or display: block. This is necessary for the proper rendering of the image element in that layout mode. You cannot use styled-jsx because it's scoped to the current component (unless you mark the style as global). Responsive images with a static export When you import a static image, Next.js automatically sets its width and height based on the file. You can make the image responsive by setting the style: Responsive images with a remote URL If the source image is a dynamic or a remote URL, you must provide the width and height props so Next.js can calculate the aspect ratio: Try it out: - Demo the image responsive to viewport Responsive image with fill If you don't know the aspect ratio of the image, you can add the fill prop with the objectFit prop set to cover. This will make the image fill the full width of its parent container. Background Image Use the fill prop to make the image cover the entire screen area: For examples of the Image component used with the various styles, see the Image Component Demo. Remote images To use a remote image, the src property should be a URL string. Since Next.js does not have access to remote files during the build process, you'll need to provide the width, height and optional blurDataURL props manually. The width and height attributes are used to infer the correct aspect ratio of image and avoid layout shift from the image loading in. The width and height do not determine the rendered size of the image file. To safely allow optimizing images, define a list of supported URL patterns in next.config.js. Be as specific as possible to prevent malicious usage. For example, the following configuration will only allow images from a specific AWS S3 bucket: Theme detection If you want to display a different image for light and dark mode, you can create a new component that wraps two components and reveals the correct one based on a CSS media query. > Good to know: The default behavior of loading=\"lazy\" ensures that only the correct image is loaded. You cannot use preload or loading=\"eager\" because that would cause both images to load. Instead, you can use fetchPriority=\"high\". Try it out: - Demo light/dark mode theme detection Art direction If you want to display a different image for mobile and desktop, sometimes called Art Direction, you can provide different src, width, height, and quality props to getImageProps(). Background CSS You can even convert the srcSet string to the image-set() CSS function to optimize a background image. Version History | Version | Changes | | ---------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | | v16.0.0 | qualities default configuration changed to [75], preload prop added, priority prop deprecated, dangerouslyAllowLocalIP config added, maximumRedirects config added. | | v15.3.0 | remotePatterns added support for array of URL objects. | | v15.0.0 | contentDispositionType configuration default changed to attachment. | | v14.2.23 | qualities configuration added. | | v14.2.15 | decoding prop added and localPatterns configuration added. | | v14.2.14 | remotePatterns.search prop added. | | v14.2.0 | overrideSrc prop added. | | v14.1.0 | getImageProps() is stable. | | v14.0.0 | onLoadingComplete prop and domains config deprecated. | | v13.4.14 | placeholder prop support for data:/image... | | v13.2.0 | contentDispositionType configuration added. | | v13.0.6 | ref prop added. | | v13.0.0 | The next/image import was renamed to next/legacy/image. The next/future/image import was renamed to next/image. A codemod is available to safely and automatically rename your imports. wrapper removed. layout, objectFit, objectPosition, lazyBoundary, lazyRoot props removed. alt is required. onLoadingComplete receives reference to img element. Built-in loader config removed. | | v12.3.0 | remotePatterns and unoptimized configuration is stable. | | v12.2.0 | Experimental remotePatterns and experimental unoptimized configuration added. layout=\"raw\" removed. | | v12.1.1 | style prop added. Experimental support for layout=\"raw\" added. | | v12.1.0 | dangerouslyAllowSVG and contentSecurityPolicy configuration added. | | v12.0.9 | lazyRoot prop added. | | v12.0.0 | formats configuration added.AVIF support added.Wrapper changed to . | | v11.1.0 | onLoadingComplete and lazyBoundary props added. | | v11.0.0 | src prop support for static import.placeholder prop added.blurDataURL prop added. | | v10.0.5 | loader prop added. | | v10.0.1 | layout prop added. | | v10.0.0 | next/image introduced. |",
    "excerpt": "The Next.js Image component extends the HTML element for automatic image optimization. > Good to know: If you are using a version of Next.js prior to 13, you'll want to use the next/legacy/image docum...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/02-components/image"
  },
  {
    "id": "01-app-03-api-reference-02-components-index",
    "path": "01-app\\03-api-reference\\02-components\\index.mdx",
    "title": "Components",
    "description": "API Reference for Next.js built-in components.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/02-components"
  },
  {
    "id": "01-app-03-api-reference-02-components-link",
    "path": "01-app\\03-api-reference\\02-components\\link.mdx",
    "title": "Link Component",
    "description": "Enable fast client-side navigation with the built-in `next/link` component.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Reference",
        "slug": "reference"
      },
      {
        "level": 3,
        "text": " (required)",
        "slug": "-required"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Linking to dynamic route segments",
        "slug": "linking-to-dynamic-route-segments"
      },
      {
        "level": 3,
        "text": "Checking active links",
        "slug": "checking-active-links"
      },
      {
        "level": 3,
        "text": "Linking to dynamic route segments",
        "slug": "linking-to-dynamic-route-segments"
      },
      {
        "level": 3,
        "text": "Scrolling to an ",
        "slug": "scrolling-to-an-"
      },
      {
        "level": 3,
        "text": "Passing a URL Object",
        "slug": "passing-a-url-object"
      },
      {
        "level": 3,
        "text": "Replace the URL instead of push",
        "slug": "replace-the-url-instead-of-push"
      },
      {
        "level": 3,
        "text": "Disable scrolling to the top of the page",
        "slug": "disable-scrolling-to-the-top-of-the-page"
      },
      {
        "level": 3,
        "text": "Prefetching links in Proxy",
        "slug": "prefetching-links-in-proxy"
      },
      {
        "level": 3,
        "text": "Blocking navigation",
        "slug": "blocking-navigation"
      },
      {
        "level": 2,
        "text": "Version history",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Page() {\r\n  return <Link href=\"/dashboard\">Dashboard</Link>\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Page() {\r\n  return <Link href=\"/dashboard\">Dashboard</Link>\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Home() {\r\n  return <Link href=\"/dashboard\">Dashboard</Link>\r\n}",
        "context": "filename=\"pages/index.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Home() {\r\n  return <Link href=\"/dashboard\">Dashboard</Link>\r\n}",
        "context": "filename=\"pages/index.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\n\r\n// Navigate to /about?name=test\r\nexport default function Page() {\r\n  return (\r\n    <Link\r\n      href={{\r\n        pathname: '/about',\r\n        query: { name: 'test' },\r\n      }}\r\n    >\r\n      About\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\n// Navigate to /about?name=test\r\nexport default function Page() {\r\n  return (\r\n    <Link\r\n      href={{\r\n        pathname: '/about',\r\n        query: { name: 'test' },\r\n      }}\r\n    >\r\n      About\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\n\r\n// Navigate to /about?name=test\r\nexport default function Home() {\r\n  return (\r\n    <Link\r\n      href={{\r\n        pathname: '/about',\r\n        query: { name: 'test' },\r\n      }}\r\n    >\r\n      About\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"pages/index.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\n// Navigate to /about?name=test\r\nexport default function Home() {\r\n  return (\r\n    <Link\r\n      href={{\r\n        pathname: '/about',\r\n        query: { name: 'test' },\r\n      }}\r\n    >\r\n      About\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"pages/index.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <Link href=\"/dashboard\" replace>\r\n      Dashboard\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <Link href=\"/dashboard\" replace>\r\n      Dashboard\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Home() {\r\n  return (\r\n    <Link href=\"/dashboard\" replace>\r\n      Dashboard\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"pages/index.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Home() {\r\n  return (\r\n    <Link href=\"/dashboard\" replace>\r\n      Dashboard\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"pages/index.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <Link href=\"/dashboard\" scroll={false}>\r\n      Dashboard\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <Link href=\"/dashboard\" scroll={false}>\r\n      Dashboard\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Home() {\r\n  return (\r\n    <Link href=\"/dashboard\" scroll={false}>\r\n      Dashboard\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"pages/index.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Home() {\r\n  return (\r\n    <Link href=\"/dashboard\" scroll={false}>\r\n      Dashboard\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"pages/index.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <Link href=\"/dashboard\" prefetch={false}>\r\n      Dashboard\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <Link href=\"/dashboard\" prefetch={false}>\r\n      Dashboard\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Home() {\r\n  return (\r\n    <Link href=\"/dashboard\" prefetch={false}>\r\n      Dashboard\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"pages/index.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Home() {\r\n  return (\r\n    <Link href=\"/dashboard\" prefetch={false}>\r\n      Dashboard\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"pages/index.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Home() {\r\n  return (\r\n    <Link href=\"/dashboard\" shallow={false}>\r\n      Dashboard\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"pages/index.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Home() {\r\n  return (\r\n    <Link href=\"/dashboard\" shallow={false}>\r\n      Dashboard\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"pages/index.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Home() {\r\n  return (\r\n    <>\r\n      {/* Default behavior: locale is prepended */}\r\n      <Link href=\"/dashboard\">Dashboard (with locale)</Link>\r\n\r\n      {/* Disable locale prepending */}\r\n      <Link href=\"/dashboard\" locale={false}>\r\n        Dashboard (without locale)\r\n      </Link>\r\n\r\n      {/* Specify a different locale */}\r\n      <Link href=\"/dashboard\" locale=\"fr\">\r\n        Dashboard (French)\r\n      </Link>\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"pages/index.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Home() {\r\n  return (\r\n    <>\r\n      {/* Default behavior: locale is prepended */}\r\n      <Link href=\"/dashboard\">Dashboard (with locale)</Link>\r\n\r\n      {/* Disable locale prepending */}\r\n      <Link href=\"/dashboard\" locale={false}>\r\n        Dashboard (without locale)\r\n      </Link>\r\n\r\n      {/* Specify a different locale */}\r\n      <Link href=\"/dashboard\" locale=\"fr\">\r\n        Dashboard (French)\r\n      </Link>\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"pages/index.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <Link\r\n      href=\"/dashboard\"\r\n      onNavigate={(e) => {\r\n        // Only executes during SPA navigation\r\n        console.log('Navigating...')\r\n\r\n        // Optionally prevent navigation\r\n        // e.preventDefault()\r\n      }}\r\n    >\r\n      Dashboard\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <Link\r\n      href=\"/dashboard\"\r\n      onNavigate={(e) => {\r\n        // Only executes during SPA navigation\r\n        console.log('Navigating...')\r\n\r\n        // Optionally prevent navigation\r\n        // e.preventDefault()\r\n      }}\r\n    >\r\n      Dashboard\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\n\r\ninterface Post {\r\n  id: number\r\n  title: string\r\n  slug: string\r\n}\r\n\r\nexport default function PostList({ posts }: { posts: Post[] }) {\r\n  return (\r\n    <ul>\r\n      {posts.map((post) => (\r\n        <li key={post.id}>\r\n          <Link href={`/blog/${post.slug}`}>{post.title}</Link>\r\n        </li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}",
        "context": "filename=\"app/blog/post-list.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function PostList({ posts }) {\r\n  return (\r\n    <ul>\r\n      {posts.map((post) => (\r\n        <li key={post.id}>\r\n          <Link href={`/blog/${post.slug}`}>{post.title}</Link>\r\n        </li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}",
        "context": "filename=\"app/blog/post-list.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { usePathname } from 'next/navigation'\r\nimport Link from 'next/link'\r\n\r\nexport function Links() {\r\n  const pathname = usePathname()\r\n\r\n  return (\r\n    <nav>\r\n      <Link className={`link ${pathname === '/' ? 'active' : ''}`} href=\"/\">\r\n        Home\r\n      </Link>\r\n\r\n      <Link\r\n        className={`link ${pathname === '/about' ? 'active' : ''}`}\r\n        href=\"/about\"\r\n      >\r\n        About\r\n      </Link>\r\n    </nav>\r\n  )\r\n}",
        "context": "filename=\"app/ui/nav-links.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { usePathname } from 'next/navigation'\r\nimport Link from 'next/link'\r\n\r\nexport function Links() {\r\n  const pathname = usePathname()\r\n\r\n  return (\r\n    <nav>\r\n      <Link className={`link ${pathname === '/' ? 'active' : ''}`} href=\"/\">\r\n        Home\r\n      </Link>\r\n\r\n      <Link\r\n        className={`link ${pathname === '/about' ? 'active' : ''}`}\r\n        href=\"/about\"\r\n      >\r\n        About\r\n      </Link>\r\n    </nav>\r\n  )\r\n}",
        "context": "filename=\"app/ui/nav-links.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\n\r\nfunction Posts({ posts }) {\r\n  return (\r\n    <ul>\r\n      {posts.map((post) => (\r\n        <li key={post.id}>\r\n          <Link href={`/blog/${post.slug}`}>{post.title}</Link>\r\n        </li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}",
        "context": "filename=\"pages/blog/index.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\nfunction Posts({ posts }) {\r\n  return (\r\n    <ul>\r\n      {posts.map((post) => (\r\n        <li key={post.id}>\r\n          <Link href={`/blog/${post.slug}`}>{post.title}</Link>\r\n        </li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}\r\n\r\nexport default Posts",
        "context": "filename=\"pages/blog/index.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "<Link href=\"/dashboard#settings\">Settings</Link>\r\n\r\n// Output\r\n<a href=\"/dashboard#settings\">Settings</a>",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\n\r\nfunction Home() {\r\n  return (\r\n    <ul>\r\n      <li>\r\n        <Link\r\n          href={{\r\n            pathname: '/about',\r\n            query: { name: 'test' },\r\n          }}\r\n        >\r\n          About us\r\n        </Link>\r\n      </li>\r\n      <li>\r\n        <Link\r\n          href={{\r\n            pathname: '/blog/[slug]',\r\n            query: { slug: 'my-post' },\r\n          }}\r\n        >\r\n          Blog Post\r\n        </Link>\r\n      </li>\r\n    </ul>\r\n  )\r\n}\r\n\r\nexport default Home",
        "context": "filename=\"pages/index.ts\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\nfunction Home() {\r\n  return (\r\n    <ul>\r\n      <li>\r\n        <Link\r\n          href={{\r\n            pathname: '/about',\r\n            query: { name: 'test' },\r\n          }}\r\n        >\r\n          About us\r\n        </Link>\r\n      </li>\r\n      <li>\r\n        <Link\r\n          href={{\r\n            pathname: '/blog/[slug]',\r\n            query: { slug: 'my-post' },\r\n          }}\r\n        >\r\n          Blog Post\r\n        </Link>\r\n      </li>\r\n    </ul>\r\n  )\r\n}\r\n\r\nexport default Home",
        "context": "filename=\"pages/index.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <Link href=\"/about\" replace>\r\n      About us\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <Link href=\"/about\" replace>\r\n      About us\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Home() {\r\n  return (\r\n    <Link href=\"/about\" replace>\r\n      About us\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"pages/index.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Home() {\r\n  return (\r\n    <Link href=\"/about\" replace>\r\n      About us\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"pages/index.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <Link href=\"/#hashid\" scroll={false}>\r\n      Disables scrolling to the top\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <Link href=\"/#hashid\" scroll={false}>\r\n      Disables scrolling to the top\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "// useRouter\r\nimport { useRouter } from 'next/navigation'\r\n\r\nconst router = useRouter()\r\n\r\nrouter.push('/dashboard', { scroll: false })",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Home() {\r\n  return (\r\n    <Link href=\"/#hashid\" scroll={false}>\r\n      Disables scrolling to the top\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"pages/index.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Home() {\r\n  return (\r\n    <Link href=\"/#hashid\" scroll={false}>\r\n      Disables scrolling to the top\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"pages/index.tsx\" switcher"
      },
      {
        "language": "ts",
        "code": "import { NextResponse } from 'next/server'\r\n\r\nexport function proxy(request: Request) {\r\n  const nextUrl = request.nextUrl\r\n  if (nextUrl.pathname === '/dashboard') {\r\n    if (request.cookies.authToken) {\r\n      return NextResponse.rewrite(new URL('/auth/dashboard', request.url))\r\n    } else {\r\n      return NextResponse.rewrite(new URL('/public/dashboard', request.url))\r\n    }\r\n  }\r\n}",
        "context": "filename=\"proxy.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { NextResponse } from 'next/server'\r\n\r\nexport function proxy(request) {\r\n  const nextUrl = request.nextUrl\r\n  if (nextUrl.pathname === '/dashboard') {\r\n    if (request.cookies.authToken) {\r\n      return NextResponse.rewrite(new URL('/auth/dashboard', request.url))\r\n    } else {\r\n      return NextResponse.rewrite(new URL('/public/dashboard', request.url))\r\n    }\r\n  }\r\n}",
        "context": "filename=\"proxy.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport Link from 'next/link'\r\nimport useIsAuthed from './hooks/useIsAuthed' // Your auth hook\r\n\r\nexport default function Page() {\r\n  const isAuthed = useIsAuthed()\r\n  const path = isAuthed ? '/auth/dashboard' : '/public/dashboard'\r\n  return (\r\n    <Link as=\"/dashboard\" href={path}>\r\n      Dashboard\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "js",
        "code": "'use client'\r\n\r\nimport Link from 'next/link'\r\nimport useIsAuthed from './hooks/useIsAuthed' // Your auth hook\r\n\r\nexport default function Page() {\r\n  const isAuthed = useIsAuthed()\r\n  const path = isAuthed ? '/auth/dashboard' : '/public/dashboard'\r\n  return (\r\n    <Link as=\"/dashboard\" href={path}>\r\n      Dashboard\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport Link from 'next/link'\r\nimport useIsAuthed from './hooks/useIsAuthed' // Your auth hook\r\n\r\nexport default function Home() {\r\n  const isAuthed = useIsAuthed()\r\n  const path = isAuthed ? '/auth/dashboard' : '/public/dashboard'\r\n  return (\r\n    <Link as=\"/dashboard\" href={path}>\r\n      Dashboard\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"pages/index.tsx\" switcher"
      },
      {
        "language": "js",
        "code": "'use client'\r\n\r\nimport Link from 'next/link'\r\nimport useIsAuthed from './hooks/useIsAuthed' // Your auth hook\r\n\r\nexport default function Home() {\r\n  const isAuthed = useIsAuthed()\r\n  const path = isAuthed ? '/auth/dashboard' : '/public/dashboard'\r\n  return (\r\n    <Link as=\"/dashboard\" href={path}>\r\n      Dashboard\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"pages/index.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { createContext, useState, useContext } from 'react'\r\n\r\ninterface NavigationBlockerContextType {\r\n  isBlocked: boolean\r\n  setIsBlocked: (isBlocked: boolean) => void\r\n}\r\n\r\nexport const NavigationBlockerContext =\r\n  createContext<NavigationBlockerContextType>({\r\n    isBlocked: false,\r\n    setIsBlocked: () => {},\r\n  })\r\n\r\nexport function NavigationBlockerProvider({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  const [isBlocked, setIsBlocked] = useState(false)\r\n\r\n  return (\r\n    <NavigationBlockerContext.Provider value={{ isBlocked, setIsBlocked }}>\r\n      {children}\r\n    </NavigationBlockerContext.Provider>\r\n  )\r\n}\r\n\r\nexport function useNavigationBlocker() {\r\n  return useContext(NavigationBlockerContext)\r\n}",
        "context": "filename=\"app/contexts/navigation-blocker.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { createContext, useState, useContext } from 'react'\r\n\r\nexport const NavigationBlockerContext = createContext({\r\n  isBlocked: false,\r\n  setIsBlocked: () => {},\r\n})\r\n\r\nexport function NavigationBlockerProvider({ children }) {\r\n  const [isBlocked, setIsBlocked] = useState(false)\r\n\r\n  return (\r\n    <NavigationBlockerContext.Provider value={{ isBlocked, setIsBlocked }}>\r\n      {children}\r\n    </NavigationBlockerContext.Provider>\r\n  )\r\n}\r\n\r\nexport function useNavigationBlocker() {\r\n  return useContext(NavigationBlockerContext)\r\n}",
        "context": "filename=\"app/contexts/navigation-blocker.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { useNavigationBlocker } from '../contexts/navigation-blocker'\r\n\r\nexport default function Form() {\r\n  const { setIsBlocked } = useNavigationBlocker()\r\n\r\n  return (\r\n    <form\r\n      onSubmit={(e) => {\r\n        e.preventDefault()\r\n        setIsBlocked(false)\r\n      }}\r\n      onChange={() => setIsBlocked(true)}\r\n    >\r\n      <input type=\"text\" name=\"name\" />\r\n      <button type=\"submit\">Save</button>\r\n    </form>\r\n  )\r\n}",
        "context": "filename=\"app/components/form.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { useNavigationBlocker } from '../contexts/navigation-blocker'\r\n\r\nexport default function Form() {\r\n  const { setIsBlocked } = useNavigationBlocker()\r\n\r\n  return (\r\n    <form\r\n      onSubmit={(e) => {\r\n        e.preventDefault()\r\n        setIsBlocked(false)\r\n      }}\r\n      onChange={() => setIsBlocked(true)}\r\n    >\r\n      <input type=\"text\" name=\"name\" />\r\n      <button type=\"submit\">Save</button>\r\n    </form>\r\n  )\r\n}",
        "context": "filename=\"app/components/form.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport Link from 'next/link'\r\nimport { useNavigationBlocker } from '../contexts/navigation-blocker'\r\n\r\ninterface CustomLinkProps extends React.ComponentProps<typeof Link> {\r\n  children: React.ReactNode\r\n}\r\n\r\nexport function CustomLink({ children, ...props }: CustomLinkProps) {\r\n  const { isBlocked } = useNavigationBlocker()\r\n\r\n  return (\r\n    <Link\r\n      onNavigate={(e) => {\r\n        if (\r\n          isBlocked &&\r\n          !window.confirm('You have unsaved changes. Leave anyway?')\r\n        ) {\r\n          e.preventDefault()\r\n        }\r\n      }}\r\n      {...props}\r\n    >\r\n      {children}\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"app/components/custom-link.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport Link from 'next/link'\r\nimport { useNavigationBlocker } from '../contexts/navigation-blocker'\r\n\r\nexport function CustomLink({ children, ...props }) {\r\n  const { isBlocked } = useNavigationBlocker()\r\n\r\n  return (\r\n    <Link\r\n      onNavigate={(e) => {\r\n        if (\r\n          isBlocked &&\r\n          !window.confirm('You have unsaved changes. Leave anyway?')\r\n        ) {\r\n          e.preventDefault()\r\n        }\r\n      }}\r\n      {...props}\r\n    >\r\n      {children}\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"app/components/custom-link.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { CustomLink as Link } from './custom-link'\r\n\r\nexport default function Nav() {\r\n  return (\r\n    <nav>\r\n      <Link href=\"/\">Home</Link>\r\n      <Link href=\"/about\">About</Link>\r\n    </nav>\r\n  )\r\n}",
        "context": "filename=\"app/components/nav.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { CustomLink as Link } from './custom-link'\r\n\r\nexport default function Nav() {\r\n  return (\r\n    <nav>\r\n      <Link href=\"/\">Home</Link>\r\n      <Link href=\"/about\">About</Link>\r\n    </nav>\r\n  )\r\n}",
        "context": "filename=\"app/components/nav.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { NavigationBlockerProvider } from './contexts/navigation-blocker'\r\n\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>\r\n        <NavigationBlockerProvider>{children}</NavigationBlockerProvider>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { NavigationBlockerProvider } from './contexts/navigation-blocker'\r\n\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>\r\n        <NavigationBlockerProvider>{children}</NavigationBlockerProvider>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Nav from './components/nav'\r\nimport Form from './components/form'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <div>\r\n      <Nav />\r\n      <main>\r\n        <h1>Welcome to the Dashboard</h1>\r\n        <Form />\r\n      </main>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Nav from './components/nav'\r\nimport Form from './components/form'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <div>\r\n      <Nav />\r\n      <main>\r\n        <h1>Welcome to the Dashboard</h1>\r\n        <Form />\r\n      </main>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      }
    ],
    "content": "is a React component that extends the HTML element to provide prefetching and client-side navigation between routes. It is the primary way to navigate between routes in Next.js. Basic usage: Reference The following props can be passed to the component: | Prop | Example | Type | Required | | --------------------------- | ------------------------ | ----------------- | -------- | | href | href=\"/dashboard\" | String or Object | Yes | | as | as=\"/post/abc\" | String or Object | - | | replace | replace={false} | Boolean | - | | scroll | scroll={false} | Boolean | - | | prefetch | prefetch={false} | Boolean | - | | shallow | shallow={false} | Boolean | - | | locale | locale=\"fr\" | String or Boolean | - | | onNavigate | onNavigate={(e) => {}} | Function | - | | Prop | Example | Type | Required | | --------------------------- | ------------------------ | ---------------- | -------- | | href | href=\"/dashboard\" | String or Object | Yes | | replace | replace={false} | Boolean | - | | scroll | scroll={false} | Boolean | - | | prefetch | prefetch={false} | Boolean or null | - | | onNavigate | onNavigate={(e) => {}} | Function | - | > Good to know: tag attributes such as className or target=\"blank\" can be added to as props and will be passed to the underlying element. href (required) The path or URL to navigate to. replace Defaults to false. When true, next/link will replace the current history state instead of adding a new URL into the browser's history stack. scroll Defaults to true. The default scrolling behavior of in Next.js is to maintain scroll position, similar to how browsers handle back and forwards navigation. When you navigate to a new Page, scroll position will stay the same as long as the Page is visible in the viewport. However, if the Page is not visible in the viewport, Next.js will scroll to the top of the first Page element. When scroll = {false}, Next.js will not attempt to scroll to the first Page element. > Good to know: Next.js checks if scroll: false before managing scroll behavior. If scrolling is enabled, it identifies the relevant DOM node for navigation and inspects each top-level element. All non-scrollable elements and those without rendered HTML are bypassed, this includes sticky or fixed positioned elements, and non-visible elements such as those calculated with getBoundingClientRect. Next.js then continues through siblings until it identifies a scrollable element that is visible in the viewport. prefetch Prefetching happens when a component enters the user's viewport (initially or through scroll). Next.js prefetches and loads the linked route (denoted by the href) and its data in the background to improve the performance of client-side navigations. If the prefetched data has expired by the time the user hovers over a , Next.js will attempt to prefetch it again. Prefetching is only enabled in production. The following values can be passed to the prefetch prop: - \"auto\" or null (default): Prefetch behavior depends on whether the route is static or dynamic. For static routes, the full route will be prefetched (including all its data). For dynamic routes, the partial route down to the nearest segment with a loading.js boundary will be prefetched. - true: The full route will be prefetched for both static and dynamic routes. - false: Prefetching will never happen both on entering the viewport and on hover. Prefetching happens when a component enters the user's viewport (initially or through scroll). Next.js prefetches and loads the linked route (denoted by the href) and data in the background to improve the performance of client-side navigation's. Prefetching is only enabled in production. The following values can be passed to the prefetch prop: - true (default): The full route and its data will be prefetched. - false: Prefetching will not happen when entering the viewport, but will happen on hover. If you want to completely remove fetching on hover as well, consider using an tag or incrementally adopting the App Router, which enables disabling prefetching on hover too. shallow Update the path of the current page without rerunning getStaticProps, getServerSideProps or getInitialProps. Defaults to false. locale The active locale is automatically prepended. locale allows for providing a different locale. When false href has to include the locale as the default behavior is disabled. as Optional decorator for the path that will be shown in the browser URL bar. Before Next.js 9.5.3 this was used for dynamic routes, check our previous docs to see how it worked. When this path differs from the one provided in href the previous href/as behavior is used as shown in the previous docs. onNavigate An event handler called during client-side navigation. The handler receives an event object that includes a preventDefault() method, allowing you to cancel the navigation if needed. > Good to know: While onClick and onNavigate may seem similar, they serve different purposes. onClick executes for all click events, while onNavigate only runs during client-side navigation. Some key differences: > > - When using modifier keys (Ctrl/Cmd + Click), onClick executes but onNavigate doesn't since Next.js prevents default navigation for new tabs. > - External URLs won't trigger onNavigate since it's only for client-side and same-origin navigations. > - Links with the download attribute will work with onClick but not onNavigate since the browser will treat the linked URL as a download. Examples The following examples demonstrate how to use the component in different scenarios. Linking to dynamic route segments When linking to dynamic segments, you can use template literals and interpolation to generate a list of links. For example, to generate a list of blog posts: Checking active links You can use usePathname() to determine if a link is active. For example, to add a class to the active link, you can check if the current pathname matches the href of the link: Linking to dynamic route segments For dynamic route segments, it can be handy to use template literals to create the link's path. For example, you can generate a list of links to the dynamic route pages/blog/[slug].js Scrolling to an id If you'd like to scroll to a specific id on navigation, you can append your URL with a hash link or just pass a hash link to the href prop. This is possible since renders to an element. > Good to know: > > - Next.js will scroll to the Page if it is not visible in the viewport upon navigation. Passing a URL Object Link can also receive a URL object and it will automatically format it to create the URL string: The above example has a link to: - A predefined route: /about?name=test - A dynamic route: /blog/my-post You can use every property as defined in the Node.js URL module documentation. Replace the URL instead of push The default behavior of the Link component is to push a new URL into the history stack. You can use the replace prop to prevent adding a new entry, as in the following example: Disable scrolling to the top of the page The default scrolling behavior of in Next.js is to maintain scroll position, similar to how browsers handle back and forwards navigation. When you navigate to a new Page, scroll position will stay the same as long as the Page is visible in the viewport. However, if the Page is not visible in the viewport, Next.js will scroll to the top of the first Page element. If you'd like to disable this behavior, you can pass scroll={false} to the component, or scroll: false to router.push() or router.replace(). Using router.push() or router.replace(): The default behavior of Link is to scroll to the top of the page. When there is a hash defined it will scroll to the specific id, like a normal tag. To prevent scrolling to the top / hash scroll={false} can be added to Link: Prefetching links in Proxy It's common to use Proxy for authentication or other purposes that involve rewriting the user to a different page. In order for the component to properly prefetch links with rewrites via Proxy, you need to tell Next.js both the URL to display and the URL to prefetch. This is required to avoid un-necessary fetches to proxy to know the correct route to prefetch. For example, if you want to serve a /dashboard route that has authenticated and visitor views, you can add the following in your Proxy to redirect the user to the correct page: In this case, you would want to use the following code in your component: > Good to know: If you're using Dynamic Routes, you'll need to adapt your as and href props. For example, if you have a Dynamic Route like /dashboard/authed/[user] that you want to present differently via proxy, you would write: Profile. Blocking navigation You can use the onNavigate prop to block navigation when certain conditions are met, such as when a form has unsaved changes. When you need to block navigation across multiple components in your app (like preventing navigation from any link while a form is being edited), React Context provides a clean way to share this blocking state. First, create a context to track the navigation blocking state: Create a form component that uses the context: Create a custom Link component that blocks navigation: Create a navigation component: Finally, wrap your app with the NavigationBlockerProvider in the root layout and use the components in your page: Then, use the Nav and Form components in your page: When a user tries to navigate away using CustomLink while the form has unsaved changes, they'll be prompted to confirm before leaving. Version history | Version | Changes | | --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | v15.4.0 | Add auto as an alias to the default prefetch behavior. | | v15.3.0 | Add onNavigate API | | v13.0.0 | No longer requires a child tag. A codemod is provided to automatically update your codebase. | | v10.0.0 | href props pointing to a dynamic route are automatically resolved and no longer require an as prop. | | v8.0.0 | Improved prefetching performance. | | v1.0.0 | next/link introduced. |",
    "excerpt": "is a React component that extends the HTML element to provide prefetching and client-side navigation between routes. It is the primary way to navigate between routes in Next.js. Basic usage: Reference...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/02-components/link"
  },
  {
    "id": "01-app-03-api-reference-02-components-script",
    "path": "01-app\\03-api-reference\\02-components\\script.mdx",
    "title": "Script Component",
    "description": "Optimize third-party scripts in your Next.js application using the built-in `next/script` Component.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Props",
        "slug": "props"
      },
      {
        "level": 2,
        "text": "Required Props",
        "slug": "required-props"
      },
      {
        "level": 2,
        "text": "Optional Props",
        "slug": "optional-props"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "import Script from 'next/script'\r\n\r\nexport default function Dashboard() {\r\n  return (\r\n    <>\r\n      <Script src=\"https://example.com/script.js\" />\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/dashboard/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Script from 'next/script'\r\n\r\nexport default function Dashboard() {\r\n  return (\r\n    <>\r\n      <Script src=\"https://example.com/script.js\" />\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/dashboard/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Script from 'next/script'\r\n\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>\r\n        {children}\r\n        <Script\r\n          src=\"https://example.com/script.js\"\r\n          strategy=\"beforeInteractive\"\r\n        />\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Script from 'next/script'\r\n\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>\r\n        {children}\r\n        <Script\r\n          src=\"https://example.com/script.js\"\r\n          strategy=\"beforeInteractive\"\r\n        />\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { Html, Head, Main, NextScript } from 'next/document'\r\nimport Script from 'next/script'\r\n\r\nexport default function Document() {\r\n  return (\r\n    <Html>\r\n      <Head />\r\n      <body>\r\n        <Main />\r\n        <NextScript />\r\n        <Script\r\n          src=\"https://example.com/script.js\"\r\n          strategy=\"beforeInteractive\"\r\n        />\r\n      </body>\r\n    </Html>\r\n  )\r\n}",
        "context": "filename=\"pages/_document.js\""
      },
      {
        "language": "jsx",
        "code": "import Script from 'next/script'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <Script src=\"https://example.com/script.js\" strategy=\"afterInteractive\" />\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\""
      },
      {
        "language": "jsx",
        "code": "import Script from 'next/script'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <Script src=\"https://example.com/script.js\" strategy=\"lazyOnload\" />\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  experimental: {\r\n    nextScriptWorkers: true,\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "tsx",
        "code": "import Script from 'next/script'\r\n\r\nexport default function Home() {\r\n  return (\r\n    <>\r\n      <Script src=\"https://example.com/script.js\" strategy=\"worker\" />\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"pages/home.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Script from 'next/script'\r\n\r\nexport default function Home() {\r\n  return (\r\n    <>\r\n      <Script src=\"https://example.com/script.js\" strategy=\"worker\" />\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"pages/home.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport Script from 'next/script'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <Script\r\n        src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.20/lodash.min.js\"\r\n        onLoad={() => {\r\n          console.log(_.sample([1, 2, 3, 4]))\r\n        }}\r\n      />\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport Script from 'next/script'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <Script\r\n        src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.20/lodash.min.js\"\r\n        onLoad={() => {\r\n          console.log(_.sample([1, 2, 3, 4]))\r\n        }}\r\n      />\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { useRef } from 'react'\r\nimport Script from 'next/script'\r\n\r\nexport default function Page() {\r\n  const mapRef = useRef()\r\n\r\n  return (\r\n    <>\r\n      <div ref={mapRef}></div>\r\n      <Script\r\n        id=\"google-maps\"\r\n        src=\"https://maps.googleapis.com/maps/api/js\"\r\n        onReady={() => {\r\n          new google.maps.Map(mapRef.current, {\r\n            center: { lat: -34.397, lng: 150.644 },\r\n            zoom: 8,\r\n          })\r\n        }}\r\n      />\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { useRef } from 'react'\r\nimport Script from 'next/script'\r\n\r\nexport default function Page() {\r\n  const mapRef = useRef()\r\n\r\n  return (\r\n    <>\r\n      <div ref={mapRef}></div>\r\n      <Script\r\n        id=\"google-maps\"\r\n        src=\"https://maps.googleapis.com/maps/api/js\"\r\n        onReady={() => {\r\n          new google.maps.Map(mapRef.current, {\r\n            center: { lat: -34.397, lng: 150.644 },\r\n            zoom: 8,\r\n          })\r\n        }}\r\n      />\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { useRef } from 'react'\r\nimport Script from 'next/script'\r\n\r\nexport default function Page() {\r\n  const mapRef = useRef()\r\n\r\n  return (\r\n    <>\r\n      <div ref={mapRef}></div>\r\n      <Script\r\n        id=\"google-maps\"\r\n        src=\"https://maps.googleapis.com/maps/api/js\"\r\n        onReady={() => {\r\n          new google.maps.Map(mapRef.current, {\r\n            center: { lat: -34.397, lng: 150.644 },\r\n            zoom: 8,\r\n          })\r\n        }}\r\n      />\r\n    </>\r\n  )\r\n}",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport Script from 'next/script'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <Script\r\n        src=\"https://example.com/script.js\"\r\n        onError={(e: Error) => {\r\n          console.error('Script failed to load', e)\r\n        }}\r\n      />\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport Script from 'next/script'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <Script\r\n        src=\"https://example.com/script.js\"\r\n        onError={(e) => {\r\n          console.error('Script failed to load', e)\r\n        }}\r\n      />\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Script from 'next/script'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <Script\r\n        src=\"https://example.com/script.js\"\r\n        onError={(e: Error) => {\r\n          console.error('Script failed to load', e)\r\n        }}\r\n      />\r\n    </>\r\n  )\r\n}",
        "context": ""
      }
    ],
    "content": "This API reference will help you understand how to use props available for the Script Component. For features and usage, please see the Optimizing Scripts page. Props Here's a summary of the props available for the Script Component: | Prop | Example | Type | Required | | ----------------------- | --------------------------------- | -------- | ------------------------------------- | | src | src=\"http://example.com/script\" | String | Required unless inline script is used | | strategy | strategy=\"lazyOnload\" | String | - | | onLoad | onLoad={onLoadFunc} | Function | - | | onReady | onReady={onReadyFunc} | Function | - | | onError | onError={onErrorFunc} | Function | - | Required Props The component requires the following properties. src A path string specifying the URL of an external script. This can be either an absolute external URL or an internal path. The src property is required unless an inline script is used. Optional Props The component accepts a number of additional properties beyond those which are required. strategy The loading strategy of the script. There are four different strategies that can be used: - beforeInteractive: Load before any Next.js code and before any page hydration occurs. - afterInteractive: (default) Load early but after some hydration on the page occurs. - lazyOnload: Load during browser idle time. - worker: (experimental) Load in a web worker. beforeInteractive Scripts that load with the beforeInteractive strategy are injected into the initial HTML from the server, downloaded before any Next.js module, and executed in the order they are placed. Scripts denoted with this strategy are preloaded and fetched before any first-party code, but their execution does not block page hydration from occurring. beforeInteractive scripts must be placed inside the root layout (app/layout.tsx) and are designed to load scripts that are needed by the entire site (i.e. the script will load when any page in the application has been loaded server-side). beforeInteractive scripts must be placed inside the Document Component (pages/document.js) and are designed to load scripts that are needed by the entire site (i.e. the script will load when any page in the application has been loaded server-side). This strategy should only be used for critical scripts that need to be fetched as soon as possible. > Good to know: Scripts with beforeInteractive will always be injected inside the head of the HTML document regardless of where it's placed in the component. Some examples of scripts that should be fetched as soon as possible with beforeInteractive include: - Bot detectors - Cookie consent managers afterInteractive Scripts that use the afterInteractive strategy are injected into the HTML client-side and will load after some (or all) hydration occurs on the page. This is the default strategy of the Script component and should be used for any script that needs to load as soon as possible but not before any first-party Next.js code. afterInteractive scripts can be placed inside of any page or layout and will only load and execute when that page (or group of pages) is opened in the browser. Some examples of scripts that are good candidates for afterInteractive include: - Tag managers - Analytics lazyOnload Scripts that use the lazyOnload strategy are injected into the HTML client-side during browser idle time and will load after all resources on the page have been fetched. This strategy should be used for any background or low priority scripts that do not need to load early. lazyOnload scripts can be placed inside of any page or layout and will only load and execute when that page (or group of pages) is opened in the browser. Examples of scripts that do not need to load immediately and can be fetched with lazyOnload include: - Chat support plugins - Social media widgets worker > Warning: The worker strategy is not yet stable and does not yet work with the App Router. Use with caution. Scripts that use the worker strategy are off-loaded to a web worker in order to free up the main thread and ensure that only critical, first-party resources are processed on it. While this strategy can be used for any script, it is an advanced use case that is not guaranteed to support all third-party scripts. To use worker as a strategy, the nextScriptWorkers flag must be enabled in next.config.js: worker scripts can only currently be used in the pages/ directory: onLoad > Warning: onLoad does not yet work with Server Components and can only be used in Client Components. Further, onLoad can't be used with beforeInteractive – consider using onReady instead. Some third-party scripts require users to run JavaScript code once after the script has finished loading in order to instantiate content or call a function. If you are loading a script with either afterInteractive or lazyOnload as a loading strategy, you can execute code after it has loaded using the onLoad property. Here's an example of executing a lodash method only after the library has been loaded. onReady > Warning: onReady does not yet work with Server Components and can only be used in Client Components. Some third-party scripts require users to run JavaScript code after the script has finished loading and every time the component is mounted (after a route navigation for example). You can execute code after the script's load event when it first loads and then after every subsequent component re-mount using the onReady property. Here's an example of how to re-instantiate a Google Maps JS embed every time the component is mounted: onError > Warning: onError does not yet work with Server Components and can only be used in Client Components. onError cannot be used with the beforeInteractive loading strategy. Sometimes it is helpful to catch when a script fails to load. These errors can be handled with the onError property: Version History | Version | Changes | | --------- | ------------------------------------------------------------------------- | | v13.0.0 | beforeInteractive and afterInteractive is modified to support app. | | v12.2.4 | onReady prop added. | | v12.2.2 | Allow next/script with beforeInteractive to be placed in document. | | v11.0.0 | next/script introduced. |",
    "excerpt": "This API reference will help you understand how to use props available for the Script Component. For features and usage, please see the Optimizing Scripts page. Props Here's a summary of the props ava...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/02-components/script"
  },
  {
    "id": "01-app-03-api-reference-03-file-conventions-01-metadata-app-icons",
    "path": "01-app\\03-api-reference\\03-file-conventions\\01-metadata\\app-icons.mdx",
    "title": "favicon, icon, and apple-icon",
    "description": "API Reference for the Favicon, Icon and Apple Icon file conventions.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Image files (.ico, .jpg, .png)",
        "slug": "image-files-ico-jpg-png"
      },
      {
        "level": 2,
        "text": "Generate icons using code (.js, .ts, .tsx)",
        "slug": "generate-icons-using-code-js-ts-tsx"
      },
      {
        "level": 3,
        "text": "Props",
        "slug": "props"
      },
      {
        "level": 4,
        "text": " (optional)",
        "slug": "-optional"
      },
      {
        "level": 3,
        "text": "Returns",
        "slug": "returns"
      },
      {
        "level": 3,
        "text": "Config exports",
        "slug": "config-exports"
      },
      {
        "level": 4,
        "text": "Route Segment Config",
        "slug": "route-segment-config"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "html",
        "code": "<link rel=\"icon\" href=\"/favicon.ico\" sizes=\"any\" />",
        "context": "filename=\"<head> output\""
      },
      {
        "language": "html",
        "code": "<link\r\n  rel=\"icon\"\r\n  href=\"/icon?<generated>\"\r\n  type=\"image/<generated>\"\r\n  sizes=\"<generated>\"\r\n/>",
        "context": "filename=\"<head> output\""
      },
      {
        "language": "html",
        "code": "<link\r\n  rel=\"apple-touch-icon\"\r\n  href=\"/apple-icon?<generated>\"\r\n  type=\"image/<generated>\"\r\n  sizes=\"<generated>\"\r\n/>",
        "context": "filename=\"<head> output\""
      },
      {
        "language": "tsx",
        "code": "import { ImageResponse } from 'next/og'\r\n\r\n// Image metadata\r\nexport const size = {\r\n  width: 32,\r\n  height: 32,\r\n}\r\nexport const contentType = 'image/png'\r\n\r\n// Image generation\r\nexport default function Icon() {\r\n  return new ImageResponse(\r\n    (\r\n      // ImageResponse JSX element\r\n      <div\r\n        style={{\r\n          fontSize: 24,\r\n          background: 'black',\r\n          width: '100%',\r\n          height: '100%',\r\n          display: 'flex',\r\n          alignItems: 'center',\r\n          justifyContent: 'center',\r\n          color: 'white',\r\n        }}\r\n      >\r\n        A\r\n      </div>\r\n    ),\r\n    // ImageResponse options\r\n    {\r\n      // For convenience, we can re-use the exported icons size metadata\r\n      // config to also set the ImageResponse's width and height.\r\n      ...size,\r\n    }\r\n  )\r\n}",
        "context": "filename=\"app/icon.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { ImageResponse } from 'next/og'\r\n\r\n// Image metadata\r\nexport const size = {\r\n  width: 32,\r\n  height: 32,\r\n}\r\nexport const contentType = 'image/png'\r\n\r\n// Image generation\r\nexport default function Icon() {\r\n  return new ImageResponse(\r\n    (\r\n      // ImageResponse JSX element\r\n      <div\r\n        style={{\r\n          fontSize: 24,\r\n          background: 'black',\r\n          width: '100%',\r\n          height: '100%',\r\n          display: 'flex',\r\n          alignItems: 'center',\r\n          justifyContent: 'center',\r\n          color: 'white',\r\n        }}\r\n      >\r\n        A\r\n      </div>\r\n    ),\r\n    // ImageResponse options\r\n    {\r\n      // For convenience, we can re-use the exported icons size metadata\r\n      // config to also set the ImageResponse's width and height.\r\n      ...size,\r\n    }\r\n  )\r\n}",
        "context": "filename=\"app/icon.js\" switcher"
      },
      {
        "language": "html",
        "code": "<link rel=\"icon\" href=\"/icon?<generated>\" type=\"image/png\" sizes=\"32x32\" />",
        "context": "filename=\"<head> output\""
      },
      {
        "language": "tsx",
        "code": "export default async function Icon({\r\n  params,\r\n}: {\r\n  params: Promise<{ slug: string }>\r\n}) {\r\n  const { slug } = await params\r\n  // ...\r\n}",
        "context": "filename=\"app/shop/[slug]/icon.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default async function Icon({ params }) {\r\n  const { slug } = await params\r\n  // ...\r\n}",
        "context": "filename=\"app/shop/[slug]/icon.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export const size = { width: 32, height: 32 }\r\n\r\nexport default function Icon() {}",
        "context": "filename=\"icon.tsx | apple-icon.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export const size = { width: 32, height: 32 }\r\n\r\nexport default function Icon() {}",
        "context": "filename=\"icon.js | apple-icon.js\" switcher"
      },
      {
        "language": "html",
        "code": "<link rel=\"icon\" sizes=\"32x32\" />",
        "context": "filename=\"<head> output\""
      },
      {
        "language": "tsx",
        "code": "export const contentType = 'image/png'\r\n\r\nexport default function Icon() {}",
        "context": "filename=\"icon.tsx | apple-icon.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export const contentType = 'image/png'\r\n\r\nexport default function Icon() {}",
        "context": "filename=\"icon.js | apple-icon.js\" switcher"
      },
      {
        "language": "html",
        "code": "<link rel=\"icon\" type=\"image/png\" />",
        "context": "filename=\"<head> output\""
      }
    ],
    "content": "The favicon, icon, or apple-icon file conventions allow you to set icons for your application. They are useful for adding app icons that appear in places like web browser tabs, phone home screens, and search engine results. There are two ways to set app icons: - Using image files (.ico, .jpg, .png) - Using code to generate an icon (.js, .ts, .tsx) Image files (.ico, .jpg, .png) Use an image file to set an app icon by placing a favicon, icon, or apple-icon image file within your /app directory. The favicon image can only be located in the top level of app/. Next.js will evaluate the file and automatically add the appropriate tags to your app's element. | File convention | Supported file types | Valid locations | | --------------------------- | --------------------------------------- | --------------- | | favicon | .ico | app/ | | icon | .ico, .jpg, .jpeg, .png, .svg | app// | | apple-icon | .jpg, .jpeg, .png | app// | favicon Add a favicon.ico image file to the root /app route segment. icon Add an icon.(ico|jpg|jpeg|png|svg) image file. apple-icon Add an apple-icon.(jpg|jpeg|png) image file. > Good to know: > > - You can set multiple icons by adding a number suffix to the file name. For example, icon1.png, icon2.png, etc. Numbered files will sort lexically. > - Favicons can only be set in the root /app segment. If you need more granularity, you can use icon. > - The appropriate tags and attributes such as rel, href, type, and sizes are determined by the icon type and metadata of the evaluated file. > - For example, a 32 by 32px .png file will have type=\"image/png\" and sizes=\"32x32\" attributes. > - sizes=\"any\" is added to icons when the extension is .svg or the image size of the file is not determined. More details in this favicon handbook. Generate icons using code (.js, .ts, .tsx) In addition to using literal image files, you can programmatically generate icons using code. Generate an app icon by creating an icon or apple-icon route that default exports a function. | File convention | Supported file types | | --------------- | -------------------- | | icon | .js, .ts, .tsx | | apple-icon | .js, .ts, .tsx | The easiest way to generate an icon is to use the ImageResponse API from next/og. > Good to know: > > - By default, generated icons are statically optimized (generated at build time and cached) unless they use Dynamic APIs or uncached data. > - You can generate multiple icons in the same file using generateImageMetadata. > - You cannot generate a favicon icon. Use icon or a favicon.ico file instead. > - App icons are special Route Handlers that are cached by default unless they use a Dynamic API or dynamic config option. Props The default export function receives the following props: params (optional) A promise that resolves to an object containing the dynamic route parameters object from the root segment down to the segment icon or apple-icon is colocated in. > Good to know: If you use generateImageMetadata, the function will also receive an id prop that is a promise resolving to the id value from one of the items returned by generateImageMetadata. | Route | URL | params | | ------------------------------- | ----------- | ---------------------------------- | | app/shop/icon.js | /shop | undefined | | app/shop/[slug]/icon.js | /shop/1 | Promise | | app/shop/[tag]/[item]/icon.js | /shop/1/2 | Promise | Returns The default export function should return a Blob | ArrayBuffer | TypedArray | DataView | ReadableStream | Response. > Good to know: ImageResponse satisfies this return type. Config exports You can optionally configure the icon's metadata by exporting size and contentType variables from the icon or apple-icon route. | Option | Type | | ----------------------------- | --------------------------------------------------------------------------------------------------------------- | | size | { width: number; height: number } | | contentType | string - image MIME type | size contentType Route Segment Config icon and apple-icon are specialized Route Handlers that can use the same route segment configuration options as Pages and Layouts. Version History | Version | Changes | | --------- | ---------------------------------------------------- | | v16.0.0 | params is now a promise that resolves to an object | | v13.3.0 | favicon icon and apple-icon introduced |",
    "excerpt": "The favicon, icon, or apple-icon file conventions allow you to set icons for your application. They are useful for adding app icons that appear in places like web browser tabs, phone home screens, and...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/03-file-conventions/01-metadata/app-icons"
  },
  {
    "id": "01-app-03-api-reference-03-file-conventions-01-metadata-index",
    "path": "01-app\\03-api-reference\\03-file-conventions\\01-metadata\\index.mdx",
    "title": "Metadata Files API Reference",
    "description": "API documentation for the metadata file conventions.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "This section of the docs covers Metadata file conventions. File-based metadata can be defined by adding special metadata files to route segments. Each file convention can be defined using a static file (e.g. opengraph-image.jpg), or a dynamic variant that uses code to generate the file (e.g. opengraph-image.js). Once a file is defined, Next.js will automatically serve the file (with hashes in production for caching) and update the relevant head elements with the correct metadata, such as the asset's URL, file type, and image size. > Good to know: > > - Special Route Handlers like sitemap.ts, opengraph-image.tsx, and icon.tsx, and other metadata files are cached by default. > - If using along with proxy.ts, configure the matcher to exclude the metadata files.",
    "excerpt": "This section of the docs covers Metadata file conventions. File-based metadata can be defined by adding special metadata files to route segments. Each file convention can be defined using a static fil...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/03-file-conventions/01-metadata"
  },
  {
    "id": "01-app-03-api-reference-03-file-conventions-01-metadata-manifest",
    "path": "01-app\\03-api-reference\\03-file-conventions\\01-metadata\\manifest.mdx",
    "title": "manifest.json",
    "description": "API Reference for manifest.json file.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Static Manifest file",
        "slug": "static-manifest-file"
      },
      {
        "level": 2,
        "text": "Generate a Manifest file",
        "slug": "generate-a-manifest-file"
      },
      {
        "level": 3,
        "text": "Manifest Object",
        "slug": "manifest-object"
      }
    ],
    "codeBlocks": [
      {
        "language": "json",
        "code": "{\r\n  \"name\": \"My Next.js Application\",\r\n  \"short_name\": \"Next.js App\",\r\n  \"description\": \"An application built with Next.js\",\r\n  \"start_url\": \"/\"\r\n  // ...\r\n}",
        "context": "filename=\"app/manifest.json | app/manifest.webmanifest\""
      },
      {
        "language": "ts",
        "code": "import type { MetadataRoute } from 'next'\r\n\r\nexport default function manifest(): MetadataRoute.Manifest {\r\n  return {\r\n    name: 'Next.js App',\r\n    short_name: 'Next.js App',\r\n    description: 'Next.js App',\r\n    start_url: '/',\r\n    display: 'standalone',\r\n    background_color: '#fff',\r\n    theme_color: '#fff',\r\n    icons: [\r\n      {\r\n        src: '/favicon.ico',\r\n        sizes: 'any',\r\n        type: 'image/x-icon',\r\n      },\r\n    ],\r\n  }\r\n}",
        "context": "filename=\"app/manifest.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export default function manifest() {\r\n  return {\r\n    name: 'Next.js App',\r\n    short_name: 'Next.js App',\r\n    description: 'Next.js App',\r\n    start_url: '/',\r\n    display: 'standalone',\r\n    background_color: '#fff',\r\n    theme_color: '#fff',\r\n    icons: [\r\n      {\r\n        src: '/favicon.ico',\r\n        sizes: 'any',\r\n        type: 'image/x-icon',\r\n      },\r\n    ],\r\n  }\r\n}",
        "context": "filename=\"app/manifest.js\" switcher"
      }
    ],
    "content": "Add or generate a manifest.(json|webmanifest) file that matches the Web Manifest Specification in the root of app directory to provide information about your web application for the browser. Static Manifest file Generate a Manifest file Add a manifest.js or manifest.ts file that returns a Manifest object. > Good to know: manifest.js is special Route Handlers that is cached by default unless it uses a Dynamic API or dynamic config option. Manifest Object The manifest object contains an extensive list of options that may be updated due to new web standards. For information on all the current options, refer to the MetadataRoute.Manifest type in your code editor if using TypeScript or see the MDN docs.",
    "excerpt": "Add or generate a manifest.(json|webmanifest) file that matches the Web Manifest Specification in the root of app directory to provide information about your web application for the browser. Static Ma...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/03-file-conventions/01-metadata/manifest"
  },
  {
    "id": "01-app-03-api-reference-03-file-conventions-01-metadata-opengraph-image",
    "path": "01-app\\03-api-reference\\03-file-conventions\\01-metadata\\opengraph-image.mdx",
    "title": "opengraph-image and twitter-image",
    "description": "API Reference for the Open Graph Image and Twitter Image file conventions.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Image files (.jpg, .png, .gif)",
        "slug": "image-files-jpg-png-gif"
      },
      {
        "level": 2,
        "text": "Generate images using code (.js, .ts, .tsx)",
        "slug": "generate-images-using-code-js-ts-tsx"
      },
      {
        "level": 3,
        "text": "Props",
        "slug": "props"
      },
      {
        "level": 4,
        "text": " (optional)",
        "slug": "-optional"
      },
      {
        "level": 3,
        "text": "Returns",
        "slug": "returns"
      },
      {
        "level": 3,
        "text": "Config exports",
        "slug": "config-exports"
      },
      {
        "level": 4,
        "text": "Route Segment Config",
        "slug": "route-segment-config"
      },
      {
        "level": 3,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 4,
        "text": "Using external data",
        "slug": "using-external-data"
      },
      {
        "level": 4,
        "text": "Using Node.js runtime with local assets",
        "slug": "using-nodejs-runtime-with-local-assets"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "html",
        "code": "<meta property=\"og:image\" content=\"<generated>\" />\r\n<meta property=\"og:image:type\" content=\"<generated>\" />\r\n<meta property=\"og:image:width\" content=\"<generated>\" />\r\n<meta property=\"og:image:height\" content=\"<generated>\" />",
        "context": "filename=\"<head> output\""
      },
      {
        "language": "html",
        "code": "<meta name=\"twitter:image\" content=\"<generated>\" />\r\n<meta name=\"twitter:image:type\" content=\"<generated>\" />\r\n<meta name=\"twitter:image:width\" content=\"<generated>\" />\r\n<meta name=\"twitter:image:height\" content=\"<generated>\" />",
        "context": "filename=\"<head> output\""
      },
      {
        "language": "txt",
        "code": "About Acme",
        "context": "filename=\"opengraph-image.alt.txt\""
      },
      {
        "language": "html",
        "code": "<meta property=\"og:image:alt\" content=\"About Acme\" />",
        "context": "filename=\"<head> output\""
      },
      {
        "language": "txt",
        "code": "About Acme",
        "context": "filename=\"twitter-image.alt.txt\""
      },
      {
        "language": "html",
        "code": "<meta property=\"twitter:image:alt\" content=\"About Acme\" />",
        "context": "filename=\"<head> output\""
      },
      {
        "language": "tsx",
        "code": "import { ImageResponse } from 'next/og'\r\nimport { readFile } from 'node:fs/promises'\r\nimport { join } from 'node:path'\r\n\r\n// Image metadata\r\nexport const alt = 'About Acme'\r\nexport const size = {\r\n  width: 1200,\r\n  height: 630,\r\n}\r\n\r\nexport const contentType = 'image/png'\r\n\r\n// Image generation\r\nexport default async function Image() {\r\n  // Font loading, process.cwd() is Next.js project directory\r\n  const interSemiBold = await readFile(\r\n    join(process.cwd(), 'assets/Inter-SemiBold.ttf')\r\n  )\r\n\r\n  return new ImageResponse(\r\n    (\r\n      // ImageResponse JSX element\r\n      <div\r\n        style={{\r\n          fontSize: 128,\r\n          background: 'white',\r\n          width: '100%',\r\n          height: '100%',\r\n          display: 'flex',\r\n          alignItems: 'center',\r\n          justifyContent: 'center',\r\n        }}\r\n      >\r\n        About Acme\r\n      </div>\r\n    ),\r\n    // ImageResponse options\r\n    {\r\n      // For convenience, we can re-use the exported opengraph-image\r\n      // size config to also set the ImageResponse's width and height.\r\n      ...size,\r\n      fonts: [\r\n        {\r\n          name: 'Inter',\r\n          data: interSemiBold,\r\n          style: 'normal',\r\n          weight: 400,\r\n        },\r\n      ],\r\n    }\r\n  )\r\n}",
        "context": "filename=\"app/about/opengraph-image.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { ImageResponse } from 'next/og'\r\nimport { readFile } from 'node:fs/promises'\r\nimport { join } from 'node:path'\r\n\r\n// Image metadata\r\nexport const alt = 'About Acme'\r\nexport const size = {\r\n  width: 1200,\r\n  height: 630,\r\n}\r\n\r\nexport const contentType = 'image/png'\r\n\r\n// Image generation\r\nexport default async function Image() {\r\n  // Font loading, process.cwd() is Next.js project directory\r\n  const interSemiBold = await readFile(\r\n    join(process.cwd(), 'assets/Inter-SemiBold.ttf')\r\n  )\r\n\r\n  return new ImageResponse(\r\n    (\r\n      // ImageResponse JSX element\r\n      <div\r\n        style={{\r\n          fontSize: 128,\r\n          background: 'white',\r\n          width: '100%',\r\n          height: '100%',\r\n          display: 'flex',\r\n          alignItems: 'center',\r\n          justifyContent: 'center',\r\n        }}\r\n      >\r\n        About Acme\r\n      </div>\r\n    ),\r\n    // ImageResponse options\r\n    {\r\n      // For convenience, we can re-use the exported opengraph-image\r\n      // size config to also set the ImageResponse's width and height.\r\n      ...size,\r\n      fonts: [\r\n        {\r\n          name: 'Inter',\r\n          data: interSemiBold,\r\n          style: 'normal',\r\n          weight: 400,\r\n        },\r\n      ],\r\n    }\r\n  )\r\n}",
        "context": "filename=\"app/about/opengraph-image.js\" switcher"
      },
      {
        "language": "html",
        "code": "<meta property=\"og:image\" content=\"<generated>\" />\r\n<meta property=\"og:image:alt\" content=\"About Acme\" />\r\n<meta property=\"og:image:type\" content=\"image/png\" />\r\n<meta property=\"og:image:width\" content=\"1200\" />\r\n<meta property=\"og:image:height\" content=\"630\" />",
        "context": "filename=\"<head> output\""
      },
      {
        "language": "tsx",
        "code": "export default async function Image({\r\n  params,\r\n}: {\r\n  params: Promise<{ slug: string }>\r\n}) {\r\n  const { slug } = await params\r\n  // ...\r\n}",
        "context": "filename=\"app/shop/[slug]/opengraph-image.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default async function Image({ params }) {\r\n  const { slug } = await params\r\n  // ...\r\n}",
        "context": "filename=\"app/shop/[slug]/opengraph-image.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export const alt = 'My images alt text'\r\n\r\nexport default function Image() {}",
        "context": "filename=\"opengraph-image.tsx | twitter-image.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export const alt = 'My images alt text'\r\n\r\nexport default function Image() {}",
        "context": "filename=\"opengraph-image.js | twitter-image.js\" switcher"
      },
      {
        "language": "html",
        "code": "<meta property=\"og:image:alt\" content=\"My images alt text\" />",
        "context": "filename=\"<head> output\""
      },
      {
        "language": "tsx",
        "code": "export const size = { width: 1200, height: 630 }\r\n\r\nexport default function Image() {}",
        "context": "filename=\"opengraph-image.tsx | twitter-image.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export const size = { width: 1200, height: 630 }\r\n\r\nexport default function Image() {}",
        "context": "filename=\"opengraph-image.js | twitter-image.js\" switcher"
      },
      {
        "language": "html",
        "code": "<meta property=\"og:image:width\" content=\"1200\" />\r\n<meta property=\"og:image:height\" content=\"630\" />",
        "context": "filename=\"<head> output\""
      },
      {
        "language": "tsx",
        "code": "export const contentType = 'image/png'\r\n\r\nexport default function Image() {}",
        "context": "filename=\"opengraph-image.tsx | twitter-image.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export const contentType = 'image/png'\r\n\r\nexport default function Image() {}",
        "context": "filename=\"opengraph-image.js | twitter-image.js\" switcher"
      },
      {
        "language": "html",
        "code": "<meta property=\"og:image:type\" content=\"image/png\" />",
        "context": "filename=\"<head> output\""
      },
      {
        "language": "tsx",
        "code": "import { ImageResponse } from 'next/og'\r\n\r\nexport const alt = 'About Acme'\r\nexport const size = {\r\n  width: 1200,\r\n  height: 630,\r\n}\r\nexport const contentType = 'image/png'\r\n\r\nexport default async function Image({\r\n  params,\r\n}: {\r\n  params: Promise<{ slug: string }>\r\n}) {\r\n  const { slug } = await params\r\n  const post = await fetch(`https://.../posts/${slug}`).then((res) =>\r\n    res.json()\r\n  )\r\n\r\n  return new ImageResponse(\r\n    (\r\n      <div\r\n        style={{\r\n          fontSize: 48,\r\n          background: 'white',\r\n          width: '100%',\r\n          height: '100%',\r\n          display: 'flex',\r\n          alignItems: 'center',\r\n          justifyContent: 'center',\r\n        }}\r\n      >\r\n        {post.title}\r\n      </div>\r\n    ),\r\n    {\r\n      ...size,\r\n    }\r\n  )\r\n}",
        "context": "filename=\"app/posts/[slug]/opengraph-image.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { ImageResponse } from 'next/og'\r\n\r\nexport const alt = 'About Acme'\r\nexport const size = {\r\n  width: 1200,\r\n  height: 630,\r\n}\r\nexport const contentType = 'image/png'\r\n\r\nexport default async function Image({ params }) {\r\n  const { slug } = await params\r\n  const post = await fetch(`https://.../posts/${slug}`).then((res) =>\r\n    res.json()\r\n  )\r\n\r\n  return new ImageResponse(\r\n    (\r\n      <div\r\n        style={{\r\n          fontSize: 48,\r\n          background: 'white',\r\n          width: '100%',\r\n          height: '100%',\r\n          display: 'flex',\r\n          alignItems: 'center',\r\n          justifyContent: 'center',\r\n        }}\r\n      >\r\n        {post.title}\r\n      </div>\r\n    ),\r\n    {\r\n      ...size,\r\n    }\r\n  )\r\n}",
        "context": "filename=\"app/posts/[slug]/opengraph-image.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { ImageResponse } from 'next/og'\r\nimport { join } from 'node:path'\r\nimport { readFile } from 'node:fs/promises'\r\n\r\nexport default async function Image() {\r\n  const logoData = await readFile(join(process.cwd(), 'logo.png'), 'base64')\r\n  const logoSrc = `data:image/png;base64,${logoData}`\r\n\r\n  return new ImageResponse(\r\n    (\r\n      <div\r\n        style={{\r\n          display: 'flex',\r\n          alignItems: 'center',\r\n          justifyContent: 'center',\r\n        }}\r\n      >\r\n        <img src={logoSrc} height=\"100\" />\r\n      </div>\r\n    )\r\n  )\r\n}",
        "context": "filename=\"app/opengraph-image.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { ImageResponse } from 'next/og'\r\nimport { join } from 'node:path'\r\nimport { readFile } from 'node:fs/promises'\r\n\r\nexport default async function Image() {\r\n  const logoData = await readFile(join(process.cwd(), 'logo.png'), 'base64')\r\n  const logoSrc = `data:image/png;base64,${logoData}`\r\n\r\n  return new ImageResponse(\r\n    (\r\n      <div\r\n        style={{\r\n          display: 'flex',\r\n          alignItems: 'center',\r\n          justifyContent: 'center',\r\n        }}\r\n      >\r\n        <img src={logoSrc} height=\"100\" />\r\n      </div>\r\n    )\r\n  )\r\n}",
        "context": "filename=\"app/opengraph-image.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { ImageResponse } from 'next/og'\r\nimport { join } from 'node:path'\r\nimport { readFile } from 'node:fs/promises'\r\n\r\nexport default async function Image() {\r\n  const logoData = await readFile(join(process.cwd(), 'logo.png'))\r\n  const logoSrc = Uint8Array.from(logoData).buffer\r\n\r\n  return new ImageResponse(\r\n    (\r\n      <div\r\n        style={{\r\n          display: 'flex',\r\n          alignItems: 'center',\r\n          justifyContent: 'center',\r\n        }}\r\n      >\r\n        {/* @ts-expect-error Satori accepts ArrayBuffer/typed arrays for <img src> at runtime */}\r\n        <img src={logoSrc} height=\"100\" />\r\n      </div>\r\n    )\r\n  )\r\n}",
        "context": "filename=\"app/opengraph-image.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { ImageResponse } from 'next/og'\r\nimport { join } from 'node:path'\r\nimport { readFile } from 'node:fs/promises'\r\n\r\nexport default async function Image() {\r\n  const logoData = await readFile(join(process.cwd(), 'logo.png'))\r\n  const logoSrc = Uint8Array.from(logoData).buffer\r\n\r\n  return new ImageResponse(\r\n    (\r\n      <div\r\n        style={{\r\n          display: 'flex',\r\n          alignItems: 'center',\r\n          justifyContent: 'center',\r\n        }}\r\n      >\r\n        <img src={logoSrc} height=\"100\" />\r\n      </div>\r\n    )\r\n  )\r\n}",
        "context": "filename=\"app/opengraph-image.js\" switcher"
      }
    ],
    "content": "The opengraph-image and twitter-image file conventions allow you to set Open Graph and Twitter images for a route segment. They are useful for setting the images that appear on social networks and messaging apps when a user shares a link to your site. There are two ways to set Open Graph and Twitter images: - Using image files (.jpg, .png, .gif) - Using code to generate images (.js, .ts, .tsx) Image files (.jpg, .png, .gif) Use an image file to set a route segment's shared image by placing an opengraph-image or twitter-image image file in the segment. Next.js will evaluate the file and automatically add the appropriate tags to your app's element. | File convention | Supported file types | | ----------------------------------------------- | ------------------------------- | | opengraph-image | .jpg, .jpeg, .png, .gif | | twitter-image | .jpg, .jpeg, .png, .gif | | opengraph-image.alt | .txt | | twitter-image.alt | .txt | > Good to know: > > The twitter-image file size must not exceed 5MB, and the opengraph-image file size must not exceed 8MB. If the image file size exceeds these limits, the build will fail. opengraph-image Add an opengraph-image.(jpg|jpeg|png|gif) image file to any route segment. twitter-image Add a twitter-image.(jpg|jpeg|png|gif) image file to any route segment. opengraph-image.alt.txt Add an accompanying opengraph-image.alt.txt file in the same route segment as the opengraph-image.(jpg|jpeg|png|gif) image it's alt text. twitter-image.alt.txt Add an accompanying twitter-image.alt.txt file in the same route segment as the twitter-image.(jpg|jpeg|png|gif) image it's alt text. Generate images using code (.js, .ts, .tsx) In addition to using literal image files, you can programmatically generate images using code. Generate a route segment's shared image by creating an opengraph-image or twitter-image route that default exports a function. | File convention | Supported file types | | ----------------- | -------------------- | | opengraph-image | .js, .ts, .tsx | | twitter-image | .js, .ts, .tsx | > Good to know: > > - By default, generated images are statically optimized (generated at build time and cached) unless they use Dynamic APIs or uncached data. > - You can generate multiple Images in the same file using generateImageMetadata. > - opengraph-image.js and twitter-image.js are special Route Handlers that is cached by default unless it uses a Dynamic API or dynamic config option. The easiest way to generate an image is to use the ImageResponse API from next/og. Props The default export function receives the following props: params (optional) A promise that resolves to an object containing the dynamic route parameters object from the root segment down to the segment opengraph-image or twitter-image is colocated in. > Good to know: If you use generateImageMetadata, the function will also receive an id prop that is a promise resolving to the id value from one of the items returned by generateImageMetadata. | Route | URL | params | | ------------------------------------------ | ----------- | ---------------------------------- | | app/shop/opengraph-image.js | /shop | undefined | | app/shop/[slug]/opengraph-image.js | /shop/1 | Promise | | app/shop/[tag]/[item]/opengraph-image.js | /shop/1/2 | Promise | Returns The default export function should return a Blob | ArrayBuffer | TypedArray | DataView | ReadableStream | Response. > Good to know: ImageResponse satisfies this return type. Config exports You can optionally configure the image's metadata by exporting alt, size, and contentType variables from opengraph-image or twitter-image route. | Option | Type | | ----------------------------- | --------------------------------------------------------------------------------------------------------------- | | alt | string | | size | { width: number; height: number } | | contentType | string - image MIME type | alt size contentType Route Segment Config opengraph-image and twitter-image are specialized Route Handlers that can use the same route segment configuration options as Pages and Layouts. Examples Using external data This example uses the params object and external data to generate the image. > Good to know: > By default, this generated image will be statically optimized. You can configure the individual fetch options or route segments options to change this behavior. Using Node.js runtime with local assets These examples use the Node.js runtime to fetch a local image from the file system and pass it to the src attribute, either as a base64 string or an ArrayBuffer. Place the local asset relative to the project root, not the example source file. Passing an ArrayBuffer to the src attribute of an element is not part of the HTML spec. The rendering engine used by next/og supports it, but because TypeScript definitions follow the spec, you need a @ts-expect-error directive or similar to use this feature. Version History | Version | Changes | | --------- | ---------------------------------------------------- | | v16.0.0 | params is now a promise that resolves to an object | | v13.3.0 | opengraph-image and twitter-image introduced. |",
    "excerpt": "The opengraph-image and twitter-image file conventions allow you to set Open Graph and Twitter images for a route segment. They are useful for setting the images that appear on social networks and mes...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/03-file-conventions/01-metadata/opengraph-image"
  },
  {
    "id": "01-app-03-api-reference-03-file-conventions-01-metadata-robots",
    "path": "01-app\\03-api-reference\\03-file-conventions\\01-metadata\\robots.mdx",
    "title": "robots.txt",
    "description": "API Reference for robots.txt file.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Static ",
        "slug": "static-"
      },
      {
        "level": 2,
        "text": "Generate a Robots file",
        "slug": "generate-a-robots-file"
      },
      {
        "level": 3,
        "text": "Customizing specific user agents",
        "slug": "customizing-specific-user-agents"
      },
      {
        "level": 3,
        "text": "Robots object",
        "slug": "robots-object"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "txt",
        "code": "User-Agent: *\r\nAllow: /\r\nDisallow: /private/\r\n\r\nSitemap: https://acme.com/sitemap.xml",
        "context": "filename=\"app/robots.txt\""
      },
      {
        "language": "ts",
        "code": "import type { MetadataRoute } from 'next'\r\n\r\nexport default function robots(): MetadataRoute.Robots {\r\n  return {\r\n    rules: {\r\n      userAgent: '*',\r\n      allow: '/',\r\n      disallow: '/private/',\r\n    },\r\n    sitemap: 'https://acme.com/sitemap.xml',\r\n  }\r\n}",
        "context": "filename=\"app/robots.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export default function robots() {\r\n  return {\r\n    rules: {\r\n      userAgent: '*',\r\n      allow: '/',\r\n      disallow: '/private/',\r\n    },\r\n    sitemap: 'https://acme.com/sitemap.xml',\r\n  }\r\n}",
        "context": "filename=\"app/robots.js\" switcher"
      },
      {
        "language": "txt",
        "code": "User-Agent: *\r\nAllow: /\r\nDisallow: /private/\r\n\r\nSitemap: https://acme.com/sitemap.xml",
        "context": ""
      },
      {
        "language": "ts",
        "code": "import type { MetadataRoute } from 'next'\r\n\r\nexport default function robots(): MetadataRoute.Robots {\r\n  return {\r\n    rules: [\r\n      {\r\n        userAgent: 'Googlebot',\r\n        allow: ['/'],\r\n        disallow: '/private/',\r\n      },\r\n      {\r\n        userAgent: ['Applebot', 'Bingbot'],\r\n        disallow: ['/'],\r\n      },\r\n    ],\r\n    sitemap: 'https://acme.com/sitemap.xml',\r\n  }\r\n}",
        "context": "filename=\"app/robots.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export default function robots() {\r\n  return {\r\n    rules: [\r\n      {\r\n        userAgent: 'Googlebot',\r\n        allow: ['/'],\r\n        disallow: ['/private/'],\r\n      },\r\n      {\r\n        userAgent: ['Applebot', 'Bingbot'],\r\n        disallow: ['/'],\r\n      },\r\n    ],\r\n    sitemap: 'https://acme.com/sitemap.xml',\r\n  }\r\n}",
        "context": "filename=\"app/robots.js\" switcher"
      },
      {
        "language": "txt",
        "code": "User-Agent: Googlebot\r\nAllow: /\r\nDisallow: /private/\r\n\r\nUser-Agent: Applebot\r\nDisallow: /\r\n\r\nUser-Agent: Bingbot\r\nDisallow: /\r\n\r\nSitemap: https://acme.com/sitemap.xml",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "type Robots = {\r\n  rules:\r\n    | {\r\n        userAgent?: string | string[]\r\n        allow?: string | string[]\r\n        disallow?: string | string[]\r\n        crawlDelay?: number\r\n      }\r\n    | Array<{\r\n        userAgent: string | string[]\r\n        allow?: string | string[]\r\n        disallow?: string | string[]\r\n        crawlDelay?: number\r\n      }>\r\n  sitemap?: string | string[]\r\n  host?: string\r\n}",
        "context": ""
      }
    ],
    "content": "Add or generate a robots.txt file that matches the Robots Exclusion Standard in the root of app directory to tell search engine crawlers which URLs they can access on your site. Static robots.txt Generate a Robots file Add a robots.js or robots.ts file that returns a Robots object. > Good to know: robots.js is a special Route Handlers that is cached by default unless it uses a Dynamic API or dynamic config option. Output: Customizing specific user agents You can customise how individual search engine bots crawl your site by passing an array of user agents to the rules property. For example: Output: Robots object Version History | Version | Changes | | --------- | -------------------- | | v13.3.0 | robots introduced. |",
    "excerpt": "Add or generate a robots.txt file that matches the Robots Exclusion Standard in the root of app directory to tell search engine crawlers which URLs they can access on your site. Static robots.txt Gene...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/03-file-conventions/01-metadata/robots"
  },
  {
    "id": "01-app-03-api-reference-03-file-conventions-01-metadata-sitemap",
    "path": "01-app\\03-api-reference\\03-file-conventions\\01-metadata\\sitemap.mdx",
    "title": "sitemap.xml",
    "description": "API Reference for the sitemap.xml file.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 3,
        "text": "Sitemap files (.xml)",
        "slug": "sitemap-files-xml"
      },
      {
        "level": 3,
        "text": "Generating a sitemap using code (.js, .ts)",
        "slug": "generating-a-sitemap-using-code-js-ts"
      },
      {
        "level": 3,
        "text": "Image Sitemaps",
        "slug": "image-sitemaps"
      },
      {
        "level": 3,
        "text": "Video Sitemaps",
        "slug": "video-sitemaps"
      },
      {
        "level": 3,
        "text": "Generate a localized Sitemap",
        "slug": "generate-a-localized-sitemap"
      },
      {
        "level": 3,
        "text": "Generating multiple sitemaps",
        "slug": "generating-multiple-sitemaps"
      },
      {
        "level": 2,
        "text": "Returns",
        "slug": "returns"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "xml",
        "code": "<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\r\n  <url>\r\n    <loc>https://acme.com</loc>\r\n    <lastmod>2023-04-06T15:02:24.021Z</lastmod>\r\n    <changefreq>yearly</changefreq>\r\n    <priority>1</priority>\r\n  </url>\r\n  <url>\r\n    <loc>https://acme.com/about</loc>\r\n    <lastmod>2023-04-06T15:02:24.021Z</lastmod>\r\n    <changefreq>monthly</changefreq>\r\n    <priority>0.8</priority>\r\n  </url>\r\n  <url>\r\n    <loc>https://acme.com/blog</loc>\r\n    <lastmod>2023-04-06T15:02:24.021Z</lastmod>\r\n    <changefreq>weekly</changefreq>\r\n    <priority>0.5</priority>\r\n  </url>\r\n</urlset>",
        "context": "filename=\"app/sitemap.xml\""
      },
      {
        "language": "ts",
        "code": "import type { MetadataRoute } from 'next'\r\n\r\nexport default function sitemap(): MetadataRoute.Sitemap {\r\n  return [\r\n    {\r\n      url: 'https://acme.com',\r\n      lastModified: new Date(),\r\n      changeFrequency: 'yearly',\r\n      priority: 1,\r\n    },\r\n    {\r\n      url: 'https://acme.com/about',\r\n      lastModified: new Date(),\r\n      changeFrequency: 'monthly',\r\n      priority: 0.8,\r\n    },\r\n    {\r\n      url: 'https://acme.com/blog',\r\n      lastModified: new Date(),\r\n      changeFrequency: 'weekly',\r\n      priority: 0.5,\r\n    },\r\n  ]\r\n}",
        "context": "filename=\"app/sitemap.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export default function sitemap() {\r\n  return [\r\n    {\r\n      url: 'https://acme.com',\r\n      lastModified: new Date(),\r\n      changeFrequency: 'yearly',\r\n      priority: 1,\r\n    },\r\n    {\r\n      url: 'https://acme.com/about',\r\n      lastModified: new Date(),\r\n      changeFrequency: 'monthly',\r\n      priority: 0.8,\r\n    },\r\n    {\r\n      url: 'https://acme.com/blog',\r\n      lastModified: new Date(),\r\n      changeFrequency: 'weekly',\r\n      priority: 0.5,\r\n    },\r\n  ]\r\n}",
        "context": "filename=\"app/sitemap.js\" switcher"
      },
      {
        "language": "xml",
        "code": "<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\r\n  <url>\r\n    <loc>https://acme.com</loc>\r\n    <lastmod>2023-04-06T15:02:24.021Z</lastmod>\r\n    <changefreq>yearly</changefreq>\r\n    <priority>1</priority>\r\n  </url>\r\n  <url>\r\n    <loc>https://acme.com/about</loc>\r\n    <lastmod>2023-04-06T15:02:24.021Z</lastmod>\r\n    <changefreq>monthly</changefreq>\r\n    <priority>0.8</priority>\r\n  </url>\r\n  <url>\r\n    <loc>https://acme.com/blog</loc>\r\n    <lastmod>2023-04-06T15:02:24.021Z</lastmod>\r\n    <changefreq>weekly</changefreq>\r\n    <priority>0.5</priority>\r\n  </url>\r\n</urlset>",
        "context": "filename=\"acme.com/sitemap.xml\""
      },
      {
        "language": "ts",
        "code": "import type { MetadataRoute } from 'next'\r\n\r\nexport default function sitemap(): MetadataRoute.Sitemap {\r\n  return [\r\n    {\r\n      url: 'https://example.com',\r\n      lastModified: '2021-01-01',\r\n      changeFrequency: 'weekly',\r\n      priority: 0.5,\r\n      images: ['https://example.com/image.jpg'],\r\n    },\r\n  ]\r\n}",
        "context": "filename=\"app/sitemap.ts\" switcher"
      },
      {
        "language": "xml",
        "code": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<urlset\r\n  xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\"\r\n  xmlns:image=\"http://www.google.com/schemas/sitemap-image/1.1\"\r\n>\r\n  <url>\r\n    <loc>https://example.com</loc>\r\n    <image:image>\r\n      <image:loc>https://example.com/image.jpg</image:loc>\r\n    </image:image>\r\n    <lastmod>2021-01-01</lastmod>\r\n    <changefreq>weekly</changefreq>\r\n    <priority>0.5</priority>\r\n  </url>\r\n</urlset>",
        "context": "filename=\"acme.com/sitemap.xml\""
      },
      {
        "language": "ts",
        "code": "import type { MetadataRoute } from 'next'\r\n\r\nexport default function sitemap(): MetadataRoute.Sitemap {\r\n  return [\r\n    {\r\n      url: 'https://example.com',\r\n      lastModified: '2021-01-01',\r\n      changeFrequency: 'weekly',\r\n      priority: 0.5,\r\n      videos: [\r\n        {\r\n          title: 'example',\r\n          thumbnail_loc: 'https://example.com/image.jpg',\r\n          description: 'this is the description',\r\n        },\r\n      ],\r\n    },\r\n  ]\r\n}",
        "context": "filename=\"app/sitemap.ts\" switcher"
      },
      {
        "language": "xml",
        "code": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<urlset\r\n  xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\"\r\n  xmlns:video=\"http://www.google.com/schemas/sitemap-video/1.1\"\r\n>\r\n  <url>\r\n    <loc>https://example.com</loc>\r\n    <video:video>\r\n      <video:title>example</video:title>\r\n      <video:thumbnail_loc>https://example.com/image.jpg</video:thumbnail_loc>\r\n      <video:description>this is the description</video:description>\r\n    </video:video>\r\n    <lastmod>2021-01-01</lastmod>\r\n    <changefreq>weekly</changefreq>\r\n    <priority>0.5</priority>\r\n  </url>\r\n</urlset>",
        "context": "filename=\"acme.com/sitemap.xml\""
      },
      {
        "language": "ts",
        "code": "import type { MetadataRoute } from 'next'\r\n\r\nexport default function sitemap(): MetadataRoute.Sitemap {\r\n  return [\r\n    {\r\n      url: 'https://acme.com',\r\n      lastModified: new Date(),\r\n      alternates: {\r\n        languages: {\r\n          es: 'https://acme.com/es',\r\n          de: 'https://acme.com/de',\r\n        },\r\n      },\r\n    },\r\n    {\r\n      url: 'https://acme.com/about',\r\n      lastModified: new Date(),\r\n      alternates: {\r\n        languages: {\r\n          es: 'https://acme.com/es/about',\r\n          de: 'https://acme.com/de/about',\r\n        },\r\n      },\r\n    },\r\n    {\r\n      url: 'https://acme.com/blog',\r\n      lastModified: new Date(),\r\n      alternates: {\r\n        languages: {\r\n          es: 'https://acme.com/es/blog',\r\n          de: 'https://acme.com/de/blog',\r\n        },\r\n      },\r\n    },\r\n  ]\r\n}",
        "context": "filename=\"app/sitemap.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export default function sitemap() {\r\n  return [\r\n    {\r\n      url: 'https://acme.com',\r\n      lastModified: new Date(),\r\n      alternates: {\r\n        languages: {\r\n          es: 'https://acme.com/es',\r\n          de: 'https://acme.com/de',\r\n        },\r\n      },\r\n    },\r\n    {\r\n      url: 'https://acme.com/about',\r\n      lastModified: new Date(),\r\n      alternates: {\r\n        languages: {\r\n          es: 'https://acme.com/es/about',\r\n          de: 'https://acme.com/de/about',\r\n        },\r\n      },\r\n    },\r\n    {\r\n      url: 'https://acme.com/blog',\r\n      lastModified: new Date(),\r\n      alternates: {\r\n        languages: {\r\n          es: 'https://acme.com/es/blog',\r\n          de: 'https://acme.com/de/blog',\r\n        },\r\n      },\r\n    },\r\n  ]\r\n}",
        "context": "filename=\"app/sitemap.js\" switcher"
      },
      {
        "language": "xml",
        "code": "<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\" xmlns:xhtml=\"http://www.w3.org/1999/xhtml\">\r\n  <url>\r\n    <loc>https://acme.com</loc>\r\n    <xhtml:link\r\n      rel=\"alternate\"\r\n      hreflang=\"es\"\r\n      href=\"https://acme.com/es\"/>\r\n    <xhtml:link\r\n      rel=\"alternate\"\r\n      hreflang=\"de\"\r\n      href=\"https://acme.com/de\"/>\r\n    <lastmod>2023-04-06T15:02:24.021Z</lastmod>\r\n  </url>\r\n  <url>\r\n    <loc>https://acme.com/about</loc>\r\n    <xhtml:link\r\n      rel=\"alternate\"\r\n      hreflang=\"es\"\r\n      href=\"https://acme.com/es/about\"/>\r\n    <xhtml:link\r\n      rel=\"alternate\"\r\n      hreflang=\"de\"\r\n      href=\"https://acme.com/de/about\"/>\r\n    <lastmod>2023-04-06T15:02:24.021Z</lastmod>\r\n  </url>\r\n  <url>\r\n    <loc>https://acme.com/blog</loc>\r\n    <xhtml:link\r\n      rel=\"alternate\"\r\n      hreflang=\"es\"\r\n      href=\"https://acme.com/es/blog\"/>\r\n    <xhtml:link\r\n      rel=\"alternate\"\r\n      hreflang=\"de\"\r\n      href=\"https://acme.com/de/blog\"/>\r\n    <lastmod>2023-04-06T15:02:24.021Z</lastmod>\r\n  </url>\r\n</urlset>",
        "context": "filename=\"acme.com/sitemap.xml\""
      },
      {
        "language": "ts",
        "code": "import type { MetadataRoute } from 'next'\r\nimport { BASE_URL } from '@/app/lib/constants'\r\n\r\nexport async function generateSitemaps() {\r\n  // Fetch the total number of products and calculate the number of sitemaps needed\r\n  return [{ id: 0 }, { id: 1 }, { id: 2 }, { id: 3 }]\r\n}\r\n\r\nexport default async function sitemap({\r\n  id,\r\n}: {\r\n  id: number\r\n}): Promise<MetadataRoute.Sitemap> {\r\n  // Google's limit is 50,000 URLs per sitemap\r\n  const start = id * 50000\r\n  const end = start + 50000\r\n  const products = await getProducts(\r\n    `SELECT id, date FROM products WHERE id BETWEEN ${start} AND ${end}`\r\n  )\r\n  return products.map((product) => ({\r\n    url: `${BASE_URL}/product/${product.id}`,\r\n    lastModified: product.date,\r\n  }))\r\n}",
        "context": "filename=\"app/product/sitemap.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { BASE_URL } from '@/app/lib/constants'\r\n\r\nexport async function generateSitemaps() {\r\n  // Fetch the total number of products and calculate the number of sitemaps needed\r\n  return [{ id: 0 }, { id: 1 }, { id: 2 }, { id: 3 }]\r\n}\r\n\r\nexport default async function sitemap({ id }) {\r\n  // Google's limit is 50,000 URLs per sitemap\r\n  const start = id * 50000\r\n  const end = start + 50000\r\n  const products = await getProducts(\r\n    `SELECT id, date FROM products WHERE id BETWEEN ${start} AND ${end}`\r\n  )\r\n  return products.map((product) => ({\r\n    url: `${BASE_URL}/product/${product.id}`,\r\n    lastModified: product.date,\r\n  }))\r\n}",
        "context": "filename=\"app/product/sitemap.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "type Sitemap = Array<{\r\n  url: string\r\n  lastModified?: string | Date\r\n  changeFrequency?:\r\n    | 'always'\r\n    | 'hourly'\r\n    | 'daily'\r\n    | 'weekly'\r\n    | 'monthly'\r\n    | 'yearly'\r\n    | 'never'\r\n  priority?: number\r\n  alternates?: {\r\n    languages?: Languages<string>\r\n  }\r\n}>",
        "context": ""
      }
    ],
    "content": "sitemap.(xml|js|ts) is a special file that matches the Sitemaps XML format to help search engine crawlers index your site more efficiently. Sitemap files (.xml) For smaller applications, you can create a sitemap.xml file and place it in the root of your app directory. Generating a sitemap using code (.js, .ts) You can use the sitemap.(js|ts) file convention to programmatically generate a sitemap by exporting a default function that returns an array of URLs. If using TypeScript, a Sitemap type is available. > Good to know: sitemap.js is a special Route Handler that is cached by default unless it uses a Dynamic API or dynamic config option. Output: Image Sitemaps You can use images property to create image sitemaps. Learn more details in the Google Developer Docs. Output: Video Sitemaps You can use videos property to create video sitemaps. Learn more details in the Google Developer Docs. Output: Generate a localized Sitemap Output: Generating multiple sitemaps While a single sitemap will work for most applications. For large web applications, you may need to split a sitemap into multiple files. There are two ways you can create multiple sitemaps: - By nesting sitemap.(xml|js|ts) inside multiple route segments e.g. app/sitemap.xml and app/products/sitemap.xml. - By using the generateSitemaps function. For example, to split a sitemap using generateSitemaps, return an array of objects with the sitemap id. Then, use the id to generate the unique sitemaps. Your generated sitemaps will be available at /.../sitemap/[id]. For example, /product/sitemap/1.xml. See the generateSitemaps API reference for more information. Returns The default function exported from sitemap.(xml|ts|js) should return an array of objects with the following properties: Version History | Version | Changes | | ---------- | ------------------------------------------------------------ | | v14.2.0 | Add localizations support. | | v13.4.14 | Add changeFrequency and priority attributes to sitemaps. | | v13.3.0 | sitemap introduced. |",
    "excerpt": "sitemap.(xml|js|ts) is a special file that matches the Sitemaps XML format to help search engine crawlers index your site more efficiently. Sitemap files (.xml) For smaller applications, you can creat...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/03-file-conventions/01-metadata/sitemap"
  },
  {
    "id": "01-app-03-api-reference-03-file-conventions-default",
    "path": "01-app\\03-api-reference\\03-file-conventions\\default.mdx",
    "title": "default.js",
    "description": "API Reference for the default.js file.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Reference",
        "slug": "reference"
      },
      {
        "level": 3,
        "text": " (optional)",
        "slug": "-optional"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "import { notFound } from 'next/navigation'\r\n\r\nexport default function Default() {\r\n  notFound()\r\n}",
        "context": "filename=\"app/@team/default.js\""
      },
      {
        "language": "tsx",
        "code": "export default async function Default({\r\n  params,\r\n}: {\r\n  params: Promise<{ artist: string }>\r\n}) {\r\n  const { artist } = await params\r\n}",
        "context": "filename=\"app/[artist]/@sidebar/default.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default async function Default({ params }) {\r\n  const { artist } = await params\r\n}",
        "context": "filename=\"app/[artist]/@sidebar/default.js\" switcher"
      }
    ],
    "content": "The default.js file is used to render a fallback within Parallel Routes when Next.js cannot recover a slot's active state after a full-page load. During soft navigation, Next.js keeps track of the active state (subpage) for each slot. However, for hard navigations (full-page load), Next.js cannot recover the active state. In this case, a default.js file can be rendered for subpages that don't match the current URL. Consider the following folder structure. The @team slot has a settings page, but @analytics does not. When navigating to /settings, the @team slot will render the settings page while maintaining the currently active page for the @analytics slot. On refresh, Next.js will render a default.js for @analytics. If default.js doesn't exist, an error is returned for named slots (@team, @analytics, etc) and requires you to define a default.js in order to continue. If you want to preserve the old behavior of returning a 404 in these situations, you can create a default.js that contains: Additionally, since children is an implicit slot, you also need to create a default.js file to render a fallback for children when Next.js cannot recover the active state of the parent page. If you don't create a default.js for the children slot, it will return a 404 page for the route. Reference params (optional) A promise that resolves to an object containing the dynamic route parameters from the root segment down to the slot's subpages. For example: | Example | URL | params | | ------------------------------------------ | ------------ | -------------------------------------------- | | app/[artist]/@sidebar/default.js | /zack | Promise | | app/[artist]/[album]/@sidebar/default.js | /zack/next | Promise | - Since the params prop is a promise. You must use async/await or React's use function to access the values. - In version 14 and earlier, params was a synchronous prop. To help with backwards compatibility, you can still access it synchronously in Next.js 15, but this behavior will be deprecated in the future.",
    "excerpt": "The default.js file is used to render a fallback within Parallel Routes when Next.js cannot recover a slot's active state after a full-page load. During soft navigation, Next.js keeps track of the act...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/03-file-conventions/default"
  },
  {
    "id": "01-app-03-api-reference-03-file-conventions-dynamic-routes",
    "path": "01-app\\03-api-reference\\03-file-conventions\\dynamic-routes.mdx",
    "title": "Dynamic Route Segments",
    "description": "Dynamic Route Segments can be used to programmatically generate route segments from dynamic data.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Convention",
        "slug": "convention"
      },
      {
        "level": 3,
        "text": "In Client Components",
        "slug": "in-client-components"
      },
      {
        "level": 3,
        "text": "Catch-all Segments",
        "slug": "catch-all-segments"
      },
      {
        "level": 3,
        "text": "Optional Catch-all Segments",
        "slug": "optional-catch-all-segments"
      },
      {
        "level": 3,
        "text": "TypeScript",
        "slug": "typescript"
      },
      {
        "level": 2,
        "text": "Behavior",
        "slug": "behavior"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "With ",
        "slug": "with-"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "export default async function Page({\r\n  params,\r\n}: {\r\n  params: Promise<{ slug: string }>\r\n}) {\r\n  const { slug } = await params\r\n  return <div>My Post: {slug}</div>\r\n}",
        "context": "filename=\"app/blog/[slug]/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default async function Page({ params }) {\r\n  const { slug } = await params\r\n  return <div>My Post: {slug}</div>\r\n}",
        "context": "filename=\"app/blog/[slug]/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\nimport { use } from 'react'\r\n\r\nexport default function BlogPostPage({\r\n  params,\r\n}: {\r\n  params: Promise<{ slug: string }>\r\n}) {\r\n  const { slug } = use(params)\r\n\r\n  return (\r\n    <div>\r\n      <p>{slug}</p>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/blog/[slug]/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\nimport { use } from 'react'\r\nimport { useParams } from 'next/navigation'\r\n\r\nexport default function BlogPostPage({ params }) {\r\n  const { slug } = use(params)\r\n\r\n  return (\r\n    <div>\r\n      <p>{slug}</p>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/blog/[slug]/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { notFound } from 'next/navigation'\r\nimport type { Locale } from '@i18n/types'\r\nimport { isValidLocale } from '@i18n/utils'\r\n\r\nfunction assertValidLocale(value: string): asserts value is Locale {\r\n  if (!isValidLocale(value)) notFound()\r\n}\r\n\r\nexport default async function Page(props: PageProps<'/[locale]'>) {\r\n  const { locale } = await props.params // locale is typed as string\r\n  assertValidLocale(locale)\r\n  // locale is now typed as Locale\r\n}",
        "context": "filename=\"/app/[locale]/page.tsx\""
      },
      {
        "language": "tsx",
        "code": "export async function generateStaticParams() {\r\n  const posts = await fetch('https://.../posts').then((res) => res.json())\r\n\r\n  return posts.map((post) => ({\r\n    slug: post.slug,\r\n  }))\r\n}",
        "context": "filename=\"app/blog/[slug]/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export async function generateStaticParams() {\r\n  const posts = await fetch('https://.../posts').then((res) => res.json())\r\n\r\n  return posts.map((post) => ({\r\n    slug: post.slug,\r\n  }))\r\n}",
        "context": "filename=\"app/blog/[slug]/page.js\" switcher"
      }
    ],
    "content": "When you don't know the exact route segment names ahead of time and want to create routes from dynamic data, you can use Dynamic Segments that are filled in at request time or prerendered at build time. Convention A Dynamic Segment can be created by wrapping a folder's name in square brackets: [folderName]. For example, a blog could include the following route app/blog/[slug]/page.js where [slug] is the Dynamic Segment for blog posts. Dynamic Segments are passed as the params prop to layout, page, route, and generateMetadata functions. | Route | Example URL | params | | ------------------------- | ----------- | --------------- | | app/blog/[slug]/page.js | /blog/a | { slug: 'a' } | | app/blog/[slug]/page.js | /blog/b | { slug: 'b' } | | app/blog/[slug]/page.js | /blog/c | { slug: 'c' } | In Client Components In a Client Component page, dynamic segments from props can be accessed using the use hook. Alternatively Client Components can use the useParams hook to access the params anywhere in the Client Component tree. Catch-all Segments Dynamic Segments can be extended to catch-all subsequent segments by adding an ellipsis inside the brackets [...folderName]. For example, app/shop/[...slug]/page.js will match /shop/clothes, but also /shop/clothes/tops, /shop/clothes/tops/t-shirts, and so on. | Route | Example URL | params | | ---------------------------- | ------------- | --------------------------- | | app/shop/[...slug]/page.js | /shop/a | { slug: ['a'] } | | app/shop/[...slug]/page.js | /shop/a/b | { slug: ['a', 'b'] } | | app/shop/[...slug]/page.js | /shop/a/b/c | { slug: ['a', 'b', 'c'] } | Optional Catch-all Segments Catch-all Segments can be made optional by including the parameter in double square brackets: [[...folderName]]. For example, app/shop/[[...slug]]/page.js will also match /shop, in addition to /shop/clothes, /shop/clothes/tops, /shop/clothes/tops/t-shirts. The difference between catch-all and optional catch-all segments is that with optional, the route without the parameter is also matched (/shop in the example above). | Route | Example URL | params | | ------------------------------ | ------------- | --------------------------- | | app/shop/[[...slug]]/page.js | /shop | { slug: undefined } | | app/shop/[[...slug]]/page.js | /shop/a | { slug: ['a'] } | | app/shop/[[...slug]]/page.js | /shop/a/b | { slug: ['a', 'b'] } | | app/shop/[[...slug]]/page.js | /shop/a/b/c | { slug: ['a', 'b', 'c'] } | TypeScript When using TypeScript, you can add types for params depending on your configured route segment — use PageProps, LayoutProps, or RouteContext to type params in page, layout, and route respectively. Route params values are typed as string, string[], or undefined (for optional catch-all segments), because their values aren't known until runtime. Users can enter any URL into the address bar, and these broad types help ensure that your application code handles all these possible cases. | Route | params Type Definition | | ----------------------------------- | ---------------------------------------- | | app/blog/[slug]/page.js | { slug: string } | | app/shop/[...slug]/page.js | { slug: string[] } | | app/shop/[[...slug]]/page.js | { slug?: string[] } | | app/[categoryId]/[itemId]/page.js | { categoryId: string, itemId: string } | If you're working on a route where params can only have a fixed number of valid values, such as a [locale] param with a known set of language codes, you can use runtime validation to handle any invalid params a user may enter, and let the rest of your application work with the narrower type from your known set. Behavior - Since the params prop is a promise. You must use async/await or React's use function to access the values. - In version 14 and earlier, params was a synchronous prop. To help with backwards compatibility, you can still access it synchronously in Next.js 15, but this behavior will be deprecated in the future. Examples With generateStaticParams The generateStaticParams function can be used to statically generate routes at build time instead of on-demand at request time. When using fetch inside the generateStaticParams function, the requests are automatically deduplicated. This avoids multiple network calls for the same data Layouts, Pages, and other generateStaticParams functions, speeding up build time.",
    "excerpt": "When you don't know the exact route segment names ahead of time and want to create routes from dynamic data, you can use Dynamic Segments that are filled in at request time or prerendered at build tim...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/03-file-conventions/dynamic-routes"
  },
  {
    "id": "01-app-03-api-reference-03-file-conventions-error",
    "path": "01-app\\03-api-reference\\03-file-conventions\\error.mdx",
    "title": "error.js",
    "description": "API reference for the error.js special file.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Reference",
        "slug": "reference"
      },
      {
        "level": 3,
        "text": "Props",
        "slug": "props"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Global Error",
        "slug": "global-error"
      },
      {
        "level": 3,
        "text": "Graceful error recovery with a custom error boundary",
        "slug": "graceful-error-recovery-with-a-custom-error-boundary"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "'use client' // Error boundaries must be Client Components\r\n\r\nimport { useEffect } from 'react'\r\n\r\nexport default function Error({\r\n  error,\r\n  reset,\r\n}: {\r\n  error: Error & { digest?: string }\r\n  reset: () => void\r\n}) {\r\n  useEffect(() => {\r\n    // Log the error to an error reporting service\r\n    console.error(error)\r\n  }, [error])\r\n\r\n  return (\r\n    <div>\r\n      <h2>Something went wrong!</h2>\r\n      <button\r\n        onClick={\r\n          // Attempt to recover by trying to re-render the segment\r\n          () => reset()\r\n        }\r\n      >\r\n        Try again\r\n      </button>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/dashboard/error.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client' // Error boundaries must be Client Components\r\n\r\nimport { useEffect } from 'react'\r\n\r\nexport default function Error({ error, reset }) {\r\n  useEffect(() => {\r\n    // Log the error to an error reporting service\r\n    console.error(error)\r\n  }, [error])\r\n\r\n  return (\r\n    <div>\r\n      <h2>Something went wrong!</h2>\r\n      <button\r\n        onClick={\r\n          // Attempt to recover by trying to re-render the segment\r\n          () => reset()\r\n        }\r\n      >\r\n        Try again\r\n      </button>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/dashboard/error.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client' // Error boundaries must be Client Components\r\n\r\nexport default function Error({\r\n  error,\r\n  reset,\r\n}: {\r\n  error: Error & { digest?: string }\r\n  reset: () => void\r\n}) {\r\n  return (\r\n    <div>\r\n      <h2>Something went wrong!</h2>\r\n      <button onClick={() => reset()}>Try again</button>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/dashboard/error.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client' // Error boundaries must be Client Components\r\n\r\nexport default function Error({ error, reset }) {\r\n  return (\r\n    <div>\r\n      <h2>Something went wrong!</h2>\r\n      <button onClick={() => reset()}>Try again</button>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/dashboard/error.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client' // Error boundaries must be Client Components\r\n\r\nexport default function GlobalError({\r\n  error,\r\n  reset,\r\n}: {\r\n  error: Error & { digest?: string }\r\n  reset: () => void\r\n}) {\r\n  return (\r\n    // global-error must include html and body tags\r\n    <html>\r\n      <body>\r\n        <h2>Something went wrong!</h2>\r\n        <button onClick={() => reset()}>Try again</button>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/global-error.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client' // Error boundaries must be Client Components\r\n\r\nexport default function GlobalError({ error, reset }) {\r\n  return (\r\n    // global-error must include html and body tags\r\n    <html>\r\n      <body>\r\n        <h2>Something went wrong!</h2>\r\n        <button onClick={() => reset()}>Try again</button>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/global-error.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport React, { Component, ErrorInfo, ReactNode } from 'react'\r\n\r\ninterface ErrorBoundaryProps {\r\n  children: ReactNode\r\n  onError?: (error: Error, errorInfo: ErrorInfo) => void\r\n}\r\n\r\ninterface ErrorBoundaryState {\r\n  hasError: boolean\r\n}\r\n\r\nexport class GracefullyDegradingErrorBoundary extends Component<\r\n  ErrorBoundaryProps,\r\n  ErrorBoundaryState\r\n> {\r\n  private contentRef: React.RefObject<HTMLDivElement | null>\r\n\r\n  constructor(props: ErrorBoundaryProps) {\r\n    super(props)\r\n    this.state = { hasError: false }\r\n    this.contentRef = React.createRef()\r\n  }\r\n\r\n  static getDerivedStateFromError(_: Error): ErrorBoundaryState {\r\n    return { hasError: true }\r\n  }\r\n\r\n  componentDidCatch(error: Error, errorInfo: ErrorInfo) {\r\n    if (this.props.onError) {\r\n      this.props.onError(error, errorInfo)\r\n    }\r\n  }\r\n\r\n  render() {\r\n    if (this.state.hasError) {\r\n      // Render the current HTML content without hydration\r\n      return (\r\n        <>\r\n          <div\r\n            ref={this.contentRef}\r\n            suppressHydrationWarning\r\n            dangerouslySetInnerHTML={{\r\n              __html: this.contentRef.current?.innerHTML || '',\r\n            }}\r\n          />\r\n          <div className=\"fixed bottom-0 left-0 right-0 bg-red-600 text-white py-4 px-6 text-center\">\r\n            <p className=\"font-semibold\">\r\n              An error occurred during page rendering\r\n            </p>\r\n          </div>\r\n        </>\r\n      )\r\n    }\r\n\r\n    return <div ref={this.contentRef}>{this.props.children}</div>\r\n  }\r\n}\r\n\r\nexport default GracefullyDegradingErrorBoundary",
        "context": "filename=\"app/dashboard/error.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport React, { Component, createRef } from 'react'\r\n\r\nclass GracefullyDegradingErrorBoundary extends Component {\r\n  constructor(props) {\r\n    super(props)\r\n    this.state = { hasError: false }\r\n    this.contentRef = createRef()\r\n  }\r\n\r\n  static getDerivedStateFromError(_) {\r\n    return { hasError: true }\r\n  }\r\n\r\n  componentDidCatch(error, errorInfo) {\r\n    if (this.props.onError) {\r\n      this.props.onError(error, errorInfo)\r\n    }\r\n  }\r\n\r\n  render() {\r\n    if (this.state.hasError) {\r\n      // Render the current HTML content without hydration\r\n      return (\r\n        <>\r\n          <div\r\n            ref={this.contentRef}\r\n            suppressHydrationWarning\r\n            dangerouslySetInnerHTML={{\r\n              __html: this.contentRef.current?.innerHTML || '',\r\n            }}\r\n          />\r\n          <div className=\"fixed bottom-0 left-0 right-0 bg-red-600 text-white py-4 px-6 text-center\">\r\n            <p className=\"font-semibold\">\r\n              An error occurred during page rendering\r\n            </p>\r\n          </div>\r\n        </>\r\n      )\r\n    }\r\n\r\n    return <div ref={this.contentRef}>{this.props.children}</div>\r\n  }\r\n}\r\n\r\nexport default GracefullyDegradingErrorBoundary",
        "context": "filename=\"app/dashboard/error.js\" switcher"
      }
    ],
    "content": "An error file allows you to handle unexpected runtime errors and display fallback UI. error.js wraps a route segment and its nested children in a React Error Boundary. When an error throws within the boundary, the error component shows as the fallback UI. > Good to know: > > - The React DevTools allow you to toggle error boundaries to test error states. > - If you want errors to bubble up to the parent error boundary, you can throw when rendering the error component. Reference Props error An instance of an Error object forwarded to the error.js Client Component. > Good to know: During development, the Error object forwarded to the client will be serialized and include the message of the original error for easier debugging. However, this behavior is different in production to avoid leaking potentially sensitive details included in the error to the client. error.message - Errors forwarded from Client Components show the original Error message. - Errors forwarded from Server Components show a generic message with an identifier. This is to prevent leaking sensitive details. You can use the identifier, under errors.digest, to match the corresponding server-side logs. error.digest An automatically generated hash of the error thrown. It can be used to match the corresponding error in server-side logs. reset The cause of an error can sometimes be temporary. In these cases, trying again might resolve the issue. An error component can use the reset() function to prompt the user to attempt to recover from the error. When executed, the function will try to re-render the error boundary's contents. If successful, the fallback error component is replaced with the result of the re-render. Examples Global Error While less common, you can handle errors in the root layout or template using global-error.jsx, located in the root app directory, even when leveraging internationalization. Global error UI must define its own and tags, global styles, fonts, or other dependencies that your error page requires. This file replaces the root layout or template when active. > Good to know: Error boundaries must be Client Components, which means that metadata and generateMetadata exports are not supported in global-error.jsx. As an alternative, you can use the React component. Graceful error recovery with a custom error boundary When rendering fails on the client, it can be useful to show the last known server rendered UI for a better user experience. The GracefullyDegradingErrorBoundary is an example of a custom error boundary that captures and preserves the current HTML before an error occurs. If a rendering error happens, it re-renders the captured HTML and displays a persistent notification bar to inform the user. Version History | Version | Changes | | --------- | ------------------------------------------- | | v15.2.0 | Also display global-error in development. | | v13.1.0 | global-error introduced. | | v13.0.0 | error introduced. |",
    "excerpt": "An error file allows you to handle unexpected runtime errors and display fallback UI. error.js wraps a route segment and its nested children in a React Error Boundary. When an error throws within the...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/03-file-conventions/error"
  },
  {
    "id": "01-app-03-api-reference-03-file-conventions-forbidden",
    "path": "01-app\\03-api-reference\\03-file-conventions\\forbidden.mdx",
    "title": "forbidden.js",
    "description": "API reference for the forbidden.js special file.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Reference",
        "slug": "reference"
      },
      {
        "level": 3,
        "text": "Props",
        "slug": "props"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Forbidden() {\r\n  return (\r\n    <div>\r\n      <h2>Forbidden</h2>\r\n      <p>You are not authorized to access this resource.</p>\r\n      <Link href=\"/\">Return Home</Link>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/forbidden.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Forbidden() {\r\n  return (\r\n    <div>\r\n      <h2>Forbidden</h2>\r\n      <p>You are not authorized to access this resource.</p>\r\n      <Link href=\"/\">Return Home</Link>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/forbidden.jsx\" switcher"
      }
    ],
    "content": "The forbidden file is used to render UI when the forbidden function is invoked during authentication. Along with allowing you to customize the UI, Next.js will return a 403 status code. Reference Props forbidden.js components do not accept any props. Version History | Version | Changes | | --------- | -------------------------- | | v15.1.0 | forbidden.js introduced. |",
    "excerpt": "The forbidden file is used to render UI when the forbidden function is invoked during authentication. Along with allowing you to customize the UI, Next.js will return a 403 status code. Reference Prop...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/03-file-conventions/forbidden"
  },
  {
    "id": "01-app-03-api-reference-03-file-conventions-index",
    "path": "01-app\\03-api-reference\\03-file-conventions\\index.mdx",
    "title": "File-system conventions",
    "description": "API Reference for Next.js file-system conventions.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/03-file-conventions"
  },
  {
    "id": "01-app-03-api-reference-03-file-conventions-instrumentation-client",
    "path": "01-app\\03-api-reference\\03-file-conventions\\instrumentation-client.mdx",
    "title": "instrumentation-client.js",
    "description": "Learn how to add client-side instrumentation to track and monitor your Next.js application's frontend performance.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Usage",
        "slug": "usage"
      },
      {
        "level": 2,
        "text": "Router navigation tracking",
        "slug": "router-navigation-tracking"
      },
      {
        "level": 2,
        "text": "Performance considerations",
        "slug": "performance-considerations"
      },
      {
        "level": 2,
        "text": "Execution timing",
        "slug": "execution-timing"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Error tracking",
        "slug": "error-tracking"
      },
      {
        "level": 3,
        "text": "Analytics tracking",
        "slug": "analytics-tracking"
      },
      {
        "level": 3,
        "text": "Performance monitoring",
        "slug": "performance-monitoring"
      },
      {
        "level": 3,
        "text": "Polyfills",
        "slug": "polyfills"
      },
      {
        "level": 2,
        "text": "Version history",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "// Set up performance monitoring\r\nperformance.mark('app-init')\r\n\r\n// Initialize analytics\r\nconsole.log('Analytics initialized')\r\n\r\n// Set up error tracking\r\nwindow.addEventListener('error', (event) => {\r\n  // Send to your error tracking service\r\n  reportError(event.error)\r\n})",
        "context": "filename=\"instrumentation-client.ts\" switcher"
      },
      {
        "language": "js",
        "code": "// Set up performance monitoring\r\nperformance.mark('app-init')\r\n\r\n// Initialize analytics\r\nconsole.log('Analytics initialized')\r\n\r\n// Set up error tracking\r\nwindow.addEventListener('error', (event) => {\r\n  // Send to your error tracking service\r\n  reportError(event.error)\r\n})",
        "context": "filename=\"instrumentation-client.js\" switcher"
      },
      {
        "language": "ts",
        "code": "performance.mark('app-init')\r\n\r\nexport function onRouterTransitionStart(\r\n  url: string,\r\n  navigationType: 'push' | 'replace' | 'traverse'\r\n) {\r\n  console.log(`Navigation started: ${navigationType} to ${url}`)\r\n  performance.mark(`nav-start-${Date.now()}`)\r\n}",
        "context": "filename=\"instrumentation-client.ts\" switcher"
      },
      {
        "language": "js",
        "code": "performance.mark('app-init')\r\n\r\nexport function onRouterTransitionStart(url, navigationType) {\r\n  console.log(`Navigation started: ${navigationType} to ${url}`)\r\n  performance.mark(`nav-start-${Date.now()}`)\r\n}",
        "context": "filename=\"instrumentation-client.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import Monitor from './lib/monitoring'\r\n\r\nMonitor.initialize()\r\n\r\nexport function onRouterTransitionStart(url: string) {\r\n  Monitor.pushEvent({\r\n    message: `Navigation to ${url}`,\r\n    category: 'navigation',\r\n  })\r\n}",
        "context": "filename=\"instrumentation-client.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import Monitor from './lib/monitoring'\r\n\r\nMonitor.initialize()\r\n\r\nexport function onRouterTransitionStart(url) {\r\n  Monitor.pushEvent({\r\n    message: `Navigation to ${url}`,\r\n    category: 'navigation',\r\n  })\r\n}",
        "context": "filename=\"instrumentation-client.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { analytics } from './lib/analytics'\r\n\r\nanalytics.init()\r\n\r\nexport function onRouterTransitionStart(url: string, navigationType: string) {\r\n  analytics.track('page_navigation', {\r\n    url,\r\n    type: navigationType,\r\n    timestamp: Date.now(),\r\n  })\r\n}",
        "context": "filename=\"instrumentation-client.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { analytics } from './lib/analytics'\r\n\r\nanalytics.init()\r\n\r\nexport function onRouterTransitionStart(url, navigationType) {\r\n  analytics.track('page_navigation', {\r\n    url,\r\n    type: navigationType,\r\n    timestamp: Date.now(),\r\n  })\r\n}",
        "context": "filename=\"instrumentation-client.js\" switcher"
      },
      {
        "language": "ts",
        "code": "const startTime = performance.now()\r\n\r\nconst observer = new PerformanceObserver(\r\n  (list: PerformanceObserverEntryList) => {\r\n    for (const entry of list.getEntries()) {\r\n      if (entry instanceof PerformanceNavigationTiming) {\r\n        console.log('Time to Interactive:', entry.loadEventEnd - startTime)\r\n      }\r\n    }\r\n  }\r\n)\r\n\r\nobserver.observe({ entryTypes: ['navigation'] })\r\n\r\nexport function onRouterTransitionStart(url: string) {\r\n  performance.mark(`nav-start-${url}`)\r\n}",
        "context": "filename=\"instrumentation-client.ts\" switcher"
      },
      {
        "language": "js",
        "code": "const startTime = performance.now()\r\n\r\nconst observer = new PerformanceObserver((list) => {\r\n  for (const entry of list.getEntries()) {\r\n    if (entry instanceof PerformanceNavigationTiming) {\r\n      console.log('Time to Interactive:', entry.loadEventEnd - startTime)\r\n    }\r\n  }\r\n})\r\n\r\nobserver.observe({ entryTypes: ['navigation'] })\r\n\r\nexport function onRouterTransitionStart(url) {\r\n  performance.mark(`nav-start-${url}`)\r\n}",
        "context": "filename=\"instrumentation-client.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import './lib/polyfills'\r\n\r\nif (!window.ResizeObserver) {\r\n  import('./lib/polyfills/resize-observer').then((mod) => {\r\n    window.ResizeObserver = mod.default\r\n  })\r\n}",
        "context": "filename=\"instrumentation-client.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import './lib/polyfills'\r\n\r\nif (!window.ResizeObserver) {\r\n  import('./lib/polyfills/resize-observer').then((mod) => {\r\n    window.ResizeObserver = mod.default\r\n  })\r\n}",
        "context": "filename=\"instrumentation-client.js\" switcher"
      }
    ],
    "content": "The instrumentation-client.js|ts file allows you to add monitoring, analytics code, and other side-effects that run before your application becomes interactive. This is useful for setting up performance tracking, error monitoring, polyfills, or any other client-side observability tools. To use it, place the file in the root of your application or inside a src folder. Usage Unlike server-side instrumentation, you do not need to export any specific functions. You can write your monitoring code directly in the file: Error handling: Implement try-catch blocks around your instrumentation code to ensure robust monitoring. This prevents individual tracking failures from affecting other instrumentation features. Router navigation tracking You can export an onRouterTransitionStart function to receive notifications when navigation begins: The onRouterTransitionStart function receives two parameters: - url: string - The URL being navigated to - navigationType: 'push' | 'replace' | 'traverse' - The type of navigation Performance considerations Keep instrumentation code lightweight. Next.js monitors initialization time in development and will log warnings if it takes longer than 16ms, which could impact smooth page loading. Execution timing The instrumentation-client.js file executes at a specific point in the application lifecycle: 1. After the HTML document is loaded 2. Before React hydration begins 3. Before user interactions are possible This timing makes it ideal for setting up error tracking, analytics, and performance monitoring that needs to capture early application lifecycle events. Examples Error tracking Initialize error tracking before React starts and add navigation breadcrumbs for better debugging context. Analytics tracking Initialize analytics and track navigation events with detailed metadata for user behavior analysis. Performance monitoring Track Time to Interactive and navigation performance using the Performance Observer API and performance marks. Polyfills Load polyfills before application code runs. Use static imports for immediate loading and dynamic imports for conditional loading based on feature detection. Version history | Version | Changes | | ------- | ----------------------------------- | | v15.3 | instrumentation-client introduced |",
    "excerpt": "The instrumentation-client.js|ts file allows you to add monitoring, analytics code, and other side-effects that run before your application becomes interactive. This is useful for setting up performan...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/03-file-conventions/instrumentation-client"
  },
  {
    "id": "01-app-03-api-reference-03-file-conventions-instrumentation",
    "path": "01-app\\03-api-reference\\03-file-conventions\\instrumentation.mdx",
    "title": "instrumentation.js",
    "description": "API reference for the instrumentation.js file.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Exports",
        "slug": "exports"
      },
      {
        "level": 3,
        "text": " (optional)",
        "slug": "-optional"
      },
      {
        "level": 3,
        "text": " (optional)",
        "slug": "-optional"
      },
      {
        "level": 4,
        "text": "Parameters",
        "slug": "parameters"
      },
      {
        "level": 3,
        "text": "Specifying the runtime",
        "slug": "specifying-the-runtime"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "import { registerOTel } from '@vercel/otel'\r\n\r\nexport function register() {\r\n  registerOTel('next-app')\r\n}",
        "context": "filename=\"instrumentation.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { registerOTel } from '@vercel/otel'\r\n\r\nexport function register() {\r\n  registerOTel('next-app')\r\n}",
        "context": "filename=\"instrumentation.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { type Instrumentation } from 'next'\r\n\r\nexport const onRequestError: Instrumentation.onRequestError = async (\r\n  err,\r\n  request,\r\n  context\r\n) => {\r\n  await fetch('https://.../report-error', {\r\n    method: 'POST',\r\n    body: JSON.stringify({\r\n      message: err.message,\r\n      request,\r\n      context,\r\n    }),\r\n    headers: {\r\n      'Content-Type': 'application/json',\r\n    },\r\n  })\r\n}",
        "context": "filename=\"instrumentation.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export async function onRequestError(err, request, context) {\r\n  await fetch('https://.../report-error', {\r\n    method: 'POST',\r\n    body: JSON.stringify({\r\n      message: err.message,\r\n      request,\r\n      context,\r\n    }),\r\n    headers: {\r\n      'Content-Type': 'application/json',\r\n    },\r\n  })\r\n}",
        "context": "filename=\"instrumentation.js\" switcher"
      },
      {
        "language": "ts",
        "code": "export function onRequestError(\r\n  error: { digest: string } & Error,\r\n  request: {\r\n    path: string // resource path, e.g. /blog?name=foo\r\n    method: string // request method. e.g. GET, POST, etc\r\n    headers: { [key: string]: string | string[] }\r\n  },\r\n  context: {\r\n    routerKind: 'Pages Router' | 'App Router' // the router type\r\n    routePath: string // the route file path, e.g. /app/blog/[dynamic]\r\n    routeType: 'render' | 'route' | 'action' | 'proxy' // the context in which the error occurred\r\n    renderSource:\r\n      | 'react-server-components'\r\n      | 'react-server-components-payload'\r\n      | 'server-rendering'\r\n    revalidateReason: 'on-demand' | 'stale' | undefined // undefined is a normal request without revalidation\r\n    renderType: 'dynamic' | 'dynamic-resume' // 'dynamic-resume' for PPR\r\n  }\r\n): void | Promise<void>",
        "context": "filename=\"Types\""
      },
      {
        "language": "js",
        "code": "export function register() {\r\n  if (process.env.NEXT_RUNTIME === 'edge') {\r\n    return require('./register.edge')\r\n  } else {\r\n    return require('./register.node')\r\n  }\r\n}\r\n\r\nexport function onRequestError() {\r\n  if (process.env.NEXT_RUNTIME === 'edge') {\r\n    return require('./on-request-error.edge')\r\n  } else {\r\n    return require('./on-request-error.node')\r\n  }\r\n}",
        "context": "filename=\"instrumentation.js\""
      }
    ],
    "content": "The instrumentation.js|ts file is used to integrate observability tools into your application, allowing you to track the performance and behavior, and to debug issues in production. To use it, place the file in the root of your application or inside a src folder if using one. Exports register (optional) The file exports a register function that is called once when a new Next.js server instance is initiated. register can be an async function. onRequestError (optional) You can optionally export an onRequestError function to track server errors to any custom observability provider. - If you're running any async tasks in onRequestError, make sure they're awaited. onRequestError will be triggered when the Next.js server captures the error. - The error instance might not be the original error instance thrown, as it may be processed by React if encountered during Server Components rendering. If this happens, you can use digest property on an error to identify the actual error type. Parameters The function accepts three parameters: error, request, and context. - error: The caught error itself (type is always Error), and a digest property which is the unique ID of the error. - request: Read-only request information associated with the error. - context: The context in which the error occurred. This can be the type of router (App or Pages Router), and/or (Server Components ('render'), Route Handlers ('route'), Server Actions ('action'), or Proxy ('proxy')). Specifying the runtime The instrumentation.js file works in both the Node.js and Edge runtime, however, you can use process.env.NEXTRUNTIME to target a specific runtime. Version History | Version | Changes | | --------- | ------------------------------------------------------- | | v15.0.0 | onRequestError introduced, instrumentation stable | | v14.0.4 | Turbopack support for instrumentation | | v13.2.0 | instrumentation introduced as an experimental feature |",
    "excerpt": "The instrumentation.js|ts file is used to integrate observability tools into your application, allowing you to track the performance and behavior, and to debug issues in production. To use it, place t...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/03-file-conventions/instrumentation"
  },
  {
    "id": "01-app-03-api-reference-03-file-conventions-intercepting-routes",
    "path": "01-app\\03-api-reference\\03-file-conventions\\intercepting-routes.mdx",
    "title": "Intercepting Routes",
    "description": "Use intercepting routes to load a new route within the current layout while masking the browser URL, useful for advanced routing patterns such as modals.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Convention",
        "slug": "convention"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Modals",
        "slug": "modals"
      }
    ],
    "codeBlocks": [],
    "content": "Intercepting routes allows you to load a route from another part of your application within the current layout. This routing paradigm can be useful when you want to display the content of a route without the user switching to a different context. For example, when clicking on a photo in a feed, you can display the photo in a modal, overlaying the feed. In this case, Next.js intercepts the /photo/123 route, masks the URL, and overlays it over /feed. However, when navigating to the photo by clicking a shareable URL or by refreshing the page, the entire photo page should render instead of the modal. No route interception should occur. Convention Intercepting routes can be defined with the (..) convention, which is similar to relative path convention ../ but for route segments. You can use: - (.) to match segments on the same level - (..) to match segments one level above - (..)(..) to match segments two levels above - (...) to match segments from the root app directory For example, you can intercept the photo segment from within the feed segment by creating a (..)photo directory. > Good to know: The (..) convention is based on route segments, not the file-system. For example, it does not consider @slot folders in Parallel Routes. Examples Modals Intercepting Routes can be used together with Parallel Routes to create modals. This allows you to solve common challenges when building modals, such as: - Making the modal content shareable through a URL. - Preserving context when the page is refreshed, instead of closing the modal. - Closing the modal on backwards navigation rather than going to the previous route. - Reopening the modal on forwards navigation. Consider the following UI pattern, where a user can open a photo modal from a gallery using client-side navigation, or navigate to the photo page directly from a shareable URL: In the above example, the path to the photo segment can use the (..) matcher since @modal is a slot and not a segment. This means that the photo route is only one segment level higher, despite being two file-system levels higher. See the Parallel Routes documentation for a step-by-step example, or see our image gallery example. > Good to know: > > - Other examples could include opening a login modal in a top navbar while also having a dedicated /login page, or opening a shopping cart in a side modal.",
    "excerpt": "Intercepting routes allows you to load a route from another part of your application within the current layout. This routing paradigm can be useful when you want to display the content of a route with...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/03-file-conventions/intercepting-routes"
  },
  {
    "id": "01-app-03-api-reference-03-file-conventions-layout",
    "path": "01-app\\03-api-reference\\03-file-conventions\\layout.mdx",
    "title": "layout.js",
    "description": "API reference for the layout.js file.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Reference",
        "slug": "reference"
      },
      {
        "level": 3,
        "text": "Props",
        "slug": "props"
      },
      {
        "level": 4,
        "text": " (required)",
        "slug": "-required"
      },
      {
        "level": 4,
        "text": " (optional)",
        "slug": "-optional"
      },
      {
        "level": 3,
        "text": "Layout Props Helper",
        "slug": "layout-props-helper"
      },
      {
        "level": 3,
        "text": "Root Layout",
        "slug": "root-layout"
      },
      {
        "level": 2,
        "text": "Caveats",
        "slug": "caveats"
      },
      {
        "level": 3,
        "text": "Request Object",
        "slug": "request-object"
      },
      {
        "level": 3,
        "text": "Query params",
        "slug": "query-params"
      },
      {
        "level": 3,
        "text": "Pathname",
        "slug": "pathname"
      },
      {
        "level": 3,
        "text": "Fetching Data",
        "slug": "fetching-data"
      },
      {
        "level": 3,
        "text": "Accessing child segments",
        "slug": "accessing-child-segments"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Metadata",
        "slug": "metadata"
      },
      {
        "level": 3,
        "text": "Active Nav Links",
        "slug": "active-nav-links"
      },
      {
        "level": 3,
        "text": "Displaying content based on ",
        "slug": "displaying-content-based-on-"
      },
      {
        "level": 3,
        "text": "Reading  in Client Components",
        "slug": "reading-in-client-components"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "export default function DashboardLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return <section>{children}</section>\r\n}",
        "context": "filename=\"app/dashboard/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function DashboardLayout({ children }) {\r\n  return <section>{children}</section>\r\n}",
        "context": "filename=\"app/dashboard/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function RootLayout({ children }) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default async function Layout({\r\n  children,\r\n  params,\r\n}: {\r\n  children: React.ReactNode\r\n  params: Promise<{ team: string }>\r\n}) {\r\n  const { team } = await params\r\n}",
        "context": "filename=\"app/dashboard/[team]/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default async function Layout({ children, params }) {\r\n  const { team } = await params\r\n}",
        "context": "filename=\"app/dashboard/[team]/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default function Layout(props: LayoutProps<'/dashboard'>) {\r\n  return (\r\n    <section>\r\n      {props.children}\r\n      {/* If you have app/dashboard/@analytics, it appears as a typed slot: */}\r\n      {/* {props.analytics} */}\r\n    </section>\r\n  )\r\n}",
        "context": "filename=\"app/dashboard/layout.tsx\""
      },
      {
        "language": "tsx",
        "code": "export default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <html>\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function RootLayout({ children }) {\r\n  return (\r\n    <html>\r\n      <body>{children}</body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { cookies } from 'next/headers'\r\n\r\nexport default async function Layout({ children }) {\r\n  const cookieStore = await cookies()\r\n  const theme = cookieStore.get('theme')\r\n  return '...'\r\n}",
        "context": "filename=\"app/shop/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { cookies } from 'next/headers'\r\n\r\nexport default async function Layout({ children }) {\r\n  const cookieStore = await cookies()\r\n  const theme = cookieStore.get('theme')\r\n  return '...'\r\n}",
        "context": "filename=\"app/shop/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { useSearchParams } from 'next/navigation'\r\n\r\nexport default function Search() {\r\n  const searchParams = useSearchParams()\r\n\r\n  const search = searchParams.get('search')\r\n\r\n  return '...'\r\n}",
        "context": "filename=\"app/ui/search.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { useSearchParams } from 'next/navigation'\r\n\r\nexport default function Search() {\r\n  const searchParams = useSearchParams()\r\n\r\n  const search = searchParams.get('search')\r\n\r\n  return '...'\r\n}",
        "context": "filename=\"app/ui/search.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Search from '@/app/ui/search'\r\n\r\nexport default function Layout({ children }) {\r\n  return (\r\n    <>\r\n      <Search />\r\n      {children}\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/shop/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Search from '@/app/ui/search'\r\n\r\nexport default function Layout({ children }) {\r\n  return (\r\n    <>\r\n      <Search />\r\n      {children}\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/shop/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { usePathname } from 'next/navigation'\r\n\r\n// Simplified breadcrumbs logic\r\nexport default function Breadcrumbs() {\r\n  const pathname = usePathname()\r\n  const segments = pathname.split('/')\r\n\r\n  return (\r\n    <nav>\r\n      {segments.map((segment, index) => (\r\n        <span key={index}>\r\n          {' > '}\r\n          {segment}\r\n        </span>\r\n      ))}\r\n    </nav>\r\n  )\r\n}",
        "context": "filename=\"app/ui/breadcrumbs.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { usePathname } from 'next/navigation'\r\n\r\n// Simplified breadcrumbs logic\r\nexport default function Breadcrumbs() {\r\n  const pathname = usePathname()\r\n  const segments = pathname.split('/')\r\n\r\n  return (\r\n    <nav>\r\n      {segments.map((segment, index) => (\r\n        <span key={index}>\r\n          {' > '}\r\n          {segment}\r\n        </span>\r\n      ))}\r\n    </nav>\r\n  )\r\n}",
        "context": "filename=\"app/ui/breadcrumbs.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { Breadcrumbs } from '@/app/ui/Breadcrumbs'\r\n\r\nexport default function Layout({ children }) {\r\n  return (\r\n    <>\r\n      <Breadcrumbs />\r\n      <main>{children}</main>\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/docs/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { Breadcrumbs } from '@/app/ui/Breadcrumbs'\r\n\r\nexport default function Layout({ children }) {\r\n  return (\r\n    <>\r\n      <Breadcrumbs />\r\n      <main>{children}</main>\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/docs/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export async function getUser(id: string) {\r\n  const res = await fetch(`https://.../users/${id}`)\r\n  return res.json()\r\n}",
        "context": "filename=\"app/lib/data.ts\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { getUser } from '@/app/lib/data'\r\nimport { UserName } from '@/app/ui/user-name'\r\n\r\nexport default async function Layout({ children }) {\r\n  const user = await getUser('1')\r\n\r\n  return (\r\n    <>\r\n      <nav>\r\n        {/* ... */}\r\n        <UserName user={user.name} />\r\n      </nav>\r\n      {children}\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/dashboard/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { getUser } from '@/app/lib/data'\r\nimport { UserName } from '@/app/ui/user-name'\r\n\r\nexport default async function Layout({ children }) {\r\n  const user = await getUser('1')\r\n\r\n  return (\r\n    <>\r\n      <nav>\r\n        {/* ... */}\r\n        <UserName user={user.name} />\r\n      </nav>\r\n      {children}\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/dashboard/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { getUser } from '@/app/lib/data'\r\nimport { UserName } from '@/app/ui/user-name'\r\n\r\nexport default async function Page() {\r\n  const user = await getUser('1')\r\n\r\n  return (\r\n    <div>\r\n      <h1>Welcome {user.name}</h1>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/dashboard/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { getUser } from '@/app/lib/data'\r\nimport { UserName } from '@/app/ui/user-name'\r\n\r\nexport default async function Page() {\r\n  const user = await getUser('1')\r\n\r\n  return (\r\n    <div>\r\n      <h1>Welcome {user.name}</h1>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/dashboard/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport Link from 'next/link'\r\nimport { useSelectedLayoutSegment } from 'next/navigation'\r\n\r\nexport default function NavLink({\r\n  slug,\r\n  children,\r\n}: {\r\n  slug: string\r\n  children: React.ReactNode\r\n}) {\r\n  const segment = useSelectedLayoutSegment()\r\n  const isActive = slug === segment\r\n\r\n  return (\r\n    <Link\r\n      href={`/blog/${slug}`}\r\n      // Change style depending on whether the link is active\r\n      style={{ fontWeight: isActive ? 'bold' : 'normal' }}\r\n    >\r\n      {children}\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"app/ui/nav-link.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport Link from 'next/link'\r\nimport { useSelectedLayoutSegment } from 'next/navigation'\r\n\r\nexport default function NavLinks({ slug, children }) {\r\n  const segment = useSelectedLayoutSegment()\r\n  const isActive = slug === segment\r\n\r\n  return (\r\n    <Link\r\n      href={`/blog/${slug}`}\r\n      style={{ fontWeight: isActive ? 'bold' : 'normal' }}\r\n    >\r\n      {children}\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"app/ui/nav-link.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { NavLink } from './nav-link'\r\nimport getPosts from './get-posts'\r\n\r\nexport default async function Layout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  const featuredPosts = await getPosts()\r\n  return (\r\n    <div>\r\n      {featuredPosts.map((post) => (\r\n        <div key={post.id}>\r\n          <NavLink slug={post.slug}>{post.title}</NavLink>\r\n        </div>\r\n      ))}\r\n      <div>{children}</div>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/blog/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { NavLink } from './nav-link'\r\nimport getPosts from './get-posts'\r\n\r\nexport default async function Layout({ children }) {\r\n  const featuredPosts = await getPosts()\r\n  return (\r\n    <div>\r\n      {featuredPosts.map((post) => (\r\n        <div key={post.id}>\r\n          <NavLink slug={post.slug}>{post.title}</NavLink>\r\n        </div>\r\n      ))}\r\n      <div>{children}</div>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/blog/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import type { Metadata } from 'next'\r\n\r\nexport const metadata: Metadata = {\r\n  title: 'Next.js',\r\n}\r\n\r\nexport default function Layout({ children }: { children: React.ReactNode }) {\r\n  return '...'\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  title: 'Next.js',\r\n}\r\n\r\nexport default function Layout({ children }) {\r\n  return '...'\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { usePathname } from 'next/navigation'\r\nimport Link from 'next/link'\r\n\r\nexport function NavLinks() {\r\n  const pathname = usePathname()\r\n\r\n  return (\r\n    <nav>\r\n      <Link className={`link ${pathname === '/' ? 'active' : ''}`} href=\"/\">\r\n        Home\r\n      </Link>\r\n\r\n      <Link\r\n        className={`link ${pathname === '/about' ? 'active' : ''}`}\r\n        href=\"/about\"\r\n      >\r\n        About\r\n      </Link>\r\n    </nav>\r\n  )\r\n}",
        "context": "filename=\"app/ui/nav-links.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { usePathname } from 'next/navigation'\r\nimport Link from 'next/link'\r\n\r\nexport function Links() {\r\n  const pathname = usePathname()\r\n\r\n  return (\r\n    <nav>\r\n      <Link className={`link ${pathname === '/' ? 'active' : ''}`} href=\"/\">\r\n        Home\r\n      </Link>\r\n\r\n      <Link\r\n        className={`link ${pathname === '/about' ? 'active' : ''}`}\r\n        href=\"/about\"\r\n      >\r\n        About\r\n      </Link>\r\n    </nav>\r\n  )\r\n}",
        "context": "filename=\"app/ui/nav-links.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { NavLinks } from '@/app/ui/nav-links'\r\n\r\nexport default function Layout({ children }: { children: React.ReactNode }) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>\r\n        <NavLinks />\r\n        <main>{children}</main>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { NavLinks } from '@/app/ui/nav-links'\r\n\r\nexport default function Layout({ children }) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>\r\n        <NavLinks />\r\n        <main>{children}</main>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default async function DashboardLayout({\r\n  children,\r\n  params,\r\n}: {\r\n  children: React.ReactNode\r\n  params: Promise<{ team: string }>\r\n}) {\r\n  const { team } = await params\r\n\r\n  return (\r\n    <section>\r\n      <header>\r\n        <h1>Welcome to {team}'s Dashboard</h1>\r\n      </header>\r\n      <main>{children}</main>\r\n    </section>\r\n  )\r\n}",
        "context": "filename=\"app/dashboard/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default async function DashboardLayout({ children, params }) {\r\n  const { team } = await params\r\n\r\n  return (\r\n    <section>\r\n      <header>\r\n        <h1>Welcome to {team}'s Dashboard</h1>\r\n      </header>\r\n      <main>{children}</main>\r\n    </section>\r\n  )\r\n}",
        "context": "filename=\"app/dashboard/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { use } from 'react'\r\n\r\nexport default function Page({\r\n  params,\r\n}: {\r\n  params: Promise<{ slug: string }>\r\n}) {\r\n  const { slug } = use(params)\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "js",
        "code": "'use client'\r\n\r\nimport { use } from 'react'\r\n\r\nexport default function Page({ params }) {\r\n  const { slug } = use(params)\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      }
    ],
    "content": "The layout file is used to define a layout in your Next.js application. A root layout is the top-most layout in the root app directory. It is used to define the and tags and other globally shared UI. Reference Props children (required) Layout components should accept and use a children prop. During rendering, children will be populated with the route segments the layout is wrapping. These will primarily be the component of a child Layout (if it exists) or Page, but could also be other special files like Loading or Error when applicable. params (optional) A promise that resolves to an object containing the dynamic route parameters object from the root segment down to that layout. | Example Route | URL | params | | --------------------------------- | -------------- | ---------------------------------- | | app/dashboard/[team]/layout.js | /dashboard/1 | Promise | | app/shop/[tag]/[item]/layout.js | /shop/1/2 | Promise | | app/blog/[...slug]/layout.js | /blog/1/2 | Promise | - Since the params prop is a promise. You must use async/await or React's use function to access the values. - In version 14 and earlier, params was a synchronous prop. To help with backwards compatibility, you can still access it synchronously in Next.js 15, but this behavior will be deprecated in the future. Layout Props Helper You can type layouts with LayoutProps to get a strongly typed params and named slots inferred from your directory structure. LayoutProps is a globally available helper. > Good to know: > > - Types are generated during next dev, next build or next typegen. > - After type generation, the LayoutProps helper is globally available. It doesn't need to be imported. Root Layout The app directory must include a root layout, which is the top-most layout in the root app directory. Typically, the root layout is app/layout.js. - The root layout must define and tags. - You should not manually add tags such as and to root layouts. Instead, you should use the Metadata API which automatically handles advanced requirements such as streaming and de-duplicating elements. - You can use route groups to create multiple root layouts. - Navigating across multiple root layouts will cause a full page load (as opposed to a client-side navigation). For example, navigating from /cart that uses app/(shop)/layout.js to /blog that uses app/(marketing)/layout.js will cause a full page load. This only applies to multiple root layouts. - The root layout can be under a dynamic segment, for example when implementing internationalization with app/[lang]/layout.js. Caveats Request Object Layouts are cached in the client during navigation to avoid unnecessary server requests. Layouts do not rerender. They can be cached and reused to avoid unnecessary computation when navigating between pages. By restricting layouts from accessing the raw request, Next.js can prevent the execution of potentially slow or expensive user code within the layout, which could negatively impact performance. To access the request object, you can use headers and cookies APIs in Server Components and Functions. Query params Layouts do not rerender on navigation, so they cannot access search params which would otherwise become stale. To access updated query parameters, you can use the Page searchParams prop, or read them inside a Client Component using the useSearchParams hook. Since Client Components re-render on navigation, they have access to the latest query parameters. Pathname Layouts do not re-render on navigation, so they do not access pathname which would otherwise become stale. To access the current pathname, you can read it inside a Client Component using the usePathname hook. Since Client Components re-render during navigation, they have access to the latest pathname. Fetching Data Layouts cannot pass data to their children. However, you can fetch the same data in a route more than once, and use React cache to dedupe the requests without affecting performance. Alternatively, when using fetchin Next.js, requests are automatically deduped. Accessing child segments Layouts do not have access to the route segments below itself. To access all route segments, you can use useSelectedLayoutSegment or useSelectedLayoutSegments in a Client Component. Examples Metadata You can modify the HTML elements such as title and meta using the metadata object or generateMetadata function. > Good to know: You should not manually add tags such as and to root layouts. Instead, use the Metadata APIs which automatically handles advanced requirements such as streaming and de-duplicating elements. Active Nav Links You can use the usePathname hook to determine if a nav link is active. Since usePathname is a client hook, you need to extract the nav links into a Client Component, which can be imported into your layout: Displaying content based on params Using dynamic route segments, you can display or fetch specific content based on the params prop. Reading params in Client Components To use params in a Client Component (which cannot be async), you can use React's use function to read the promise: Version History | Version | Changes | | ------------ | --------------------------------------------------------------------------------------------- | | v15.0.0-RC | params is now a promise. A codemod is available. | | v13.0.0 | layout introduced. |",
    "excerpt": "The layout file is used to define a layout in your Next.js application. A root layout is the top-most layout in the root app directory. It is used to define the and tags and other globally shared UI....",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/03-file-conventions/layout"
  },
  {
    "id": "01-app-03-api-reference-03-file-conventions-loading",
    "path": "01-app\\03-api-reference\\03-file-conventions\\loading.mdx",
    "title": "loading.js",
    "description": "API reference for the loading.js file.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Reference",
        "slug": "reference"
      },
      {
        "level": 3,
        "text": "Parameters",
        "slug": "parameters"
      },
      {
        "level": 2,
        "text": "Behavior",
        "slug": "behavior"
      },
      {
        "level": 3,
        "text": "Navigation",
        "slug": "navigation"
      },
      {
        "level": 3,
        "text": "Instant Loading States",
        "slug": "instant-loading-states"
      },
      {
        "level": 3,
        "text": "SEO",
        "slug": "seo"
      },
      {
        "level": 3,
        "text": "Status Codes",
        "slug": "status-codes"
      },
      {
        "level": 3,
        "text": "Browser limits",
        "slug": "browser-limits"
      },
      {
        "level": 2,
        "text": "Platform Support",
        "slug": "platform-support"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Streaming with Suspense",
        "slug": "streaming-with-suspense"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "export default function Loading() {\r\n  // Or a custom loading skeleton component\r\n  return <p>Loading...</p>\r\n}",
        "context": "filename=\"app/feed/loading.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function Loading() {\r\n  // Or a custom loading skeleton component\r\n  return <p>Loading...</p>\r\n}",
        "context": "filename=\"app/feed/loading.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default function Loading() {\r\n  // You can add any UI inside Loading, including a Skeleton.\r\n  return <LoadingSkeleton />\r\n}",
        "context": "filename=\"app/dashboard/loading.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function Loading() {\r\n  // You can add any UI inside Loading, including a Skeleton.\r\n  return <LoadingSkeleton />\r\n}",
        "context": "filename=\"app/dashboard/loading.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { Suspense } from 'react'\r\nimport { PostFeed, Weather } from './Components'\r\n\r\nexport default function Posts() {\r\n  return (\r\n    <section>\r\n      <Suspense fallback={<p>Loading feed...</p>}>\r\n        <PostFeed />\r\n      </Suspense>\r\n      <Suspense fallback={<p>Loading weather...</p>}>\r\n        <Weather />\r\n      </Suspense>\r\n    </section>\r\n  )\r\n}",
        "context": "filename=\"app/dashboard/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { Suspense } from 'react'\r\nimport { PostFeed, Weather } from './Components'\r\n\r\nexport default function Posts() {\r\n  return (\r\n    <section>\r\n      <Suspense fallback={<p>Loading feed...</p>}>\r\n        <PostFeed />\r\n      </Suspense>\r\n      <Suspense fallback={<p>Loading weather...</p>}>\r\n        <Weather />\r\n      </Suspense>\r\n    </section>\r\n  )\r\n}",
        "context": "filename=\"app/dashboard/page.js\" switcher"
      }
    ],
    "content": "The special file loading.js helps you create meaningful Loading UI with React Suspense. With this convention, you can show an instant loading state from the server while the content of a route segment streams in. The new content is automatically swapped in once complete. Inside the loading.js file, you can add any light-weight loading UI. You may find it helpful to use the React Developer Tools to manually toggle Suspense boundaries. By default, this file is a Server Component - but can also be used as a Client Component through the \"use client\" directive. Reference Parameters Loading UI components do not accept any parameters. Behavior Navigation - The Fallback UI is prefetched, making navigation immediate unless prefetching hasn't completed. - Navigation is interruptible, meaning changing routes does not need to wait for the content of the route to fully load before navigating to another route. - Shared layouts remain interactive while new route segments load. Instant Loading States An instant loading state is fallback UI that is shown immediately upon navigation. You can pre-render loading indicators such as skeletons and spinners, or a small but meaningful part of future screens such as a cover photo, title, etc. This helps users understand the app is responding and provides a better user experience. Create a loading state by adding a loading.js file inside a folder. In the same folder, loading.js will be nested inside layout.js. It will automatically wrap the page.js file and any children below in a boundary. SEO - For bots that only scrape static HTML, and cannot execute JavaScript like a full browser, such as Twitterbot, Next.js resolves generateMetadata before streaming UI, and metadata is placed in the of the initial HTML. - Otherwise, streaming metadata may be used. Next.js automatically detects user agents to choose between blocking and streaming behavior. - Since streaming is server-rendered, it does not impact SEO. You can use the Rich Results Test tool from Google to see how your page appears to Google's web crawlers and view the serialized HTML (source). Status Codes When streaming, a 200 status code will be returned to signal that the request was successful. The server can still communicate errors or issues to the client within the streamed content itself, for example, when using redirect or notFound. Because the response headers have already been sent to the client, the status code of the response cannot be updated. For example, when a 404 page is streamed to the client, Next.js includes a tag in the streamed HTML. This prevents search engines from indexing that URL even if the HTTP status is 200. See Google’s guidance on the robots meta tag. Some crawlers may label these responses as “soft 404s”. In the streaming case, this does not lead to indexation because the page is explicitly marked noindex in the HTML. If you need a 404 status, for compliance or analytics, ensure the resource exists before the response body is streamed, so that the server can set the HTTP status code. You can run this check in proxy to rewrite missing slugs to a not-found route, or produce a 404 response. Keep proxy checks fast, and avoid fetching full content there. When is the response body streamed? The response body starts streaming when a Suspense fallback renders (for example, a loading.tsx) or when a Server Component suspends under a Suspense boundary. Place notFound() before those boundaries and before any await that may suspend. To start streaming, the response headers must be set. This is why it is not possible to change the status code after streaming started. Browser limits Some browsers buffer a streaming response. You may not see the streamed response until the response exceeds 1024 bytes. This typically only affects “hello world” applications, but not real applications. Platform Support | Deployment Option | Supported | | ------------------------------------------------------------------- | ----------------- | | Node.js server | Yes | | Docker container | Yes | | Static export | No | | Adapters | Platform-specific | Learn how to configure streaming when self-hosting Next.js. Examples Streaming with Suspense In addition to loading.js, you can also manually create Suspense Boundaries for your own UI components. The App Router supports streaming with Suspense. works by wrapping a component that performs an asynchronous action (e.g. fetch data), showing fallback UI (e.g. skeleton, spinner) while it's happening, and then swapping in your component once the action completes. By using Suspense, you get the benefits of: 1. Streaming Server Rendering - Progressively rendering HTML from the server to the client. 2. Selective Hydration - React prioritizes what components to make interactive first based on user interaction. For more Suspense examples and use cases, please see the React Documentation. Version History | Version | Changes | | --------- | --------------------- | | v13.0.0 | loading introduced. |",
    "excerpt": "The special file loading.js helps you create meaningful Loading UI with React Suspense. With this convention, you can show an instant loading state from the server while the content of a route segment...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/03-file-conventions/loading"
  },
  {
    "id": "01-app-03-api-reference-03-file-conventions-mdx-components",
    "path": "01-app\\03-api-reference\\03-file-conventions\\mdx-components.mdx",
    "title": "mdx-components.js",
    "description": "API reference for the mdx-components.js file.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Exports",
        "slug": "exports"
      },
      {
        "level": 3,
        "text": " function",
        "slug": "-function"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "import type { MDXComponents } from 'mdx/types'\r\n\r\nconst components: MDXComponents = {}\r\n\r\nexport function useMDXComponents(): MDXComponents {\r\n  return components\r\n}",
        "context": "filename=\"mdx-components.tsx\" switcher"
      },
      {
        "language": "js",
        "code": "const components = {}\r\n\r\nexport function useMDXComponents() {\r\n  return components\r\n}",
        "context": "filename=\"mdx-components.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import type { MDXComponents } from 'mdx/types'\r\n\r\nconst components: MDXComponents = {}\r\n\r\nexport function useMDXComponents(): MDXComponents {\r\n  return components\r\n}",
        "context": "filename=\"mdx-components.tsx\" switcher"
      },
      {
        "language": "js",
        "code": "const components = {}\r\n\r\nexport function useMDXComponents() {\r\n  return components\r\n}",
        "context": "filename=\"mdx-components.js\" switcher"
      }
    ],
    "content": "The mdx-components.js|tsx file is required to use @next/mdx with App Router and will not work without it. Additionally, you can use it to customize styles. Use the file mdx-components.tsx (or .js) in the root of your project to define MDX Components. For example, at the same level as pages or app, or inside src if applicable. Exports useMDXComponents function The file must export a single function named useMDXComponents. This function does not accept any arguments. Version History | Version | Changes | | --------- | -------------------- | | v13.1.2 | MDX Components added |",
    "excerpt": "The mdx-components.js|tsx file is required to use @next/mdx with App Router and will not work without it. Additionally, you can use it to customize styles. Use the file mdx-components.tsx (or .js) in...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/03-file-conventions/mdx-components"
  },
  {
    "id": "01-app-03-api-reference-03-file-conventions-not-found",
    "path": "01-app\\03-api-reference\\03-file-conventions\\not-found.mdx",
    "title": "not-found.js",
    "description": "API reference for the not-found.js file.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": " (experimental)",
        "slug": "-experimental"
      },
      {
        "level": 2,
        "text": "Reference",
        "slug": "reference"
      },
      {
        "level": 3,
        "text": "Props",
        "slug": "props"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Data Fetching",
        "slug": "data-fetching"
      },
      {
        "level": 3,
        "text": "Metadata",
        "slug": "metadata"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function NotFound() {\r\n  return (\r\n    <div>\r\n      <h2>Not Found</h2>\r\n      <p>Could not find requested resource</p>\r\n      <Link href=\"/\">Return Home</Link>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/not-found.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function NotFound() {\r\n  return (\r\n    <div>\r\n      <h2>Not Found</h2>\r\n      <p>Could not find requested resource</p>\r\n      <Link href=\"/\">Return Home</Link>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/blog/not-found.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  experimental: {\r\n    globalNotFound: true,\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\""
      },
      {
        "language": "tsx",
        "code": "// Import global styles and fonts\r\nimport './globals.css'\r\nimport { Inter } from 'next/font/google'\r\nimport type { Metadata } from 'next'\r\n\r\nconst inter = Inter({ subsets: ['latin'] })\r\n\r\nexport const metadata: Metadata = {\r\n  title: '404 - Page Not Found',\r\n  description: 'The page you are looking for does not exist.',\r\n}\r\n\r\nexport default function GlobalNotFound() {\r\n  return (\r\n    <html lang=\"en\" className={inter.className}>\r\n      <body>\r\n        <h1>404 - Page Not Found</h1>\r\n        <p>This page does not exist.</p>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/global-not-found.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "// Import global styles and fonts\r\nimport './globals.css'\r\nimport { Inter } from 'next/font/google'\r\n\r\nconst inter = Inter({ subsets: ['latin'] })\r\n\r\nexport const metadata = {\r\n  title: '404 - Page Not Found',\r\n  description: 'The page you are looking for does not exist.',\r\n}\r\n\r\nexport default function GlobalNotFound() {\r\n  return (\r\n    <html lang=\"en\" className={inter.className}>\r\n      <body>\r\n        <h1>404 - Page Not Found</h1>\r\n        <p>This page does not exist.</p>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/global-not-found.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\nimport { headers } from 'next/headers'\r\n\r\nexport default async function NotFound() {\r\n  const headersList = await headers()\r\n  const domain = headersList.get('host')\r\n  const data = await getSiteData(domain)\r\n  return (\r\n    <div>\r\n      <h2>Not Found: {data.name}</h2>\r\n      <p>Could not find requested resource</p>\r\n      <p>\r\n        View <Link href=\"/blog\">all posts</Link>\r\n      </p>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/not-found.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\nimport { headers } from 'next/headers'\r\n\r\nexport default async function NotFound() {\r\n  const headersList = await headers()\r\n  const domain = headersList.get('host')\r\n  const data = await getSiteData(domain)\r\n  return (\r\n    <div>\r\n      <h2>Not Found: {data.name}</h2>\r\n      <p>Could not find requested resource</p>\r\n      <p>\r\n        View <Link href=\"/blog\">all posts</Link>\r\n      </p>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/not-found.jsx\" switcher"
      },
      {
        "language": "tsx",
        "code": "import type { Metadata } from 'next'\r\n\r\nexport const metadata: Metadata = {\r\n  title: 'Not Found',\r\n  description: 'The page you are looking for does not exist.',\r\n}\r\n\r\nexport default function GlobalNotFound() {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>\r\n        <div>\r\n          <h1>Not Found</h1>\r\n          <p>The page you are looking for does not exist.</p>\r\n        </div>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/global-not-found.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  title: 'Not Found',\r\n  description: 'The page you are looking for does not exist.',\r\n}\r\n\r\nexport default function GlobalNotFound() {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>\r\n        <div>\r\n          <h1>Not Found</h1>\r\n          <p>The page you are looking for does not exist.</p>\r\n        </div>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/global-not-found.js\" switcher"
      }
    ],
    "content": "Next.js provides two conventions to handle not found cases: - not-found.js: Used when you call the notFound function in a route segment. - global-not-found.js: Used to define a global 404 page for unmatched routes across your entire app. This is handled at the routing level and doesn't depend on rendering a layout or page. not-found.js The not-found file is used to render UI when the notFound function is thrown within a route segment. Along with serving a custom UI, Next.js will return a 200 HTTP status code for streamed responses, and 404 for non-streamed responses. global-not-found.js (experimental) The global-not-found.js file lets you define a 404 page for your entire application. Unlike not-found.js, which works at the route level, this is used when a requested URL doesn't match any route at all. Next.js skips rendering and directly returns this global page. The global-not-found.js file bypasses your app's normal rendering, which means you'll need to import any global styles, fonts, or other dependencies that your 404 page requires. > Good to know: A smaller version of your global styles, and a simpler font family could improve performance of this page. global-not-found.js is useful when you can't build a 404 page using a combination of layout.js and not-found.js. This can happen in two cases: - Your app has multiple root layouts (e.g. app/(admin)/layout.tsx and app/(shop)/layout.tsx), so there's no single layout to compose a global 404 from. - Your root layout is defined using top-level dynamic segments (e.g. app/[country]/layout.tsx), which makes composing a consistent 404 page harder. To enable it, add the globalNotFound flag in next.config.ts: Then, create a file in the root of the app directory: app/global-not-found.js: Unlike not-found.js, this file must return a full HTML document, including and tags. Reference Props not-found.js or global-not-found.js components do not accept any props. > Good to know: In addition to catching expected notFound() errors, the root app/not-found.js and app/global-not-found.js files handle any unmatched URLs for your whole application. This means users that visit a URL that is not handled by your app will be shown the exported UI. Examples Data Fetching By default, not-found is a Server Component. You can mark it as async to fetch and display data: If you need to use Client Component hooks like usePathname to display content based on the path, you must fetch data on the client-side instead. Metadata For global-not-found.js, you can export a metadata object or a generateMetadata function to customize the , , and other head tags for your 404 page: > Good to know: Next.js automatically injects for pages that return a 404 status code, including global-not-found.js pages. Version History | Version | Changes | | --------- | --------------------------------------------------- | | v15.4.0 | global-not-found.js introduced (experimental). | | v13.3.0 | Root app/not-found handles global unmatched URLs. | | v13.0.0 | not-found introduced. |",
    "excerpt": "Next.js provides two conventions to handle not found cases: - not-found.js: Used when you call the notFound function in a route segment. - global-not-found.js: Used to define a global 404 page for unm...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/03-file-conventions/not-found"
  },
  {
    "id": "01-app-03-api-reference-03-file-conventions-page",
    "path": "01-app\\03-api-reference\\03-file-conventions\\page.mdx",
    "title": "page.js",
    "description": "API reference for the page.js file.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Good to know",
        "slug": "good-to-know"
      },
      {
        "level": 2,
        "text": "Reference",
        "slug": "reference"
      },
      {
        "level": 3,
        "text": "Props",
        "slug": "props"
      },
      {
        "level": 4,
        "text": " (optional)",
        "slug": "-optional"
      },
      {
        "level": 4,
        "text": " (optional)",
        "slug": "-optional"
      },
      {
        "level": 3,
        "text": "Page Props Helper",
        "slug": "page-props-helper"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Displaying content based on ",
        "slug": "displaying-content-based-on-"
      },
      {
        "level": 3,
        "text": "Handling filtering with ",
        "slug": "handling-filtering-with-"
      },
      {
        "level": 3,
        "text": "Reading  and  in Client Components",
        "slug": "reading-and-in-client-components"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "export default function Page({\r\n  params,\r\n  searchParams,\r\n}: {\r\n  params: Promise<{ slug: string }>\r\n  searchParams: Promise<{ [key: string]: string | string[] | undefined }>\r\n}) {\r\n  return <h1>My Page</h1>\r\n}",
        "context": "filename=\"app/blog/[slug]/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function Page({ params, searchParams }) {\r\n  return <h1>My Page</h1>\r\n}",
        "context": "filename=\"app/blog/[slug]/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default async function Page({\r\n  params,\r\n}: {\r\n  params: Promise<{ slug: string }>\r\n}) {\r\n  const { slug } = await params\r\n}",
        "context": "filename=\"app/shop/[slug]/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default async function Page({ params }) {\r\n  const { slug } = await params\r\n}",
        "context": "filename=\"app/shop/[slug]/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default async function Page({\r\n  searchParams,\r\n}: {\r\n  searchParams: Promise<{ [key: string]: string | string[] | undefined }>\r\n}) {\r\n  const filters = (await searchParams).filters\r\n}",
        "context": "filename=\"app/shop/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default async function Page({ searchParams }) {\r\n  const filters = (await searchParams).filters\r\n}",
        "context": "filename=\"app/shop/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\nimport { use } from 'react'\r\n\r\nexport default function Page({\r\n  searchParams,\r\n}: {\r\n  searchParams: Promise<{ [key: string]: string | string[] | undefined }>\r\n}) {\r\n  const filters = use(searchParams).filters\r\n}",
        "context": "filename=\"app/shop/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\nimport { use } from 'react'\r\n\r\nexport default function Page({ searchParams }) {\r\n  const filters = use(searchParams).filters\r\n}",
        "context": "filename=\"app/page.jsx\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default async function Page(props: PageProps<'/blog/[slug]'>) {\r\n  const { slug } = await props.params\r\n  const query = await props.searchParams\r\n  return <h1>Blog Post: {slug}</h1>\r\n}",
        "context": "filename=\"app/blog/[slug]/page.tsx\""
      },
      {
        "language": "tsx",
        "code": "export default async function Page({\r\n  params,\r\n}: {\r\n  params: Promise<{ slug: string }>\r\n}) {\r\n  const { slug } = await params\r\n  return <h1>Blog Post: {slug}</h1>\r\n}",
        "context": "filename=\"app/blog/[slug]/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default async function Page({ params }) {\r\n  const { slug } = await params\r\n  return <h1>Blog Post: {slug}</h1>\r\n}",
        "context": "filename=\"app/blog/[slug]/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default async function Page({\r\n  searchParams,\r\n}: {\r\n  searchParams: Promise<{ [key: string]: string | string[] | undefined }>\r\n}) {\r\n  const { page = '1', sort = 'asc', query = '' } = await searchParams\r\n\r\n  return (\r\n    <div>\r\n      <h1>Product Listing</h1>\r\n      <p>Search query: {query}</p>\r\n      <p>Current page: {page}</p>\r\n      <p>Sort order: {sort}</p>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/shop/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default async function Page({ searchParams }) {\r\n  const { page = '1', sort = 'asc', query = '' } = await searchParams\r\n\r\n  return (\r\n    <div>\r\n      <h1>Product Listing</h1>\r\n      <p>Search query: {query}</p>\r\n      <p>Current page: {page}</p>\r\n      <p>Sort order: {sort}</p>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/shop/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { use } from 'react'\r\n\r\nexport default function Page({\r\n  params,\r\n  searchParams,\r\n}: {\r\n  params: Promise<{ slug: string }>\r\n  searchParams: Promise<{ [key: string]: string | string[] | undefined }>\r\n}) {\r\n  const { slug } = use(params)\r\n  const { query } = use(searchParams)\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "js",
        "code": "'use client'\r\n\r\nimport { use } from 'react'\r\n\r\nexport default function Page({ params, searchParams }) {\r\n  const { slug } = use(params)\r\n  const { query } = use(searchParams)\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      }
    ],
    "content": "The page file allows you to define UI that is unique to a route. You can create a page by default exporting a component from the file: Good to know - The .js, .jsx, or .tsx file extensions can be used for page. - A page is always the leaf of the route subtree. - A page file is required to make a route segment publicly accessible. - Pages are Server Components by default, but can be set to a Client Component. Reference Props params (optional) A promise that resolves to an object containing the dynamic route parameters from the root segment down to that page. | Example Route | URL | params | | ------------------------------------ | ----------- | --------------------------------------- | | app/shop/[slug]/page.js | /shop/1 | Promise | | app/shop/[category]/[item]/page.js | /shop/1/2 | Promise | | app/shop/[...slug]/page.js | /shop/1/2 | Promise | - Since the params prop is a promise, you must use async/await or React's use function to access the values. - In version 14 and earlier, params was a synchronous prop. To help with backwards compatibility, you can still access it synchronously in Next.js 15, but this behavior will be deprecated in the future. searchParams (optional) A promise that resolves to an object containing the search parameters of the current URL. For example: Client Component pages can also access searchParams using React’s use hook: | Example URL | searchParams | | --------------- | ----------------------------- | | /shop?a=1 | Promise | | /shop?a=1&b=2 | Promise | | /shop?a=1&a=2 | Promise | - Since the searchParams prop is a promise. You must use async/await or React's use function to access the values. - In version 14 and earlier, searchParams was a synchronous prop. To help with backwards compatibility, you can still access it synchronously in Next.js 15, but this behavior will be deprecated in the future. - searchParams is a Dynamic API whose values cannot be known ahead of time. Using it will opt the page into dynamic rendering at request time. - searchParams is a plain JavaScript object, not a URLSearchParams instance. Page Props Helper You can type pages with PageProps to get strongly typed params and searchParams from the route literal. PageProps is a globally available helper. > Good to know > > - Using a literal route (e.g. '/blog/[slug]') enables autocomplete and strict keys for params. > - Static routes resolve params to {}. > - Types are generated during next dev, next build, or with next typegen. > - After type generation, the PageProps helper is globally available. It doesn't need to be imported. Examples Displaying content based on params Using dynamic route segments, you can display or fetch specific content for the page based on the params prop. Handling filtering with searchParams You can use the searchParams prop to handle filtering, pagination, or sorting based on the query string of the URL. Reading searchParams and params in Client Components To use searchParams and params in a Client Component (which cannot be async), you can use React's use function to read the promise: Version History | Version | Changes | | ------------ | ---------------------------------------------------------------------------------------------------------------- | | v15.0.0-RC | params and searchParams are now promises. A codemod is available. | | v13.0.0 | page introduced. |",
    "excerpt": "The page file allows you to define UI that is unique to a route. You can create a page by default exporting a component from the file: Good to know - The .js, .jsx, or .tsx file extensions can be used...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/03-file-conventions/page"
  },
  {
    "id": "01-app-03-api-reference-03-file-conventions-parallel-routes",
    "path": "01-app\\03-api-reference\\03-file-conventions\\parallel-routes.mdx",
    "title": "Parallel Routes",
    "description": "Simultaneously render one or more pages in the same view that can be navigated independently. A pattern for highly dynamic applications.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Convention",
        "slug": "convention"
      },
      {
        "level": 3,
        "text": "Slots",
        "slug": "slots"
      },
      {
        "level": 2,
        "text": "Behavior",
        "slug": "behavior"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "With ",
        "slug": "with-"
      },
      {
        "level": 3,
        "text": "Conditional Routes",
        "slug": "conditional-routes"
      },
      {
        "level": 3,
        "text": "Tab Groups",
        "slug": "tab-groups"
      },
      {
        "level": 3,
        "text": "Modals",
        "slug": "modals"
      },
      {
        "level": 4,
        "text": "Opening the modal",
        "slug": "opening-the-modal"
      },
      {
        "level": 4,
        "text": "Closing the modal",
        "slug": "closing-the-modal"
      },
      {
        "level": 3,
        "text": "Loading and Error UI",
        "slug": "loading-and-error-ui"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "export default function Layout({\r\n  children,\r\n  team,\r\n  analytics,\r\n}: {\r\n  children: React.ReactNode\r\n  analytics: React.ReactNode\r\n  team: React.ReactNode\r\n}) {\r\n  return (\r\n    <>\r\n      {children}\r\n      {team}\r\n      {analytics}\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function Layout({ children, team, analytics }) {\r\n  return (\r\n    <>\r\n      {children}\r\n      {team}\r\n      {analytics}\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { useSelectedLayoutSegment } from 'next/navigation'\r\n\r\nexport default function Layout({ auth }: { auth: React.ReactNode }) {\r\n  const loginSegment = useSelectedLayoutSegment('auth')\r\n  // ...\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { useSelectedLayoutSegment } from 'next/navigation'\r\n\r\nexport default function Layout({ auth }) {\r\n  const loginSegment = useSelectedLayoutSegment('auth')\r\n  // ...\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { checkUserRole } from '@/lib/auth'\r\n\r\nexport default function Layout({\r\n  user,\r\n  admin,\r\n}: {\r\n  user: React.ReactNode\r\n  admin: React.ReactNode\r\n}) {\r\n  const role = checkUserRole()\r\n  return role === 'admin' ? admin : user\r\n}",
        "context": "filename=\"app/dashboard/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { checkUserRole } from '@/lib/auth'\r\n\r\nexport default function Layout({ user, admin }) {\r\n  const role = checkUserRole()\r\n  return role === 'admin' ? admin : user\r\n}",
        "context": "filename=\"app/dashboard/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Layout({ children }: { children: React.ReactNode }) {\r\n  return (\r\n    <>\r\n      <nav>\r\n        <Link href=\"/page-views\">Page Views</Link>\r\n        <Link href=\"/visitors\">Visitors</Link>\r\n      </nav>\r\n      <div>{children}</div>\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/@analytics/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Layout({ children }) {\r\n  return (\r\n    <>\r\n      <nav>\r\n        <Link href=\"/page-views\">Page Views</Link>\r\n        <Link href=\"/visitors\">Visitors</Link>\r\n      </nav>\r\n      <div>{children}</div>\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/@analytics/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { Login } from '@/app/ui/login'\r\n\r\nexport default function Page() {\r\n  return <Login />\r\n}",
        "context": "filename=\"app/login/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { Login } from '@/app/ui/login'\r\n\r\nexport default function Page() {\r\n  return <Login />\r\n}",
        "context": "filename=\"app/login/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default function Default() {\r\n  return null\r\n}",
        "context": "filename=\"app/@auth/default.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function Default() {\r\n  return null\r\n}",
        "context": "filename=\"app/@auth/default.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { Modal } from '@/app/ui/modal'\r\nimport { Login } from '@/app/ui/login'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <Modal>\r\n      <Login />\r\n    </Modal>\r\n  )\r\n}",
        "context": "filename=\"app/@auth/(.)login/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { Modal } from '@/app/ui/modal'\r\nimport { Login } from '@/app/ui/login'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <Modal>\r\n      <Login />\r\n    </Modal>\r\n  )\r\n}",
        "context": "filename=\"app/@auth/(.)login/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Layout({\r\n  auth,\r\n  children,\r\n}: {\r\n  auth: React.ReactNode\r\n  children: React.ReactNode\r\n}) {\r\n  return (\r\n    <>\r\n      <nav>\r\n        <Link href=\"/login\">Open modal</Link>\r\n      </nav>\r\n      <div>{auth}</div>\r\n      <div>{children}</div>\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Layout({ auth, children }) {\r\n  return (\r\n    <>\r\n      <nav>\r\n        <Link href=\"/login\">Open modal</Link>\r\n      </nav>\r\n      <div>{auth}</div>\r\n      <div>{children}</div>\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { useRouter } from 'next/navigation'\r\n\r\nexport function Modal({ children }: { children: React.ReactNode }) {\r\n  const router = useRouter()\r\n\r\n  return (\r\n    <>\r\n      <button\r\n        onClick={() => {\r\n          router.back()\r\n        }}\r\n      >\r\n        Close modal\r\n      </button>\r\n      <div>{children}</div>\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/ui/modal.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { useRouter } from 'next/navigation'\r\n\r\nexport function Modal({ children }) {\r\n  const router = useRouter()\r\n\r\n  return (\r\n    <>\r\n      <button\r\n        onClick={() => {\r\n          router.back()\r\n        }}\r\n      >\r\n        Close modal\r\n      </button>\r\n      <div>{children}</div>\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/ui/modal.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\n\r\nexport function Modal({ children }: { children: React.ReactNode }) {\r\n  return (\r\n    <>\r\n      <Link href=\"/\">Close modal</Link>\r\n      <div>{children}</div>\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/ui/modal.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\nexport function Modal({ children }) {\r\n  return (\r\n    <>\r\n      <Link href=\"/\">Close modal</Link>\r\n      <div>{children}</div>\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/ui/modal.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default function Page() {\r\n  return null\r\n}",
        "context": "filename=\"app/@auth/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function Page() {\r\n  return null\r\n}",
        "context": "filename=\"app/@auth/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default function CatchAll() {\r\n  return null\r\n}",
        "context": "filename=\"app/@auth/[...catchAll]/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function CatchAll() {\r\n  return null\r\n}",
        "context": "filename=\"app/@auth/[...catchAll]/page.js\" switcher"
      }
    ],
    "content": "Parallel Routes allows you to simultaneously or conditionally render one or more pages within the same layout. They are useful for highly dynamic sections of an app, such as dashboards and feeds on social sites. For example, considering a dashboard, you can use parallel routes to simultaneously render the team and analytics pages: Convention Slots Parallel routes are created using named slots. Slots are defined with the @folder convention. For example, the following file structure defines two slots: @analytics and @team: Slots are passed as props to the shared parent layout. For the example above, the component in app/layout.js now accepts the @analytics and @team slots props, and can render them in parallel alongside the children prop: However, slots are not route segments and do not affect the URL structure. For example, for /@analytics/views, the URL will be /views since @analytics is a slot. Slots are combined with the regular Page component to form the final page associated with the route segment. Because of this, you cannot have separate static and dynamic slots at the same route segment level. If one slot is dynamic, all slots at that level must be dynamic. > Good to know: > > - The children prop is an implicit slot that does not need to be mapped to a folder. This means app/page.js is equivalent to app/@children/page.js. default.js You can define a default.js file to render as a fallback for unmatched slots during the initial load or full-page reload. Consider the following folder structure. The @team slot has a /settings page, but @analytics does not. When navigating to /settings, the @team slot will render the /settings page while maintaining the currently active page for the @analytics slot. On refresh, Next.js will render a default.js for @analytics. If default.js doesn't exist, a 404 is rendered instead. Additionally, since children is an implicit slot, you also need to create a default.js file to render a fallback for children when Next.js cannot recover the active state of the parent page. Behavior By default, Next.js keeps track of the active state (or subpage) for each slot. However, the content rendered within a slot will depend on the type of navigation: - Soft Navigation: During client-side navigation, Next.js will perform a partial render, changing the subpage within the slot, while maintaining the other slot's active subpages, even if they don't match the current URL. - Hard Navigation: After a full-page load (browser refresh), Next.js cannot determine the active state for the slots that don't match the current URL. Instead, it will render a default.js file for the unmatched slots, or 404 if default.js doesn't exist. > Good to know: > > - The 404 for unmatched routes helps ensure that you don't accidentally render a parallel route on a page that it was not intended for. Examples With useSelectedLayoutSegment(s) Both useSelectedLayoutSegment and useSelectedLayoutSegments accept a parallelRoutesKey parameter, which allows you to read the active route segment within a slot. When a user navigates to app/@auth/login (or /login in the URL bar), loginSegment will be equal to the string \"login\". Conditional Routes You can use Parallel Routes to conditionally render routes based on certain conditions, such as user role. For example, to render a different dashboard page for the /admin or /user roles: Tab Groups You can add a layout inside a slot to allow users to navigate the slot independently. This is useful for creating tabs. For example, the @analytics slot has two subpages: /page-views and /visitors. Within @analytics, create a layout file to share the tabs between the two pages: Modals Parallel Routes can be used together with Intercepting Routes to create modals that support deep linking. This allows you to solve common challenges when building modals, such as: - Making the modal content shareable through a URL. - Preserving context when the page is refreshed, instead of closing the modal. - Closing the modal on backwards navigation rather than going to the previous route. - Reopening the modal on forwards navigation. Consider the following UI pattern, where a user can open a login modal from a layout using client-side navigation, or access a separate /login page: To implement this pattern, start by creating a /login route that renders your main login page. Then, inside the @auth slot, add default.js file that returns null. This ensures that the modal is not rendered when it's not active. Inside your @auth slot, intercept the /login route by importing the component and its children into the @auth/(.)login/page.tsx file, and updating the folder name to /@auth/(.)login/page.tsx. > Good to know: > > - The convention (.) is used for intercepting routes. See Intercepting Routes docs for more information. > - By separating the functionality from the modal content (), you can ensure any content inside the modal, e.g. forms, are Server Components. See Interleaving Client and Server Components for more information. Opening the modal Now, you can leverage the Next.js router to open and close the modal. This ensures the URL is correctly updated when the modal is open, and when navigating backwards and forwards. To open the modal, pass the @auth slot as a prop to the parent layout and render it alongside the children prop. When the user clicks the , the modal will open instead of navigating to the /login page. However, on refresh or initial load, navigating to /login will take the user to the main login page. Closing the modal You can close the modal by calling router.back() or by using the Link component. When using the Link component to navigate away from a page that shouldn't render the @auth slot anymore, we need to make sure the parallel route matches to a component that returns null. For example, when navigating back to the root page, we create a @auth/page.tsx component: Or if navigating to any other page (such as /foo, /foo/bar, etc), you can use a catch-all slot: > Good to know: > > - We use a catch-all route in our @auth slot to close the modal because of how parallel routes behave. Since client-side navigations to a route that no longer match the slot will remain visible, we need to match the slot to a route that returns null to close the modal. > - Other examples could include opening a photo modal in a gallery while also having a dedicated /photo/[id] page, or opening a shopping cart in a side modal. > - View an example of modals with Intercepted and Parallel Routes. Loading and Error UI Parallel Routes can be streamed independently, allowing you to define independent error and loading states for each route: See the Loading UI and Error Handling documentation for more information.",
    "excerpt": "Parallel Routes allows you to simultaneously or conditionally render one or more pages within the same layout. They are useful for highly dynamic sections of an app, such as dashboards and feeds on so...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/03-file-conventions/parallel-routes"
  },
  {
    "id": "01-app-03-api-reference-03-file-conventions-proxy",
    "path": "01-app\\03-api-reference\\03-file-conventions\\proxy.mdx",
    "title": "proxy.js",
    "description": "API reference for the proxy.js file.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Exports",
        "slug": "exports"
      },
      {
        "level": 3,
        "text": "Proxy function",
        "slug": "proxy-function"
      },
      {
        "level": 3,
        "text": "Config object (optional)",
        "slug": "config-object-optional"
      },
      {
        "level": 3,
        "text": "Matcher",
        "slug": "matcher"
      },
      {
        "level": 2,
        "text": "Params",
        "slug": "params"
      },
      {
        "level": 2,
        "text": "NextResponse",
        "slug": "nextresponse"
      },
      {
        "level": 2,
        "text": "Execution order",
        "slug": "execution-order"
      },
      {
        "level": 2,
        "text": "Runtime",
        "slug": "runtime"
      },
      {
        "level": 2,
        "text": "Advanced Proxy flags",
        "slug": "advanced-proxy-flags"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Conditional Statements",
        "slug": "conditional-statements"
      },
      {
        "level": 3,
        "text": "Using Cookies",
        "slug": "using-cookies"
      },
      {
        "level": 3,
        "text": "Setting Headers",
        "slug": "setting-headers"
      },
      {
        "level": 3,
        "text": "CORS",
        "slug": "cors"
      },
      {
        "level": 3,
        "text": "Producing a response",
        "slug": "producing-a-response"
      },
      {
        "level": 3,
        "text": "Negative matching",
        "slug": "negative-matching"
      },
      {
        "level": 3,
        "text": " and ",
        "slug": "-and-"
      },
      {
        "level": 3,
        "text": "Unit testing (experimental)",
        "slug": "unit-testing-experimental"
      },
      {
        "level": 2,
        "text": "Platform support",
        "slug": "platform-support"
      },
      {
        "level": 2,
        "text": "Migration to Proxy",
        "slug": "migration-to-proxy"
      },
      {
        "level": 3,
        "text": "Why the Change",
        "slug": "why-the-change"
      },
      {
        "level": 3,
        "text": "Why \"Proxy\"",
        "slug": "why-proxy"
      },
      {
        "level": 3,
        "text": "How to Migrate",
        "slug": "how-to-migrate"
      },
      {
        "level": 2,
        "text": "Version history",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "import { NextResponse, NextRequest } from 'next/server'\r\n\r\n// This function can be marked `async` if using `await` inside\r\nexport function proxy(request: NextRequest) {\r\n  return NextResponse.redirect(new URL('/home', request.url))\r\n}\r\n\r\nexport const config = {\r\n  matcher: '/about/:path*',\r\n}",
        "context": "filename=\"proxy.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { NextResponse } from 'next/server'\r\n\r\n// This function can be marked `async` if using `await` inside\r\nexport function proxy(request) {\r\n  return NextResponse.redirect(new URL('/home', request.url))\r\n}\r\n\r\nexport const config = {\r\n  matcher: '/about/:path*',\r\n}",
        "context": "filename=\"proxy.js\" switcher"
      },
      {
        "language": "js",
        "code": "// Example of default export\r\nexport default function proxy(request) {\r\n  // Proxy logic\r\n}",
        "context": "filename=\"proxy.js\""
      },
      {
        "language": "js",
        "code": "export const config = {\r\n  matcher: ['/about/:path*', '/dashboard/:path*'],\r\n}",
        "context": "filename=\"proxy.js\""
      },
      {
        "language": "js",
        "code": "export const config = {\r\n  matcher: [\r\n    // Exclude API routes, static files, image optimizations, and .png files\r\n    '/((?!api|_next/static|_next/image|.*\\\\.png$).*)',\r\n  ],\r\n}",
        "context": "filename=\"proxy.js\""
      },
      {
        "language": "js",
        "code": "export const config = {\r\n  matcher: [\r\n    {\r\n      source: '/api/:path*',\r\n      locale: false,\r\n      has: [\r\n        { type: 'header', key: 'Authorization', value: 'Bearer Token' },\r\n        { type: 'query', key: 'userId', value: '123' },\r\n      ],\r\n      missing: [{ type: 'cookie', key: 'session', value: 'active' }],\r\n    },\r\n  ],\r\n}",
        "context": "filename=\"proxy.js\""
      },
      {
        "language": "tsx",
        "code": "import type { NextRequest } from 'next/server'\r\n\r\nexport function proxy(request: NextRequest) {\r\n  // Proxy logic goes here\r\n}",
        "context": "filename=\"proxy.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export function proxy(request) {\r\n  // Proxy logic goes here\r\n}",
        "context": "filename=\"proxy.js\" switcher"
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  skipTrailingSlashRedirect: true,\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "const legacyPrefixes = ['/docs', '/blog']\r\n\r\nexport default async function proxy(req) {\r\n  const { pathname } = req.nextUrl\r\n\r\n  if (legacyPrefixes.some((prefix) => pathname.startsWith(prefix))) {\r\n    return NextResponse.next()\r\n  }\r\n\r\n  // apply trailing slash handling\r\n  if (\r\n    !pathname.endsWith('/') &&\r\n    !pathname.match(/((?!\\.well-known(?:\\/.*)?)(?:[^/]+\\/)*[^/]+\\.\\w+)/)\r\n  ) {\r\n    return NextResponse.redirect(\r\n      new URL(`${req.nextUrl.pathname}/`, req.nextUrl)\r\n    )\r\n  }\r\n}",
        "context": "filename=\"proxy.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  skipMiddlewareUrlNormalize: true,\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "export default async function proxy(req) {\r\n  const { pathname } = req.nextUrl\r\n\r\n  // GET /_next/data/build-id/hello.json\r\n\r\n  console.log(pathname)\r\n  // with the flag this now /_next/data/build-id/hello.json\r\n  // without the flag this would be normalized to /hello\r\n}",
        "context": "filename=\"proxy.js\""
      },
      {
        "language": "ts",
        "code": "import { NextResponse } from 'next/server'\r\nimport type { NextRequest } from 'next/server'\r\n\r\nexport function proxy(request: NextRequest) {\r\n  if (request.nextUrl.pathname.startsWith('/about')) {\r\n    return NextResponse.rewrite(new URL('/about-2', request.url))\r\n  }\r\n\r\n  if (request.nextUrl.pathname.startsWith('/dashboard')) {\r\n    return NextResponse.rewrite(new URL('/dashboard/user', request.url))\r\n  }\r\n}",
        "context": "filename=\"proxy.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { NextResponse } from 'next/server'\r\n\r\nexport function proxy(request) {\r\n  if (request.nextUrl.pathname.startsWith('/about')) {\r\n    return NextResponse.rewrite(new URL('/about-2', request.url))\r\n  }\r\n\r\n  if (request.nextUrl.pathname.startsWith('/dashboard')) {\r\n    return NextResponse.rewrite(new URL('/dashboard/user', request.url))\r\n  }\r\n}",
        "context": "filename=\"proxy.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { NextResponse } from 'next/server'\r\nimport type { NextRequest } from 'next/server'\r\n\r\nexport function proxy(request: NextRequest) {\r\n  // Assume a \"Cookie:nextjs=fast\" header to be present on the incoming request\r\n  // Getting cookies from the request using the `RequestCookies` API\r\n  let cookie = request.cookies.get('nextjs')\r\n  console.log(cookie) // => { name: 'nextjs', value: 'fast', Path: '/' }\r\n  const allCookies = request.cookies.getAll()\r\n  console.log(allCookies) // => [{ name: 'nextjs', value: 'fast' }]\r\n\r\n  request.cookies.has('nextjs') // => true\r\n  request.cookies.delete('nextjs')\r\n  request.cookies.has('nextjs') // => false\r\n\r\n  // Setting cookies on the response using the `ResponseCookies` API\r\n  const response = NextResponse.next()\r\n  response.cookies.set('vercel', 'fast')\r\n  response.cookies.set({\r\n    name: 'vercel',\r\n    value: 'fast',\r\n    path: '/',\r\n  })\r\n  cookie = response.cookies.get('vercel')\r\n  console.log(cookie) // => { name: 'vercel', value: 'fast', Path: '/' }\r\n  // The outgoing response will have a `Set-Cookie:vercel=fast;path=/` header.\r\n\r\n  return response\r\n}",
        "context": "filename=\"proxy.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { NextResponse } from 'next/server'\r\n\r\nexport function proxy(request) {\r\n  // Assume a \"Cookie:nextjs=fast\" header to be present on the incoming request\r\n  // Getting cookies from the request using the `RequestCookies` API\r\n  let cookie = request.cookies.get('nextjs')\r\n  console.log(cookie) // => { name: 'nextjs', value: 'fast', Path: '/' }\r\n  const allCookies = request.cookies.getAll()\r\n  console.log(allCookies) // => [{ name: 'nextjs', value: 'fast' }]\r\n\r\n  request.cookies.has('nextjs') // => true\r\n  request.cookies.delete('nextjs')\r\n  request.cookies.has('nextjs') // => false\r\n\r\n  // Setting cookies on the response using the `ResponseCookies` API\r\n  const response = NextResponse.next()\r\n  response.cookies.set('vercel', 'fast')\r\n  response.cookies.set({\r\n    name: 'vercel',\r\n    value: 'fast',\r\n    path: '/',\r\n  })\r\n  cookie = response.cookies.get('vercel')\r\n  console.log(cookie) // => { name: 'vercel', value: 'fast', Path: '/' }\r\n  // The outgoing response will have a `Set-Cookie:vercel=fast;path=/` header.\r\n\r\n  return response\r\n}",
        "context": "filename=\"proxy.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { NextResponse } from 'next/server'\r\nimport type { NextRequest } from 'next/server'\r\n\r\nexport function proxy(request: NextRequest) {\r\n  // Clone the request headers and set a new header `x-hello-from-proxy1`\r\n  const requestHeaders = new Headers(request.headers)\r\n  requestHeaders.set('x-hello-from-proxy1', 'hello')\r\n\r\n  // You can also set request headers in NextResponse.next\r\n  const response = NextResponse.next({\r\n    request: {\r\n      // New request headers\r\n      headers: requestHeaders,\r\n    },\r\n  })\r\n\r\n  // Set a new response header `x-hello-from-proxy2`\r\n  response.headers.set('x-hello-from-proxy2', 'hello')\r\n  return response\r\n}",
        "context": "filename=\"proxy.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { NextResponse } from 'next/server'\r\n\r\nexport function proxy(request) {\r\n  // Clone the request headers and set a new header `x-hello-from-proxy1`\r\n  const requestHeaders = new Headers(request.headers)\r\n  requestHeaders.set('x-hello-from-proxy1', 'hello')\r\n\r\n  // You can also set request headers in NextResponse.next\r\n  const response = NextResponse.next({\r\n    request: {\r\n      // New request headers\r\n      headers: requestHeaders,\r\n    },\r\n  })\r\n\r\n  // Set a new response header `x-hello-from-proxy2`\r\n  response.headers.set('x-hello-from-proxy2', 'hello')\r\n  return response\r\n}",
        "context": "filename=\"proxy.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { NextRequest, NextResponse } from 'next/server'\r\n\r\nconst allowedOrigins = ['https://acme.com', 'https://my-app.org']\r\n\r\nconst corsOptions = {\r\n  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\r\n  'Access-Control-Allow-Headers': 'Content-Type, Authorization',\r\n}\r\n\r\nexport function proxy(request: NextRequest) {\r\n  // Check the origin from the request\r\n  const origin = request.headers.get('origin') ?? ''\r\n  const isAllowedOrigin = allowedOrigins.includes(origin)\r\n\r\n  // Handle preflighted requests\r\n  const isPreflight = request.method === 'OPTIONS'\r\n\r\n  if (isPreflight) {\r\n    const preflightHeaders = {\r\n      ...(isAllowedOrigin && { 'Access-Control-Allow-Origin': origin }),\r\n      ...corsOptions,\r\n    }\r\n    return NextResponse.json({}, { headers: preflightHeaders })\r\n  }\r\n\r\n  // Handle simple requests\r\n  const response = NextResponse.next()\r\n\r\n  if (isAllowedOrigin) {\r\n    response.headers.set('Access-Control-Allow-Origin', origin)\r\n  }\r\n\r\n  Object.entries(corsOptions).forEach(([key, value]) => {\r\n    response.headers.set(key, value)\r\n  })\r\n\r\n  return response\r\n}\r\n\r\nexport const config = {\r\n  matcher: '/api/:path*',\r\n}",
        "context": "filename=\"proxy.ts\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { NextResponse } from 'next/server'\r\n\r\nconst allowedOrigins = ['https://acme.com', 'https://my-app.org']\r\n\r\nconst corsOptions = {\r\n  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\r\n  'Access-Control-Allow-Headers': 'Content-Type, Authorization',\r\n}\r\n\r\nexport function proxy(request) {\r\n  // Check the origin from the request\r\n  const origin = request.headers.get('origin') ?? ''\r\n  const isAllowedOrigin = allowedOrigins.includes(origin)\r\n\r\n  // Handle preflighted requests\r\n  const isPreflight = request.method === 'OPTIONS'\r\n\r\n  if (isPreflight) {\r\n    const preflightHeaders = {\r\n      ...(isAllowedOrigin && { 'Access-Control-Allow-Origin': origin }),\r\n      ...corsOptions,\r\n    }\r\n    return NextResponse.json({}, { headers: preflightHeaders })\r\n  }\r\n\r\n  // Handle simple requests\r\n  const response = NextResponse.next()\r\n\r\n  if (isAllowedOrigin) {\r\n    response.headers.set('Access-Control-Allow-Origin', origin)\r\n  }\r\n\r\n  Object.entries(corsOptions).forEach(([key, value]) => {\r\n    response.headers.set(key, value)\r\n  })\r\n\r\n  return response\r\n}\r\n\r\nexport const config = {\r\n  matcher: '/api/:path*',\r\n}",
        "context": "filename=\"proxy.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import type { NextRequest } from 'next/server'\r\nimport { isAuthenticated } from '@lib/auth'\r\n\r\n// Limit the proxy to paths starting with `/api/`\r\nexport const config = {\r\n  matcher: '/api/:function*',\r\n}\r\n\r\nexport function proxy(request: NextRequest) {\r\n  // Call our authentication function to check the request\r\n  if (!isAuthenticated(request)) {\r\n    // Respond with JSON indicating an error message\r\n    return Response.json(\r\n      { success: false, message: 'authentication failed' },\r\n      { status: 401 }\r\n    )\r\n  }\r\n}",
        "context": "filename=\"proxy.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { isAuthenticated } from '@lib/auth'\r\n\r\n// Limit the proxy to paths starting with `/api/`\r\nexport const config = {\r\n  matcher: '/api/:function*',\r\n}\r\n\r\nexport function proxy(request) {\r\n  // Call our authentication function to check the request\r\n  if (!isAuthenticated(request)) {\r\n    // Respond with JSON indicating an error message\r\n    return Response.json(\r\n      { success: false, message: 'authentication failed' },\r\n      { status: 401 }\r\n    )\r\n  }\r\n}",
        "context": "filename=\"proxy.js\" switcher"
      },
      {
        "language": "js",
        "code": "export const config = {\r\n  matcher: [\r\n    /*\r\n     * Match all request paths except for the ones starting with:\r\n     * - api (API routes)\r\n     * - _next/static (static files)\r\n     * - _next/image (image optimization files)\r\n     * - favicon.ico, sitemap.xml, robots.txt (metadata files)\r\n     */\r\n    '/((?!api|_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt).*)',\r\n  ],\r\n}",
        "context": "filename=\"proxy.js\""
      },
      {
        "language": "js",
        "code": "export const config = {\r\n  matcher: [\r\n    /*\r\n     * Match all request paths except for the ones starting with:\r\n     * - api (API routes)\r\n     * - _next/static (static files)\r\n     * - _next/image (image optimization files)\r\n     * - favicon.ico, sitemap.xml, robots.txt (metadata files)\r\n     */\r\n    {\r\n      source:\r\n        '/((?!api|_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt).*)',\r\n      missing: [\r\n        { type: 'header', key: 'next-router-prefetch' },\r\n        { type: 'header', key: 'purpose', value: 'prefetch' },\r\n      ],\r\n    },\r\n\r\n    {\r\n      source:\r\n        '/((?!api|_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt).*)',\r\n      has: [\r\n        { type: 'header', key: 'next-router-prefetch' },\r\n        { type: 'header', key: 'purpose', value: 'prefetch' },\r\n      ],\r\n    },\r\n\r\n    {\r\n      source:\r\n        '/((?!api|_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt).*)',\r\n      has: [{ type: 'header', key: 'x-present' }],\r\n      missing: [{ type: 'header', key: 'x-missing', value: 'prefetch' }],\r\n    },\r\n  ],\r\n}",
        "context": "filename=\"proxy.js\""
      },
      {
        "language": "js",
        "code": "export const config = {\r\n  matcher:\r\n    '/((?!api|_next/data|_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt).*)',\r\n}\r\n\r\n// Proxy will still run for /_next/data/* routes despite being excluded",
        "context": "filename=\"proxy.js\""
      },
      {
        "language": "ts",
        "code": "import { NextResponse } from 'next/server'\r\nimport type { NextFetchEvent, NextRequest } from 'next/server'\r\n\r\nexport function proxy(req: NextRequest, event: NextFetchEvent) {\r\n  event.waitUntil(\r\n    fetch('https://my-analytics-platform.com', {\r\n      method: 'POST',\r\n      body: JSON.stringify({ pathname: req.nextUrl.pathname }),\r\n    })\r\n  )\r\n\r\n  return NextResponse.next()\r\n}",
        "context": "filename=\"proxy.ts\""
      },
      {
        "language": "js",
        "code": "import { unstable_doesProxyMatch } from 'next/experimental/testing/server'\r\n\r\nexpect(\r\n  unstable_doesProxyMatch({\r\n    config,\r\n    nextConfig,\r\n    url: '/test',\r\n  })\r\n).toEqual(false)",
        "context": ""
      },
      {
        "language": "js",
        "code": "import { isRewrite, getRewrittenUrl } from 'next/experimental/testing/server'\r\n\r\nconst request = new NextRequest('https://nextjs.org/docs')\r\nconst response = await proxy(request)\r\nexpect(isRewrite(response)).toEqual(true)\r\nexpect(getRewrittenUrl(response)).toEqual('https://other-domain.com/docs')\r\n// getRedirectUrl could also be used if the response were a redirect",
        "context": ""
      },
      {
        "language": "bash",
        "code": "npx @next/codemod@canary middleware-to-proxy .",
        "context": ""
      },
      {
        "language": "diff",
        "code": "// middleware.ts -> proxy.ts\r\n\r\n- export function middleware() {\r\n+ export function proxy() {",
        "context": ""
      }
    ],
    "content": "> Note: The middleware file convention is deprecated and has been renamed to proxy. See Migration to Proxy for more details. The proxy.js|ts file is used to write Proxy and run code on the server before a request is completed. Then, based on the incoming request, you can modify the response by rewriting, redirecting, modifying the request or response headers, or responding directly. Proxy executes before routes are rendered. It's particularly useful for implementing custom server-side logic like authentication, logging, or handling redirects. > Good to know: > > Proxy is meant to be invoked separately of your render code and in optimized cases deployed to your CDN for fast redirect/rewrite handling, you should not attempt relying on shared modules or globals. > > To pass information from Proxy to your application, use headers, cookies, rewrites, redirects, or the URL. Create a proxy.ts (or .js) file in the project root, or inside src if applicable, so that it is located at the same level as pages or app. If you’ve customized pageExtensions, for example to .page.ts or .page.js, name your file proxy.page.ts or proxy.page.js accordingly. Exports Proxy function The file must export a single function, either as a default export or named proxy. Note that multiple proxy from the same file are not supported. Config object (optional) Optionally, a config object can be exported alongside the Proxy function. This object includes the matcher to specify paths where the Proxy applies. Matcher The matcher option allows you to target specific paths for the Proxy to run on. You can specify these paths in several ways: - For a single path: Directly use a string to define the path, like '/about'. - For multiple paths: Use an array to list multiple paths, such as matcher: ['/about', '/contact'], which applies the Proxy to both /about and /contact. Additionally, the matcher option supports complex path specifications using regular expressions. For example, you can exclude certain paths with a regular expression matcher: This enables precise control over which paths to include or exclude. The matcher option accepts an array of objects with the following keys: - source: The path or pattern used to match the request paths. It can be a string for direct path matching or a pattern for more complex matching. - locale (optional): A boolean that, when set to false, ignores locale-based routing in path matching. - has (optional): Specifies conditions based on the presence of specific request elements such as headers, query parameters, or cookies. - missing (optional): Focuses on conditions where certain request elements are absent, like missing headers or cookies. Configured matchers: 1. MUST start with / 2. Can include named parameters: /about/:path matches /about/a and /about/b but not /about/a/c 3. Can have modifiers on named parameters (starting with :): /about/:path matches /about/a/b/c because is zero or more. ? is zero or one and + one or more 4. Can use regular expression enclosed in parenthesis: /about/(.) is the same as /about/:path Read more details on path-to-regexp documentation. > Good to know: > > - The matcher values need to be constants so they can be statically analyzed at build-time. Dynamic values such as variables will be ignored. > - For backward compatibility, Next.js always considers /public as /public/index. Therefore, a matcher of /public/:path will match. Params request When defining Proxy, the default export function accepts a single parameter, request. This parameter is an instance of NextRequest, which represents the incoming HTTP request. > Good to know: > > - NextRequest is a type that represents incoming HTTP requests in Next.js Proxy, whereas NextResponse is a class used to manipulate and send back HTTP responses. NextResponse The NextResponse API allows you to: - redirect the incoming request to a different URL - rewrite the response by displaying a given URL - Set request headers for API Routes, getServerSideProps, and rewrite destinations - Set response cookies - Set response headers To produce a response from Proxy, you can: 1. rewrite to a route (Page or Route Handler) that produces a response 2. return a NextResponse directly. See Producing a Response > Good to know: For redirects, you can also use Response.redirect instead of NextResponse.redirect. To produce a response from Proxy, you can: 1. rewrite to a route (Page or Edge API Route) that produces a response 2. return a NextResponse directly. See Producing a Response Execution order Proxy will be invoked for every route in your project. Given this, it's crucial to use matchers to precisely target or exclude specific routes. The following is the execution order: 1. headers from next.config.js 2. redirects from next.config.js 3. Proxy (rewrites, redirects, etc.) 4. beforeFiles (rewrites) from next.config.js 5. Filesystem routes (public/, next/static/, pages/, app/, etc.) 6. afterFiles (rewrites) from next.config.js 7. Dynamic Routes (/blog/[slug]) 8. fallback (rewrites) from next.config.js Runtime Proxy defaults to using the Node.js runtime. The runtime config option is not available in Proxy files. Setting the runtime config option in Proxy will throw an error. Advanced Proxy flags In v13.1 of Next.js two additional flags were introduced for proxy, skipMiddlewareUrlNormalize and skipTrailingSlashRedirect to handle advanced use cases. skipTrailingSlashRedirect disables Next.js redirects for adding or removing trailing slashes. This allows custom handling inside proxy to maintain the trailing slash for some paths but not others, which can make incremental migrations easier. skipMiddlewareUrlNormalize allows for disabling the URL normalization in Next.js to make handling direct visits and client-transitions the same. In some advanced cases, this option provides full control by using the original URL. Examples Conditional Statements Using Cookies Cookies are regular headers. On a Request, they are stored in the Cookie header. On a Response they are in the Set-Cookie header. Next.js provides a convenient way to access and manipulate these cookies through the cookies extension on NextRequest and NextResponse. 1. For incoming requests, cookies comes with the following methods: get, getAll, set, and delete cookies. You can check for the existence of a cookie with has or remove all cookies with clear. 2. For outgoing responses, cookies have the following methods get, getAll, set, and delete. Setting Headers You can set request and response headers using the NextResponse API (setting request headers is available since Next.js v13.0.0). Note that the snippet uses: - NextResponse.next({ request: { headers: requestHeaders } }) to make requestHeaders available upstream - NOT NextResponse.next({ headers: requestHeaders }) which makes requestHeaders available to clients Learn more in NextResponse headers in Proxy. > Good to know: Avoid setting large headers as it might cause 431 Request Header Fields Too Large error depending on your backend web server configuration. CORS You can set CORS headers in Proxy to allow cross-origin requests, including simple and preflighted requests. > Good to know: You can configure CORS headers for individual routes in Route Handlers. Producing a response You can respond from Proxy directly by returning a Response or NextResponse instance. (This is available since Next.js v13.1.0) Negative matching The matcher config allows full regex so matching like negative lookaheads or character matching is supported. An example of a negative lookahead to match all except specific paths can be seen here: You can also bypass Proxy for certain requests by using the missing or has arrays, or a combination of both: > Good to know: > > Even when next/data is excluded in a negative matcher pattern, proxy will still be invoked for next/data routes. This is intentional behavior to prevent accidental security issues where you might protect a page but forget to protect the corresponding data route. waitUntil and NextFetchEvent The NextFetchEvent object extends the native FetchEvent object, and includes the waitUntil() method. The waitUntil() method takes a promise as an argument, and extends the lifetime of the Proxy until the promise settles. This is useful for performing work in the background. Unit testing (experimental) Starting in Next.js 15.1, the next/experimental/testing/server package contains utilities to help unit test proxy files. Unit testing proxy can help ensure that it's only run on desired paths and that custom routing logic works as intended before code reaches production. The unstabledoesProxyMatch function can be used to assert whether proxy will run for the provided URL, headers, and cookies. The entire proxy function can also be tested. Platform support | Deployment Option | Supported | | ------------------------------------------------------------------- | ----------------- | | Node.js server | Yes | | Docker container | Yes | | Static export | No | | Adapters | Platform-specific | Learn how to configure Proxy when self-hosting Next.js. Migration to Proxy Why the Change The reason behind the renaming of middleware is that the term \"middleware\" can often be confused with Express.js middleware, leading to a misinterpretation of its purpose. Also, Middleware is highly capable, so it may encourage the usage; however, this feature is recommended to be used as a last resort. Next.js is moving forward to provide better APIs with better ergonomics so that developers can achieve their goals without Middleware. This is the reason behind the renaming of middleware. Why \"Proxy\" The name Proxy clarifies what Middleware is capable of. The term \"proxy\" implies that it has a network boundary in front of the app, which is the behavior of Middleware. Also, Middleware defaults to run at the Edge Runtime, which can run closer to the client, separated from the app's region. These behaviors align better with the term \"proxy\" and provide a clearer purpose of the feature. How to Migrate We recommend users avoid relying on Middleware unless no other options exist. Our goal is to give them APIs with better ergonomics so they can achieve their goals without Middleware. The term “middleware” often confuses users with Express.js middleware, which can encourage misuse. To clarify our direction, we are renaming the file convention to “proxy.” This highlights that we are moving away from Middleware, breaking down its overloaded features, and making the Proxy clear in its purpose. Next.js provides a codemod to migrate from middleware.ts to proxy.ts. You can run the following command to migrate: The codemod will rename the file and the function name from middleware to proxy. Version history | Version | Changes | | --------- | --------------------------------------------------------------------------------------------- | | v16.0.0 | Middleware is deprecated and renamed to Proxy | | v15.5.0 | Middleware can now use the Node.js runtime (stable) | | v15.2.0 | Middleware can now use the Node.js runtime (experimental) | | v13.1.0 | Advanced Middleware flags added | | v13.0.0 | Middleware can modify request headers, response headers, and send responses | | v12.2.0 | Middleware is stable, please see the upgrade guide | | v12.0.9 | Enforce absolute URLs in Edge Runtime (PR) | | v12.0.0 | Middleware (Beta) added |",
    "excerpt": "> Note: The middleware file convention is deprecated and has been renamed to proxy. See Migration to Proxy for more details. The proxy.js|ts file is used to write Proxy and run code on the server befo...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/03-file-conventions/proxy"
  },
  {
    "id": "01-app-03-api-reference-03-file-conventions-public-folder",
    "path": "01-app\\03-api-reference\\03-file-conventions\\public-folder.mdx",
    "title": "public Folder",
    "description": "Next.js allows you to serve static files, like images, in the public directory. You can learn how it works here.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Caching",
        "slug": "caching"
      },
      {
        "level": 2,
        "text": "Robots, Favicons, and others",
        "slug": "robots-favicons-and-others"
      }
    ],
    "codeBlocks": [
      {
        "language": "jsx",
        "code": "import Image from 'next/image'\r\n\r\nexport function Avatar({ id, alt }) {\r\n  return <Image src={`/avatars/${id}.png`} alt={alt} width=\"64\" height=\"64\" />\r\n}\r\n\r\nexport function AvatarOfMe() {\r\n  return <Avatar id=\"me\" alt=\"A portrait of me\" />\r\n}",
        "context": "filename=\"avatar.js\""
      },
      {
        "language": "jsx",
        "code": "Cache-Control: public, max-age=0",
        "context": ""
      }
    ],
    "content": "Next.js can serve static files, like images, under a folder called public in the root directory. Files inside public can then be referenced by your code starting from the base URL (/). For example, the file public/avatars/me.png can be viewed by visiting the /avatars/me.png path. The code to display that image might look like: Caching Next.js cannot safely cache assets in the public folder because they may change. The default caching headers applied are: Robots, Favicons, and others The folder is also useful for robots.txt, favicon.ico, Google Site Verification, and any other static files (including .html). But make sure to not have a static file with the same name as a file in the pages/ directory, as this will result in an error. Read more. For static metadata files, such as robots.txt, favicon.ico, etc, you should use special metadata files inside the app folder.",
    "excerpt": "Next.js can serve static files, like images, under a folder called public in the root directory. Files inside public can then be referenced by your code starting from the base URL (/). For example, th...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/03-file-conventions/public-folder"
  },
  {
    "id": "01-app-03-api-reference-03-file-conventions-route-groups",
    "path": "01-app\\03-api-reference\\03-file-conventions\\route-groups.mdx",
    "title": "Route Groups",
    "description": "Route Groups can be used to partition your Next.js application into different sections.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Convention",
        "slug": "convention"
      },
      {
        "level": 2,
        "text": "Use cases",
        "slug": "use-cases"
      },
      {
        "level": 2,
        "text": "Caveats",
        "slug": "caveats"
      }
    ],
    "codeBlocks": [],
    "content": "Route Groups are a folder convention that let you organize routes by category or team. Convention A route group can be created by wrapping a folder's name in parenthesis: (folderName). This convention indicates the folder is for organizational purposes and should not be included in the route's URL path. Use cases - Organizing routes by team, concern, or feature. - Defining multiple root layouts. - Opting specific route segments into sharing a layout, while keeping others out. Caveats - Full page load: If you navigate between routes that use different root layouts, it'll trigger a full page reload. For example, navigating from /cart that uses app/(shop)/layout.js to /blog that uses app/(marketing)/layout.js. This only applies to multiple root layouts. - Conflicting paths: Routes in different groups should not resolve to the same URL path. For example, (marketing)/about/page.js and (shop)/about/page.js would both resolve to /about and cause an error. - Top-level root layout: If you use multiple root layouts without a top-level layout.js file, make sure your home route (/) is defined within one of the route groups, e.g. app/(marketing)/page.js.",
    "excerpt": "Route Groups are a folder convention that let you organize routes by category or team. Convention A route group can be created by wrapping a folder's name in parenthesis: (folderName). This convention...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/03-file-conventions/route-groups"
  },
  {
    "id": "01-app-03-api-reference-03-file-conventions-route-segment-config",
    "path": "01-app\\03-api-reference\\03-file-conventions\\route-segment-config.mdx",
    "title": "Route Segment Config",
    "description": "Learn about how to configure options for Next.js route segments.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Options",
        "slug": "options"
      },
      {
        "level": 4,
        "text": "Revalidation Frequency",
        "slug": "revalidation-frequency"
      },
      {
        "level": 4,
        "text": "Cross-route segment behavior",
        "slug": "cross-route-segment-behavior"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "export const dynamic = 'auto'\r\n// 'auto' | 'force-dynamic' | 'error' | 'force-static'",
        "context": "filename=\"layout.tsx | page.tsx | route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export const dynamic = 'auto'\r\n// 'auto' | 'force-dynamic' | 'error' | 'force-static'",
        "context": "filename=\"layout.js | page.js | route.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export const dynamicParams = true // true | false",
        "context": "filename=\"layout.tsx | page.tsx\" switcher"
      },
      {
        "language": "js",
        "code": "export const dynamicParams = true // true | false",
        "context": "filename=\"layout.js | page.js | route.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export const revalidate = false\r\n// false | 0 | number",
        "context": "filename=\"layout.tsx | page.tsx | route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export const revalidate = false\r\n// false | 0 | number",
        "context": "filename=\"layout.js | page.js | route.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export const fetchCache = 'auto'\r\n// 'auto' | 'default-cache' | 'only-cache'\r\n// 'force-cache' | 'force-no-store' | 'default-no-store' | 'only-no-store'",
        "context": "filename=\"layout.tsx | page.tsx | route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export const fetchCache = 'auto'\r\n// 'auto' | 'default-cache' | 'only-cache'\r\n// 'force-cache' | 'force-no-store' | 'default-no-store' | 'only-no-store'",
        "context": "filename=\"layout.js | page.js | route.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export const runtime = 'nodejs'\r\n// 'nodejs' | 'edge'",
        "context": "filename=\"layout.tsx | page.tsx | route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export const runtime = 'nodejs'\r\n// 'nodejs' | 'edge'",
        "context": "filename=\"layout.js | page.js | route.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export const preferredRegion = 'auto'\r\n// 'auto' | 'global' | 'home' | ['iad1', 'sfo1']",
        "context": "filename=\"layout.tsx | page.tsx | route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export const preferredRegion = 'auto'\r\n// 'auto' | 'global' | 'home' | ['iad1', 'sfo1']",
        "context": "filename=\"layout.js | page.js | route.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export const maxDuration = 5",
        "context": "filename=\"layout.tsx | page.tsx | route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export const maxDuration = 5",
        "context": "filename=\"layout.js | page.js | route.js\" switcher"
      }
    ],
    "content": "> Good to know: > > - The options outlined on this page are disabled if the cacheComponents flag is on, and will eventually be deprecated in the future. > - Route Segment options only take effect in Server Component Pages, Layouts, or Route Handlers. > - generateStaticParams cannot be used inside a 'use client' file. The Route Segment options allows you to configure the behavior of a Page, Layout, or Route Handler by directly exporting the following variables: | Option | Type | Default | | ------------------------------------- | ------------------------------------------------------------------------------------------------------------------------- | -------------------------- | | dynamic | 'auto' \\| 'force-dynamic' \\| 'error' \\| 'force-static' | 'auto' | | dynamicParams | boolean | true | | revalidate | false \\| 0 \\| number | false | | fetchCache | 'auto' \\| 'default-cache' \\| 'only-cache' \\| 'force-cache' \\| 'force-no-store' \\| 'default-no-store' \\| 'only-no-store' | 'auto' | | runtime | 'nodejs' \\| 'edge' | 'nodejs' | | preferredRegion | 'auto' \\| 'global' \\| 'home' \\| string \\| string[] | 'auto' | | maxDuration | number | Set by deployment platform | Options dynamic Change the dynamic behavior of a layout or page to fully static or fully dynamic. > Good to know: The new model in the app directory favors granular caching control at the fetch request level over the binary all-or-nothing model of getServerSideProps and getStaticProps at the page-level in the pages directory. The dynamic option is a way to opt back in to the previous model as a convenience and provides a simpler migration path. - 'auto' (default): The default option to cache as much as possible without preventing any components from opting into dynamic behavior. - 'force-dynamic': Force dynamic rendering, which will result in routes being rendered for each user at request time. This option is equivalent to: - Setting the option of every fetch() request in a layout or page to { cache: 'no-store', next: { revalidate: 0 } }. - Setting the segment config to export const fetchCache = 'force-no-store' - 'error': Force static rendering and cache the data of a layout or page by causing an error if any components use Dynamic APIs or uncached data. This option is equivalent to: - getStaticProps() in the pages directory. - Setting the option of every fetch() request in a layout or page to { cache: 'force-cache' }. - Setting the segment config to fetchCache = 'only-cache'. - 'force-static': Force static rendering and cache the data of a layout or page by forcing cookies, headers() and useSearchParams() to return empty values. It is possible to revalidate, revalidatePath, or revalidateTag, in pages or layouts rendered with force-static. > Good to know: > > - Instructions on how to migrate from getServerSideProps and getStaticProps to dynamic: 'force-dynamic' and dynamic: 'error' can be found in the upgrade guide. dynamicParams Control what happens when a dynamic segment is visited that was not generated with generateStaticParams. - true (default): Dynamic segments not included in generateStaticParams are generated on demand. - false: Dynamic segments not included in generateStaticParams will return a 404. > Good to know: > > - This option replaces the fallback: true | false | blocking option of getStaticPaths in the pages directory. > - To statically render all paths the first time they're visited, you'll need to return an empty array in generateStaticParams or utilize export const dynamic = 'force-static'. > - When dynamicParams = true, the segment uses Streaming Server Rendering. revalidate Set the default revalidation time for a layout or page. This option does not override the revalidate value set by individual fetch requests. - false (default): The default heuristic to cache any fetch requests that set their cache option to 'force-cache' or are discovered before a Dynamic API is used. Semantically equivalent to revalidate: Infinity which effectively means the resource should be cached indefinitely. It is still possible for individual fetch requests to use cache: 'no-store' or revalidate: 0 to avoid being cached and make the route dynamically rendered. Or set revalidate to a positive number lower than the route default to increase the revalidation frequency of a route. - 0: Ensure a layout or page is always dynamically rendered even if no Dynamic APIs or uncached data fetches are discovered. This option changes the default of fetch requests that do not set a cache option to 'no-store' but leaves fetch requests that opt into 'force-cache' or use a positive revalidate as is. - number: (in seconds) Set the default revalidation frequency of a layout or page to n seconds. > Good to know: > > - The revalidate value needs to be statically analyzable. For example revalidate = 600 is valid, but revalidate = 60 10 is not. > - The revalidate value is not available when using runtime = 'edge'. > - In Development, Pages are always rendered on-demand and are never cached. This allows you to see changes immediately without waiting for a revalidation period to pass. Revalidation Frequency - The lowest revalidate across each layout and page of a single route will determine the revalidation frequency of the entire route. This ensures that child pages are revalidated as frequently as their parent layouts. - Individual fetch requests can set a lower revalidate than the route's default revalidate to increase the revalidation frequency of the entire route. This allows you to dynamically opt-in to more frequent revalidation for certain routes based on some criteria. fetchCache This is an advanced option that should only be used if you specifically need to override the default behavior. By default, Next.js will cache any fetch() requests that are reachable before any Dynamic APIs are used and will not cache fetch requests that are discovered after Dynamic APIs are used. fetchCache allows you to override the default cache option of all fetch requests in a layout or page. - 'auto' (default): The default option to cache fetch requests before Dynamic APIs with the cache option they provide and not cache fetch requests after Dynamic APIs. - 'default-cache': Allow any cache option to be passed to fetch but if no option is provided then set the cache option to 'force-cache'. This means that even fetch requests after Dynamic APIs are considered static. - 'only-cache': Ensure all fetch requests opt into caching by changing the default to cache: 'force-cache' if no option is provided and causing an error if any fetch requests use cache: 'no-store'. - 'force-cache': Ensure all fetch requests opt into caching by setting the cache option of all fetch requests to 'force-cache'. - 'default-no-store': Allow any cache option to be passed to fetch but if no option is provided then set the cache option to 'no-store'. This means that even fetch requests before Dynamic APIs are considered dynamic. - 'only-no-store': Ensure all fetch requests opt out of caching by changing the default to cache: 'no-store' if no option is provided and causing an error if any fetch requests use cache: 'force-cache' - 'force-no-store': Ensure all fetch requests opt out of caching by setting the cache option of all fetch requests to 'no-store'. This forces all fetch requests to be re-fetched every request even if they provide a 'force-cache' option. Cross-route segment behavior - Any options set across each layout and page of a single route need to be compatible with each other. - If both the 'only-cache' and 'force-cache' are provided, then 'force-cache' wins. If both 'only-no-store' and 'force-no-store' are provided, then 'force-no-store' wins. The force option changes the behavior across the route so a single segment with 'force-' would prevent any errors caused by 'only-'. - The intention of the 'only-' and 'force-' options is to guarantee the whole route is either fully static or fully dynamic. This means: - A combination of 'only-cache' and 'only-no-store' in a single route is not allowed. - A combination of 'force-cache' and 'force-no-store' in a single route is not allowed. - A parent cannot provide 'default-no-store' if a child provides 'auto' or '-cache' since that could make the same fetch have different behavior. - It is generally recommended to leave shared parent layouts as 'auto' and customize the options where child segments diverge. runtime We recommend using the Node.js runtime for rendering your application. This option cannot be used in Proxy. > Good to know: Using runtime: 'edge' is not supported for Cache Components. - 'nodejs' (default) - 'edge' preferredRegion Support for preferredRegion, and regions supported, is dependent on your deployment platform. > Good to know: > > - If a preferredRegion is not specified, it will inherit the option of the nearest parent layout. > - The root layout defaults to all regions. maxDuration By default, Next.js does not limit the execution of server-side logic (rendering a page or handling an API). Deployment platforms can use maxDuration from the Next.js build output to add specific execution limits. Note: This setting requires Next.js 13.4.10 or higher. > Good to know: > > - If using Server Actions, set the maxDuration at the page level to change the default timeout of all Server Actions used on the page. generateStaticParams The generateStaticParams function can be used in combination with dynamic route segments to define the list of route segment parameters that will be statically generated at build time instead of on-demand at request time. See the API reference for more details. Version History | Version | | | ------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | v16.0.0 | export const experimentalppr = true removed. A codemod is available. | | v15.0.0-RC | export const runtime = \"experimental-edge\" deprecated. A codemod is available. |",
    "excerpt": "> Good to know: > > - The options outlined on this page are disabled if the cacheComponents flag is on, and will eventually be deprecated in the future. > - Route Segment options only take effect in S...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/03-file-conventions/route-segment-config"
  },
  {
    "id": "01-app-03-api-reference-03-file-conventions-route",
    "path": "01-app\\03-api-reference\\03-file-conventions\\route.mdx",
    "title": "route.js",
    "description": "API reference for the route.js special file.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Reference",
        "slug": "reference"
      },
      {
        "level": 3,
        "text": "HTTP Methods",
        "slug": "http-methods"
      },
      {
        "level": 3,
        "text": "Parameters",
        "slug": "parameters"
      },
      {
        "level": 4,
        "text": " (optional)",
        "slug": "-optional"
      },
      {
        "level": 4,
        "text": " (optional)",
        "slug": "-optional"
      },
      {
        "level": 3,
        "text": "Route Context Helper",
        "slug": "route-context-helper"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Cookies",
        "slug": "cookies"
      },
      {
        "level": 3,
        "text": "Headers",
        "slug": "headers"
      },
      {
        "level": 3,
        "text": "Revalidating Cached Data",
        "slug": "revalidating-cached-data"
      },
      {
        "level": 3,
        "text": "Redirects",
        "slug": "redirects"
      },
      {
        "level": 3,
        "text": "Dynamic Route Segments",
        "slug": "dynamic-route-segments"
      },
      {
        "level": 3,
        "text": "URL Query Parameters",
        "slug": "url-query-parameters"
      },
      {
        "level": 3,
        "text": "Streaming",
        "slug": "streaming"
      },
      {
        "level": 3,
        "text": "Request Body",
        "slug": "request-body"
      },
      {
        "level": 3,
        "text": "Request Body FormData",
        "slug": "request-body-formdata"
      },
      {
        "level": 3,
        "text": "CORS",
        "slug": "cors"
      },
      {
        "level": 3,
        "text": "Webhooks",
        "slug": "webhooks"
      },
      {
        "level": 3,
        "text": "Non-UI Responses",
        "slug": "non-ui-responses"
      },
      {
        "level": 3,
        "text": "Segment Config Options",
        "slug": "segment-config-options"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "export async function GET() {\r\n  return Response.json({ message: 'Hello World' })\r\n}",
        "context": "filename=\"route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export async function GET() {\r\n  return Response.json({ message: 'Hello World' })\r\n}",
        "context": "filename=\"route.js\" switcher"
      },
      {
        "language": "ts",
        "code": "export async function GET(request: Request) {}\r\n\r\nexport async function HEAD(request: Request) {}\r\n\r\nexport async function POST(request: Request) {}\r\n\r\nexport async function PUT(request: Request) {}\r\n\r\nexport async function DELETE(request: Request) {}\r\n\r\nexport async function PATCH(request: Request) {}\r\n\r\n// If `OPTIONS` is not defined, Next.js will automatically implement `OPTIONS` and set the appropriate Response `Allow` header depending on the other methods defined in the Route Handler.\r\nexport async function OPTIONS(request: Request) {}",
        "context": "filename=\"route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export async function GET(request) {}\r\n\r\nexport async function HEAD(request) {}\r\n\r\nexport async function POST(request) {}\r\n\r\nexport async function PUT(request) {}\r\n\r\nexport async function DELETE(request) {}\r\n\r\nexport async function PATCH(request) {}\r\n\r\n// If `OPTIONS` is not defined, Next.js will automatically implement `OPTIONS` and set the appropriate Response `Allow` header depending on the other methods defined in the Route Handler.\r\nexport async function OPTIONS(request) {}",
        "context": "filename=\"route.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import type { NextRequest } from 'next/server'\r\n\r\nexport async function GET(request: NextRequest) {\r\n  const url = request.nextUrl\r\n}",
        "context": "filename=\"route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export async function GET(request) {\r\n  const url = request.nextUrl\r\n}",
        "context": "filename=\"route.js\" switcher"
      },
      {
        "language": "ts",
        "code": "export async function GET(\r\n  request: Request,\r\n  { params }: { params: Promise<{ team: string }> }\r\n) {\r\n  const { team } = await params\r\n}",
        "context": "filename=\"app/dashboard/[team]/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export async function GET(request, { params }) {\r\n  const { team } = await params\r\n}",
        "context": "filename=\"app/dashboard/[team]/route.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import type { NextRequest } from 'next/server'\r\n\r\nexport async function GET(_req: NextRequest, ctx: RouteContext<'/users/[id]'>) {\r\n  const { id } = await ctx.params\r\n  return Response.json({ id })\r\n}",
        "context": "filename=\"app/users/[id]/route.ts\""
      },
      {
        "language": "ts",
        "code": "import { cookies } from 'next/headers'\r\n\r\nexport async function GET(request: NextRequest) {\r\n  const cookieStore = await cookies()\r\n\r\n  const a = cookieStore.get('a')\r\n  const b = cookieStore.set('b', '1')\r\n  const c = cookieStore.delete('c')\r\n}",
        "context": "filename=\"route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { cookies } from 'next/headers'\r\n\r\nexport async function GET(request) {\r\n  const cookieStore = await cookies()\r\n\r\n  const a = cookieStore.get('a')\r\n  const b = cookieStore.set('b', '1')\r\n  const c = cookieStore.delete('c')\r\n}",
        "context": "filename=\"route.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { cookies } from 'next/headers'\r\n\r\nexport async function GET(request: Request) {\r\n  const cookieStore = await cookies()\r\n  const token = cookieStore.get('token')\r\n\r\n  return new Response('Hello, Next.js!', {\r\n    status: 200,\r\n    headers: { 'Set-Cookie': `token=${token.value}` },\r\n  })\r\n}",
        "context": "filename=\"app/api/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { cookies } from 'next/headers'\r\n\r\nexport async function GET(request) {\r\n  const cookieStore = await cookies()\r\n  const token = cookieStore.get('token')\r\n\r\n  return new Response('Hello, Next.js!', {\r\n    status: 200,\r\n    headers: { 'Set-Cookie': `token=${token.value}` },\r\n  })\r\n}",
        "context": "filename=\"app/api/route.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { type NextRequest } from 'next/server'\r\n\r\nexport async function GET(request: NextRequest) {\r\n  const token = request.cookies.get('token')\r\n}",
        "context": "filename=\"app/api/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export async function GET(request) {\r\n  const token = request.cookies.get('token')\r\n}",
        "context": "filename=\"app/api/route.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { headers } from 'next/headers'\r\nimport type { NextRequest } from 'next/server'\r\n\r\nexport async function GET(request: NextRequest) {\r\n  const headersList = await headers()\r\n  const referer = headersList.get('referer')\r\n}",
        "context": "filename=\"route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { headers } from 'next/headers'\r\n\r\nexport async function GET(request) {\r\n  const headersList = await headers()\r\n  const referer = headersList.get('referer')\r\n}",
        "context": "filename=\"route.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { headers } from 'next/headers'\r\n\r\nexport async function GET(request: Request) {\r\n  const headersList = await headers()\r\n  const referer = headersList.get('referer')\r\n\r\n  return new Response('Hello, Next.js!', {\r\n    status: 200,\r\n    headers: { referer: referer },\r\n  })\r\n}",
        "context": "filename=\"app/api/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { headers } from 'next/headers'\r\n\r\nexport async function GET(request) {\r\n  const headersList = await headers()\r\n  const referer = headersList.get('referer')\r\n\r\n  return new Response('Hello, Next.js!', {\r\n    status: 200,\r\n    headers: { referer: referer },\r\n  })\r\n}",
        "context": "filename=\"app/api/route.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { type NextRequest } from 'next/server'\r\n\r\nexport async function GET(request: NextRequest) {\r\n  const requestHeaders = new Headers(request.headers)\r\n}",
        "context": "filename=\"app/api/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export async function GET(request) {\r\n  const requestHeaders = new Headers(request.headers)\r\n}",
        "context": "filename=\"app/api/route.js\" switcher"
      },
      {
        "language": "ts",
        "code": "export const revalidate = 60\r\n\r\nexport async function GET() {\r\n  const data = await fetch('https://api.vercel.app/blog')\r\n  const posts = await data.json()\r\n\r\n  return Response.json(posts)\r\n}",
        "context": "filename=\"app/posts/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export const revalidate = 60\r\n\r\nexport async function GET() {\r\n  const data = await fetch('https://api.vercel.app/blog')\r\n  const posts = await data.json()\r\n\r\n  return Response.json(posts)\r\n}",
        "context": "filename=\"app/posts/route.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { redirect } from 'next/navigation'\r\n\r\nexport async function GET(request: Request) {\r\n  redirect('https://nextjs.org/')\r\n}",
        "context": "filename=\"app/api/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { redirect } from 'next/navigation'\r\n\r\nexport async function GET(request) {\r\n  redirect('https://nextjs.org/')\r\n}",
        "context": "filename=\"app/api/route.js\" switcher"
      },
      {
        "language": "ts",
        "code": "export async function GET(\r\n  request: Request,\r\n  { params }: { params: Promise<{ slug: string }> }\r\n) {\r\n  const { slug } = await params // 'a', 'b', or 'c'\r\n}",
        "context": "filename=\"app/items/[slug]/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export async function GET(request, { params }) {\r\n  const { slug } = await params // 'a', 'b', or 'c'\r\n}",
        "context": "filename=\"app/items/[slug]/route.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { type NextRequest } from 'next/server'\r\n\r\nexport function GET(request: NextRequest) {\r\n  const searchParams = request.nextUrl.searchParams\r\n  const query = searchParams.get('query')\r\n  // query is \"hello\" for /api/search?query=hello\r\n}",
        "context": "filename=\"app/api/search/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export function GET(request) {\r\n  const searchParams = request.nextUrl.searchParams\r\n  const query = searchParams.get('query')\r\n  // query is \"hello\" for /api/search?query=hello\r\n}",
        "context": "filename=\"app/api/search/route.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { openai } from '@ai-sdk/openai'\r\nimport { StreamingTextResponse, streamText } from 'ai'\r\n\r\nexport async function POST(req: Request) {\r\n  const { messages } = await req.json()\r\n  const result = await streamText({\r\n    model: openai('gpt-4-turbo'),\r\n    messages,\r\n  })\r\n\r\n  return new StreamingTextResponse(result.toAIStream())\r\n}",
        "context": "filename=\"app/api/chat/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { openai } from '@ai-sdk/openai'\r\nimport { StreamingTextResponse, streamText } from 'ai'\r\n\r\nexport async function POST(req) {\r\n  const { messages } = await req.json()\r\n  const result = await streamText({\r\n    model: openai('gpt-4-turbo'),\r\n    messages,\r\n  })\r\n\r\n  return new StreamingTextResponse(result.toAIStream())\r\n}",
        "context": "filename=\"app/api/chat/route.js\" switcher"
      },
      {
        "language": "ts",
        "code": "// https://developer.mozilla.org/docs/Web/API/ReadableStream#convert_async_iterator_to_stream\r\nfunction iteratorToStream(iterator: any) {\r\n  return new ReadableStream({\r\n    async pull(controller) {\r\n      const { value, done } = await iterator.next()\r\n\r\n      if (done) {\r\n        controller.close()\r\n      } else {\r\n        controller.enqueue(value)\r\n      }\r\n    },\r\n  })\r\n}\r\n\r\nfunction sleep(time: number) {\r\n  return new Promise((resolve) => {\r\n    setTimeout(resolve, time)\r\n  })\r\n}\r\n\r\nconst encoder = new TextEncoder()\r\n\r\nasync function* makeIterator() {\r\n  yield encoder.encode('<p>One</p>')\r\n  await sleep(200)\r\n  yield encoder.encode('<p>Two</p>')\r\n  await sleep(200)\r\n  yield encoder.encode('<p>Three</p>')\r\n}\r\n\r\nexport async function GET() {\r\n  const iterator = makeIterator()\r\n  const stream = iteratorToStream(iterator)\r\n\r\n  return new Response(stream)\r\n}",
        "context": "filename=\"app/api/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "// https://developer.mozilla.org/docs/Web/API/ReadableStream#convert_async_iterator_to_stream\r\nfunction iteratorToStream(iterator) {\r\n  return new ReadableStream({\r\n    async pull(controller) {\r\n      const { value, done } = await iterator.next()\r\n\r\n      if (done) {\r\n        controller.close()\r\n      } else {\r\n        controller.enqueue(value)\r\n      }\r\n    },\r\n  })\r\n}\r\n\r\nfunction sleep(time) {\r\n  return new Promise((resolve) => {\r\n    setTimeout(resolve, time)\r\n  })\r\n}\r\n\r\nconst encoder = new TextEncoder()\r\n\r\nasync function* makeIterator() {\r\n  yield encoder.encode('<p>One</p>')\r\n  await sleep(200)\r\n  yield encoder.encode('<p>Two</p>')\r\n  await sleep(200)\r\n  yield encoder.encode('<p>Three</p>')\r\n}\r\n\r\nexport async function GET() {\r\n  const iterator = makeIterator()\r\n  const stream = iteratorToStream(iterator)\r\n\r\n  return new Response(stream)\r\n}",
        "context": "filename=\"app/api/route.js\" switcher"
      },
      {
        "language": "ts",
        "code": "export async function POST(request: Request) {\r\n  const res = await request.json()\r\n  return Response.json({ res })\r\n}",
        "context": "filename=\"app/items/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export async function POST(request) {\r\n  const res = await request.json()\r\n  return Response.json({ res })\r\n}",
        "context": "filename=\"app/items/route.js\" switcher"
      },
      {
        "language": "ts",
        "code": "export async function POST(request: Request) {\r\n  const formData = await request.formData()\r\n  const name = formData.get('name')\r\n  const email = formData.get('email')\r\n  return Response.json({ name, email })\r\n}",
        "context": "filename=\"app/items/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export async function POST(request) {\r\n  const formData = await request.formData()\r\n  const name = formData.get('name')\r\n  const email = formData.get('email')\r\n  return Response.json({ name, email })\r\n}",
        "context": "filename=\"app/items/route.js\" switcher"
      },
      {
        "language": "ts",
        "code": "export async function GET(request: Request) {\r\n  return new Response('Hello, Next.js!', {\r\n    status: 200,\r\n    headers: {\r\n      'Access-Control-Allow-Origin': '*',\r\n      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\r\n      'Access-Control-Allow-Headers': 'Content-Type, Authorization',\r\n    },\r\n  })\r\n}",
        "context": "filename=\"app/api/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export async function GET(request) {\r\n  return new Response('Hello, Next.js!', {\r\n    status: 200,\r\n    headers: {\r\n      'Access-Control-Allow-Origin': '*',\r\n      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\r\n      'Access-Control-Allow-Headers': 'Content-Type, Authorization',\r\n    },\r\n  })\r\n}",
        "context": "filename=\"app/api/route.js\" switcher"
      },
      {
        "language": "ts",
        "code": "export async function POST(request: Request) {\r\n  try {\r\n    const text = await request.text()\r\n    // Process the webhook payload\r\n  } catch (error) {\r\n    return new Response(`Webhook error: ${error.message}`, {\r\n      status: 400,\r\n    })\r\n  }\r\n\r\n  return new Response('Success!', {\r\n    status: 200,\r\n  })\r\n}",
        "context": "filename=\"app/api/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export async function POST(request) {\r\n  try {\r\n    const text = await request.text()\r\n    // Process the webhook payload\r\n  } catch (error) {\r\n    return new Response(`Webhook error: ${error.message}`, {\r\n      status: 400,\r\n    })\r\n  }\r\n\r\n  return new Response('Success!', {\r\n    status: 200,\r\n  })\r\n}",
        "context": "filename=\"app/api/route.js\" switcher"
      },
      {
        "language": "ts",
        "code": "export async function GET() {\r\n  return new Response(\r\n    `<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<rss version=\"2.0\">\r\n\r\n<channel>\r\n  <title>Next.js Documentation</title>\r\n  <link>https://nextjs.org/docs</link>\r\n  <description>The React Framework for the Web</description>\r\n</channel>\r\n\r\n</rss>`,\r\n    {\r\n      headers: {\r\n        'Content-Type': 'text/xml',\r\n      },\r\n    }\r\n  )\r\n}",
        "context": "filename=\"app/rss.xml/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export async function GET() {\r\n  return new Response(`<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<rss version=\"2.0\">\r\n\r\n<channel>\r\n  <title>Next.js Documentation</title>\r\n  <link>https://nextjs.org/docs</link>\r\n  <description>The React Framework for the Web</description>\r\n</channel>\r\n\r\n</rss>`)\r\n}",
        "context": "filename=\"app/rss.xml/route.js\" switcher"
      },
      {
        "language": "ts",
        "code": "export const dynamic = 'auto'\r\nexport const dynamicParams = true\r\nexport const revalidate = false\r\nexport const fetchCache = 'auto'\r\nexport const runtime = 'nodejs'\r\nexport const preferredRegion = 'auto'",
        "context": "filename=\"app/items/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export const dynamic = 'auto'\r\nexport const dynamicParams = true\r\nexport const revalidate = false\r\nexport const fetchCache = 'auto'\r\nexport const runtime = 'nodejs'\r\nexport const preferredRegion = 'auto'",
        "context": "filename=\"app/items/route.js\" switcher"
      }
    ],
    "content": "Route Handlers allow you to create custom request handlers for a given route using the Web Request and Response APIs. Reference HTTP Methods A route file allows you to create custom request handlers for a given route. The following HTTP methods are supported: GET, POST, PUT, PATCH, DELETE, HEAD, and OPTIONS. Parameters request (optional) The request object is a NextRequest object, which is an extension of the Web Request API. NextRequest gives you further control over the incoming request, including easily accessing cookies and an extended, parsed, URL object nextUrl. context (optional) - params: a promise that resolves to an object containing the dynamic route parameters for the current route. | Example | URL | params | | -------------------------------- | -------------- | ---------------------------------- | | app/dashboard/[team]/route.js | /dashboard/1 | Promise | | app/shop/[tag]/[item]/route.js | /shop/1/2 | Promise | | app/blog/[...slug]/route.js | /blog/1/2 | Promise | Route Context Helper You can type the Route Handler context using RouteContext to get strongly typed params from a route literal. RouteContext is a globally available helper. > Good to know > > - Types are generated during next dev, next build or next typegen. > - After type generation, the RouteContext helper is globally available. It doesn't need to be imported. Examples Cookies You can read or set cookies with cookies from next/headers. Alternatively, you can return a new Response using the Set-Cookie header. You can also use the underlying Web APIs to read cookies from the request (NextRequest): Headers You can read headers with headers from next/headers. This headers instance is read-only. To set headers, you need to return a new Response with new headers. You can also use the underlying Web APIs to read headers from the request (NextRequest): Revalidating Cached Data You can revalidate cached data using the revalidate route segment config option. Redirects Dynamic Route Segments Route Handlers can use Dynamic Segments to create request handlers from dynamic data. | Route | Example URL | params | | --------------------------- | ----------- | ------------------------ | | app/items/[slug]/route.js | /items/a | Promise | | app/items/[slug]/route.js | /items/b | Promise | | app/items/[slug]/route.js | /items/c | Promise | URL Query Parameters The request object passed to the Route Handler is a NextRequest instance, which includes some additional convenience methods, such as those for more easily handling query parameters. Streaming Streaming is commonly used in combination with Large Language Models (LLMs), such as OpenAI, for AI-generated content. Learn more about the AI SDK. These abstractions use the Web APIs to create a stream. You can also use the underlying Web APIs directly. Request Body You can read the Request body using the standard Web API methods: Request Body FormData You can read the FormData using the request.formData() function: Since formData data are all strings, you may want to use zod-form-data to validate the request and retrieve data in the format you prefer (e.g. number). CORS You can set CORS headers for a specific Route Handler using the standard Web API methods: > Good to know: > > - To add CORS headers to multiple Route Handlers, you can use Proxy or the next.config.js file. Webhooks You can use a Route Handler to receive webhooks from third-party services: Notably, unlike API Routes with the Pages Router, you do not need to use bodyParser to use any additional configuration. Non-UI Responses You can use Route Handlers to return non-UI content. Note that sitemap.xml, robots.txt, app icons, and open graph images all have built-in support. Segment Config Options Route Handlers use the same route segment configuration as pages and layouts. See the API reference for more details. Version History | Version | Changes | | ------------ | ---------------------------------------------------------------------------------------------------- | | v15.0.0-RC | context.params is now a promise. A codemod is available | | v15.0.0-RC | The default caching for GET handlers was changed from static to dynamic | | v13.2.0 | Route Handlers are introduced. |",
    "excerpt": "Route Handlers allow you to create custom request handlers for a given route using the Web Request and Response APIs. Reference HTTP Methods A route file allows you to create custom request handlers f...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/03-file-conventions/route"
  },
  {
    "id": "01-app-03-api-reference-03-file-conventions-src-folder",
    "path": "01-app\\03-api-reference\\03-file-conventions\\src-folder.mdx",
    "title": "src Folder",
    "description": "Save pages under the `src` folder as an alternative to the root `pages` directory.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "As an alternative to having the special Next.js app or pages directories in the root of your project, Next.js also supports the common pattern of placing application code under the src folder. This separates application code from project configuration files which mostly live in the root of a project, which is preferred by some individuals and teams. To use the src folder, move the app Router folder or pages Router folder to src/app or src/pages respectively. > Good to know: > > - The /public directory should remain in the root of your project. > - Config files like package.json, next.config.js and tsconfig.json should remain in the root of your project. > - .env. files should remain in the root of your project. > - src/app or src/pages will be ignored if app or pages are present in the root directory. > - If you're using src, you'll probably also move other application folders such as /components or /lib. > - If you're using Proxy, ensure it is placed inside the src folder. > - If you're using Tailwind CSS, you'll need to add the /src prefix to the tailwind.config.js file in the content section. > - If you are using TypeScript paths for imports such as @/, you should update the paths object in tsconfig.json to include src/.",
    "excerpt": "As an alternative to having the special Next.js app or pages directories in the root of your project, Next.js also supports the common pattern of placing application code under the src folder. This se...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/03-file-conventions/src-folder"
  },
  {
    "id": "01-app-03-api-reference-03-file-conventions-template",
    "path": "01-app\\03-api-reference\\03-file-conventions\\template.mdx",
    "title": "template.js",
    "description": "API Reference for the template.js file.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Convention",
        "slug": "convention"
      },
      {
        "level": 2,
        "text": "Props",
        "slug": "props"
      },
      {
        "level": 3,
        "text": " (required)",
        "slug": "-required"
      },
      {
        "level": 2,
        "text": "Behavior",
        "slug": "behavior"
      },
      {
        "level": 3,
        "text": "Templates during navigation and remounting",
        "slug": "templates-during-navigation-and-remounting"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "export default function Template({ children }: { children: React.ReactNode }) {\r\n  return <div>{children}</div>\r\n}",
        "context": "filename=\"app/template.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function Template({ children }) {\r\n  return <div>{children}</div>\r\n}",
        "context": "filename=\"app/template.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "<Layout>\r\n  {/* Note that the template is given a unique key. */}\r\n  <Template key={routeParam}>{children}</Template>\r\n</Layout>",
        "context": "filename=\"Output\""
      },
      {
        "language": "jsx",
        "code": "<Layout>\r\n  {/* Note that the template is automatically given a unique key. */}\r\n  <Template key={routeParam}>{children}</Template>\r\n</Layout>",
        "context": "filename=\"Output\""
      },
      {
        "language": "text",
        "code": "app\r\n├── about\r\n│   ├── page.tsx\r\n├── blog\r\n│   ├── [slug]\r\n│   │   └── page.tsx\r\n│   ├── page.tsx\r\n│   └── template.tsx\r\n├── layout.tsx\r\n├── page.tsx\r\n└── template.tsx",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "<RootLayout>\r\n  {/* app/template.tsx */}\r\n  <Template key=\"/\">\r\n    <Page />\r\n  </Template>\r\n</RootLayout>",
        "context": "filename=\"Output\""
      },
      {
        "language": "jsx",
        "code": "<RootLayout>\r\n  {/* app/template.tsx */}\r\n  <Template key=\"/about\">\r\n    <AboutPage />\r\n  </Template>\r\n</RootLayout>",
        "context": "filename=\"Output\""
      },
      {
        "language": "jsx",
        "code": "<RootLayout>\r\n  {/* app/template.tsx (root) */}\r\n  <Template key=\"/blog\">\r\n    {/* app/blog/template.tsx */}\r\n    <Template key=\"/blog\">\r\n      <BlogIndexPage />\r\n    </Template>\r\n  </Template>\r\n</RootLayout>",
        "context": "filename=\"Output\""
      },
      {
        "language": "jsx",
        "code": "<RootLayout>\r\n  {/* app/template.tsx (root) */}\r\n  <Template key=\"/blog\">\r\n    {/* app/blog/template.tsx */}\r\n    {/* remounts because the child segment at this level changed */}\r\n    <Template key=\"/blog/first-post\">\r\n      <BlogPostPage slug=\"first-post\" />\r\n    </Template>\r\n  </Template>\r\n</RootLayout>",
        "context": "filename=\"Output\""
      },
      {
        "language": "jsx",
        "code": "<RootLayout>\r\n  {/* app/template.tsx (root) */}\r\n  <Template key=\"/blog\">\r\n    {/* app/blog/template.tsx */}\r\n    {/* remounts again due to changed child segment */}\r\n    <Template key=\"/blog/second-post\">\r\n      <BlogPostPage slug=\"second-post\" />\r\n    </Template>\r\n  </Template>\r\n</RootLayout>",
        "context": "filename=\"Output\""
      }
    ],
    "content": "A template file is similar to a layout in that it wraps a layout or page. Unlike layouts that persist across routes and maintain state, templates are given a unique key, meaning children Client Components reset their state on navigation. They are useful when you need to: - Resynchronize useEffect on navigation. - Reset the state of a child Client Components on navigation. For example, an input field. - To change default framework behavior. For example, Suspense boundaries inside layouts only show a fallback on first load, while templates show it on every navigation. Convention A template can be defined by exporting a default React component from a template.js file. The component should accept a children prop. In terms of nesting, template.js is rendered between a layout and its children. Here's a simplified output: Props children (required) Template accepts a children prop. Behavior - Server Components: By default, templates are Server Components. - With navigation: Templates receive a unique key for their own segment level. They remount when that segment (including its dynamic params) changes. Navigations within deeper segments do not remount higher-level templates. Search params do not trigger remounts. - State reset: Any Client Component inside the template will reset its state on navigation. - Effect re-run: Effects like useEffect will re-synchronize as the component remounts. - DOM reset: DOM elements inside the template are fully recreated. Templates during navigation and remounting This section illustrates how templates behave during navigation. It shows, step by step, which templates remount on each route change and why. Using this project tree: Starting at /, the React tree looks roughly like this. > Note: The key values shown in the examples are illustrative, the values in your application may differ. Navigating to /about (first segment changes), the root template key changes, it remounts: Navigating to /blog (first segment changes), the root template key changes, it remounts and the blog-level template mounts: Navigating within the same first segment to /blog/first-post (child segment changes), the root template key doesn't change, but the blog-level template key changes, it remounts: Navigating to /blog/second-post (same first segment, different child segment), the root template key doesn't change, but the blog-level template key changes, it remounts again: Version History | Version | Changes | | --------- | ---------------------- | | v13.0.0 | template introduced. |",
    "excerpt": "A template file is similar to a layout in that it wraps a layout or page. Unlike layouts that persist across routes and maintain state, templates are given a unique key, meaning children Client Compon...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/03-file-conventions/template"
  },
  {
    "id": "01-app-03-api-reference-03-file-conventions-unauthorized",
    "path": "01-app\\03-api-reference\\03-file-conventions\\unauthorized.mdx",
    "title": "unauthorized.js",
    "description": "API reference for the unauthorized.js special file.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Reference",
        "slug": "reference"
      },
      {
        "level": 3,
        "text": "Props",
        "slug": "props"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Displaying login UI to unauthenticated users",
        "slug": "displaying-login-ui-to-unauthenticated-users"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "import Login from '@/app/components/Login'\r\n\r\nexport default function Unauthorized() {\r\n  return (\r\n    <main>\r\n      <h1>401 - Unauthorized</h1>\r\n      <p>Please log in to access this page.</p>\r\n      <Login />\r\n    </main>\r\n  )\r\n}",
        "context": "filename=\"app/unauthorized.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Login from '@/app/components/Login'\r\n\r\nexport default function Unauthorized() {\r\n  return (\r\n    <main>\r\n      <h1>401 - Unauthorized</h1>\r\n      <p>Please log in to access this page.</p>\r\n      <Login />\r\n    </main>\r\n  )\r\n}",
        "context": "filename=\"app/unauthorized.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { verifySession } from '@/app/lib/dal'\r\nimport { unauthorized } from 'next/navigation'\r\n\r\nexport default async function DashboardPage() {\r\n  const session = await verifySession()\r\n\r\n  if (!session) {\r\n    unauthorized()\r\n  }\r\n\r\n  return <div>Dashboard</div>\r\n}",
        "context": "filename=\"app/dashboard/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { verifySession } from '@/app/lib/dal'\r\nimport { unauthorized } from 'next/navigation'\r\n\r\nexport default async function DashboardPage() {\r\n  const session = await verifySession()\r\n\r\n  if (!session) {\r\n    unauthorized()\r\n  }\r\n\r\n  return <div>Dashboard</div>\r\n}",
        "context": "filename=\"app/dashboard/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Login from '@/app/components/Login'\r\n\r\nexport default function UnauthorizedPage() {\r\n  return (\r\n    <main>\r\n      <h1>401 - Unauthorized</h1>\r\n      <p>Please log in to access this page.</p>\r\n      <Login />\r\n    </main>\r\n  )\r\n}",
        "context": "filename=\"app/unauthorized.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Login from '@/app/components/Login'\r\n\r\nexport default function UnauthorizedPage() {\r\n  return (\r\n    <main>\r\n      <h1>401 - Unauthorized</h1>\r\n      <p>Please log in to access this page.</p>\r\n      <Login />\r\n    </main>\r\n  )\r\n}",
        "context": "filename=\"app/unauthorized.js\" switcher"
      }
    ],
    "content": "The unauthorized file is used to render UI when the unauthorized function is invoked during authentication. Along with allowing you to customize the UI, Next.js will return a 401 status code. Reference Props unauthorized.js components do not accept any props. Examples Displaying login UI to unauthenticated users You can use unauthorized function to render the unauthorized.js file with a login UI. Version History | Version | Changes | | --------- | ----------------------------- | | v15.1.0 | unauthorized.js introduced. |",
    "excerpt": "The unauthorized file is used to render UI when the unauthorized function is invoked during authentication. Along with allowing you to customize the UI, Next.js will return a 401 status code. Referenc...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/03-file-conventions/unauthorized"
  },
  {
    "id": "01-app-03-api-reference-04-functions-after",
    "path": "01-app\\03-api-reference\\04-functions\\after.mdx",
    "title": "after",
    "description": "API Reference for the after function.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Reference",
        "slug": "reference"
      },
      {
        "level": 3,
        "text": "Parameters",
        "slug": "parameters"
      },
      {
        "level": 3,
        "text": "Duration",
        "slug": "duration"
      },
      {
        "level": 2,
        "text": "Good to know",
        "slug": "good-to-know"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "With request APIs",
        "slug": "with-request-apis"
      },
      {
        "level": 2,
        "text": "Platform Support",
        "slug": "platform-support"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "import { after } from 'next/server'\r\n// Custom logging function\r\nimport { log } from '@/app/utils'\r\n\r\nexport default function Layout({ children }: { children: React.ReactNode }) {\r\n  after(() => {\r\n    // Execute after the layout is rendered and sent to the user\r\n    log()\r\n  })\r\n  return <>{children}</>\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { after } from 'next/server'\r\n// Custom logging function\r\nimport { log } from '@/app/utils'\r\n\r\nexport default function Layout({ children }) {\r\n  after(() => {\r\n    // Execute after the layout is rendered and sent to the user\r\n    log()\r\n  })\r\n  return <>{children}</>\r\n}",
        "context": "filename=\"app/layout.jsx\" switcher"
      },
      {
        "language": "ts",
        "code": "import { after } from 'next/server'\r\nimport { cookies, headers } from 'next/headers'\r\nimport { logUserAction } from '@/app/utils'\r\n\r\nexport async function POST(request: Request) {\r\n  // Perform mutation\r\n  // ...\r\n\r\n  // Log user activity for analytics\r\n  after(async () => {\r\n    const userAgent = (await headers().get('user-agent')) || 'unknown'\r\n    const sessionCookie =\r\n      (await cookies().get('session-id'))?.value || 'anonymous'\r\n\r\n    logUserAction({ sessionCookie, userAgent })\r\n  })\r\n\r\n  return new Response(JSON.stringify({ status: 'success' }), {\r\n    status: 200,\r\n    headers: { 'Content-Type': 'application/json' },\r\n  })\r\n}",
        "context": "filename=\"app/api/route.ts\" highlight={2,7-9} switcher"
      },
      {
        "language": "js",
        "code": "import { after } from 'next/server'\r\nimport { cookies, headers } from 'next/headers'\r\nimport { logUserAction } from '@/app/utils'\r\n\r\nexport async function POST(request) {\r\n  // Perform mutation\r\n  // ...\r\n\r\n  // Log user activity for analytics\r\n  after(async () => {\r\n    const userAgent = (await headers().get('user-agent')) || 'unknown'\r\n    const sessionCookie =\r\n      (await cookies().get('session-id'))?.value || 'anonymous'\r\n\r\n    logUserAction({ sessionCookie, userAgent })\r\n  })\r\n\r\n  return new Response(JSON.stringify({ status: 'success' }), {\r\n    status: 200,\r\n    headers: { 'Content-Type': 'application/json' },\r\n  })\r\n}",
        "context": "filename=\"app/api/route.js\" highlight={2,7-9} switcher"
      },
      {
        "language": "jsx",
        "code": "const RequestContext = globalThis[Symbol.for('@next/request-context')]\r\nconst contextValue = RequestContext?.get()\r\nconst waitUntil = contextValue?.waitUntil",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "type NextRequestContext = {\r\n  get(): NextRequestContextValue | undefined\r\n}\r\n\r\ntype NextRequestContextValue = {\r\n  waitUntil?: (promise: Promise<any>) => void\r\n}",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "import { AsyncLocalStorage } from 'node:async_hooks'\r\n\r\nconst RequestContextStorage = new AsyncLocalStorage<NextRequestContextValue>()\r\n\r\n// Define and inject the accessor that next.js will use\r\nconst RequestContext: NextRequestContext = {\r\n  get() {\r\n    return RequestContextStorage.getStore()\r\n  },\r\n}\r\nglobalThis[Symbol.for('@next/request-context')] = RequestContext\r\n\r\nconst handler = (req, res) => {\r\n  const contextValue = { waitUntil: YOUR_WAITUNTIL }\r\n  // Provide the value\r\n  return RequestContextStorage.run(contextValue, () => nextJsHandler(req, res))\r\n}",
        "context": ""
      }
    ],
    "content": "after allows you to schedule work to be executed after a response (or prerender) is finished. This is useful for tasks and other side effects that should not block the response, such as logging and analytics. It can be used in Server Components (including generateMetadata), Server Actions, Route Handlers, and Proxy. The function accepts a callback that will be executed after the response (or prerender) is finished: > Good to know: after is not a Dynamic API and calling it does not cause a route to become dynamic. If it's used within a static page, the callback will execute at build time, or whenever a page is revalidated. Reference Parameters - A callback function which will be executed after the response (or prerender) is finished. Duration after will run for the platform's default or configured max duration of your route. If your platform supports it, you can configure the timeout limit using the maxDuration route segment config. Good to know - after will be executed even if the response didn't complete successfully. Including when an error is thrown or when notFound or redirect is called. - You can use React cache to deduplicate functions called inside after. - after can be nested inside other after calls, for example, you can create utility functions that wrap after calls to add additional functionality. Examples With request APIs You can use request APIs such as cookies and headers inside after in Server Actions and Route Handlers. This is useful for logging activity after a mutation. For example: However, you cannot use these request APIs inside after in Server Components. This is because Next.js needs to know which part of the tree access the request APIs to support Cache Components, but after runs after React's rendering lifecycle. Platform Support | Deployment Option | Supported | | ------------------------------------------------------------------- | ----------------- | | Node.js server | Yes | | Docker container | Yes | | Static export | No | | Adapters | Platform-specific | Learn how to configure after when self-hosting Next.js. Reference: supporting after for serverless platforms Using after in a serverless context requires waiting for asynchronous tasks to finish after the response has been sent. In Next.js and Vercel, this is achieved using a primitive called waitUntil(promise), which extends the lifetime of a serverless invocation until all promises passed to waitUntil have settled. If you want your users to be able to run after, you will have to provide your implementation of waitUntil that behaves in an analogous way. When after is called, Next.js will access waitUntil like this: Which means that globalThis[Symbol.for('@next/request-context')] is expected to contain an object like this: Here is an example of the implementation. Version History | Version History | Description | | --------------- | ---------------------------- | | v15.1.0 | after became stable. | | v15.0.0-rc | unstableafter introduced. |",
    "excerpt": "after allows you to schedule work to be executed after a response (or prerender) is finished. This is useful for tasks and other side effects that should not block the response, such as logging and an...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/04-functions/after"
  },
  {
    "id": "01-app-03-api-reference-04-functions-cacheLife",
    "path": "01-app\\03-api-reference\\04-functions\\cacheLife.mdx",
    "title": "cacheLife",
    "description": "Learn how to use the cacheLife function to set the cache expiration time for a cached function or component.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Usage",
        "slug": "usage"
      },
      {
        "level": 3,
        "text": "Basic setup",
        "slug": "basic-setup"
      },
      {
        "level": 3,
        "text": "Using preset profiles",
        "slug": "using-preset-profiles"
      },
      {
        "level": 2,
        "text": "Reference",
        "slug": "reference"
      },
      {
        "level": 3,
        "text": "Cache profile properties",
        "slug": "cache-profile-properties"
      },
      {
        "level": 3,
        "text": "Preset cache profiles",
        "slug": "preset-cache-profiles"
      },
      {
        "level": 3,
        "text": "Custom cache profiles",
        "slug": "custom-cache-profiles"
      },
      {
        "level": 3,
        "text": "Overriding the default cache profiles",
        "slug": "overriding-the-default-cache-profiles"
      },
      {
        "level": 3,
        "text": "Inline cache profiles",
        "slug": "inline-cache-profiles"
      },
      {
        "level": 3,
        "text": "Client router cache behavior",
        "slug": "client-router-cache-behavior"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Using preset profiles",
        "slug": "using-preset-profiles"
      },
      {
        "level": 3,
        "text": "Custom profiles for specific needs",
        "slug": "custom-profiles-for-specific-needs"
      },
      {
        "level": 3,
        "text": "Inline profiles for unique cases",
        "slug": "inline-profiles-for-unique-cases"
      },
      {
        "level": 3,
        "text": "Caching individual functions",
        "slug": "caching-individual-functions"
      },
      {
        "level": 3,
        "text": "Nested caching behavior",
        "slug": "nested-caching-behavior"
      }
    ],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  cacheComponents: true,\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "const nextConfig = {\r\n  cacheComponents: true,\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use cache'\r\nimport { cacheLife } from 'next/cache'\r\n\r\nexport default async function BlogPage() {\r\n  cacheLife('days') // Blog content updated daily\r\n\r\n  const posts = await getBlogPosts()\r\n  return <div>{/* render posts */}</div>\r\n}",
        "context": "filename=\"app/blog/page.tsx\" highlight={1,5}"
      },
      {
        "language": "tsx",
        "code": "cacheLife({ stale: 300 }) // 5 minutes",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "cacheLife({ revalidate: 900 }) // 15 minutes",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "cacheLife({ expire: 3600 }) // 1 hour",
        "context": ""
      },
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  cacheComponents: true,\r\n  cacheLife: {\r\n    biweekly: {\r\n      stale: 60 * 60 * 24 * 14, // 14 days\r\n      revalidate: 60 * 60 * 24, // 1 day\r\n      expire: 60 * 60 * 24 * 14, // 14 days\r\n    },\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\""
      },
      {
        "language": "js",
        "code": "const nextConfig = {\r\n  cacheComponents: true,\r\n  cacheLife: {\r\n    biweekly: {\r\n      stale: 60 * 60 * 24 * 14, // 14 days\r\n      revalidate: 60 * 60 * 24, // 1 day\r\n      expire: 60 * 60 * 24 * 14, // 14 days\r\n    },\r\n  },\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use cache'\r\nimport { cacheLife } from 'next/cache'\r\n\r\nexport default async function Page() {\r\n  cacheLife('biweekly')\r\n  return <div>Page</div>\r\n}",
        "context": "filename=\"app/page.tsx\" highlight={5}"
      },
      {
        "language": "ts",
        "code": "const nextConfig = {\r\n  cacheComponents: true,\r\n  cacheLife: {\r\n    days: {\r\n      stale: 3600, // 1 hour\r\n      revalidate: 900, // 15 minutes\r\n      expire: 86400, // 1 day\r\n    },\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\""
      },
      {
        "language": "ts",
        "code": "const nextConfig = {\r\n  cacheComponents: true,\r\n  cacheLife: {\r\n    // Override the 'days' profile\r\n    days: {\r\n      stale: 3600, // 1 hour\r\n      revalidate: 900, // 15 minutes\r\n      expire: 86400, // 1 day\r\n    },\r\n  },\r\n}",
        "context": "filename=\"next.config.ts\""
      },
      {
        "language": "tsx",
        "code": "'use cache'\r\nimport { cacheLife } from 'next/cache'\r\n\r\nexport default async function Page() {\r\n  cacheLife({\r\n    stale: 3600,\r\n    revalidate: 900,\r\n    expire: 86400,\r\n  })\r\n\r\n  return <div>Page</div>\r\n}",
        "context": "filename=\"app/page.tsx\""
      },
      {
        "language": "tsx",
        "code": "import { cacheLife } from 'next/cache'\r\n\r\nexport default async function BlogPost() {\r\n  'use cache'\r\n  cacheLife('days') // Blog posts updated daily\r\n\r\n  const post = await fetchBlogPost()\r\n  return <article>{post.content}</article>\r\n}",
        "context": "filename=\"app/blog/[slug]/page.tsx\""
      },
      {
        "language": "tsx",
        "code": "import { cacheLife } from 'next/cache'\r\n\r\nexport default async function ProductPage() {\r\n  'use cache'\r\n  cacheLife('hours') // Product data updated multiple times per day\r\n\r\n  const product = await fetchProduct()\r\n  return <div>{product.name}</div>\r\n}",
        "context": "filename=\"app/products/[id]/page.tsx\""
      },
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  cacheComponents: true,\r\n  cacheLife: {\r\n    editorial: {\r\n      stale: 600, // 10 minutes\r\n      revalidate: 3600, // 1 hour\r\n      expire: 86400, // 1 day\r\n    },\r\n    marketing: {\r\n      stale: 300, // 5 minutes\r\n      revalidate: 1800, // 30 minutes\r\n      expire: 43200, // 12 hours\r\n    },\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\""
      },
      {
        "language": "tsx",
        "code": "import { cacheLife } from 'next/cache'\r\n\r\nexport default async function EditorialPage() {\r\n  'use cache'\r\n  cacheLife('editorial')\r\n  // ...\r\n}",
        "context": "filename=\"app/editorial/page.tsx\""
      },
      {
        "language": "tsx",
        "code": "import { cacheLife } from 'next/cache'\r\nimport { getDb } from '@lib/db'\r\n\r\nasync function getLimitedOffer() {\r\n  'use cache'\r\n\r\n  cacheLife({\r\n    stale: 60, // 1 minute\r\n    revalidate: 300, // 5 minutes\r\n    expire: 3600, // 1 hour\r\n  })\r\n\r\n  const offer = await getDb().offer.findFirst({\r\n    where: { type: 'limited' },\r\n    orderBy: { created_at: 'desc' },\r\n  })\r\n\r\n  return offer\r\n}\r\n\r\nexport async function GET() {\r\n  const offer = await getLimitedOffer()\r\n\r\n  return Response.json(offer)\r\n}",
        "context": "filename=\"app/api/limited-offer/route.ts\""
      },
      {
        "language": "tsx",
        "code": "import { cacheLife } from 'next/cache'\r\n\r\nexport async function getSettings() {\r\n  'use cache'\r\n  cacheLife('max') // Settings rarely change\r\n\r\n  return await fetchSettings()\r\n}",
        "context": "filename=\"lib/api.ts\""
      },
      {
        "language": "tsx",
        "code": "import { cacheLife } from 'next/cache'\r\n\r\nexport async function getRealtimeStats() {\r\n  'use cache'\r\n  cacheLife('seconds') // Stats update constantly\r\n\r\n  return await fetchStats()\r\n}",
        "context": "filename=\"lib/stats.ts\""
      },
      {
        "language": "tsx",
        "code": "import { cacheLife } from 'next/cache'\r\nimport { RealtimeWidget } from './realtime-widget'\r\n\r\nexport default async function Dashboard() {\r\n  'use cache'\r\n  cacheLife('hours') // Dashboard cached for hours\r\n\r\n  return (\r\n    <div>\r\n      <h1>Dashboard</h1>\r\n      <RealtimeWidget />\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/dashboard/page.tsx\""
      },
      {
        "language": "tsx",
        "code": "import { cacheLife } from 'next/cache'\r\n\r\nexport async function RealtimeWidget() {\r\n  'use cache'\r\n  cacheLife('seconds') // Widget needs fresh data\r\n\r\n  const data = await fetchRealtimeData()\r\n  return <div>{data.value}</div>\r\n}",
        "context": "filename=\"app/dashboard/realtime-widget.tsx\""
      }
    ],
    "content": "The cacheLife function is used to set the cache lifetime of a function or component. It should be used alongside the use cache directive, and within the scope of the function or component. Usage Basic setup To use cacheLife, first enable the cacheComponents flag in your next.config.js file: Using preset profiles Next.js provides preset cache profiles that cover common caching needs. Each profile balances three factors: - How long users see cached content without checking for updates (client-side) - How often fresh content is generated on the server - When old content expires completely Choose a profile based on how frequently your content changes: - seconds - Real-time data (stock prices, live scores) - minutes - Frequently updated (social feeds, news) - hours - Multiple daily updates (product inventory, weather) - days - Daily updates (blog posts, articles) - weeks - Weekly updates (podcasts, newsletters) - max - Rarely changes (legal pages, archived content) Import cacheLife and pass a profile name: The profile name tells Next.js how to cache the entire function's output. If you need more control over timing values, see the Reference section below. > Good to know: The use cache directive can be placed at the file level or at the top of a function or component, and cacheLife must be called within its scope. Reference Cache profile properties Cache profiles control caching behavior through three timing properties: - stale: How long the client can use cached data without checking the server - revalidate: After this time, the next request will trigger a background refresh - expire: After this time with no requests, the next one waits for fresh content stale Client-side: How long the client can use cached data without checking the server. During this time, the client-side router displays cached content immediately without any network request. After this period expires, the router must check with the server on the next navigation or request. This provides instant page loads from the client cache, but data may be outdated. revalidate How often the server regenerates cached content in the background. - When a request arrives after this period, the server: 1. Serves the cached version immediately (if available) 2. Regenerates content in the background 3. Updates the cache with fresh content - Similar to Incremental Static Regeneration (ISR) expire Maximum time before the server must regenerate cached content. - After this period with no traffic, the server regenerates content synchronously on the next request - When you set both revalidate and expire, expire must be longer than revalidate. Next.js validates this and raises an error for invalid configurations. Preset cache profiles If you don't specify a profile, Next.js uses the default profile. We recommend explicitly setting a profile to make caching behavior clear. | Profile | Use Case | stale | revalidate | expire | | ----------- | -------------------------------------- | ---------- | ------------ | -------- | | default | Standard content | 5 minutes | 15 minutes | 1 year | | seconds | Real-time data | 30 seconds | 1 second | 1 minute | | minutes | Frequently updated content | 5 minutes | 1 minute | 1 hour | | hours | Content updated multiple times per day | 5 minutes | 1 hour | 1 day | | days | Content updated daily | 5 minutes | 1 day | 1 week | | weeks | Content updated weekly | 5 minutes | 1 week | 30 days | | max | Stable content that rarely changes | 5 minutes | 30 days | 1 year | Custom cache profiles Define reusable cache profiles in your next.config.ts file: The example above caches for 14 days, checks for updates daily, and expires the cache after 14 days. You can then reference this profile throughout your application by its name: Overriding the default cache profiles While the default cache profiles provide a useful way to think about how fresh or stale any given part of cacheable output can be, you may prefer different named profiles to better align with your applications caching strategies. You can override the default named cache profiles by creating a new configuration with the same name as the defaults. The example below shows how to override the default \"days\" cache profile: You can also override the preset profiles by using the same name: Inline cache profiles For one-off cases, pass a profile object directly to cacheLife: Inline profiles apply only to the specific function or component. For reusable configurations, define custom profiles in next.config.ts. Using cacheLife({}) with an empty object applies the default profile values. Client router cache behavior The stale property controls the client-side router cache, not the Cache-Control header: - The server sends the stale time via the x-nextjs-stale-time response header - The client router uses this value to determine when to revalidate - Minimum of 30 seconds is enforced to ensure prefetched links remain usable This 30-second minimum prevents prefetched data from expiring before users can click on links. It only applies to time-based expiration. When you call revalidation functions from a Server Action (revalidateTag, revalidatePath, updateTag, or refresh), the entire client cache is immediately cleared, bypassing the stale time. > Good to know: The stale property in cacheLife differs from staleTimes. While staleTimes is a global setting affecting all routes, cacheLife allows per-function or per-route configuration. Updating staleTimes.static also updates the stale value of the default cache profile. Examples Using preset profiles The simplest way to configure caching is using preset profiles. Choose one that matches your content's update pattern: Custom profiles for specific needs Define custom profiles when preset options don't match your requirements: Then use these profiles throughout your application: Inline profiles for unique cases Use inline profiles when a specific function needs one-off caching behavior: Caching individual functions Apply caching to utility functions for granular control: Nested caching behavior When components with different cache profiles are nested, Next.js respects the shortest duration among them: In this example, the outer Dashboard component specifies the hours profile, but it contains RealtimeWidget which uses the seconds profile. The shortest duration from the nested profiles takes precedence, ensuring the widget gets fresh data while the rest of the dashboard can be cached longer. > Good to know: This shortest-duration behavior ensures that no part of your page serves stale data longer than its most frequently updated component requires.",
    "excerpt": "The cacheLife function is used to set the cache lifetime of a function or component. It should be used alongside the use cache directive, and within the scope of the function or component. Usage Basic...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/04-functions/cacheLife"
  },
  {
    "id": "01-app-03-api-reference-04-functions-cacheTag",
    "path": "01-app\\03-api-reference\\04-functions\\cacheTag.mdx",
    "title": "cacheTag",
    "description": "Learn how to use the cacheTag function to manage cache invalidation in your Next.js application.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Usage",
        "slug": "usage"
      },
      {
        "level": 2,
        "text": "Good to know",
        "slug": "good-to-know"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Tagging components or functions",
        "slug": "tagging-components-or-functions"
      },
      {
        "level": 3,
        "text": "Creating tags from external data",
        "slug": "creating-tags-from-external-data"
      },
      {
        "level": 3,
        "text": "Invalidating tagged cache",
        "slug": "invalidating-tagged-cache"
      }
    ],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  cacheComponents: true,\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "const nextConfig = {\r\n  cacheComponents: true,\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { cacheTag } from 'next/cache'\r\n\r\nexport async function getData() {\r\n  'use cache'\r\n  cacheTag('my-data')\r\n  const data = await fetch('/api/data')\r\n  return data\r\n}",
        "context": "filename=\"app/data.ts\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { cacheTag } from 'next/cache'\r\n\r\nexport async function getData() {\r\n  'use cache'\r\n  cacheTag('my-data')\r\n  const data = await fetch('/api/data')\r\n  return data\r\n}",
        "context": "filename=\"app/data.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use server'\r\n\r\nimport { revalidateTag } from 'next/cache'\r\n\r\nexport default async function submit() {\r\n  await addPost()\r\n  revalidateTag('my-data')\r\n}",
        "context": "filename=\"app/action.ts\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use server'\r\n\r\nimport { revalidateTag } from 'next/cache'\r\n\r\nexport default async function submit() {\r\n  await addPost()\r\n  revalidateTag('my-data')\r\n}",
        "context": "filename=\"app/action.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "cacheTag('tag-one', 'tag-two')",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "import { cacheTag } from 'next/cache'\r\n\r\ninterface BookingsProps {\r\n  type: string\r\n}\r\n\r\nexport async function Bookings({ type = 'haircut' }: BookingsProps) {\r\n  'use cache'\r\n  cacheTag('bookings-data')\r\n\r\n  async function getBookingsData() {\r\n    const data = await fetch(`/api/bookings?type=${encodeURIComponent(type)}`)\r\n    return data\r\n  }\r\n\r\n  return //...\r\n}",
        "context": "filename=\"app/components/bookings.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { cacheTag } from 'next/cache'\r\n\r\nexport async function Bookings({ type = 'haircut' }) {\r\n  'use cache'\r\n  cacheTag('bookings-data')\r\n\r\n  async function getBookingsData() {\r\n    const data = await fetch(`/api/bookings?type=${encodeURIComponent(type)}`)\r\n    return data\r\n  }\r\n\r\n  return //...\r\n}",
        "context": "filename=\"app/components/bookings.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { cacheTag } from 'next/cache'\r\n\r\ninterface BookingsProps {\r\n  type: string\r\n}\r\n\r\nexport async function Bookings({ type = 'haircut' }: BookingsProps) {\r\n  async function getBookingsData() {\r\n    'use cache'\r\n    const data = await fetch(`/api/bookings?type=${encodeURIComponent(type)}`)\r\n    cacheTag('bookings-data', data.id)\r\n    return data\r\n  }\r\n  return //...\r\n}",
        "context": "filename=\"app/components/bookings.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { cacheTag } from 'next/cache'\r\n\r\nexport async function Bookings({ type = 'haircut' }) {\r\n  async function getBookingsData() {\r\n    'use cache'\r\n    const data = await fetch(`/api/bookings?type=${encodeURIComponent(type)}`)\r\n    cacheTag('bookings-data', data.id)\r\n    return data\r\n  }\r\n  return //...\r\n}",
        "context": "filename=\"app/components/bookings.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use server'\r\n\r\nimport { revalidateTag } from 'next/cache'\r\n\r\nexport async function updateBookings() {\r\n  await updateBookingData()\r\n  revalidateTag('bookings-data')\r\n}",
        "context": "filename=\"app/actions.ts\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use server'\r\n\r\nimport { revalidateTag } from 'next/cache'\r\n\r\nexport async function updateBookings() {\r\n  await updateBookingData()\r\n  revalidateTag('bookings-data')\r\n}",
        "context": "filename=\"app/actions.js\" switcher"
      }
    ],
    "content": "The cacheTag function allows you to tag cached data for on-demand invalidation. By associating tags with cache entries, you can selectively purge or revalidate specific cache entries without affecting other cached data. Usage To use cacheTag, enable the cacheComponents flag in your next.config.js file: The cacheTag function takes one or more string values. You can then purge the cache on-demand using revalidateTag API in another function, for example, a route handler or Server Action: Good to know - Idempotent Tags: Applying the same tag multiple times has no additional effect. - Multiple Tags: You can assign multiple tags to a single cache entry by passing multiple string values to cacheTag. - Limits: The max length for a custom tag is 256 characters and the max tag items is 128. Examples Tagging components or functions Tag your cached data by calling cacheTag within a cached function or component: Creating tags from external data You can use the data returned from an async function to tag the cache entry. Invalidating tagged cache Using revalidateTag, you can invalidate the cache for a specific tag when needed:",
    "excerpt": "The cacheTag function allows you to tag cached data for on-demand invalidation. By associating tags with cache entries, you can selectively purge or revalidate specific cache entries without affecting...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/04-functions/cacheTag"
  },
  {
    "id": "01-app-03-api-reference-04-functions-connection",
    "path": "01-app\\03-api-reference\\04-functions\\connection.mdx",
    "title": "connection",
    "description": "API Reference for the connection function.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Reference",
        "slug": "reference"
      },
      {
        "level": 3,
        "text": "Type",
        "slug": "type"
      },
      {
        "level": 3,
        "text": "Parameters",
        "slug": "parameters"
      },
      {
        "level": 3,
        "text": "Returns",
        "slug": "returns"
      },
      {
        "level": 2,
        "text": "Good to know",
        "slug": "good-to-know"
      },
      {
        "level": 3,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "import { connection } from 'next/server'\r\n\r\nexport default async function Page() {\r\n  await connection()\r\n  // Everything below will be excluded from prerendering\r\n  const rand = Math.random()\r\n  return <span>{rand}</span>\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { connection } from 'next/server'\r\n\r\nexport default async function Page() {\r\n  await connection()\r\n  // Everything below will be excluded from prerendering\r\n  const rand = Math.random()\r\n  return <span>{rand}</span>\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "function connection(): Promise<void>",
        "context": ""
      }
    ],
    "content": "The connection() function allows you to indicate rendering should wait for an incoming user request before continuing. It's useful when a component doesn't use Dynamic APIs, but you want it to be dynamically rendered at runtime and not statically rendered at build time. This usually occurs when you access external information that you intentionally want to change the result of a render, such as Math.random() or new Date(). Reference Type Parameters - The function does not accept any parameters. Returns - The function returns a void Promise. It is not meant to be consumed. Good to know - connection replaces unstablenoStore to better align with the future of Next.js. - The function is only necessary when dynamic rendering is required and common Dynamic APIs are not used. Version History | Version | Changes | | ------------ | ------------------------ | | v15.0.0 | connection stabilized. | | v15.0.0-RC | connection introduced. |",
    "excerpt": "The connection() function allows you to indicate rendering should wait for an incoming user request before continuing. It's useful when a component doesn't use Dynamic APIs, but you want it to be dyna...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/04-functions/connection"
  },
  {
    "id": "01-app-03-api-reference-04-functions-cookies",
    "path": "01-app\\03-api-reference\\04-functions\\cookies.mdx",
    "title": "cookies",
    "description": "API Reference for the cookies function.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Reference",
        "slug": "reference"
      },
      {
        "level": 3,
        "text": "Methods",
        "slug": "methods"
      },
      {
        "level": 3,
        "text": "Options",
        "slug": "options"
      },
      {
        "level": 2,
        "text": "Good to know",
        "slug": "good-to-know"
      },
      {
        "level": 2,
        "text": "Understanding Cookie Behavior in Server Components",
        "slug": "understanding-cookie-behavior-in-server-components"
      },
      {
        "level": 2,
        "text": "Understanding Cookie Behavior in Server Actions",
        "slug": "understanding-cookie-behavior-in-server-actions"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Getting a cookie",
        "slug": "getting-a-cookie"
      },
      {
        "level": 3,
        "text": "Getting all cookies",
        "slug": "getting-all-cookies"
      },
      {
        "level": 3,
        "text": "Setting a cookie",
        "slug": "setting-a-cookie"
      },
      {
        "level": 3,
        "text": "Checking if a cookie exists",
        "slug": "checking-if-a-cookie-exists"
      },
      {
        "level": 3,
        "text": "Deleting cookies",
        "slug": "deleting-cookies"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "import { cookies } from 'next/headers'\r\n\r\nexport default async function Page() {\r\n  const cookieStore = await cookies()\r\n  const theme = cookieStore.get('theme')\r\n  return '...'\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "js",
        "code": "import { cookies } from 'next/headers'\r\n\r\nexport default async function Page() {\r\n  const cookieStore = await cookies()\r\n  const theme = cookieStore.get('theme')\r\n  return '...'\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { cookies } from 'next/headers'\r\n\r\nexport default async function Page() {\r\n  const cookieStore = await cookies()\r\n  const theme = cookieStore.get('theme')\r\n  return '...'\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { cookies } from 'next/headers'\r\n\r\nexport default async function Page() {\r\n  const cookieStore = await cookies()\r\n  const theme = cookieStore.get('theme')\r\n  return '...'\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { cookies } from 'next/headers'\r\n\r\nexport default async function Page() {\r\n  const cookieStore = await cookies()\r\n  return cookieStore.getAll().map((cookie) => (\r\n    <div key={cookie.name}>\r\n      <p>Name: {cookie.name}</p>\r\n      <p>Value: {cookie.value}</p>\r\n    </div>\r\n  ))\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { cookies } from 'next/headers'\r\n\r\nexport default async function Page() {\r\n  const cookieStore = await cookies()\r\n  return cookieStore.getAll().map((cookie) => (\r\n    <div key={cookie.name}>\r\n      <p>Name: {cookie.name}</p>\r\n      <p>Value: {cookie.value}</p>\r\n    </div>\r\n  ))\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use server'\r\n\r\nimport { cookies } from 'next/headers'\r\n\r\nexport async function create(data) {\r\n  const cookieStore = await cookies()\r\n\r\n  cookieStore.set('name', 'lee')\r\n  // or\r\n  cookieStore.set('name', 'lee', { secure: true })\r\n  // or\r\n  cookieStore.set({\r\n    name: 'name',\r\n    value: 'lee',\r\n    httpOnly: true,\r\n    path: '/',\r\n  })\r\n}",
        "context": "filename=\"app/actions.ts\" switcher"
      },
      {
        "language": "js",
        "code": "'use server'\r\n\r\nimport { cookies } from 'next/headers'\r\n\r\nexport async function create(data) {\r\n  const cookieStore = await cookies()\r\n\r\n  cookieStore.set('name', 'lee')\r\n  // or\r\n  cookieStore.set('name', 'lee', { secure: true })\r\n  // or\r\n  cookieStore.set({\r\n    name: 'name',\r\n    value: 'lee',\r\n    httpOnly: true,\r\n    path: '/',\r\n  })\r\n}",
        "context": "filename=\"app/actions.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { cookies } from 'next/headers'\r\n\r\nexport default async function Page() {\r\n  const cookieStore = await cookies()\r\n  const hasCookie = cookieStore.has('theme')\r\n  return '...'\r\n}",
        "context": "filename=\"app/page.ts\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { cookies } from 'next/headers'\r\n\r\nexport default async function Page() {\r\n  const cookieStore = await cookies()\r\n  const hasCookie = cookieStore.has('theme')\r\n  return '...'\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use server'\r\n\r\nimport { cookies } from 'next/headers'\r\n\r\nexport async function delete(data) {\r\n  (await cookies()).delete('name')\r\n}",
        "context": "filename=\"app/actions.ts\" switcher"
      },
      {
        "language": "js",
        "code": "'use server'\r\n\r\nimport { cookies } from 'next/headers'\r\n\r\nexport async function delete(data) {\r\n  (await cookies()).delete('name')\r\n}",
        "context": "filename=\"app/actions.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use server'\r\n\r\nimport { cookies } from 'next/headers'\r\n\r\nexport async function delete(data) {\r\n  (await cookies()).set('name', '')\r\n}",
        "context": "filename=\"app/actions.ts\" switcher"
      },
      {
        "language": "js",
        "code": "'use server'\r\n\r\nimport { cookies } from 'next/headers'\r\n\r\nexport async function delete(data) {\r\n  (await cookies()).set('name', '')\r\n}",
        "context": "filename=\"app/actions.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use server'\r\n\r\nimport { cookies } from 'next/headers'\r\n\r\nexport async function delete(data) {\r\n  (await cookies()).set('name', 'value', { maxAge: 0 })\r\n}",
        "context": "filename=\"app/actions.ts\" switcher"
      },
      {
        "language": "js",
        "code": "'use server'\r\n\r\nimport { cookies } from 'next/headers'\r\n\r\nexport async function delete(data) {\r\n  (await cookies()).set('name', 'value', { maxAge: 0 })\r\n``\r\n}",
        "context": "filename=\"app/actions.js\" switcher"
      }
    ],
    "content": "cookies is an async function that allows you to read the HTTP incoming request cookies in Server Components, and read/write outgoing request cookies in Server Actions or Route Handlers. Reference Methods The following methods are available: | Method | Return Type | Description | | --------------------------- | ---------------- | ------------------------------------------------------------------------------- | | get('name') | Object | Accepts a cookie name and returns an object with the name and value. | | getAll() | Array of objects | Returns a list of all the cookies with a matching name. | | has('name') | Boolean | Accepts a cookie name and returns a boolean based on if the cookie exists. | | set(name, value, options) | - | Accepts a cookie name, value, and options and sets the outgoing request cookie. | | delete(name) | - | Accepts a cookie name and deletes the cookie. | | clear() | - | Deletes all cookies. | | toString() | String | Returns a string representation of the cookies. | Options When setting a cookie, the following properties from the options object are supported: | Option | Type | Description | | ------------- | -------------------------------------- | ---------------------------------------------------------------------------------- | | name | String | Specifies the name of the cookie. | | value | String | Specifies the value to be stored in the cookie. | | expires | Date | Defines the exact date when the cookie will expire. | | maxAge | Number | Sets the cookie’s lifespan in seconds. | | domain | String | Specifies the domain where the cookie is available. | | path | String, default: '/' | Limits the cookie's scope to a specific path within the domain. | | secure | Boolean | Ensures the cookie is sent only over HTTPS connections for added security. | | httpOnly | Boolean | Restricts the cookie to HTTP requests, preventing client-side access. | | sameSite | Boolean, 'lax', 'strict', 'none' | Controls the cookie's cross-site request behavior. | | priority | String (\"low\", \"medium\", \"high\") | Specifies the cookie's priority | | partitioned | Boolean | Indicates whether the cookie is partitioned. | The only option with a default value is path. To learn more about these options, see the MDN docs. Good to know - cookies is an asynchronous function that returns a promise. You must use async/await or React's use function to access cookies. - In version 14 and earlier, cookies was a synchronous function. To help with backwards compatibility, you can still access it synchronously in Next.js 15, but this behavior will be deprecated in the future. - cookies is a Dynamic API whose returned values cannot be known ahead of time. Using it in a layout or page will opt a route into dynamic rendering. - The .delete method can only be called: - In a Server Action or Route Handler. - If it belongs to the same domain from which .set is called. For wildcard domains, the specific subdomain must be an exact match. Additionally, the code must be executed on the same protocol (HTTP or HTTPS) as the cookie you want to delete. - HTTP does not allow setting cookies after streaming starts, so you must use .set in a Server Action or Route Handler. Understanding Cookie Behavior in Server Components When working with cookies in Server Components, it's important to understand that cookies are fundamentally a client-side storage mechanism: - Reading cookies works in Server Components because you're accessing the cookie data that the client's browser sends to the server in the HTTP request headers. - Setting cookies cannot be done directly in a Server Component, even when using a Route Handler or Server Action. This is because cookies are actually stored by the browser, not the server. The server can only send instructions (via Set-Cookie headers) to tell the browser to store cookies - the actual storage happens on the client side. This is why cookie operations that modify state (.set, .delete, .clear) must be performed in a Route Handler or Server Action where the response headers can be properly set. Understanding Cookie Behavior in Server Actions After you set or delete a cookie in a Server Action, Next.js re-renders the current page and its layouts on the server so the UI reflects the new cookie value. See the Caching guide. The UI is not unmounted, but effects that depend on data coming from the server will re-run. To refresh cached data too, call revalidatePath or revalidateTag inside the action. Examples Getting a cookie You can use the (await cookies()).get('name') method to get a single cookie: Getting all cookies You can use the (await cookies()).getAll() method to get all cookies with a matching name. If name is unspecified, it returns all the available cookies. Setting a cookie You can use the (await cookies()).set(name, value, options) method in a Server Action or Route Handler to set a cookie. The options object is optional. Checking if a cookie exists You can use the (await cookies()).has(name) method to check if a cookie exists: Deleting cookies There are three ways you can delete a cookie. Using the delete() method: Setting a new cookie with the same name and an empty value: Setting the maxAge to 0 will immediately expire a cookie. maxAge accepts a value in seconds. Version History | Version | Changes | | ------------ | ------------------------------------------------------------------------------------------------------ | | v15.0.0-RC | cookies is now an async function. A codemod is available. | | v13.0.0 | cookies introduced. |",
    "excerpt": "cookies is an async function that allows you to read the HTTP incoming request cookies in Server Components, and read/write outgoing request cookies in Server Actions or Route Handlers. Reference Meth...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/04-functions/cookies"
  },
  {
    "id": "01-app-03-api-reference-04-functions-draft-mode",
    "path": "01-app\\03-api-reference\\04-functions\\draft-mode.mdx",
    "title": "draftMode",
    "description": "API Reference for the draftMode function.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Reference",
        "slug": "reference"
      },
      {
        "level": 2,
        "text": "Good to know",
        "slug": "good-to-know"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Enabling Draft Mode",
        "slug": "enabling-draft-mode"
      },
      {
        "level": 3,
        "text": "Disabling Draft Mode",
        "slug": "disabling-draft-mode"
      },
      {
        "level": 3,
        "text": "Checking if Draft Mode is enabled",
        "slug": "checking-if-draft-mode-is-enabled"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "import { draftMode } from 'next/headers'\r\n\r\nexport default async function Page() {\r\n  const { isEnabled } = await draftMode()\r\n}",
        "context": "filename=\"app/page.ts\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { draftMode } from 'next/headers'\r\n\r\nexport default async function Page() {\r\n  const { isEnabled } = await draftMode()\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { draftMode } from 'next/headers'\r\n\r\nexport async function GET(request: Request) {\r\n  const draft = await draftMode()\r\n  draft.enable()\r\n  return new Response('Draft mode is enabled')\r\n}",
        "context": "filename=\"app/draft/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { draftMode } from 'next/headers'\r\n\r\nexport async function GET(request) {\r\n  const draft = await draftMode()\r\n  draft.enable()\r\n  return new Response('Draft mode is enabled')\r\n}",
        "context": "filename=\"app/draft/route.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { draftMode } from 'next/headers'\r\n\r\nexport async function GET(request: Request) {\r\n  const draft = await draftMode()\r\n  draft.disable()\r\n  return new Response('Draft mode is disabled')\r\n}",
        "context": "filename=\"app/draft/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { draftMode } from 'next/headers'\r\n\r\nexport async function GET(request) {\r\n  const draft = await draftMode()\r\n  draft.disable()\r\n  return new Response('Draft mode is disabled')\r\n}",
        "context": "filename=\"app/draft/route.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { draftMode } from 'next/headers'\r\n\r\nexport default async function Page() {\r\n  const { isEnabled } = await draftMode()\r\n  return (\r\n    <main>\r\n      <h1>My Blog Post</h1>\r\n      <p>Draft Mode is currently {isEnabled ? 'Enabled' : 'Disabled'}</p>\r\n    </main>\r\n  )\r\n}",
        "context": "filename=\"app/page.ts\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { draftMode } from 'next/headers'\r\n\r\nexport default async function Page() {\r\n  const { isEnabled } = await draftMode()\r\n  return (\r\n    <main>\r\n      <h1>My Blog Post</h1>\r\n      <p>Draft Mode is currently {isEnabled ? 'Enabled' : 'Disabled'}</p>\r\n    </main>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      }
    ],
    "content": "draftMode is an async function allows you to enable and disable Draft Mode, as well as check if Draft Mode is enabled in a Server Component. Reference The following methods and properties are available: | Method | Description | | ----------- | --------------------------------------------------------------------------------- | | isEnabled | A boolean value that indicates if Draft Mode is enabled. | | enable() | Enables Draft Mode in a Route Handler by setting a cookie (prerenderbypass). | | disable() | Disables Draft Mode in a Route Handler by deleting a cookie. | Good to know - draftMode is an asynchronous function that returns a promise. You must use async/await or React's use function. - In version 14 and earlier, draftMode was a synchronous function. To help with backwards compatibility, you can still access it synchronously in Next.js 15, but this behavior will be deprecated in the future. - A new bypass cookie value will be generated each time you run next build. This ensures that the bypass cookie can’t be guessed. - To test Draft Mode locally over HTTP, your browser will need to allow third-party cookies and local storage access. Examples Enabling Draft Mode To enable Draft Mode, create a new Route Handler and call the enable() method: Disabling Draft Mode By default, the Draft Mode session ends when the browser is closed. To disable Draft Mode manually, call the disable() method in your Route Handler: Then, send a request to invoke the Route Handler. If calling the route using the component, you must pass prefetch={false} to prevent accidentally deleting the cookie on prefetch. Checking if Draft Mode is enabled You can check if Draft Mode is enabled in a Server Component with the isEnabled property: Version History | Version | Changes | | ------------ | -------------------------------------------------------------------------------------------------------- | | v15.0.0-RC | draftMode is now an async function. A codemod is available. | | v13.4.0 | draftMode introduced. |",
    "excerpt": "draftMode is an async function allows you to enable and disable Draft Mode, as well as check if Draft Mode is enabled in a Server Component. Reference The following methods and properties are availabl...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/04-functions/draft-mode"
  },
  {
    "id": "01-app-03-api-reference-04-functions-fetch",
    "path": "01-app\\03-api-reference\\04-functions\\fetch.mdx",
    "title": "fetch",
    "description": "API reference for the extended fetch function.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Troubleshooting",
        "slug": "troubleshooting"
      },
      {
        "level": 3,
        "text": "Fetch default  and  not showing fresh data in development",
        "slug": "fetch-default-and-not-showing-fresh-data-in-development"
      },
      {
        "level": 3,
        "text": "Hard refresh and caching in development",
        "slug": "hard-refresh-and-caching-in-development"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "export default async function Page() {\r\n  let data = await fetch('https://api.vercel.app/blog')\r\n  let posts = await data.json()\r\n  return (\r\n    <ul>\r\n      {posts.map((post) => (\r\n        <li key={post.id}>{post.title}</li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default async function Page() {\r\n  let data = await fetch('https://api.vercel.app/blog')\r\n  let posts = await data.json()\r\n  return (\r\n    <ul>\r\n      {posts.map((post) => (\r\n        <li key={post.id}>{post.title}</li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "ts",
        "code": "fetch(`https://...`, { cache: 'force-cache' | 'no-store' })",
        "context": ""
      },
      {
        "language": "ts",
        "code": "fetch(`https://...`, { next: { revalidate: false | 0 | number } })",
        "context": ""
      },
      {
        "language": "ts",
        "code": "fetch(`https://...`, { next: { tags: ['collection'] } })",
        "context": ""
      }
    ],
    "content": "Next.js extends the Web fetch() API to allow each request on the server to set its own persistent caching and revalidation semantics. In the browser, the cache option indicates how a fetch request will interact with the browser's HTTP cache. With this extension, cache indicates how a server-side fetch request will interact with the framework's persistent Data Cache. You can call fetch with async and await directly within Server Components. fetch(url, options) Since Next.js extends the Web fetch() API, you can use any of the native options available. options.cache Configure how the request should interact with Next.js Data Cache. - auto no cache (default): Next.js fetches the resource from the remote server on every request in development, but will fetch once during next build because the route will be statically prerendered. If Dynamic APIs are detected on the route, Next.js will fetch the resource on every request. - no-store: Next.js fetches the resource from the remote server on every request, even if Dynamic APIs are not detected on the route. - force-cache: Next.js looks for a matching request in its Data Cache. - If there is a match and it is fresh, it will be returned from the cache. - If there is no match or a stale match, Next.js will fetch the resource from the remote server and update the cache with the downloaded resource. options.next.revalidate Set the cache lifetime of a resource (in seconds). Data Cache. - false - Cache the resource indefinitely. Semantically equivalent to revalidate: Infinity. The HTTP cache may evict older resources over time. - 0 - Prevent the resource from being cached. - number - (in seconds) Specify the resource should have a cache lifetime of at most n seconds. > Good to know: > > - If an individual fetch() request sets a revalidate number lower than the default revalidate of a route, the whole route revalidation interval will be decreased. > - If two fetch requests with the same URL in the same route have different revalidate values, the lower value will be used. > - Conflicting options such as { revalidate: 3600, cache: 'no-store' } are not allowed, both will be ignored, and in development mode a warning will be printed to the terminal. options.next.tags Set the cache tags of a resource. Data can then be revalidated on-demand using revalidateTag. The max length for a custom tag is 256 characters and the max tag items is 128. Troubleshooting Fetch default auto no store and cache: 'no-store' not showing fresh data in development Next.js caches fetch responses in Server Components across Hot Module Replacement (HMR) in local development for faster responses and to reduce costs for billed API calls. By default, the HMR cache applies to all fetch requests, including those with the default auto no cache and cache: 'no-store' option. This means uncached requests will not show fresh data between HMR refreshes. However, the cache will be cleared on navigation or full-page reloads. See the serverComponentsHmrCache docs for more information. Hard refresh and caching in development In development mode, if the request includes the cache-control: no-cache header, options.cache, options.next.revalidate, and options.next.tags are ignored, and the fetch request is served from the source. Browsers typically include cache-control: no-cache when the cache is disabled in developer tools or during a hard refresh. Version History | Version | Changes | | --------- | ------------------- | | v13.0.0 | fetch introduced. |",
    "excerpt": "Next.js extends the Web fetch() API to allow each request on the server to set its own persistent caching and revalidation semantics. In the browser, the cache option indicates how a fetch request wil...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/04-functions/fetch"
  },
  {
    "id": "01-app-03-api-reference-04-functions-forbidden",
    "path": "01-app\\03-api-reference\\04-functions\\forbidden.mdx",
    "title": "forbidden",
    "description": "API Reference for the forbidden function.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Good to know",
        "slug": "good-to-know"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Role-based route protection",
        "slug": "role-based-route-protection"
      },
      {
        "level": 3,
        "text": "Mutations with Server Actions",
        "slug": "mutations-with-server-actions"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  experimental: {\r\n    authInterrupts: true,\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  experimental: {\r\n    authInterrupts: true,\r\n  },\r\n}",
        "context": "filename=\"next.config.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { verifySession } from '@/app/lib/dal'\r\nimport { forbidden } from 'next/navigation'\r\n\r\nexport default async function AdminPage() {\r\n  const session = await verifySession()\r\n\r\n  // Check if the user has the 'admin' role\r\n  if (session.role !== 'admin') {\r\n    forbidden()\r\n  }\r\n\r\n  // Render the admin page for authorized users\r\n  return <></>\r\n}",
        "context": "filename=\"app/auth/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { verifySession } from '@/app/lib/dal'\r\nimport { forbidden } from 'next/navigation'\r\n\r\nexport default async function AdminPage() {\r\n  const session = await verifySession()\r\n\r\n  // Check if the user has the 'admin' role\r\n  if (session.role !== 'admin') {\r\n    forbidden()\r\n  }\r\n\r\n  // Render the admin page for authorized users\r\n  return <></>\r\n}",
        "context": "filename=\"app/auth/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { verifySession } from '@/app/lib/dal'\r\nimport { forbidden } from 'next/navigation'\r\n\r\nexport default async function AdminPage() {\r\n  const session = await verifySession()\r\n\r\n  // Check if the user has the 'admin' role\r\n  if (session.role !== 'admin') {\r\n    forbidden()\r\n  }\r\n\r\n  // Render the admin page for authorized users\r\n  return (\r\n    <main>\r\n      <h1>Admin Dashboard</h1>\r\n      <p>Welcome, {session.user.name}!</p>\r\n    </main>\r\n  )\r\n}",
        "context": "filename=\"app/admin/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { verifySession } from '@/app/lib/dal'\r\nimport { forbidden } from 'next/navigation'\r\n\r\nexport default async function AdminPage() {\r\n  const session = await verifySession()\r\n\r\n  // Check if the user has the 'admin' role\r\n  if (session.role !== 'admin') {\r\n    forbidden()\r\n  }\r\n\r\n  // Render the admin page for authorized users\r\n  return (\r\n    <main>\r\n      <h1>Admin Dashboard</h1>\r\n      <p>Welcome, {session.user.name}!</p>\r\n    </main>\r\n  )\r\n}",
        "context": "filename=\"app/admin/page.js\" switcher"
      },
      {
        "language": "ts",
        "code": "'use server'\r\n\r\nimport { verifySession } from '@/app/lib/dal'\r\nimport { forbidden } from 'next/navigation'\r\nimport db from '@/app/lib/db'\r\n\r\nexport async function updateRole(formData: FormData) {\r\n  const session = await verifySession()\r\n\r\n  // Ensure only admins can update roles\r\n  if (session.role !== 'admin') {\r\n    forbidden()\r\n  }\r\n\r\n  // Perform the role update for authorized users\r\n  // ...\r\n}",
        "context": "filename=\"app/actions/update-role.ts\" switcher"
      },
      {
        "language": "js",
        "code": "'use server'\r\n\r\nimport { verifySession } from '@/app/lib/dal'\r\nimport { forbidden } from 'next/navigation'\r\nimport db from '@/app/lib/db'\r\n\r\nexport async function updateRole(formData) {\r\n  const session = await verifySession()\r\n\r\n  // Ensure only admins can update roles\r\n  if (session.role !== 'admin') {\r\n    forbidden()\r\n  }\r\n\r\n  // Perform the role update for authorized users\r\n  // ...\r\n}",
        "context": "filename=\"app/actions/update-role.js\" switcher"
      }
    ],
    "content": "The forbidden function throws an error that renders a Next.js 403 error page. It's useful for handling authorization errors in your application. You can customize the UI using the forbidden.js file. To start using forbidden, enable the experimental authInterrupts configuration option in your next.config.js file: forbidden can be invoked in Server Components, Server Actions, and Route Handlers. Good to know - The forbidden function cannot be called in the root layout. Examples Role-based route protection You can use forbidden to restrict access to certain routes based on user roles. This ensures that users who are authenticated but lack the required permissions cannot access the route. Mutations with Server Actions When implementing mutations in Server Actions, you can use forbidden to only allow users with a specific role to update sensitive data. Version History | Version | Changes | | --------- | ----------------------- | | v15.1.0 | forbidden introduced. |",
    "excerpt": "The forbidden function throws an error that renders a Next.js 403 error page. It's useful for handling authorization errors in your application. You can customize the UI using the forbidden.js file. T...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/04-functions/forbidden"
  },
  {
    "id": "01-app-03-api-reference-04-functions-generate-image-metadata",
    "path": "01-app\\03-api-reference\\04-functions\\generate-image-metadata.mdx",
    "title": "generateImageMetadata",
    "description": "Learn how to generate multiple images in a single Metadata API special file.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Parameters",
        "slug": "parameters"
      },
      {
        "level": 4,
        "text": " (optional)",
        "slug": "-optional"
      },
      {
        "level": 2,
        "text": "Returns",
        "slug": "returns"
      },
      {
        "level": 2,
        "text": "Image generation function props",
        "slug": "image-generation-function-props"
      },
      {
        "level": 4,
        "text": " (optional)",
        "slug": "-optional"
      },
      {
        "level": 3,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 4,
        "text": "Using external data",
        "slug": "using-external-data"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "export function generateImageMetadata({\r\n  params,\r\n}: {\r\n  params: { slug: string }\r\n}) {\r\n  // ...\r\n}",
        "context": "filename=\"icon.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export function generateImageMetadata({ params }) {\r\n  // ...\r\n}",
        "context": "filename=\"icon.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { ImageResponse } from 'next/og'\r\n\r\nexport function generateImageMetadata() {\r\n  return [\r\n    {\r\n      contentType: 'image/png',\r\n      size: { width: 48, height: 48 },\r\n      id: 'small',\r\n    },\r\n    {\r\n      contentType: 'image/png',\r\n      size: { width: 72, height: 72 },\r\n      id: 'medium',\r\n    },\r\n  ]\r\n}\r\n\r\nexport default async function Icon({ id }: { id: Promise<string | number> }) {\r\n  const iconId = await id\r\n  return new ImageResponse(\r\n    (\r\n      <div\r\n        style={{\r\n          width: '100%',\r\n          height: '100%',\r\n          display: 'flex',\r\n          alignItems: 'center',\r\n          justifyContent: 'center',\r\n          fontSize: 88,\r\n          background: '#000',\r\n          color: '#fafafa',\r\n        }}\r\n      >\r\n        Icon {iconId}\r\n      </div>\r\n    )\r\n  )\r\n}",
        "context": "filename=\"icon.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { ImageResponse } from 'next/og'\r\n\r\nexport function generateImageMetadata() {\r\n  return [\r\n    {\r\n      contentType: 'image/png',\r\n      size: { width: 48, height: 48 },\r\n      id: 'small',\r\n    },\r\n    {\r\n      contentType: 'image/png',\r\n      size: { width: 72, height: 72 },\r\n      id: 'medium',\r\n    },\r\n  ]\r\n}\r\n\r\nexport default async function Icon({ id }) {\r\n  const iconId = await id\r\n  return new ImageResponse(\r\n    (\r\n      <div\r\n        style={{\r\n          width: '100%',\r\n          height: '100%',\r\n          display: 'flex',\r\n          alignItems: 'center',\r\n          justifyContent: 'center',\r\n          fontSize: 88,\r\n          background: '#000',\r\n          color: '#fafafa',\r\n        }}\r\n      >\r\n        Icon {iconId}\r\n      </div>\r\n    )\r\n  )\r\n}",
        "context": "filename=\"icon.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default async function Icon({ id }: { id: Promise<string | number> }) {\r\n  const iconId = await id\r\n  // Use iconId to generate the image\r\n}",
        "context": "filename=\"icon.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default async function Icon({ id }) {\r\n  const iconId = await id\r\n  // Use iconId to generate the image\r\n}",
        "context": "filename=\"icon.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default async function Icon({\r\n  params,\r\n}: {\r\n  params: Promise<{ slug: string }>\r\n}) {\r\n  const { slug } = await params\r\n  // Use slug to generate the image\r\n}",
        "context": "filename=\"icon.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default async function Icon({ params }) {\r\n  const { slug } = await params\r\n  // Use slug to generate the image\r\n}",
        "context": "filename=\"icon.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { ImageResponse } from 'next/og'\r\nimport { getCaptionForImage, getOGImages } from '@/app/utils/images'\r\n\r\nexport async function generateImageMetadata({\r\n  params,\r\n}: {\r\n  params: { id: string }\r\n}) {\r\n  const images = await getOGImages(params.id)\r\n\r\n  return images.map((image, idx) => ({\r\n    id: idx,\r\n    size: { width: 1200, height: 600 },\r\n    alt: image.text,\r\n    contentType: 'image/png',\r\n  }))\r\n}\r\n\r\nexport default async function Image({\r\n  params,\r\n  id,\r\n}: {\r\n  params: Promise<{ id: string }>\r\n  id: Promise<number>\r\n}) {\r\n  const productId = (await params).id\r\n  const imageId = await id\r\n  const text = await getCaptionForImage(productId, imageId)\r\n\r\n  return new ImageResponse(\r\n    (\r\n      <div\r\n        style={\r\n          {\r\n            // ...\r\n          }\r\n        }\r\n      >\r\n        {text}\r\n      </div>\r\n    )\r\n  )\r\n}",
        "context": "filename=\"app/products/[id]/opengraph-image.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { ImageResponse } from 'next/og'\r\nimport { getCaptionForImage, getOGImages } from '@/app/utils/images'\r\n\r\nexport async function generateImageMetadata({ params }) {\r\n  const images = await getOGImages(params.id)\r\n\r\n  return images.map((image, idx) => ({\r\n    id: idx,\r\n    size: { width: 1200, height: 600 },\r\n    alt: image.text,\r\n    contentType: 'image/png',\r\n  }))\r\n}\r\n\r\nexport default async function Image({ params, id }) {\r\n  const productId = (await params).id\r\n  const imageId = await id\r\n  const text = await getCaptionForImage(productId, imageId)\r\n\r\n  return new ImageResponse(\r\n    (\r\n      <div\r\n        style={\r\n          {\r\n            // ...\r\n          }\r\n        }\r\n      >\r\n        {text}\r\n      </div>\r\n    )\r\n  )\r\n}",
        "context": "filename=\"app/products/[id]/opengraph-image.js\" switcher"
      }
    ],
    "content": "You can use generateImageMetadata to generate different versions of one image or return multiple images for one route segment. This is useful for when you want to avoid hard-coding metadata values, such as for icons. Parameters generateImageMetadata function accepts the following parameters: params (optional) An object containing the dynamic route parameters object from the root segment down to the segment generateImageMetadata is called from. | Route | URL | params | | ------------------------------- | ----------- | ------------------------- | | app/shop/icon.js | /shop | undefined | | app/shop/[slug]/icon.js | /shop/1 | { slug: '1' } | | app/shop/[tag]/[item]/icon.js | /shop/1/2 | { tag: '1', item: '2' } | Returns The generateImageMetadata function should return an array of objects containing the image's metadata such as alt and size. In addition, each item must include an id value which will be passed as a promise to the props of the image generating function. | Image Metadata Object | Type | | --------------------- | ----------------------------------- | | id | string (required) | | alt | string | | size | { width: number; height: number } | | contentType | string | Image generation function props When using generateImageMetadata, the default export image generation function receives the following props: id A promise that resolves to the id value from one of the items returned by generateImageMetadata. The id will be a string or number depending on what was returned from generateImageMetadata. params (optional) A promise that resolves to an object containing the dynamic route parameters from the root segment down to the segment the image is colocated in. Examples Using external data This example uses the params object and external data to generate multiple Open Graph images for a route segment. Version History | Version | Changes | | --------- | --------------------------------------------------------------------------------------------------- | | v16.0.0 | id passed to the Image generation function is now a promise that resolves to string or number | | v16.0.0 | params passed to the Image generation function is now a promise that resolves to an object | | v13.3.0 | generateImageMetadata introduced. |",
    "excerpt": "You can use generateImageMetadata to generate different versions of one image or return multiple images for one route segment. This is useful for when you want to avoid hard-coding metadata values, su...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/04-functions/generate-image-metadata"
  },
  {
    "id": "01-app-03-api-reference-04-functions-generate-metadata",
    "path": "01-app\\03-api-reference\\04-functions\\generate-metadata.mdx",
    "title": "generateMetadata",
    "description": "Learn how to add Metadata to your Next.js application for improved search engine optimization (SEO) and web shareability.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "The  object",
        "slug": "the-object"
      },
      {
        "level": 2,
        "text": " function",
        "slug": "-function"
      },
      {
        "level": 2,
        "text": "Reference",
        "slug": "reference"
      },
      {
        "level": 3,
        "text": "Parameters",
        "slug": "parameters"
      },
      {
        "level": 3,
        "text": "Returns",
        "slug": "returns"
      },
      {
        "level": 3,
        "text": "Metadata Fields",
        "slug": "metadata-fields"
      },
      {
        "level": 5,
        "text": "String",
        "slug": "string"
      },
      {
        "level": 3,
        "text": "Other fields",
        "slug": "other-fields"
      },
      {
        "level": 4,
        "text": "URL Composition",
        "slug": "url-composition"
      },
      {
        "level": 3,
        "text": "Types",
        "slug": "types"
      },
      {
        "level": 4,
        "text": " object",
        "slug": "-object"
      },
      {
        "level": 4,
        "text": " function",
        "slug": "-function"
      },
      {
        "level": 5,
        "text": "Regular function",
        "slug": "regular-function"
      },
      {
        "level": 5,
        "text": "Async function",
        "slug": "async-function"
      },
      {
        "level": 5,
        "text": "With segment props",
        "slug": "with-segment-props"
      },
      {
        "level": 5,
        "text": "With parent metadata",
        "slug": "with-parent-metadata"
      },
      {
        "level": 5,
        "text": "JavaScript Projects",
        "slug": "javascript-projects"
      },
      {
        "level": 3,
        "text": "Unsupported Metadata",
        "slug": "unsupported-metadata"
      },
      {
        "level": 3,
        "text": "Resource hints",
        "slug": "resource-hints"
      },
      {
        "level": 2,
        "text": "Behavior",
        "slug": "behavior"
      },
      {
        "level": 3,
        "text": "Default Fields",
        "slug": "default-fields"
      },
      {
        "level": 3,
        "text": "Streaming metadata",
        "slug": "streaming-metadata"
      },
      {
        "level": 3,
        "text": "Ordering",
        "slug": "ordering"
      },
      {
        "level": 3,
        "text": "Merging",
        "slug": "merging"
      },
      {
        "level": 4,
        "text": "Overwriting fields",
        "slug": "overwriting-fields"
      },
      {
        "level": 4,
        "text": "Inheriting fields",
        "slug": "inheriting-fields"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "import type { Metadata } from 'next'\r\n\r\nexport const metadata: Metadata = {\r\n  title: '...',\r\n  description: '...',\r\n}\r\n\r\nexport default function Page() {}",
        "context": "filename=\"layout.tsx | page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  title: '...',\r\n  description: '...',\r\n}\r\n\r\nexport default function Page() {}",
        "context": "filename=\"layout.js | page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import type { Metadata, ResolvingMetadata } from 'next'\r\n\r\ntype Props = {\r\n  params: Promise<{ id: string }>\r\n  searchParams: Promise<{ [key: string]: string | string[] | undefined }>\r\n}\r\n\r\nexport async function generateMetadata(\r\n  { params, searchParams }: Props,\r\n  parent: ResolvingMetadata\r\n): Promise<Metadata> {\r\n  // read route params\r\n  const { id } = await params\r\n\r\n  // fetch data\r\n  const product = await fetch(`https://.../${id}`).then((res) => res.json())\r\n\r\n  // optionally access and extend (rather than replace) parent metadata\r\n  const previousImages = (await parent).openGraph?.images || []\r\n\r\n  return {\r\n    title: product.title,\r\n    openGraph: {\r\n      images: ['/some-specific-page-image.jpg', ...previousImages],\r\n    },\r\n  }\r\n}\r\n\r\nexport default function Page({ params, searchParams }: Props) {}",
        "context": "filename=\"app/products/[id]/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export async function generateMetadata({ params, searchParams }, parent) {\r\n  // read route params\r\n  const { id } = await params\r\n\r\n  // fetch data\r\n  const product = await fetch(`https://.../${id}`).then((res) => res.json())\r\n\r\n  // optionally access and extend (rather than replace) parent metadata\r\n  const previousImages = (await parent).openGraph?.images || []\r\n\r\n  return {\r\n    title: product.title,\r\n    openGraph: {\r\n      images: ['/some-specific-page-image.jpg', ...previousImages],\r\n    },\r\n  }\r\n}\r\n\r\nexport default function Page({ params, searchParams }) {}",
        "context": "filename=\"app/products/[id]/page.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  title: 'Next.js',\r\n}",
        "context": "filename=\"layout.js | page.js\""
      },
      {
        "language": "html",
        "code": "<title>Next.js</title>",
        "context": "filename=\"<head> output\" hideLineNumbers"
      },
      {
        "language": "tsx",
        "code": "import type { Metadata } from 'next'\r\n\r\nexport const metadata: Metadata = {\r\n  title: {\r\n    default: 'Acme',\r\n  },\r\n}",
        "context": "filename=\"app/layout.tsx\""
      },
      {
        "language": "tsx",
        "code": "import type { Metadata } from 'next'\r\n\r\nexport const metadata: Metadata = {}\r\n\r\n// Output: <title>Acme</title>",
        "context": "filename=\"app/about/page.tsx\""
      },
      {
        "language": "tsx",
        "code": "import type { Metadata } from 'next'\r\n\r\nexport const metadata: Metadata = {\r\n  title: {\r\n    template: '%s | Acme',\r\n    default: 'Acme', // a default is required when creating a template\r\n  },\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  title: {\r\n    template: '%s | Acme',\r\n    default: 'Acme', // a default is required when creating a template\r\n  },\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import type { Metadata } from 'next'\r\n\r\nexport const metadata: Metadata = {\r\n  title: 'About',\r\n}\r\n\r\n// Output: <title>About | Acme</title>",
        "context": "filename=\"app/about/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  title: 'About',\r\n}\r\n\r\n// Output: <title>About | Acme</title>",
        "context": "filename=\"app/about/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import type { Metadata } from 'next'\r\n\r\nexport const metadata: Metadata = {\r\n  title: {\r\n    template: '%s | Acme',\r\n  },\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  title: {\r\n    template: '%s | Acme',\r\n  },\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import type { Metadata } from 'next'\r\n\r\nexport const metadata: Metadata = {\r\n  title: {\r\n    absolute: 'About',\r\n  },\r\n}\r\n\r\n// Output: <title>About</title>",
        "context": "filename=\"app/about/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  title: {\r\n    absolute: 'About',\r\n  },\r\n}\r\n\r\n// Output: <title>About</title>",
        "context": "filename=\"app/about/page.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  description: 'The React Framework for the Web',\r\n}",
        "context": "filename=\"layout.js | page.js\""
      },
      {
        "language": "html",
        "code": "<meta name=\"description\" content=\"The React Framework for the Web\" />",
        "context": "filename=\"<head> output\" hideLineNumbers"
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  generator: 'Next.js',\r\n  applicationName: 'Next.js',\r\n  referrer: 'origin-when-cross-origin',\r\n  keywords: ['Next.js', 'React', 'JavaScript'],\r\n  authors: [{ name: 'Seb' }, { name: 'Josh', url: 'https://nextjs.org' }],\r\n  creator: 'Jiachi Liu',\r\n  publisher: 'Sebastian Markbåge',\r\n  formatDetection: {\r\n    email: false,\r\n    address: false,\r\n    telephone: false,\r\n  },\r\n}",
        "context": "filename=\"layout.js | page.js\""
      },
      {
        "language": "html",
        "code": "<meta name=\"application-name\" content=\"Next.js\" />\r\n<meta name=\"author\" content=\"Seb\" />\r\n<link rel=\"author\" href=\"https://nextjs.org\" />\r\n<meta name=\"author\" content=\"Josh\" />\r\n<meta name=\"generator\" content=\"Next.js\" />\r\n<meta name=\"keywords\" content=\"Next.js,React,JavaScript\" />\r\n<meta name=\"referrer\" content=\"origin-when-cross-origin\" />\r\n<meta name=\"color-scheme\" content=\"dark\" />\r\n<meta name=\"creator\" content=\"Jiachi Liu\" />\r\n<meta name=\"publisher\" content=\"Sebastian Markbåge\" />\r\n<meta name=\"format-detection\" content=\"telephone=no, address=no, email=no\" />",
        "context": "filename=\"<head> output\" hideLineNumbers"
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  metadataBase: new URL('https://acme.com'),\r\n  alternates: {\r\n    canonical: '/',\r\n    languages: {\r\n      'en-US': '/en-US',\r\n      'de-DE': '/de-DE',\r\n    },\r\n  },\r\n  openGraph: {\r\n    images: '/og-image.png',\r\n  },\r\n}",
        "context": "filename=\"layout.js | page.js\""
      },
      {
        "language": "html",
        "code": "<link rel=\"canonical\" href=\"https://acme.com\" />\r\n<link rel=\"alternate\" hreflang=\"en-US\" href=\"https://acme.com/en-US\" />\r\n<link rel=\"alternate\" hreflang=\"de-DE\" href=\"https://acme.com/de-DE\" />\r\n<meta property=\"og:image\" content=\"https://acme.com/og-image.png\" />",
        "context": "filename=\"<head> output\" hideLineNumbers"
      },
      {
        "language": "tsx",
        "code": "import type { Metadata } from 'next'\r\n\r\nexport const metadata: Metadata = {\r\n  metadataBase: new URL('https://acme.com'),\r\n}",
        "context": "filename=\"app/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  metadataBase: new URL('https://acme.com'),\r\n}",
        "context": "filename=\"app/layout.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  openGraph: {\r\n    title: 'Next.js',\r\n    description: 'The React Framework for the Web',\r\n    url: 'https://nextjs.org',\r\n    siteName: 'Next.js',\r\n    images: [\r\n      {\r\n        url: 'https://nextjs.org/og.png', // Must be an absolute URL\r\n        width: 800,\r\n        height: 600,\r\n      },\r\n      {\r\n        url: 'https://nextjs.org/og-alt.png', // Must be an absolute URL\r\n        width: 1800,\r\n        height: 1600,\r\n        alt: 'My custom alt',\r\n      },\r\n    ],\r\n    videos: [\r\n      {\r\n        url: 'https://nextjs.org/video.mp4', // Must be an absolute URL\r\n        width: 800,\r\n        height: 600,\r\n      },\r\n    ],\r\n    audio: [\r\n      {\r\n        url: 'https://nextjs.org/audio.mp3', // Must be an absolute URL\r\n      },\r\n    ],\r\n    locale: 'en_US',\r\n    type: 'website',\r\n  },\r\n}",
        "context": "filename=\"layout.js | page.js\""
      },
      {
        "language": "html",
        "code": "<meta property=\"og:title\" content=\"Next.js\" />\r\n<meta property=\"og:description\" content=\"The React Framework for the Web\" />\r\n<meta property=\"og:url\" content=\"https://nextjs.org/\" />\r\n<meta property=\"og:site_name\" content=\"Next.js\" />\r\n<meta property=\"og:locale\" content=\"en_US\" />\r\n<meta property=\"og:image\" content=\"https://nextjs.org/og.png\" />\r\n<meta property=\"og:image:width\" content=\"800\" />\r\n<meta property=\"og:image:height\" content=\"600\" />\r\n<meta property=\"og:image\" content=\"https://nextjs.org/og-alt.png\" />\r\n<meta property=\"og:image:width\" content=\"1800\" />\r\n<meta property=\"og:image:height\" content=\"1600\" />\r\n<meta property=\"og:image:alt\" content=\"My custom alt\" />\r\n<meta property=\"og:video\" content=\"https://nextjs.org/video.mp4\" />\r\n<meta property=\"og:video:width\" content=\"800\" />\r\n<meta property=\"og:video:height\" content=\"600\" />\r\n<meta property=\"og:audio\" content=\"https://nextjs.org/audio.mp3\" />\r\n<meta property=\"og:type\" content=\"website\" />",
        "context": "filename=\"<head> output\" hideLineNumbers"
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  openGraph: {\r\n    title: 'Next.js',\r\n    description: 'The React Framework for the Web',\r\n    type: 'article',\r\n    publishedTime: '2023-01-01T00:00:00.000Z',\r\n    authors: ['Seb', 'Josh'],\r\n  },\r\n}",
        "context": "filename=\"layout.js | page.js\""
      },
      {
        "language": "html",
        "code": "<meta property=\"og:title\" content=\"Next.js\" />\r\n<meta property=\"og:description\" content=\"The React Framework for the Web\" />\r\n<meta property=\"og:type\" content=\"article\" />\r\n<meta property=\"article:published_time\" content=\"2023-01-01T00:00:00.000Z\" />\r\n<meta property=\"article:author\" content=\"Seb\" />\r\n<meta property=\"article:author\" content=\"Josh\" />",
        "context": "filename=\"<head> output\" hideLineNumbers"
      },
      {
        "language": "tsx",
        "code": "import type { Metadata } from 'next'\r\n\r\nexport const metadata: Metadata = {\r\n  robots: {\r\n    index: true,\r\n    follow: true,\r\n    nocache: false,\r\n    googleBot: {\r\n      index: true,\r\n      follow: true,\r\n      noimageindex: false,\r\n      'max-video-preview': -1,\r\n      'max-image-preview': 'large',\r\n      'max-snippet': -1,\r\n    },\r\n  },\r\n}",
        "context": "filename=\"layout.tsx | page.tsx\""
      },
      {
        "language": "html",
        "code": "<meta name=\"robots\" content=\"index, follow\" />\r\n<meta\r\n  name=\"googlebot\"\r\n  content=\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"\r\n/>",
        "context": "filename=\"<head> output\" hideLineNumbers"
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  icons: {\r\n    icon: '/icon.png',\r\n    shortcut: '/shortcut-icon.png',\r\n    apple: '/apple-icon.png',\r\n    other: {\r\n      rel: 'apple-touch-icon-precomposed',\r\n      url: '/apple-touch-icon-precomposed.png',\r\n    },\r\n  },\r\n}",
        "context": "filename=\"layout.js | page.js\""
      },
      {
        "language": "html",
        "code": "<link rel=\"shortcut icon\" href=\"/shortcut-icon.png\" />\r\n<link rel=\"icon\" href=\"/icon.png\" />\r\n<link rel=\"apple-touch-icon\" href=\"/apple-icon.png\" />\r\n<link\r\n  rel=\"apple-touch-icon-precomposed\"\r\n  href=\"/apple-touch-icon-precomposed.png\"\r\n/>",
        "context": "filename=\"<head> output\" hideLineNumbers"
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  icons: {\r\n    icon: [\r\n      { url: '/icon.png' },\r\n      new URL('/icon.png', 'https://example.com'),\r\n      { url: '/icon-dark.png', media: '(prefers-color-scheme: dark)' },\r\n    ],\r\n    shortcut: ['/shortcut-icon.png'],\r\n    apple: [\r\n      { url: '/apple-icon.png' },\r\n      { url: '/apple-icon-x3.png', sizes: '180x180', type: 'image/png' },\r\n    ],\r\n    other: [\r\n      {\r\n        rel: 'apple-touch-icon-precomposed',\r\n        url: '/apple-touch-icon-precomposed.png',\r\n      },\r\n    ],\r\n  },\r\n}",
        "context": "filename=\"layout.js | page.js\""
      },
      {
        "language": "html",
        "code": "<link rel=\"shortcut icon\" href=\"/shortcut-icon.png\" />\r\n<link rel=\"icon\" href=\"/icon.png\" />\r\n<link rel=\"icon\" href=\"https://example.com/icon.png\" />\r\n<link rel=\"icon\" href=\"/icon-dark.png\" media=\"(prefers-color-scheme: dark)\" />\r\n<link rel=\"apple-touch-icon\" href=\"/apple-icon.png\" />\r\n<link\r\n  rel=\"apple-touch-icon-precomposed\"\r\n  href=\"/apple-touch-icon-precomposed.png\"\r\n/>\r\n<link\r\n  rel=\"apple-touch-icon\"\r\n  href=\"/apple-icon-x3.png\"\r\n  sizes=\"180x180\"\r\n  type=\"image/png\"\r\n/>",
        "context": "filename=\"<head> output\" hideLineNumbers"
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  manifest: 'https://nextjs.org/manifest.json',\r\n}",
        "context": "filename=\"layout.js | page.js\""
      },
      {
        "language": "html",
        "code": "<link rel=\"manifest\" href=\"https://nextjs.org/manifest.json\" />",
        "context": "filename=\"<head> output\" hideLineNumbers"
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  twitter: {\r\n    card: 'summary_large_image',\r\n    title: 'Next.js',\r\n    description: 'The React Framework for the Web',\r\n    siteId: '1467726470533754880',\r\n    creator: '@nextjs',\r\n    creatorId: '1467726470533754880',\r\n    images: ['https://nextjs.org/og.png'], // Must be an absolute URL\r\n  },\r\n}",
        "context": "filename=\"layout.js | page.js\""
      },
      {
        "language": "html",
        "code": "<meta name=\"twitter:card\" content=\"summary_large_image\" />\r\n<meta name=\"twitter:site:id\" content=\"1467726470533754880\" />\r\n<meta name=\"twitter:creator\" content=\"@nextjs\" />\r\n<meta name=\"twitter:creator:id\" content=\"1467726470533754880\" />\r\n<meta name=\"twitter:title\" content=\"Next.js\" />\r\n<meta name=\"twitter:description\" content=\"The React Framework for the Web\" />\r\n<meta name=\"twitter:image\" content=\"https://nextjs.org/og.png\" />",
        "context": "filename=\"<head> output\" hideLineNumbers"
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  twitter: {\r\n    card: 'app',\r\n    title: 'Next.js',\r\n    description: 'The React Framework for the Web',\r\n    siteId: '1467726470533754880',\r\n    creator: '@nextjs',\r\n    creatorId: '1467726470533754880',\r\n    images: {\r\n      url: 'https://nextjs.org/og.png',\r\n      alt: 'Next.js Logo',\r\n    },\r\n    app: {\r\n      name: 'twitter_app',\r\n      id: {\r\n        iphone: 'twitter_app://iphone',\r\n        ipad: 'twitter_app://ipad',\r\n        googleplay: 'twitter_app://googleplay',\r\n      },\r\n      url: {\r\n        iphone: 'https://iphone_url',\r\n        ipad: 'https://ipad_url',\r\n      },\r\n    },\r\n  },\r\n}",
        "context": "filename=\"layout.js | page.js\""
      },
      {
        "language": "html",
        "code": "<meta name=\"twitter:site:id\" content=\"1467726470533754880\" />\r\n<meta name=\"twitter:creator\" content=\"@nextjs\" />\r\n<meta name=\"twitter:creator:id\" content=\"1467726470533754880\" />\r\n<meta name=\"twitter:title\" content=\"Next.js\" />\r\n<meta name=\"twitter:description\" content=\"The React Framework for the Web\" />\r\n<meta name=\"twitter:card\" content=\"app\" />\r\n<meta name=\"twitter:image\" content=\"https://nextjs.org/og.png\" />\r\n<meta name=\"twitter:image:alt\" content=\"Next.js Logo\" />\r\n<meta name=\"twitter:app:name:iphone\" content=\"twitter_app\" />\r\n<meta name=\"twitter:app:id:iphone\" content=\"twitter_app://iphone\" />\r\n<meta name=\"twitter:app:id:ipad\" content=\"twitter_app://ipad\" />\r\n<meta name=\"twitter:app:id:googleplay\" content=\"twitter_app://googleplay\" />\r\n<meta name=\"twitter:app:url:iphone\" content=\"https://iphone_url\" />\r\n<meta name=\"twitter:app:url:ipad\" content=\"https://ipad_url\" />\r\n<meta name=\"twitter:app:name:ipad\" content=\"twitter_app\" />\r\n<meta name=\"twitter:app:name:googleplay\" content=\"twitter_app\" />",
        "context": "filename=\"<head> output\" hideLineNumbers"
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  verification: {\r\n    google: 'google',\r\n    yandex: 'yandex',\r\n    yahoo: 'yahoo',\r\n    other: {\r\n      me: ['my-email', 'my-link'],\r\n    },\r\n  },\r\n}",
        "context": "filename=\"layout.js | page.js\""
      },
      {
        "language": "html",
        "code": "<meta name=\"google-site-verification\" content=\"google\" />\r\n<meta name=\"y_key\" content=\"yahoo\" />\r\n<meta name=\"yandex-verification\" content=\"yandex\" />\r\n<meta name=\"me\" content=\"my-email\" />\r\n<meta name=\"me\" content=\"my-link\" />",
        "context": "filename=\"<head> output\" hideLineNumbers"
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  itunes: {\r\n    appId: 'myAppStoreID',\r\n    appArgument: 'myAppArgument',\r\n  },\r\n  appleWebApp: {\r\n    title: 'Apple Web App',\r\n    statusBarStyle: 'black-translucent',\r\n    startupImage: [\r\n      '/assets/startup/apple-touch-startup-image-768x1004.png',\r\n      {\r\n        url: '/assets/startup/apple-touch-startup-image-1536x2008.png',\r\n        media: '(device-width: 768px) and (device-height: 1024px)',\r\n      },\r\n    ],\r\n  },\r\n}",
        "context": "filename=\"layout.js | page.js\""
      },
      {
        "language": "html",
        "code": "<meta\r\n  name=\"apple-itunes-app\"\r\n  content=\"app-id=myAppStoreID, app-argument=myAppArgument\"\r\n/>\r\n<meta name=\"mobile-web-app-capable\" content=\"yes\" />\r\n<meta name=\"apple-mobile-web-app-title\" content=\"Apple Web App\" />\r\n<link\r\n  href=\"/assets/startup/apple-touch-startup-image-768x1004.png\"\r\n  rel=\"apple-touch-startup-image\"\r\n/>\r\n<link\r\n  href=\"/assets/startup/apple-touch-startup-image-1536x2008.png\"\r\n  media=\"(device-width: 768px) and (device-height: 1024px)\"\r\n  rel=\"apple-touch-startup-image\"\r\n/>\r\n<meta\r\n  name=\"apple-mobile-web-app-status-bar-style\"\r\n  content=\"black-translucent\"\r\n/>",
        "context": "filename=\"<head> output\" hideLineNumbers"
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  alternates: {\r\n    canonical: 'https://nextjs.org',\r\n    languages: {\r\n      'en-US': 'https://nextjs.org/en-US',\r\n      'de-DE': 'https://nextjs.org/de-DE',\r\n    },\r\n    media: {\r\n      'only screen and (max-width: 600px)': 'https://nextjs.org/mobile',\r\n    },\r\n    types: {\r\n      'application/rss+xml': 'https://nextjs.org/rss',\r\n    },\r\n  },\r\n}",
        "context": "filename=\"layout.js | page.js\""
      },
      {
        "language": "html",
        "code": "<link rel=\"canonical\" href=\"https://nextjs.org\" />\r\n<link rel=\"alternate\" hreflang=\"en-US\" href=\"https://nextjs.org/en-US\" />\r\n<link rel=\"alternate\" hreflang=\"de-DE\" href=\"https://nextjs.org/de-DE\" />\r\n<link\r\n  rel=\"alternate\"\r\n  media=\"only screen and (max-width: 600px)\"\r\n  href=\"https://nextjs.org/mobile\"\r\n/>\r\n<link\r\n  rel=\"alternate\"\r\n  type=\"application/rss+xml\"\r\n  href=\"https://nextjs.org/rss\"\r\n/>",
        "context": "filename=\"<head> output\" hideLineNumbers"
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  appLinks: {\r\n    ios: {\r\n      url: 'https://nextjs.org/ios',\r\n      app_store_id: 'app_store_id',\r\n    },\r\n    android: {\r\n      package: 'com.example.android/package',\r\n      app_name: 'app_name_android',\r\n    },\r\n    web: {\r\n      url: 'https://nextjs.org/web',\r\n      should_fallback: true,\r\n    },\r\n  },\r\n}",
        "context": "filename=\"layout.js | page.js\""
      },
      {
        "language": "html",
        "code": "<meta property=\"al:ios:url\" content=\"https://nextjs.org/ios\" />\r\n<meta property=\"al:ios:app_store_id\" content=\"app_store_id\" />\r\n<meta property=\"al:android:package\" content=\"com.example.android/package\" />\r\n<meta property=\"al:android:app_name\" content=\"app_name_android\" />\r\n<meta property=\"al:web:url\" content=\"https://nextjs.org/web\" />\r\n<meta property=\"al:web:should_fallback\" content=\"true\" />",
        "context": "filename=\"<head> output\" hideLineNumbers"
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  archives: ['https://nextjs.org/13'],\r\n}",
        "context": "filename=\"layout.js | page.js\""
      },
      {
        "language": "html",
        "code": "<link rel=\"archives\" href=\"https://nextjs.org/13\" />",
        "context": "filename=\"<head> output\" hideLineNumbers"
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  assets: ['https://nextjs.org/assets'],\r\n}",
        "context": "filename=\"layout.js | page.js\""
      },
      {
        "language": "html",
        "code": "<link rel=\"assets\" href=\"https://nextjs.org/assets\" />",
        "context": "filename=\"<head> output\" hideLineNumbers"
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  bookmarks: ['https://nextjs.org/13'],\r\n}",
        "context": "filename=\"layout.js | page.js\""
      },
      {
        "language": "html",
        "code": "<link rel=\"bookmarks\" href=\"https://nextjs.org/13\" />",
        "context": "filename=\"<head> output\" hideLineNumbers"
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  category: 'technology',\r\n}",
        "context": "filename=\"layout.js | page.js\""
      },
      {
        "language": "html",
        "code": "<meta name=\"category\" content=\"technology\" />",
        "context": "filename=\"<head> output\" hideLineNumbers"
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  facebook: {\r\n    appId: '12345678',\r\n  },\r\n}",
        "context": "filename=\"layout.js | page.js\""
      },
      {
        "language": "html",
        "code": "<meta property=\"fb:app_id\" content=\"12345678\" />",
        "context": "filename=\"<head> output\" hideLineNumbers"
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  facebook: {\r\n    admins: '12345678',\r\n  },\r\n}",
        "context": "filename=\"layout.js | page.js\""
      },
      {
        "language": "html",
        "code": "<meta property=\"fb:admins\" content=\"12345678\" />",
        "context": "filename=\"<head> output\" hideLineNumbers"
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  facebook: {\r\n    admins: ['12345678', '87654321'],\r\n  },\r\n}",
        "context": "filename=\"layout.js | page.js\""
      },
      {
        "language": "html",
        "code": "<meta property=\"fb:admins\" content=\"12345678\" />\r\n<meta property=\"fb:admins\" content=\"87654321\" />",
        "context": "filename=\"<head> output\" hideLineNumbers"
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  pinterest: {\r\n    richPin: true,\r\n  },\r\n}",
        "context": "filename=\"layout.js | page.js\""
      },
      {
        "language": "html",
        "code": "<meta name=\"pinterest-rich-pin\" content=\"true\" />",
        "context": "filename=\"<head> output\" hideLineNumbers"
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  other: {\r\n    custom: 'meta',\r\n  },\r\n}",
        "context": "filename=\"layout.js | page.js\""
      },
      {
        "language": "html",
        "code": "<meta name=\"custom\" content=\"meta\" />",
        "context": "filename=\"<head> output\" hideLineNumbers"
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  other: {\r\n    custom: ['meta1', 'meta2'],\r\n  },\r\n}",
        "context": "filename=\"layout.js | page.js\""
      },
      {
        "language": "html",
        "code": "<meta name=\"custom\" content=\"meta1\" /> <meta name=\"custom\" content=\"meta2\" />",
        "context": "filename=\"<head> output\" hideLineNumbers"
      },
      {
        "language": "tsx",
        "code": "import type { Metadata } from 'next'\r\n\r\nexport const metadata: Metadata = {\r\n  title: 'Next.js',\r\n}",
        "context": "filename=\"layout.tsx | page.tsx\""
      },
      {
        "language": "tsx",
        "code": "import type { Metadata } from 'next'\r\n\r\nexport function generateMetadata(): Metadata {\r\n  return {\r\n    title: 'Next.js',\r\n  }\r\n}",
        "context": "filename=\"layout.tsx | page.tsx\""
      },
      {
        "language": "tsx",
        "code": "import type { Metadata } from 'next'\r\n\r\nexport async function generateMetadata(): Promise<Metadata> {\r\n  return {\r\n    title: 'Next.js',\r\n  }\r\n}",
        "context": "filename=\"layout.tsx | page.tsx\""
      },
      {
        "language": "tsx",
        "code": "import type { Metadata } from 'next'\r\n\r\ntype Props = {\r\n  params: Promise<{ id: string }>\r\n  searchParams: Promise<{ [key: string]: string | string[] | undefined }>\r\n}\r\n\r\nexport function generateMetadata({ params, searchParams }: Props): Metadata {\r\n  return {\r\n    title: 'Next.js',\r\n  }\r\n}\r\n\r\nexport default function Page({ params, searchParams }: Props) {}",
        "context": "filename=\"layout.tsx | page.tsx\""
      },
      {
        "language": "tsx",
        "code": "import type { Metadata, ResolvingMetadata } from 'next'\r\n\r\nexport async function generateMetadata(\r\n  { params, searchParams }: Props,\r\n  parent: ResolvingMetadata\r\n): Promise<Metadata> {\r\n  return {\r\n    title: 'Next.js',\r\n  }\r\n}",
        "context": "filename=\"layout.tsx | page.tsx\""
      },
      {
        "language": "js",
        "code": "/** @type {import(\"next\").Metadata} */\r\nexport const metadata = {\r\n  title: 'Next.js',\r\n}",
        "context": "filename=\"layout.js | page.js\""
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport ReactDOM from 'react-dom'\r\n\r\nexport function PreloadResources() {\r\n  ReactDOM.preload('...', { as: '...' })\r\n  ReactDOM.preconnect('...', { crossOrigin: '...' })\r\n  ReactDOM.prefetchDNS('...')\r\n\r\n  return '...'\r\n}",
        "context": "filename=\"app/preload-resources.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport ReactDOM from 'react-dom'\r\n\r\nexport function PreloadResources() {\r\n  ReactDOM.preload('...', { as: '...' })\r\n  ReactDOM.preconnect('...', { crossOrigin: '...' })\r\n  ReactDOM.prefetchDNS('...')\r\n\r\n  return '...'\r\n}",
        "context": "filename=\"app/preload-resources.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "ReactDOM.preload(href: string, options: { as: string })",
        "context": ""
      },
      {
        "language": "html",
        "code": "<link rel=\"preload\" href=\"...\" as=\"...\" />",
        "context": "filename=\"<head> output\" hideLineNumbers"
      },
      {
        "language": "tsx",
        "code": "ReactDOM.preconnect(href: string, options?: { crossOrigin?: string })",
        "context": ""
      },
      {
        "language": "html",
        "code": "<link rel=\"preconnect\" href=\"...\" crossorigin />",
        "context": "filename=\"<head> output\" hideLineNumbers"
      },
      {
        "language": "tsx",
        "code": "ReactDOM.prefetchDNS(href: string)",
        "context": ""
      },
      {
        "language": "html",
        "code": "<link rel=\"dns-prefetch\" href=\"...\" />",
        "context": "filename=\"<head> output\" hideLineNumbers"
      },
      {
        "language": "html",
        "code": "<meta charset=\"utf-8\" />\r\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />",
        "context": ""
      },
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst config: NextConfig = {\r\n  htmlLimitedBots: /.*/,\r\n}\r\n\r\nexport default config",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  htmlLimitedBots: /.*/,\r\n}",
        "context": "filename=\"next.config.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  title: 'Acme',\r\n  openGraph: {\r\n    title: 'Acme',\r\n    description: 'Acme is a...',\r\n  },\r\n}",
        "context": "filename=\"app/layout.js\""
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  title: 'Blog',\r\n  openGraph: {\r\n    title: 'Blog',\r\n  },\r\n}\r\n\r\n// Output:\r\n// <title>Blog</title>\r\n// <meta property=\"og:title\" content=\"Blog\" />",
        "context": "filename=\"app/blog/page.js\""
      },
      {
        "language": "jsx",
        "code": "export const openGraphImage = { images: ['http://...'] }",
        "context": "filename=\"app/shared-metadata.js\""
      },
      {
        "language": "jsx",
        "code": "import { openGraphImage } from './shared-metadata'\r\n\r\nexport const metadata = {\r\n  openGraph: {\r\n    ...openGraphImage,\r\n    title: 'Home',\r\n  },\r\n}",
        "context": "filename=\"app/page.js\""
      },
      {
        "language": "jsx",
        "code": "import { openGraphImage } from '../shared-metadata'\r\n\r\nexport const metadata = {\r\n  openGraph: {\r\n    ...openGraphImage,\r\n    title: 'About',\r\n  },\r\n}",
        "context": "filename=\"app/about/page.js\""
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  title: 'Acme',\r\n  openGraph: {\r\n    title: 'Acme',\r\n    description: 'Acme is a...',\r\n  },\r\n}",
        "context": "filename=\"app/layout.js\""
      },
      {
        "language": "jsx",
        "code": "export const metadata = {\r\n  title: 'About',\r\n}\r\n\r\n// Output:\r\n// <title>About</title>\r\n// <meta property=\"og:title\" content=\"Acme\" />\r\n// <meta property=\"og:description\" content=\"Acme is a...\" />",
        "context": "filename=\"app/about/page.js\""
      }
    ],
    "content": "You can use the metadata object or the generateMetadata function to define metadata. The metadata object To define static metadata, export a Metadata object from a layout.js or page.js file. > See the Metadata Fields for a complete list of supported options. generateMetadata function Dynamic metadata depends on dynamic information, such as the current route parameters, external data, or metadata in parent segments, can be set by exporting a generateMetadata function that returns a Metadata object. Resolving generateMetadata is part of rendering the page. If the page can be pre-rendered and generateMetadata doesn't introduce dynamic behavior, the resulting metadata is included in the page’s initial HTML. Otherwise the metadata resolved from generateMetadata can be streamed after sending the initial UI. For type completion of params and searchParams, you can type the first argument with PageProps or LayoutProps for pages and layouts respectively. > Good to know: > > - Metadata can be added to layout.js and page.js files. > - Next.js will automatically resolve the metadata, and create the relevant tags for the page. > - The metadata object and generateMetadata function exports are only supported in Server Components. > - You cannot export both the metadata object and generateMetadata function from the same route segment. > - fetch requests inside generateMetadata are automatically memoized for the same data across generateMetadata, generateStaticParams, Layouts, Pages, and Server Components. > - React cache can be used if fetch is unavailable. > - File-based metadata has the higher priority and will override the metadata object and generateMetadata function. Reference Parameters generateMetadata function accepts the following parameters: - props - An object containing the parameters of the current route: - params - An object containing the dynamic route parameters object from the root segment down to the segment generateMetadata is called from. Examples: | Route | URL | params | | ------------------------------- | ----------- | ------------------------- | | app/shop/[slug]/page.js | /shop/1 | { slug: '1' } | | app/shop/[tag]/[item]/page.js | /shop/1/2 | { tag: '1', item: '2' } | | app/shop/[...slug]/page.js | /shop/1/2 | { slug: ['1', '2'] } | - searchParams - An object containing the current URL's search params. Examples: | URL | searchParams | | --------------- | -------------------- | | /shop?a=1 | { a: '1' } | | /shop?a=1&b=2 | { a: '1', b: '2' } | | /shop?a=1&a=2 | { a: ['1', '2'] } | - parent - A promise of the resolved metadata from parent route segments. Returns generateMetadata should return a Metadata object containing one or more metadata fields. > Good to know: > > - If metadata doesn't depend on runtime information, it should be defined using the static metadata object rather than generateMetadata. > - fetch requests are automatically memoized for the same data across generateMetadata, generateStaticParams, Layouts, Pages, and Server Components. React cache can be used if fetch is unavailable. > - searchParams are only available in page.js segments. > - The redirect() and notFound() Next.js methods can also be used inside generateMetadata. Metadata Fields The following fields are supported: title The title attribute is used to set the title of the document. It can be defined as a simple string or an optional template object. String default title.default can be used to provide a fallback title to child route segments that don't define a title. template title.template can be used to add a prefix or a suffix to titles defined in child route segments. > Good to know: > > - title.template applies to child route segments and not the segment it's defined in. This means: > - title.default is required when you add a title.template. > - title.template defined in layout.js will not apply to a title defined in a page.js of the same route segment. > - title.template defined in page.js has no effect because a page is always the terminating segment (it doesn't have any children route segments). > - title.template has no effect if a route has not defined a title or title.default. absolute title.absolute can be used to provide a title that ignores title.template set in parent segments. > Good to know: > > - layout.js > - title (string) and title.default define the default title for child segments (that do not define their own title). It will augment title.template from the closest parent segment if it exists. > - title.absolute defines the default title for child segments. It ignores title.template from parent segments. > - title.template defines a new title template for child segments. > - page.js > - If a page does not define its own title the closest parents resolved title will be used. > - title (string) defines the routes title. It will augment title.template from the closest parent segment if it exists. > - title.absolute defines the route title. It ignores title.template from parent segments. > - title.template has no effect in page.js because a page is always the terminating segment of a route. description Other fields metadataBase metadataBase is a convenience option to set a base URL prefix for metadata fields that require a fully qualified URL. - metadataBase allows URL-based metadata fields defined in the current route segment and below to use a relative path instead of an otherwise required absolute URL. - The field's relative path will be composed with metadataBase to form a fully qualified URL. > Good to know: > > - metadataBase is typically set in root app/layout.js to apply to URL-based metadata fields across all routes. > - All URL-based metadata fields that require absolute URLs can be configured with a metadataBase option. > - metadataBase can contain a subdomain e.g. https://app.acme.com or base path e.g. https://acme.com/start/from/here > - If a metadata field provides an absolute URL, metadataBase will be ignored. > - Using a relative path in a URL-based metadata field without configuring a metadataBase will cause a build error. > - Next.js will normalize duplicate slashes between metadataBase (e.g. https://acme.com/) and a relative field (e.g. /path) to a single slash (e.g. https://acme.com/path) URL Composition URL composition favors developer intent over default directory traversal semantics. - Trailing slashes between metadataBase and metadata fields are normalized. - An \"absolute\" path in a metadata field (that typically would replace the whole URL path) is treated as a \"relative\" path (starting from the end of metadataBase). For example, given the following metadataBase: Any metadata fields that inherit the above metadataBase and set their own value will be resolved as follows: | metadata field | Resolved URL | | -------------------------------- | -------------------------------- | | / | https://acme.com | | ./ | https://acme.com | | payments | https://acme.com/payments | | /payments | https://acme.com/payments | | ./payments | https://acme.com/payments | | ../payments | https://acme.com/payments | | https://beta.acme.com/payments | https://beta.acme.com/payments | openGraph > Good to know: > > - It may be more convenient to use the file-based Metadata API for Open Graph images. Rather than having to sync the config export with actual files, the file-based API will automatically generate the correct metadata for you. robots icons > Good to know: We recommend using the file-based Metadata API for icons where possible. Rather than having to sync the config export with actual files, the file-based API will automatically generate the correct metadata for you. > Good to know: The msapplication- meta tags are no longer supported in Chromium builds of Microsoft Edge, and thus no longer needed. themeColor > Deprecated: The themeColor option in metadata is deprecated as of Next.js 14. Please use the viewport configuration instead. colorScheme > Deprecated: The colorScheme option in metadata is deprecated as of Next.js 14. Please use the viewport configuration instead. manifest A web application manifest, as defined in the Web Application Manifest specification. twitter The Twitter specification is (surprisingly) used for more than just X (formerly known as Twitter). Learn more about the Twitter Card markup reference. viewport > Deprecated: The viewport option in metadata is deprecated as of Next.js 14. Please use the viewport configuration instead. verification appleWebApp alternates appLinks archives Describes a collection of records, documents, or other materials of historical interest (source). assets bookmarks category facebook You can connect a Facebook app or Facebook account to your webpage for certain Facebook Social Plugins Facebook Documentation > Good to know: You can specify either appId or admins, but not both. If you want to generate multiple fb:admins meta tags you can use array value. pinterest You can enable or disable Pinterest Rich Pins on your webpage. other All metadata options should be covered using the built-in support. However, there may be custom metadata tags specific to your site, or brand new metadata tags just released. You can use the other option to render any custom metadata tag. If you want to generate multiple same key meta tags you can use array value. Types You can add type safety to your metadata by using the Metadata type. If you are using the built-in TypeScript plugin in your IDE, you do not need to manually add the type, but you can still explicitly add it if you want. metadata object generateMetadata function Regular function Async function With segment props With parent metadata JavaScript Projects For JavaScript projects, you can use JSDoc to add type safety. Unsupported Metadata The following metadata types do not currently have built-in support. However, they can still be rendered in the layout or page itself. | Metadata | Recommendation | | ----------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | | Use appropriate HTTP Headers via redirect(), Proxy, Security Headers | | | Render the tag in the layout or page itself. | | | Render the tag in the layout or page itself. | | | Learn more about styling in Next.js. | | | Learn more about using scripts. | | | import stylesheets directly in the layout or page itself. | | | Use ReactDOM preload method | | | Use ReactDOM preconnect method | | | Use ReactDOM prefetchDNS method | Resource hints The element has a number of rel keywords that can be used to hint to the browser that an external resource is likely to be needed. The browser uses this information to apply preloading optimizations depending on the keyword. While the Metadata API doesn't directly support these hints, you can use new ReactDOM methods to safely insert them into the of the document. Start loading a resource early in the page rendering (browser) lifecycle. MDN Docs. Preemptively initiate a connection to an origin. MDN Docs. Attempt to resolve a domain name before resources get requested. MDN Docs. > Good to know: > > - These methods are currently only supported in Client Components, which are still Server Side Rendered on initial page load. > - Next.js in-built features such as next/font, next/image and next/script automatically handle relevant resource hints. Behavior Default Fields There are two default meta tags that are always added even if a route doesn't define metadata: - The meta charset tag sets the character encoding for the website. - The meta viewport tag sets the viewport width and scale for the website to adjust for different devices. > Good to know: You can overwrite the default viewport meta tag. Streaming metadata Streaming metadata allows Next.js to render and send the initial UI to the browser, without waiting for generateMetadata to complete. When generateMetadata resolves, the resulting metadata tags are appended to the tag. We have verified that metadata is interpreted correctly by bots that execute JavaScript and inspect the full DOM (e.g. Googlebot). For HTML-limited bots that can’t execute JavaScript (e.g. facebookexternalhit), metadata continues to block page rendering. The resulting metadata will be available in the tag. Next.js automatically detects HTML-limited bots by looking at the User Agent header. You can use the htmlLimitedBots option in your Next.js config file to override the default User Agent list. To fully disable streaming metadata: Streaming metadata improves perceived performance by reducing TTFB and can help lowering LCP time. Overriding htmlLimitedBots could lead to longer response times. Streaming metadata is an advanced feature, and the default should be sufficient for most cases. Ordering Metadata is evaluated in order, starting from the root segment down to the segment closest to the final page.js segment. For example: 1. app/layout.tsx (Root Layout) 2. app/blog/layout.tsx (Nested Blog Layout) 3. app/blog/[slug]/page.tsx (Blog Page) Merging Following the evaluation order, Metadata objects exported from multiple segments in the same route are shallowly merged together to form the final metadata output of a route. Duplicate keys are replaced based on their ordering. This means metadata with nested fields such as openGraph and robots that are defined in an earlier segment are overwritten by the last segment to define them. Overwriting fields In the example above: - title from app/layout.js is replaced by title in app/blog/page.js. - All openGraph fields from app/layout.js are replaced in app/blog/page.js because app/blog/page.js sets openGraph metadata. Note the absence of openGraph.description. If you'd like to share some nested fields between segments while overwriting others, you can pull them out into a separate variable: In the example above, the OG image is shared between app/layout.js and app/about/page.js while the titles are different. Inheriting fields Notes - title from app/layout.js is replaced by title in app/about/page.js. - All openGraph fields from app/layout.js are inherited in app/about/page.js because app/about/page.js doesn't set openGraph metadata. Version History | Version | Changes | | --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- | | v15.2.0 | Introduced streaming support to generateMetadata. | | v13.2.0 | viewport, themeColor, and colorScheme deprecated in favor of the viewport configuration. | | v13.2.0 | metadata and generateMetadata introduced. |",
    "excerpt": "You can use the metadata object or the generateMetadata function to define metadata. The metadata object To define static metadata, export a Metadata object from a layout.js or page.js file. > See the...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/04-functions/generate-metadata"
  },
  {
    "id": "01-app-03-api-reference-04-functions-generate-sitemaps",
    "path": "01-app\\03-api-reference\\04-functions\\generate-sitemaps.mdx",
    "title": "generateSitemaps",
    "description": "Learn how to use the generateSiteMaps function to create multiple sitemaps for your application.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Returns",
        "slug": "returns"
      },
      {
        "level": 2,
        "text": "URLs",
        "slug": "urls"
      },
      {
        "level": 2,
        "text": "Example",
        "slug": "example"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "import { BASE_URL } from '@/app/lib/constants'\r\n\r\nexport async function generateSitemaps() {\r\n  // Fetch the total number of products and calculate the number of sitemaps needed\r\n  return [{ id: 0 }, { id: 1 }, { id: 2 }, { id: 3 }]\r\n}\r\n\r\nexport default async function sitemap({\r\n  id,\r\n}: {\r\n  id: number\r\n}): Promise<MetadataRoute.Sitemap> {\r\n  // Google's limit is 50,000 URLs per sitemap\r\n  const start = id * 50000\r\n  const end = start + 50000\r\n  const products = await getProducts(\r\n    `SELECT id, date FROM products WHERE id BETWEEN ${start} AND ${end}`\r\n  )\r\n  return products.map((product) => ({\r\n    url: `${BASE_URL}/product/${product.id}`,\r\n    lastModified: product.date,\r\n  }))\r\n}",
        "context": "filename=\"app/product/sitemap.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { BASE_URL } from '@/app/lib/constants'\r\n\r\nexport async function generateSitemaps() {\r\n  // Fetch the total number of products and calculate the number of sitemaps needed\r\n  return [{ id: 0 }, { id: 1 }, { id: 2 }, { id: 3 }]\r\n}\r\n\r\nexport default async function sitemap({ id }) {\r\n  // Google's limit is 50,000 URLs per sitemap\r\n  const start = id * 50000\r\n  const end = start + 50000\r\n  const products = await getProducts(\r\n    `SELECT id, date FROM products WHERE id BETWEEN ${start} AND ${end}`\r\n  )\r\n  return products.map((product) => ({\r\n    url: `${BASE_URL}/product/${id}`,\r\n    lastModified: product.date,\r\n  }))\r\n}",
        "context": "filename=\"app/product/sitemap.js\" switcher"
      }
    ],
    "content": "You can use the generateSitemaps function to generate multiple sitemaps for your application. Returns The generateSitemaps returns an array of objects with an id property. URLs Your generated sitemaps will be available at /.../sitemap/[id].xml. For example, /product/sitemap/1.xml. Example For example, to split a sitemap using generateSitemaps, return an array of objects with the sitemap id. Then, use the id to generate the unique sitemaps. Version History | Version | Changes | | --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- | | v15.0.0 | generateSitemaps now generates consistent URLs between development and production | | v13.3.2 | generateSitemaps introduced. In development, you can view the generated sitemap on /.../sitemap.xml/[id]. For example, /product/sitemap.xml/1. |",
    "excerpt": "You can use the generateSitemaps function to generate multiple sitemaps for your application. Returns The generateSitemaps returns an array of objects with an id property. URLs Your generated sitemaps...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/04-functions/generate-sitemaps"
  },
  {
    "id": "01-app-03-api-reference-04-functions-generate-static-params",
    "path": "01-app\\03-api-reference\\04-functions\\generate-static-params.mdx",
    "title": "generateStaticParams",
    "description": "API reference for the generateStaticParams function.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Parameters",
        "slug": "parameters"
      },
      {
        "level": 2,
        "text": "Returns",
        "slug": "returns"
      },
      {
        "level": 2,
        "text": "Single Dynamic Segment",
        "slug": "single-dynamic-segment"
      },
      {
        "level": 2,
        "text": "Multiple Dynamic Segments",
        "slug": "multiple-dynamic-segments"
      },
      {
        "level": 2,
        "text": "Catch-all Dynamic Segment",
        "slug": "catch-all-dynamic-segment"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Static Rendering",
        "slug": "static-rendering"
      },
      {
        "level": 4,
        "text": "All paths at build time",
        "slug": "all-paths-at-build-time"
      },
      {
        "level": 4,
        "text": "Subset of paths at build time",
        "slug": "subset-of-paths-at-build-time"
      },
      {
        "level": 4,
        "text": "All paths at runtime",
        "slug": "all-paths-at-runtime"
      },
      {
        "level": 3,
        "text": "Disable rendering for unspecified paths",
        "slug": "disable-rendering-for-unspecified-paths"
      },
      {
        "level": 3,
        "text": "Multiple Dynamic Segments in a Route",
        "slug": "multiple-dynamic-segments-in-a-route"
      },
      {
        "level": 4,
        "text": "Generate params from the bottom up",
        "slug": "generate-params-from-the-bottom-up"
      },
      {
        "level": 4,
        "text": "Generate params from the top down",
        "slug": "generate-params-from-the-top-down"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "// Return a list of `params` to populate the [slug] dynamic segment\r\nexport async function generateStaticParams() {\r\n  const posts = await fetch('https://.../posts').then((res) => res.json())\r\n\r\n  return posts.map((post) => ({\r\n    slug: post.slug,\r\n  }))\r\n}\r\n\r\n// Multiple versions of this page will be statically generated\r\n// using the `params` returned by `generateStaticParams`\r\nexport default async function Page({\r\n  params,\r\n}: {\r\n  params: Promise<{ slug: string }>\r\n}) {\r\n  const { slug } = await params\r\n  // ...\r\n}",
        "context": "filename=\"app/blog/[slug]/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "// Return a list of `params` to populate the [slug] dynamic segment\r\nexport async function generateStaticParams() {\r\n  const posts = await fetch('https://.../posts').then((res) => res.json())\r\n\r\n  return posts.map((post) => ({\r\n    slug: post.slug,\r\n  }))\r\n}\r\n\r\n// Multiple versions of this page will be statically generated\r\n// using the `params` returned by `generateStaticParams`\r\nexport default async function Page({ params }) {\r\n  const { slug } = await params\r\n  // ...\r\n}",
        "context": "filename=\"app/blog/[slug]/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export function generateStaticParams() {\r\n  return [{ id: '1' }, { id: '2' }, { id: '3' }]\r\n}\r\n\r\n// Three versions of this page will be statically generated\r\n// using the `params` returned by `generateStaticParams`\r\n// - /product/1\r\n// - /product/2\r\n// - /product/3\r\nexport default async function Page({\r\n  params,\r\n}: {\r\n  params: Promise<{ id: string }>\r\n}) {\r\n  const { id } = await params\r\n  // ...\r\n}",
        "context": "filename=\"app/product/[id]/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export function generateStaticParams() {\r\n  return [{ id: '1' }, { id: '2' }, { id: '3' }]\r\n}\r\n\r\n// Three versions of this page will be statically generated\r\n// using the `params` returned by `generateStaticParams`\r\n// - /product/1\r\n// - /product/2\r\n// - /product/3\r\nexport default async function Page({ params }) {\r\n  const { id } = await params\r\n  // ...\r\n}",
        "context": "filename=\"app/product/[id]/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export function generateStaticParams() {\r\n  return [\r\n    { category: 'a', product: '1' },\r\n    { category: 'b', product: '2' },\r\n    { category: 'c', product: '3' },\r\n  ]\r\n}\r\n\r\n// Three versions of this page will be statically generated\r\n// using the `params` returned by `generateStaticParams`\r\n// - /products/a/1\r\n// - /products/b/2\r\n// - /products/c/3\r\nexport default async function Page({\r\n  params,\r\n}: {\r\n  params: Promise<{ category: string; product: string }>\r\n}) {\r\n  const { category, product } = await params\r\n  // ...\r\n}",
        "context": "filename=\"app/products/[category]/[product]/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export function generateStaticParams() {\r\n  return [\r\n    { category: 'a', product: '1' },\r\n    { category: 'b', product: '2' },\r\n    { category: 'c', product: '3' },\r\n  ]\r\n}\r\n\r\n// Three versions of this page will be statically generated\r\n// using the `params` returned by `generateStaticParams`\r\n// - /products/a/1\r\n// - /products/b/2\r\n// - /products/c/3\r\nexport default async function Page({ params }) {\r\n  const { category, product } = await params\r\n  // ...\r\n}",
        "context": "filename=\"app/products/[category]/[product]/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export function generateStaticParams() {\r\n  return [{ slug: ['a', '1'] }, { slug: ['b', '2'] }, { slug: ['c', '3'] }]\r\n}\r\n\r\n// Three versions of this page will be statically generated\r\n// using the `params` returned by `generateStaticParams`\r\n// - /product/a/1\r\n// - /product/b/2\r\n// - /product/c/3\r\nexport default async function Page({\r\n  params,\r\n}: {\r\n  params: Promise<{ slug: string[] }>\r\n}) {\r\n  const { slug } = await params\r\n  // ...\r\n}",
        "context": "filename=\"app/product/[...slug]/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export function generateStaticParams() {\r\n  return [{ slug: ['a', '1'] }, { slug: ['b', '2'] }, { slug: ['c', '3'] }]\r\n}\r\n\r\n// Three versions of this page will be statically generated\r\n// using the `params` returned by `generateStaticParams`\r\n// - /product/a/1\r\n// - /product/b/2\r\n// - /product/c/3\r\nexport default async function Page({ params }) {\r\n  const { slug } = await params\r\n  // ...\r\n}",
        "context": "filename=\"app/product/[...slug]/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export async function generateStaticParams() {\r\n  const posts = await fetch('https://.../posts').then((res) => res.json())\r\n\r\n  return posts.map((post) => ({\r\n    slug: post.slug,\r\n  }))\r\n}",
        "context": "filename=\"app/blog/[slug]/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export async function generateStaticParams() {\r\n  const posts = await fetch('https://.../posts').then((res) => res.json())\r\n\r\n  return posts.map((post) => ({\r\n    slug: post.slug,\r\n  }))\r\n}",
        "context": "filename=\"app/blog/[slug]/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export async function generateStaticParams() {\r\n  const posts = await fetch('https://.../posts').then((res) => res.json())\r\n\r\n  // Render the first 10 posts at build time\r\n  return posts.slice(0, 10).map((post) => ({\r\n    slug: post.slug,\r\n  }))\r\n}",
        "context": "filename=\"app/blog/[slug]/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export async function generateStaticParams() {\r\n  const posts = await fetch('https://.../posts').then((res) => res.json())\r\n\r\n  // Render the first 10 posts at build time\r\n  return posts.slice(0, 10).map((post) => ({\r\n    slug: post.slug,\r\n  }))\r\n}",
        "context": "filename=\"app/blog/[slug]/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "// All posts besides the top 10 will be a 404\r\nexport const dynamicParams = false\r\n\r\nexport async function generateStaticParams() {\r\n  const posts = await fetch('https://.../posts').then((res) => res.json())\r\n  const topPosts = posts.slice(0, 10)\r\n\r\n  return topPosts.map((post) => ({\r\n    slug: post.slug,\r\n  }))\r\n}",
        "context": "filename=\"app/blog/[slug]/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "// All posts besides the top 10 will be a 404\r\nexport const dynamicParams = false\r\n\r\nexport async function generateStaticParams() {\r\n  const posts = await fetch('https://.../posts').then((res) => res.json())\r\n  const topPosts = posts.slice(0, 10)\r\n\r\n  return topPosts.map((post) => ({\r\n    slug: post.slug,\r\n  }))\r\n}",
        "context": "filename=\"app/blog/[slug]/page.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "export async function generateStaticParams() {\r\n  return []\r\n}",
        "context": "filename=\"app/blog/[slug]/page.js\""
      },
      {
        "language": "jsx",
        "code": "export const dynamic = 'force-static'",
        "context": "filename=\"app/changelog/[slug]/page.js\""
      },
      {
        "language": "tsx",
        "code": "// Generate segments for both [category] and [product]\r\nexport async function generateStaticParams() {\r\n  const products = await fetch('https://.../products').then((res) => res.json())\r\n\r\n  return products.map((product) => ({\r\n    category: product.category.slug,\r\n    product: product.id,\r\n  }))\r\n}\r\n\r\nexport default function Page({\r\n  params,\r\n}: {\r\n  params: Promise<{ category: string; product: string }>\r\n}) {\r\n  // ...\r\n}",
        "context": "filename=\"app/products/[category]/[product]/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "// Generate segments for both [category] and [product]\r\nexport async function generateStaticParams() {\r\n  const products = await fetch('https://.../products').then((res) => res.json())\r\n\r\n  return products.map((product) => ({\r\n    category: product.category.slug,\r\n    product: product.id,\r\n  }))\r\n}\r\n\r\nexport default function Page({ params }) {\r\n  // ...\r\n}",
        "context": "filename=\"app/products/[category]/[product]/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "// Generate segments for [category]\r\nexport async function generateStaticParams() {\r\n  const products = await fetch('https://.../products').then((res) => res.json())\r\n\r\n  return products.map((product) => ({\r\n    category: product.category.slug,\r\n  }))\r\n}\r\n\r\nexport default function Layout({\r\n  params,\r\n}: {\r\n  params: Promise<{ category: string }>\r\n}) {\r\n  // ...\r\n}",
        "context": "filename=\"app/products/[category]/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "// Generate segments for [category]\r\nexport async function generateStaticParams() {\r\n  const products = await fetch('https://.../products').then((res) => res.json())\r\n\r\n  return products.map((product) => ({\r\n    category: product.category.slug,\r\n  }))\r\n}\r\n\r\nexport default function Layout({ params }) {\r\n  // ...\r\n}",
        "context": "filename=\"app/products/[category]/layout.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "// Generate segments for [product] using the `params` passed from\r\n// the parent segment's `generateStaticParams` function\r\nexport async function generateStaticParams({\r\n  params: { category },\r\n}: {\r\n  params: { category: string }\r\n}) {\r\n  const products = await fetch(\r\n    `https://.../products?category=${category}`\r\n  ).then((res) => res.json())\r\n\r\n  return products.map((product) => ({\r\n    product: product.id,\r\n  }))\r\n}\r\n\r\nexport default function Page({\r\n  params,\r\n}: {\r\n  params: Promise<{ category: string; product: string }>\r\n}) {\r\n  // ...\r\n}",
        "context": "filename=\"app/products/[category]/[product]/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "// Generate segments for [product] using the `params` passed from\r\n// the parent segment's `generateStaticParams` function\r\nexport async function generateStaticParams({ params: { category } }) {\r\n  const products = await fetch(\r\n    `https://.../products?category=${category}`\r\n  ).then((res) => res.json())\r\n\r\n  return products.map((product) => ({\r\n    product: product.id,\r\n  }))\r\n}\r\n\r\nexport default function Page({ params }) {\r\n  // ...\r\n}",
        "context": "filename=\"app/products/[category]/[product]/page.js\" switcher"
      },
      {
        "language": "ts",
        "code": "export async function generateStaticParams({\r\n  params: { category },\r\n}: {\r\n  params: Awaited<LayoutProps<'/products/[category]'>['params']>\r\n}) {\r\n  const products = await fetch(\r\n    `https://.../products?category=${category}`\r\n  ).then((res) => res.json())\r\n\r\n  return products.map((product) => ({\r\n    product: product.id,\r\n  }))\r\n}",
        "context": "filename=\"app/products/[category]/[product]/page.tsx\" switcher"
      }
    ],
    "content": "The generateStaticParams function can be used in combination with dynamic route segments to statically generate routes at build time instead of on-demand at request time. > Good to know: > > - You can use the dynamicParams segment config option to control what happens when a dynamic segment is visited that was not generated with generateStaticParams. > - You must return an empty array from generateStaticParams or utilize export const dynamic = 'force-static' in order to revalidate (ISR) paths at runtime. > - During next dev, generateStaticParams will be called when you navigate to a route. > - During next build, generateStaticParams runs before the corresponding Layouts or Pages are generated. > - During revalidation (ISR), generateStaticParams will not be called again. > - generateStaticParams replaces the getStaticPaths function in the Pages Router. Parameters options.params (optional) If multiple dynamic segments in a route use generateStaticParams, the child generateStaticParams function is executed once for each set of params the parent generates. The params object contains the populated params from the parent generateStaticParams, which can be used to generate the params in a child segment. Returns generateStaticParams should return an array of objects where each object represents the populated dynamic segments of a single route. - Each property in the object is a dynamic segment to be filled in for the route. - The properties name is the segment's name, and the properties value is what that segment should be filled in with. | Example Route | generateStaticParams Return Type | | -------------------------------- | ----------------------------------------- | | /product/[id] | { id: string }[] | | /products/[category]/[product] | { category: string, product: string }[] | | /products/[...slug] | { slug: string[] }[] | Single Dynamic Segment Multiple Dynamic Segments Catch-all Dynamic Segment Examples Static Rendering All paths at build time To statically render all paths at build time, supply the full list of paths to generateStaticParams: Subset of paths at build time To statically render a subset of paths at build time, and the rest the first time they're visited at runtime, return a partial list of paths: Then, by using the dynamicParams segment config option, you can control what happens when a dynamic segment is visited that was not generated with generateStaticParams. All paths at runtime To statically render all paths the first time they're visited, return an empty array (no paths will be rendered at build time) or utilize export const dynamic = 'force-static': > Good to know: You must always return an array from generateStaticParams, even if it's empty. Otherwise, the route will be dynamically rendered. Disable rendering for unspecified paths To prevent unspecified paths from being statically rendered at runtime, add the export const dynamicParams = false option in a route segment. When this config option is used, only paths provided by generateStaticParams will be served, and unspecified routes will 404 or match (in the case of catch-all routes). Multiple Dynamic Segments in a Route You can generate params for dynamic segments above the current layout or page, but not below. For example, given the app/products/[category]/[product] route: - app/products/[category]/[product]/page.js can generate params for both [category] and [product]. - app/products/[category]/layout.js can only generate params for [category]. There are two approaches to generating params for a route with multiple dynamic segments: Generate params from the bottom up Generate multiple dynamic segments from the child route segment. Generate params from the top down Generate the parent segments first and use the result to generate the child segments. A child route segment's generateStaticParams function is executed once for each segment a parent generateStaticParams generates. The child generateStaticParams function can use the params returned from the parent generateStaticParams function to dynamically generate its own segments. Notice that the params argument can be accessed synchronously and includes only parent segment params. For type completion, you can make use of the TypeScript Awaited helper in combination with either Page Props helper or Layout Props helper: > Good to know: fetch requests are automatically memoized for the same data across all generate-prefixed functions, Layouts, Pages, and Server Components. React cache can be used if fetch is unavailable. Version History | Version | Changes | | --------- | ---------------------------------- | | v13.0.0 | generateStaticParams introduced. |",
    "excerpt": "The generateStaticParams function can be used in combination with dynamic route segments to statically generate routes at build time instead of on-demand at request time. > Good to know: > > - You can...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/04-functions/generate-static-params"
  },
  {
    "id": "01-app-03-api-reference-04-functions-generate-viewport",
    "path": "01-app\\03-api-reference\\04-functions\\generate-viewport.mdx",
    "title": "generateViewport",
    "description": "API Reference for the generateViewport function.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "The  object",
        "slug": "the-object"
      },
      {
        "level": 2,
        "text": " function",
        "slug": "-function"
      },
      {
        "level": 2,
        "text": "Viewport Fields",
        "slug": "viewport-fields"
      },
      {
        "level": 3,
        "text": ", ,  and ",
        "slug": "--and-"
      },
      {
        "level": 2,
        "text": "Types",
        "slug": "types"
      },
      {
        "level": 3,
        "text": " object",
        "slug": "-object"
      },
      {
        "level": 3,
        "text": " function",
        "slug": "-function"
      },
      {
        "level": 4,
        "text": "Regular function",
        "slug": "regular-function"
      },
      {
        "level": 4,
        "text": "With segment props",
        "slug": "with-segment-props"
      },
      {
        "level": 4,
        "text": "JavaScript Projects",
        "slug": "javascript-projects"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "import type { Viewport } from 'next'\r\n\r\nexport const viewport: Viewport = {\r\n  themeColor: 'black',\r\n}\r\n\r\nexport default function Page() {}",
        "context": "filename=\"layout.tsx | page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export const viewport = {\r\n  themeColor: 'black',\r\n}\r\n\r\nexport default function Page() {}",
        "context": "filename=\"layout.jsx | page.jsx\" switcher"
      },
      {
        "language": "tsx",
        "code": "export function generateViewport({ params }) {\r\n  return {\r\n    themeColor: '...',\r\n  }\r\n}",
        "context": "filename=\"layout.tsx | page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export function generateViewport({ params }) {\r\n  return {\r\n    themeColor: '...',\r\n  }\r\n}",
        "context": "filename=\"layout.js | page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import type { Viewport } from 'next'\r\n\r\nexport const viewport: Viewport = {\r\n  themeColor: 'black',\r\n}",
        "context": "filename=\"layout.tsx | page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export const viewport = {\r\n  themeColor: 'black',\r\n}",
        "context": "filename=\"layout.jsx | page.jsx\" switcher"
      },
      {
        "language": "html",
        "code": "<meta name=\"theme-color\" content=\"black\" />",
        "context": "filename=\"<head> output\" hideLineNumbers"
      },
      {
        "language": "tsx",
        "code": "import type { Viewport } from 'next'\r\n\r\nexport const viewport: Viewport = {\r\n  themeColor: [\r\n    { media: '(prefers-color-scheme: light)', color: 'cyan' },\r\n    { media: '(prefers-color-scheme: dark)', color: 'black' },\r\n  ],\r\n}",
        "context": "filename=\"layout.tsx | page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export const viewport = {\r\n  themeColor: [\r\n    { media: '(prefers-color-scheme: light)', color: 'cyan' },\r\n    { media: '(prefers-color-scheme: dark)', color: 'black' },\r\n  ],\r\n}",
        "context": "filename=\"layout.jsx | page.jsx\" switcher"
      },
      {
        "language": "html",
        "code": "<meta name=\"theme-color\" media=\"(prefers-color-scheme: light)\" content=\"cyan\" />\r\n<meta name=\"theme-color\" media=\"(prefers-color-scheme: dark)\" content=\"black\" />",
        "context": "filename=\"<head> output\" hideLineNumbers"
      },
      {
        "language": "tsx",
        "code": "import type { Viewport } from 'next'\r\n\r\nexport const viewport: Viewport = {\r\n  width: 'device-width',\r\n  initialScale: 1,\r\n  maximumScale: 1,\r\n  userScalable: false,\r\n  // Also supported but less commonly used\r\n  // interactiveWidget: 'resizes-visual',\r\n}",
        "context": "filename=\"layout.tsx | page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export const viewport = {\r\n  width: 'device-width',\r\n  initialScale: 1,\r\n  maximumScale: 1,\r\n  userScalable: false,\r\n  // Also supported but less commonly used\r\n  // interactiveWidget: 'resizes-visual',\r\n}",
        "context": "filename=\"layout.jsx | page.jsx\" switcher"
      },
      {
        "language": "html",
        "code": "<meta\r\n  name=\"viewport\"\r\n  content=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no\"\r\n/>",
        "context": "filename=\"<head> output\" hideLineNumbers"
      },
      {
        "language": "tsx",
        "code": "import type { Viewport } from 'next'\r\n\r\nexport const viewport: Viewport = {\r\n  colorScheme: 'dark',\r\n}",
        "context": "filename=\"layout.tsx | page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export const viewport = {\r\n  colorScheme: 'dark',\r\n}",
        "context": "filename=\"layout.jsx | page.jsx\" switcher"
      },
      {
        "language": "html",
        "code": "<meta name=\"color-scheme\" content=\"dark\" />",
        "context": "filename=\"<head> output\" hideLineNumbers"
      },
      {
        "language": "tsx",
        "code": "import type { Viewport } from 'next'\r\n\r\nexport const viewport: Viewport = {\r\n  themeColor: 'black',\r\n}",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "import type { Viewport } from 'next'\r\n\r\nexport function generateViewport(): Viewport {\r\n  return {\r\n    themeColor: 'black',\r\n  }\r\n}",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "import type { Viewport } from 'next'\r\n\r\ntype Props = {\r\n  params: Promise<{ id: string }>\r\n  searchParams: Promise<{ [key: string]: string | string[] | undefined }>\r\n}\r\n\r\nexport function generateViewport({ params, searchParams }: Props): Viewport {\r\n  return {\r\n    themeColor: 'black',\r\n  }\r\n}\r\n\r\nexport default function Page({ params, searchParams }: Props) {}",
        "context": ""
      },
      {
        "language": "js",
        "code": "/** @type {import(\"next\").Viewport} */\r\nexport const viewport = {\r\n  themeColor: 'black',\r\n}",
        "context": ""
      }
    ],
    "content": "You can customize the initial viewport of the page with the static viewport object or the dynamic generateViewport function. > Good to know: > > - The viewport object and generateViewport function exports are only supported in Server Components. > - You cannot export both the viewport object and generateViewport function from the same route segment. > - If you're coming from migrating metadata exports, you can use metadata-to-viewport-export codemod to update your changes. The viewport object To define the viewport options, export a viewport object from a layout.jsx or page.jsx file. generateViewport function generateViewport should return a Viewport object containing one or more viewport fields. In TypeScript, the params argument can be typed via PageProps or LayoutProps depending on where generateViewport is defined. > Good to know: > > - If the viewport doesn't depend on runtime information, it should be defined using the static viewport object rather than generateViewport. Viewport Fields themeColor Learn more about theme-color. Simple theme color With media attribute width, initialScale, maximumScale and userScalable > Good to know: The viewport meta tag is automatically set, and manual configuration is usually unnecessary as the default is sufficient. However, the information is provided for completeness. colorScheme Learn more about color-scheme. Types You can add type safety to your viewport object by using the Viewport type. If you are using the built-in TypeScript plugin in your IDE, you do not need to manually add the type, but you can still explicitly add it if you want. viewport object generateViewport function Regular function With segment props JavaScript Projects For JavaScript projects, you can use JSDoc to add type safety. Version History | Version | Changes | | --------- | --------------------------------------------- | | v14.0.0 | viewport and generateViewport introduced. |",
    "excerpt": "You can customize the initial viewport of the page with the static viewport object or the dynamic generateViewport function. > Good to know: > > - The viewport object and generateViewport function exp...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/04-functions/generate-viewport"
  },
  {
    "id": "01-app-03-api-reference-04-functions-headers",
    "path": "01-app\\03-api-reference\\04-functions\\headers.mdx",
    "title": "headers",
    "description": "API reference for the headers function.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Reference",
        "slug": "reference"
      },
      {
        "level": 3,
        "text": "Parameters",
        "slug": "parameters"
      },
      {
        "level": 3,
        "text": "Returns",
        "slug": "returns"
      },
      {
        "level": 2,
        "text": "Good to know",
        "slug": "good-to-know"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Using the Authorization header",
        "slug": "using-the-authorization-header"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "import { headers } from 'next/headers'\r\n\r\nexport default async function Page() {\r\n  const headersList = await headers()\r\n  const userAgent = headersList.get('user-agent')\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { headers } from 'next/headers'\r\n\r\nexport default async function Page() {\r\n  const headersList = await headers()\r\n  const userAgent = headersList.get('user-agent')\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { headers } from 'next/headers'\r\n\r\nexport default async function Page() {\r\n  const authorization = (await headers()).get('authorization')\r\n  const res = await fetch('...', {\r\n    headers: { authorization }, // Forward the authorization header\r\n  })\r\n  const user = await res.json()\r\n\r\n  return <h1>{user.name}</h1>\r\n}",
        "context": "filename=\"app/page.js\""
      }
    ],
    "content": "headers is an async function that allows you to read the HTTP incoming request headers from a Server Component. Reference Parameters headers does not take any parameters. Returns headers returns a read-only Web Headers object. - Headers.entries(): Returns an iterator allowing to go through all key/value pairs contained in this object. - Headers.forEach(): Executes a provided function once for each key/value pair in this Headers object. - Headers.get(): Returns a String sequence of all the values of a header within a Headers object with a given name. - Headers.has(): Returns a boolean stating whether a Headers object contains a certain header. - Headers.keys(): Returns an iterator allowing you to go through all keys of the key/value pairs contained in this object. - Headers.values(): Returns an iterator allowing you to go through all values of the key/value pairs contained in this object. Good to know - headers is an asynchronous function that returns a promise. You must use async/await or React's use function. - In version 14 and earlier, headers was a synchronous function. To help with backwards compatibility, you can still access it synchronously in Next.js 15, but this behavior will be deprecated in the future. - Since headers is read-only, you cannot set or delete the outgoing request headers. - headers is a Dynamic API whose returned values cannot be known ahead of time. Using it in will opt a route into dynamic rendering. Examples Using the Authorization header Version History | Version | Changes | | ------------ | ------------------------------------------------------------------------------------------------------ | | v15.0.0-RC | headers is now an async function. A codemod is available. | | v13.0.0 | headers introduced. |",
    "excerpt": "headers is an async function that allows you to read the HTTP incoming request headers from a Server Component. Reference Parameters headers does not take any parameters. Returns headers returns a rea...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/04-functions/headers"
  },
  {
    "id": "01-app-03-api-reference-04-functions-image-response",
    "path": "01-app\\03-api-reference\\04-functions\\image-response.mdx",
    "title": "ImageResponse",
    "description": "API Reference for the ImageResponse constructor.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Reference",
        "slug": "reference"
      },
      {
        "level": 3,
        "text": "Parameters",
        "slug": "parameters"
      },
      {
        "level": 3,
        "text": "Supported HTML and CSS features",
        "slug": "supported-html-and-css-features"
      },
      {
        "level": 2,
        "text": "Behavior",
        "slug": "behavior"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Route Handlers",
        "slug": "route-handlers"
      },
      {
        "level": 3,
        "text": "File-based Metadata",
        "slug": "file-based-metadata"
      },
      {
        "level": 3,
        "text": "Custom fonts",
        "slug": "custom-fonts"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "jsx",
        "code": "import { ImageResponse } from 'next/og'\r\n\r\nnew ImageResponse(\r\n  element: ReactElement,\r\n  options: {\r\n    width?: number = 1200\r\n    height?: number = 630\r\n    emoji?: 'twemoji' | 'blobmoji' | 'noto' | 'openmoji' = 'twemoji',\r\n    fonts?: {\r\n      name: string,\r\n      data: ArrayBuffer,\r\n      weight: number,\r\n      style: 'normal' | 'italic'\r\n    }[]\r\n    debug?: boolean = false\r\n\r\n    // Options that will be passed to the HTTP response\r\n    status?: number = 200\r\n    statusText?: string\r\n    headers?: Record<string, string>\r\n  },\r\n)",
        "context": ""
      },
      {
        "language": "js",
        "code": "import { ImageResponse } from 'next/og'\r\n\r\nexport async function GET() {\r\n  try {\r\n    return new ImageResponse(\r\n      (\r\n        <div\r\n          style={{\r\n            height: '100%',\r\n            width: '100%',\r\n            display: 'flex',\r\n            flexDirection: 'column',\r\n            alignItems: 'center',\r\n            justifyContent: 'center',\r\n            backgroundColor: 'white',\r\n            padding: '40px',\r\n          }}\r\n        >\r\n          <div\r\n            style={{\r\n              fontSize: 60,\r\n              fontWeight: 'bold',\r\n              color: 'black',\r\n              textAlign: 'center',\r\n            }}\r\n          >\r\n            Welcome to My Site\r\n          </div>\r\n          <div\r\n            style={{\r\n              fontSize: 30,\r\n              color: '#666',\r\n              marginTop: '20px',\r\n            }}\r\n          >\r\n            Generated with Next.js ImageResponse\r\n          </div>\r\n        </div>\r\n      ),\r\n      {\r\n        width: 1200,\r\n        height: 630,\r\n      }\r\n    )\r\n  } catch (e) {\r\n    console.log(`${e.message}`)\r\n    return new Response(`Failed to generate the image`, {\r\n      status: 500,\r\n    })\r\n  }\r\n}",
        "context": "filename=\"app/api/route.js\""
      },
      {
        "language": "tsx",
        "code": "import { ImageResponse } from 'next/og'\r\n\r\n// Image metadata\r\nexport const alt = 'My site'\r\nexport const size = {\r\n  width: 1200,\r\n  height: 630,\r\n}\r\n\r\nexport const contentType = 'image/png'\r\n\r\n// Image generation\r\nexport default async function Image() {\r\n  return new ImageResponse(\r\n    (\r\n      // ImageResponse JSX element\r\n      <div\r\n        style={{\r\n          fontSize: 128,\r\n          background: 'white',\r\n          width: '100%',\r\n          height: '100%',\r\n          display: 'flex',\r\n          alignItems: 'center',\r\n          justifyContent: 'center',\r\n        }}\r\n      >\r\n        My site\r\n      </div>\r\n    ),\r\n    // ImageResponse options\r\n    {\r\n      // For convenience, we can re-use the exported opengraph-image\r\n      // size config to also set the ImageResponse's width and height.\r\n      ...size,\r\n    }\r\n  )\r\n}",
        "context": "filename=\"app/opengraph-image.tsx\""
      },
      {
        "language": "tsx",
        "code": "import { ImageResponse } from 'next/og'\r\nimport { readFile } from 'node:fs/promises'\r\nimport { join } from 'node:path'\r\n\r\n// Image metadata\r\nexport const alt = 'My site'\r\nexport const size = {\r\n  width: 1200,\r\n  height: 630,\r\n}\r\n\r\nexport const contentType = 'image/png'\r\n\r\n// Image generation\r\nexport default async function Image() {\r\n  // Font loading, process.cwd() is Next.js project directory\r\n  const interSemiBold = await readFile(\r\n    join(process.cwd(), 'assets/Inter-SemiBold.ttf')\r\n  )\r\n\r\n  return new ImageResponse(\r\n    (\r\n      // ...\r\n    ),\r\n    // ImageResponse options\r\n    {\r\n      // For convenience, we can re-use the exported opengraph-image\r\n      // size config to also set the ImageResponse's width and height.\r\n      ...size,\r\n      fonts: [\r\n        {\r\n          name: 'Inter',\r\n          data: interSemiBold,\r\n          style: 'normal',\r\n          weight: 400,\r\n        },\r\n      ],\r\n    }\r\n  )\r\n}",
        "context": "filename=\"app/opengraph-image.tsx\""
      }
    ],
    "content": "The ImageResponse constructor allows you to generate dynamic images using JSX and CSS. This is useful for generating social media images such as Open Graph images, Twitter cards, and more. Reference Parameters The following parameters are available for ImageResponse: > Examples are available in the Vercel OG Playground. Supported HTML and CSS features ImageResponse supports common CSS properties including flexbox and absolute positioning, custom fonts, text wrapping, centering, and nested images. Please refer to Satori’s documentation for a list of supported HTML and CSS features. Behavior - ImageResponse uses @vercel/og, Satori, and Resvg to convert HTML and CSS into PNG. - Only flexbox and a subset of CSS properties are supported. Advanced layouts (e.g. display: grid) will not work. - Maximum bundle size of 500KB. The bundle size includes your JSX, CSS, fonts, images, and any other assets. If you exceed the limit, consider reducing the size of any assets or fetching at runtime. - Only ttf, otf, and woff font formats are supported. To maximize the font parsing speed, ttf or otf are preferred over woff. Examples Route Handlers ImageResponse can be used in Route Handlers to generate images dynamically at request time. File-based Metadata You can use ImageResponse in a opengraph-image.tsx file to generate Open Graph images at build time or dynamically at request time. Custom fonts You can use custom fonts in your ImageResponse by providing a fonts array in the options. Version History | Version | Changes | | --------- | ----------------------------------------------------- | | v14.0.0 | ImageResponse moved from next/server to next/og | | v13.3.0 | ImageResponse can be imported from next/server. | | v13.0.0 | ImageResponse introduced via @vercel/og package. |",
    "excerpt": "The ImageResponse constructor allows you to generate dynamic images using JSX and CSS. This is useful for generating social media images such as Open Graph images, Twitter cards, and more. Reference P...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/04-functions/image-response"
  },
  {
    "id": "01-app-03-api-reference-04-functions-index",
    "path": "01-app\\03-api-reference\\04-functions\\index.mdx",
    "title": "Functions",
    "description": "API Reference for Next.js Functions and Hooks.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/04-functions"
  },
  {
    "id": "01-app-03-api-reference-04-functions-next-request",
    "path": "01-app\\03-api-reference\\04-functions\\next-request.mdx",
    "title": "NextRequest",
    "description": "API Reference for NextRequest.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "// Given incoming request /home\r\n// Set a cookie to hide the banner\r\n// request will have a `Set-Cookie:show-banner=false;path=/home` header\r\nrequest.cookies.set('show-banner', 'false')",
        "context": ""
      },
      {
        "language": "ts",
        "code": "// Given incoming request /home\r\n// { name: 'show-banner', value: 'false', Path: '/home' }\r\nrequest.cookies.get('show-banner')",
        "context": ""
      },
      {
        "language": "ts",
        "code": "// Given incoming request /home\r\n// [\r\n//   { name: 'experiments', value: 'new-pricing-page', Path: '/home' },\r\n//   { name: 'experiments', value: 'winter-launch', Path: '/home' },\r\n// ]\r\nrequest.cookies.getAll('experiments')\r\n// Alternatively, get all cookies for the request\r\nrequest.cookies.getAll()",
        "context": ""
      },
      {
        "language": "ts",
        "code": "// Returns true for deleted, false is nothing is deleted\r\nrequest.cookies.delete('experiments')",
        "context": ""
      },
      {
        "language": "ts",
        "code": "// Returns true if cookie exists, false if it does not\r\nrequest.cookies.has('experiments')",
        "context": ""
      },
      {
        "language": "ts",
        "code": "request.cookies.clear()",
        "context": ""
      },
      {
        "language": "ts",
        "code": "// Given a request to /home, pathname is /home\r\nrequest.nextUrl.pathname\r\n// Given a request to /home?name=lee, searchParams is { 'name': 'lee' }\r\nrequest.nextUrl.searchParams",
        "context": ""
      }
    ],
    "content": "NextRequest extends the Web Request API with additional convenience methods. cookies Read or mutate the Set-Cookie header of the request. set(name, value) Given a name, set a cookie with the given value on the request. get(name) Given a cookie name, return the value of the cookie. If the cookie is not found, undefined is returned. If multiple cookies are found, the first one is returned. getAll() Given a cookie name, return the values of the cookie. If no name is given, return all cookies on the request. delete(name) Given a cookie name, delete the cookie from the request. has(name) Given a cookie name, return true if the cookie exists on the request. clear() Remove the Set-Cookie header from the request. nextUrl Extends the native URL API with additional convenience methods, including Next.js specific properties. The following options are available: | Property | Type | Description | | ----------------- | ------------------------- | -------------------------------------------------------------------------------------------------------------------------------------- | | basePath | string | The base path of the URL. | | buildId | string \\| undefined | The build identifier of the Next.js application. Can be customized. | | defaultLocale | string \\| undefined | The default locale for internationalization. | | domainLocale | | | | - defaultLocale | string | The default locale within a domain. | | - domain | string | The domain associated with a specific locale. | | - http | boolean \\| undefined | Indicates if the domain is using HTTP. | | locales | string[] \\| undefined | An array of available locales. | | locale | string \\| undefined | The currently active locale. | | url | URL | The URL object. | | Property | Type | Description | | -------------- | ----------------------- | ------------------------------------------------------------------------------------------------------------------------------------ | | basePath | string | The base path of the URL. | | buildId | string \\| undefined | The build identifier of the Next.js application. Can be customized. | | pathname | string | The pathname of the URL. | | searchParams | Object | The search parameters of the URL. | > Note: The internationalization properties from the Pages Router are not available for usage in the App Router. Learn more about internationalization with the App Router. Version History | Version | Changes | | --------- | ----------------------- | | v15.0.0 | ip and geo removed. |",
    "excerpt": "NextRequest extends the Web Request API with additional convenience methods. cookies Read or mutate the Set-Cookie header of the request. set(name, value) Given a name, set a cookie with the given val...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/04-functions/next-request"
  },
  {
    "id": "01-app-03-api-reference-04-functions-next-response",
    "path": "01-app\\03-api-reference\\04-functions\\next-response.mdx",
    "title": "NextResponse",
    "description": "API Reference for NextResponse.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "// Given incoming request /home\r\nlet response = NextResponse.next()\r\n// Set a cookie to hide the banner\r\nresponse.cookies.set('show-banner', 'false')\r\n// Response will have a `Set-Cookie:show-banner=false;path=/home` header\r\nreturn response",
        "context": ""
      },
      {
        "language": "ts",
        "code": "// Given incoming request /home\r\nlet response = NextResponse.next()\r\n// { name: 'show-banner', value: 'false', Path: '/home' }\r\nresponse.cookies.get('show-banner')",
        "context": ""
      },
      {
        "language": "ts",
        "code": "// Given incoming request /home\r\nlet response = NextResponse.next()\r\n// [\r\n//   { name: 'experiments', value: 'new-pricing-page', Path: '/home' },\r\n//   { name: 'experiments', value: 'winter-launch', Path: '/home' },\r\n// ]\r\nresponse.cookies.getAll('experiments')\r\n// Alternatively, get all cookies for the response\r\nresponse.cookies.getAll()",
        "context": ""
      },
      {
        "language": "ts",
        "code": "// Given incoming request /home\r\nlet response = NextResponse.next()\r\n// Returns true for deleted, false if nothing is deleted\r\nresponse.cookies.delete('experiments')",
        "context": ""
      },
      {
        "language": "ts",
        "code": "import { NextResponse } from 'next/server'\r\n\r\nexport async function GET(request: Request) {\r\n  return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 })\r\n}",
        "context": "filename=\"app/api/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { NextResponse } from 'next/server'\r\n\r\nexport async function GET(request) {\r\n  return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 })\r\n}",
        "context": "filename=\"app/api/route.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { NextResponse } from 'next/server'\r\n\r\nreturn NextResponse.redirect(new URL('/new', request.url))",
        "context": ""
      },
      {
        "language": "ts",
        "code": "import { NextResponse } from 'next/server'\r\n\r\n// Given an incoming request...\r\nconst loginUrl = new URL('/login', request.url)\r\n// Add ?from=/incoming-url to the /login URL\r\nloginUrl.searchParams.set('from', request.nextUrl.pathname)\r\n// And redirect to the new URL\r\nreturn NextResponse.redirect(loginUrl)",
        "context": ""
      },
      {
        "language": "ts",
        "code": "import { NextResponse } from 'next/server'\r\n\r\n// Incoming request: /about, browser shows /about\r\n// Rewritten request: /proxy, browser shows /about\r\nreturn NextResponse.rewrite(new URL('/proxy', request.url))",
        "context": ""
      },
      {
        "language": "ts",
        "code": "import { NextResponse } from 'next/server'\r\n\r\nreturn NextResponse.next()",
        "context": ""
      },
      {
        "language": "ts",
        "code": "import { NextResponse } from 'next/server'\r\n\r\n// Given an incoming request...\r\nconst newHeaders = new Headers(request.headers)\r\n// Add a new header\r\nnewHeaders.set('x-version', '123')\r\n// Forward the modified request headers upstream\r\nreturn NextResponse.next({\r\n  request: {\r\n    // New request headers\r\n    headers: newHeaders,\r\n  },\r\n})",
        "context": ""
      },
      {
        "language": "ts",
        "code": "import { type NextRequest, NextResponse } from 'next/server'\r\n\r\nasync function proxy(request: NextRequest) {\r\n  const headers = await injectAuth(request.headers)\r\n  // DO NOT forward headers like this\r\n  return NextResponse.next({ headers })\r\n}",
        "context": ""
      },
      {
        "language": "ts",
        "code": "import { type NextRequest, NextResponse } from 'next/server'\r\n\r\nfunction proxy(request: NextRequest) {\r\n  const incoming = new Headers(request.headers)\r\n  const forwarded = new Headers()\r\n\r\n  for (const [name, value] of incoming) {\r\n    const headerName = name.toLowerCase()\r\n    // Keep only known-safe headers, discard custom x-* and other sensitive ones\r\n    if (\r\n      !headerName.startsWith('x-') &&\r\n      headerName !== 'authorization' &&\r\n      headerName !== 'cookie'\r\n    ) {\r\n      // Preserve original header name casing\r\n      forwarded.set(name, value)\r\n    }\r\n  }\r\n\r\n  return NextResponse.next({\r\n    request: {\r\n      headers: forwarded,\r\n    },\r\n  })\r\n}",
        "context": ""
      }
    ],
    "content": "NextResponse extends the Web Response API with additional convenience methods. cookies Read or mutate the Set-Cookie header of the response. set(name, value) Given a name, set a cookie with the given value on the response. get(name) Given a cookie name, return the value of the cookie. If the cookie is not found, undefined is returned. If multiple cookies are found, the first one is returned. getAll() Given a cookie name, return the values of the cookie. If no name is given, return all cookies on the response. delete(name) Given a cookie name, delete the cookie from the response. json() Produce a response with the given JSON body. redirect() Produce a response that redirects to a URL. The URL can be created and modified before being used in the NextResponse.redirect() method. For example, you can use the request.nextUrl property to get the current URL, and then modify it to redirect to a different URL. rewrite() Produce a response that rewrites (proxies) the given URL while preserving the original URL. next() The next() method is useful for Proxy, as it allows you to return early and continue routing. You can also forward headers upstream when producing the response, using NextResponse.next({ request: { headers } }): This forwards newHeaders upstream to the target page, route, or server action, and does not expose them to the client. While this pattern is useful for passing data upstream, it should be used with caution because the headers containing this data may be forwarded to external services. In contrast, NextResponse.next({ headers }) is a shorthand for sending headers from proxy to the client. This is NOT good practice and should be avoided. Among other reasons because setting response headers like Content-Type, can override framework expectations (for example, the Content-Type used by Server Actions), leading to failed submissions or broken streaming responses. In general, avoid copying all incoming request headers because doing so can leak sensitive data to clients or upstream services. Prefer a defensive approach by creating a subset of incoming request headers using an allow-list. For example, you might discard custom x- headers and only forward known-safe headers:",
    "excerpt": "NextResponse extends the Web Response API with additional convenience methods. cookies Read or mutate the Set-Cookie header of the response. set(name, value) Given a name, set a cookie with the given...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/04-functions/next-response"
  },
  {
    "id": "01-app-03-api-reference-04-functions-not-found",
    "path": "01-app\\03-api-reference\\04-functions\\not-found.mdx",
    "title": "notFound",
    "description": "API Reference for the notFound function.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "jsx",
        "code": "import { notFound } from 'next/navigation'\r\n\r\nasync function fetchUser(id) {\r\n  const res = await fetch('https://...')\r\n  if (!res.ok) return undefined\r\n  return res.json()\r\n}\r\n\r\nexport default async function Profile({ params }) {\r\n  const { id } = await params\r\n  const user = await fetchUser(id)\r\n\r\n  if (!user) {\r\n    notFound()\r\n  }\r\n\r\n  // ...\r\n}",
        "context": "filename=\"app/user/[id]/page.js\""
      }
    ],
    "content": "The notFound function allows you to render the not-found file within a route segment as well as inject a tag. notFound() Invoking the notFound() function throws a NEXTHTTPERRORFALLBACK;404 error and terminates rendering of the route segment in which it was thrown. Specifying a not-found file allows you to gracefully handle such errors by rendering a Not Found UI within the segment. > Good to know: notFound() does not require you to use return notFound() due to using the TypeScript never type. Version History | Version | Changes | | --------- | ---------------------- | | v13.0.0 | notFound introduced. |",
    "excerpt": "The notFound function allows you to render the not-found file within a route segment as well as inject a tag. notFound() Invoking the notFound() function throws a NEXTHTTPERRORFALLBACK;404 error and t...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/04-functions/not-found"
  },
  {
    "id": "01-app-03-api-reference-04-functions-permanentRedirect",
    "path": "01-app\\03-api-reference\\04-functions\\permanentRedirect.mdx",
    "title": "permanentRedirect",
    "description": "API Reference for the permanentRedirect function.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Parameters",
        "slug": "parameters"
      },
      {
        "level": 2,
        "text": "Returns",
        "slug": "returns"
      },
      {
        "level": 2,
        "text": "Example",
        "slug": "example"
      }
    ],
    "codeBlocks": [
      {
        "language": "js",
        "code": "permanentRedirect(path, type)",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import { permanentRedirect } from 'next/navigation'\r\n\r\nasync function fetchTeam(id) {\r\n  const res = await fetch('https://...')\r\n  if (!res.ok) return undefined\r\n  return res.json()\r\n}\r\n\r\nexport default async function Profile({ params }) {\r\n  const { id } = await params\r\n  const team = await fetchTeam(id)\r\n  if (!team) {\r\n    permanentRedirect('/login')\r\n  }\r\n\r\n  // ...\r\n}",
        "context": "filename=\"app/team/[id]/page.js\""
      }
    ],
    "content": "The permanentRedirect function allows you to redirect the user to another URL. permanentRedirect can be used in Server Components, Client Components, Route Handlers, and Server Actions. When used in a streaming context, this will insert a meta tag to emit the redirect on the client side. When used in a server action, it will serve a 303 HTTP redirect response to the caller. Otherwise, it will serve a 308 (Permanent) HTTP redirect response to the caller. If a resource doesn't exist, you can use the notFound function instead. > Good to know: If you prefer to return a 307 (Temporary) HTTP redirect instead of 308 (Permanent), you can use the redirect function instead. Parameters The permanentRedirect function accepts two arguments: | Parameter | Type | Description | | --------- | ------------------------------------------------------------- | ----------------------------------------------------------- | | path | string | The URL to redirect to. Can be a relative or absolute path. | | type | 'replace' (default) or 'push' (default in Server Actions) | The type of redirect to perform. | By default, permanentRedirect will use push (adding a new entry to the browser history stack) in Server Actions and replace (replacing the current URL in the browser history stack) everywhere else. You can override this behavior by specifying the type parameter. The type parameter has no effect when used in Server Components. Returns permanentRedirect does not return a value. Example Invoking the permanentRedirect() function throws a NEXTREDIRECT error and terminates rendering of the route segment in which it was thrown. > Good to know: permanentRedirect does not require you to use return permanentRedirect() as it uses the TypeScript never type.",
    "excerpt": "The permanentRedirect function allows you to redirect the user to another URL. permanentRedirect can be used in Server Components, Client Components, Route Handlers, and Server Actions. When used in a...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/04-functions/permanentRedirect"
  },
  {
    "id": "01-app-03-api-reference-04-functions-redirect",
    "path": "01-app\\03-api-reference\\04-functions\\redirect.mdx",
    "title": "redirect",
    "description": "API Reference for the redirect function.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Reference",
        "slug": "reference"
      },
      {
        "level": 3,
        "text": "Parameters",
        "slug": "parameters"
      },
      {
        "level": 3,
        "text": "Returns",
        "slug": "returns"
      },
      {
        "level": 2,
        "text": "Behavior",
        "slug": "behavior"
      },
      {
        "level": 2,
        "text": "Example",
        "slug": "example"
      },
      {
        "level": 3,
        "text": "Server Component",
        "slug": "server-component"
      },
      {
        "level": 3,
        "text": "Client Component",
        "slug": "client-component"
      },
      {
        "level": 2,
        "text": "FAQ",
        "slug": "faq"
      },
      {
        "level": 3,
        "text": "Why does  use 307 and 308?",
        "slug": "why-does-use-307-and-308"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "js",
        "code": "redirect(path, type)",
        "context": ""
      },
      {
        "language": "ts",
        "code": "import { redirect, RedirectType } from 'next/navigation'\r\n\r\nredirect('/redirect-to', RedirectType.replace)\r\n// or\r\nredirect('/redirect-to', RedirectType.push)",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "import { redirect } from 'next/navigation'\r\n\r\nasync function fetchTeam(id: string) {\r\n  const res = await fetch('https://...')\r\n  if (!res.ok) return undefined\r\n  return res.json()\r\n}\r\n\r\nexport default async function Profile({\r\n  params,\r\n}: {\r\n  params: Promise<{ id: string }>\r\n}) {\r\n  const { id } = await params\r\n  const team = await fetchTeam(id)\r\n\r\n  if (!team) {\r\n    redirect('/login')\r\n  }\r\n\r\n  // ...\r\n}",
        "context": "filename=\"app/team/[id]/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { redirect } from 'next/navigation'\r\n\r\nasync function fetchTeam(id) {\r\n  const res = await fetch('https://...')\r\n  if (!res.ok) return undefined\r\n  return res.json()\r\n}\r\n\r\nexport default async function Profile({ params }) {\r\n  const { id } = await params\r\n  const team = await fetchTeam(id)\r\n\r\n  if (!team) {\r\n    redirect('/login')\r\n  }\r\n\r\n  // ...\r\n}",
        "context": "filename=\"app/team/[id]/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { redirect, usePathname } from 'next/navigation'\r\n\r\nexport function ClientRedirect() {\r\n  const pathname = usePathname()\r\n\r\n  if (pathname.startsWith('/admin') && !pathname.includes('/login')) {\r\n    redirect('/admin/login')\r\n  }\r\n\r\n  return <div>Login Page</div>\r\n}",
        "context": "filename=\"components/client-redirect.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { redirect, usePathname } from 'next/navigation'\r\n\r\nexport function ClientRedirect() {\r\n  const pathname = usePathname()\r\n\r\n  if (pathname.startsWith('/admin') && !pathname.includes('/login')) {\r\n    redirect('/admin/login')\r\n  }\r\n\r\n  return <div>Login Page</div>\r\n}",
        "context": "filename=\"components/client-redirect.jsx\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { navigate } from './actions'\r\n\r\nexport function ClientRedirect() {\r\n  return (\r\n    <form action={navigate}>\r\n      <input type=\"text\" name=\"id\" />\r\n      <button>Submit</button>\r\n    </form>\r\n  )\r\n}",
        "context": "filename=\"app/client-redirect.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { navigate } from './actions'\r\n\r\nexport function ClientRedirect() {\r\n  return (\r\n    <form action={navigate}>\r\n      <input type=\"text\" name=\"id\" />\r\n      <button>Submit</button>\r\n    </form>\r\n  )\r\n}",
        "context": "filename=\"app/client-redirect.jsx\" switcher"
      },
      {
        "language": "ts",
        "code": "'use server'\r\n\r\nimport { redirect } from 'next/navigation'\r\n\r\nexport async function navigate(data: FormData) {\r\n  redirect(`/posts/${data.get('id')}`)\r\n}",
        "context": "filename=\"app/actions.ts\" switcher"
      },
      {
        "language": "js",
        "code": "'use server'\r\n\r\nimport { redirect } from 'next/navigation'\r\n\r\nexport async function navigate(data) {\r\n  redirect(`/posts/${data.get('id')}`)\r\n}",
        "context": "filename=\"app/actions.js\" switcher"
      }
    ],
    "content": "The redirect function allows you to redirect the user to another URL. redirect can be used while rendering in Server and Client Components, Route Handlers, and Server Actions. When used in a streaming context, this will insert a meta tag to emit the redirect on the client side. When used in a server action, it will serve a 303 HTTP redirect response to the caller. Otherwise, it will serve a 307 HTTP redirect response to the caller. If a resource doesn't exist, you can use the notFound function instead. Reference Parameters The redirect function accepts two arguments: | Parameter | Type | Description | | --------- | ------------------------------------------------------------- | ----------------------------------------------------------- | | path | string | The URL to redirect to. Can be a relative or absolute path. | | type | 'replace' (default) or 'push' (default in Server Actions) | The type of redirect to perform. | By default, redirect will use push (adding a new entry to the browser history stack) in Server Actions and replace (replacing the current URL in the browser history stack) everywhere else. You can override this behavior by specifying the type parameter. The RedirectType object contains the available options for the type parameter. The type parameter has no effect when used in Server Components. Returns redirect does not return a value. Behavior - In Server Actions and Route Handlers, redirect should be called outside the try block when using try/catch statements. - If you prefer to return a 308 (Permanent) HTTP redirect instead of 307 (Temporary), you can use the permanentRedirect function instead. - redirect throws an error so it should be called outside the try block when using try/catch statements. - redirect can be called in Client Components during the rendering process but not in event handlers. You can use the useRouter hook instead. - redirect also accepts absolute URLs and can be used to redirect to external links. - If you'd like to redirect before the render process, use next.config.js or Proxy. Example Server Component Invoking the redirect() function throws a NEXTREDIRECT error and terminates rendering of the route segment in which it was thrown. > Good to know: redirect does not require you to use return redirect() as it uses the TypeScript never type. Client Component redirect can be directly used in a Client Component. > Good to know: When using redirect in a Client Component on initial page load during Server-Side Rendering (SSR), it will perform a server-side redirect. redirect can be used in a Client Component through a Server Action. If you need to use an event handler to redirect the user, you can use the useRouter hook. FAQ Why does redirect use 307 and 308? When using redirect() you may notice that the status codes used are 307 for a temporary redirect, and 308 for a permanent redirect. While traditionally a 302 was used for a temporary redirect, and a 301 for a permanent redirect, many browsers changed the request method of the redirect, from a POST to GET request when using a 302, regardless of the origins request method. Taking the following example of a redirect from /users to /people, if you make a POST request to /users to create a new user, and are conforming to a 302 temporary redirect, the request method will be changed from a POST to a GET request. This doesn't make sense, as to create a new user, you should be making a POST request to /people, and not a GET request. The introduction of the 307 status code means that the request method is preserved as POST. - 302 - Temporary redirect, will change the request method from POST to GET - 307 - Temporary redirect, will preserve the request method as POST The redirect() method uses a 307 by default, instead of a 302 temporary redirect, meaning your requests will always be preserved as POST requests. Learn more about HTTP Redirects. Version History | Version | Changes | | --------- | ---------------------- | | v13.0.0 | redirect introduced. |",
    "excerpt": "The redirect function allows you to redirect the user to another URL. redirect can be used while rendering in Server and Client Components, Route Handlers, and Server Actions. When used in a streaming...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/04-functions/redirect"
  },
  {
    "id": "01-app-03-api-reference-04-functions-refresh",
    "path": "01-app\\03-api-reference\\04-functions\\refresh.mdx",
    "title": "refresh",
    "description": "API Reference for the refresh function.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Usage",
        "slug": "usage"
      },
      {
        "level": 2,
        "text": "Parameters",
        "slug": "parameters"
      },
      {
        "level": 2,
        "text": "Returns",
        "slug": "returns"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Error when used outside Server Actions",
        "slug": "error-when-used-outside-server-actions"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "refresh(): void;",
        "context": ""
      },
      {
        "language": "ts",
        "code": "'use server'\r\n\r\nimport { refresh } from 'next/cache'\r\nimport { redirect } from 'next/navigation'\r\n\r\nexport async function createPost(formData: FormData) {\r\n  const title = formData.get('title')\r\n  const content = formData.get('content')\r\n\r\n  // Create the post in your database\r\n  const post = await db.post.create({\r\n    data: { title, content },\r\n  })\r\n\r\n  refresh()\r\n}",
        "context": "filename=\"app/actions.ts\" switcher"
      },
      {
        "language": "js",
        "code": "'use server'\r\n\r\nimport { refresh } from 'next/cache'\r\nimport { redirect } from 'next/navigation'\r\n\r\nexport async function createPost(formData) {\r\n  const title = formData.get('title')\r\n  const content = formData.get('content')\r\n\r\n  // Create the post in your database\r\n  const post = await db.post.create({\r\n    data: { title, content },\r\n  })\r\n\r\n  refresh()\r\n}",
        "context": "filename=\"app/actions.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { refresh } from 'next/cache'\r\n\r\nexport async function POST() {\r\n  // This will throw an error\r\n  refresh()\r\n}",
        "context": "filename=\"app/api/posts/route.ts\" switcher"
      }
    ],
    "content": "refresh allows you to refresh the client router from within a Server Action. Usage refresh can only be called from within Server Actions. It cannot be used in Route Handlers, Client Components, or any other context. Parameters Returns refresh does not return a value. Examples Error when used outside Server Actions",
    "excerpt": "refresh allows you to refresh the client router from within a Server Action. Usage refresh can only be called from within Server Actions. It cannot be used in Route Handlers, Client Components, or any...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/04-functions/refresh"
  },
  {
    "id": "01-app-03-api-reference-04-functions-revalidatePath",
    "path": "01-app\\03-api-reference\\04-functions\\revalidatePath.mdx",
    "title": "revalidatePath",
    "description": "API Reference for the revalidatePath function.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Usage",
        "slug": "usage"
      },
      {
        "level": 2,
        "text": "Parameters",
        "slug": "parameters"
      },
      {
        "level": 2,
        "text": "Returns",
        "slug": "returns"
      },
      {
        "level": 2,
        "text": "What can be invalidated",
        "slug": "what-can-be-invalidated"
      },
      {
        "level": 2,
        "text": "Relationship with  and ",
        "slug": "relationship-with-and-"
      },
      {
        "level": 3,
        "text": "Building revalidation utilities",
        "slug": "building-revalidation-utilities"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Revalidating a specific URL",
        "slug": "revalidating-a-specific-url"
      },
      {
        "level": 3,
        "text": "Revalidating a Page path",
        "slug": "revalidating-a-page-path"
      },
      {
        "level": 3,
        "text": "Revalidating a Layout path",
        "slug": "revalidating-a-layout-path"
      },
      {
        "level": 3,
        "text": "Revalidating all data",
        "slug": "revalidating-all-data"
      },
      {
        "level": 3,
        "text": "Server Function",
        "slug": "server-function"
      },
      {
        "level": 3,
        "text": "Route Handler",
        "slug": "route-handler"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "revalidatePath(path: string, type?: 'page' | 'layout'): void;",
        "context": ""
      },
      {
        "language": "ts",
        "code": "export async function GET() {\r\n  const data = await fetch('https://api.vercel.app/blog', {\r\n    cache: 'force-cache',\r\n  })\r\n\r\n  return Response.json(await data.json())\r\n}",
        "context": "filename=\"app/api/data/route.ts\""
      },
      {
        "language": "tsx",
        "code": "// Page A: /blog\r\nconst posts = await fetch('https://api.vercel.app/blog', {\r\n  next: { tags: ['posts'] },\r\n})\r\n\r\n// Page B: /dashboard\r\nconst recentPosts = await fetch('https://api.vercel.app/blog?limit=5', {\r\n  next: { tags: ['posts'] },\r\n})",
        "context": ""
      },
      {
        "language": "ts",
        "code": "'use server'\r\n\r\nimport { revalidatePath, updateTag } from 'next/cache'\r\n\r\nexport async function updatePost() {\r\n  await updatePostInDatabase()\r\n\r\n  revalidatePath('/blog') // Refresh the blog page\r\n  updateTag('posts') // Refresh all pages using 'posts' tag\r\n}",
        "context": ""
      },
      {
        "language": "ts",
        "code": "import { revalidatePath } from 'next/cache'\r\nrevalidatePath('/blog/post-1')",
        "context": ""
      },
      {
        "language": "ts",
        "code": "import { revalidatePath } from 'next/cache'\r\nrevalidatePath('/blog/[slug]', 'page')\r\n// or with route groups\r\nrevalidatePath('/(main)/blog/[slug]', 'page')",
        "context": ""
      },
      {
        "language": "ts",
        "code": "import { revalidatePath } from 'next/cache'\r\nrevalidatePath('/blog/[slug]', 'layout')\r\n// or with route groups\r\nrevalidatePath('/(main)/post/[slug]', 'layout')",
        "context": ""
      },
      {
        "language": "ts",
        "code": "import { revalidatePath } from 'next/cache'\r\n\r\nrevalidatePath('/', 'layout')",
        "context": ""
      },
      {
        "language": "ts",
        "code": "'use server'\r\n\r\nimport { revalidatePath } from 'next/cache'\r\n\r\nexport default async function submit() {\r\n  await submitForm()\r\n  revalidatePath('/')\r\n}",
        "context": "filename=\"app/actions.ts\" switcher"
      },
      {
        "language": "ts",
        "code": "import { revalidatePath } from 'next/cache'\r\nimport type { NextRequest } from 'next/server'\r\n\r\nexport async function GET(request: NextRequest) {\r\n  const path = request.nextUrl.searchParams.get('path')\r\n\r\n  if (path) {\r\n    revalidatePath(path)\r\n    return Response.json({ revalidated: true, now: Date.now() })\r\n  }\r\n\r\n  return Response.json({\r\n    revalidated: false,\r\n    now: Date.now(),\r\n    message: 'Missing path to revalidate',\r\n  })\r\n}",
        "context": "filename=\"app/api/revalidate/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { revalidatePath } from 'next/cache'\r\n\r\nexport async function GET(request) {\r\n  const path = request.nextUrl.searchParams.get('path')\r\n\r\n  if (path) {\r\n    revalidatePath(path)\r\n    return Response.json({ revalidated: true, now: Date.now() })\r\n  }\r\n\r\n  return Response.json({\r\n    revalidated: false,\r\n    now: Date.now(),\r\n    message: 'Missing path to revalidate',\r\n  })\r\n}",
        "context": "filename=\"app/api/revalidate/route.js\" switcher"
      }
    ],
    "content": "revalidatePath allows you to invalidate cached data on-demand for a specific path. Usage revalidatePath can be called in Server Functions and Route Handlers. revalidatePath cannot be called in Client Components or Proxy, as it only works in server environments. > Good to know: > > - Server Functions: Updates the UI immediately (if viewing the affected path). Currently, it also causes all previously visited pages to refresh when navigated to again. This behavior is temporary and will be updated in the future to apply only to the specific path. > - Route Handlers: Marks the path for revalidation. The revalidation is done on the next visit to the specified path. This means calling revalidatePath with a dynamic route segment will not immediately trigger many revalidations at once. The invalidation only happens when the path is next visited. Parameters - path: Either a route pattern corresponding to the data you want to revalidate, for example /product/[slug], or a specific URL, /product/123. Do not append /page or /layout, use the type parameter instead. Must not exceed 1024 characters. This value is case-sensitive. - type: (optional) 'page' or 'layout' string to change the type of path to revalidate. If path contains a dynamic segment, for example /product/[slug], this parameter is required. If path is a specific URL, /product/1, omit type. Use a specific URL when you want to refresh a single page. Use a route pattern plus type to refresh multiple URLs. Returns revalidatePath does not return a value. What can be invalidated The path parameter can point to pages, layouts, or route handlers: - Pages: Invalidates the specific page - Layouts: Invalidates the layout (the layout.tsx at that segment), all nested layouts beneath it, and all pages beneath them - Route Handlers: Invalidates Data Cache entries accessed within route handlers. For example revalidatePath(\"/api/data\") invalidates this GET handler: Relationship with revalidateTag and updateTag revalidatePath, revalidateTag and updateTag serve different purposes: - revalidatePath: Invalidates a specific page or layout path - revalidateTag: Marks data with specific tags as stale. Applies across all pages that use those tags - updateTag: Expires data with specific tags. Applies across all pages that use those tags When you call revalidatePath, only the specified path gets fresh data on the next visit. Other pages that use the same data tags will continue to serve cached data until those specific tags are also revalidated: After calling revalidatePath('/blog'): - Page A (/blog): Shows fresh data (page re-rendered) - Page B (/dashboard): Still shows stale data (cache tag 'posts' not invalidated) Learn about the difference between revalidateTag and updateTag. Building revalidation utilities revalidatePath and updateTag are complementary primitives that are often used together in utility functions to ensure comprehensive data consistency across your application: This pattern ensures that both the specific page and any other pages using the same data remain consistent. Examples Revalidating a specific URL This will invalidate one specific URL for revalidation on the next page visit. Revalidating a Page path This will invalidate any URL that matches the provided page file for revalidation on the next page visit. This will not invalidate pages beneath the specific page. For example, /blog/[slug] won't invalidate /blog/[slug]/[author]. Revalidating a Layout path This will invalidate any URL that matches the provided layout file for revalidation on the next page visit. This will cause pages beneath with the same layout to be invalidated and revalidated on the next visit. For example, in the above case, /blog/[slug]/[another] would also be invalidated and revalidated on the next visit. Revalidating all data This will purge the Client-side Router Cache, and invalidate the Data Cache for revalidation on the next page visit. Server Function Route Handler",
    "excerpt": "revalidatePath allows you to invalidate cached data on-demand for a specific path. Usage revalidatePath can be called in Server Functions and Route Handlers. revalidatePath cannot be called in Client...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/04-functions/revalidatePath"
  },
  {
    "id": "01-app-03-api-reference-04-functions-revalidateTag",
    "path": "01-app\\03-api-reference\\04-functions\\revalidateTag.mdx",
    "title": "revalidateTag",
    "description": "API Reference for the revalidateTag function.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Usage",
        "slug": "usage"
      },
      {
        "level": 3,
        "text": "Revalidation Behavior",
        "slug": "revalidation-behavior"
      },
      {
        "level": 2,
        "text": "Parameters",
        "slug": "parameters"
      },
      {
        "level": 2,
        "text": "Returns",
        "slug": "returns"
      },
      {
        "level": 2,
        "text": "Relationship with ",
        "slug": "relationship-with-"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Server Action",
        "slug": "server-action"
      },
      {
        "level": 3,
        "text": "Route Handler",
        "slug": "route-handler"
      }
    ],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "revalidateTag(tag: string, profile: string | { expire?: number }): void;",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "fetch(url, { next: { tags: ['posts'] } })",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "import { cacheTag } from 'next/cache'\r\n\r\nasync function getData() {\r\n  'use cache'\r\n  cacheTag('posts')\r\n  // ...\r\n}",
        "context": ""
      },
      {
        "language": "ts",
        "code": "'use server'\r\n\r\nimport { revalidateTag } from 'next/cache'\r\n\r\nexport default async function submit() {\r\n  await addPost()\r\n  revalidateTag('posts', 'max')\r\n}",
        "context": "filename=\"app/actions.ts\" switcher"
      },
      {
        "language": "js",
        "code": "'use server'\r\n\r\nimport { revalidateTag } from 'next/cache'\r\n\r\nexport default async function submit() {\r\n  await addPost()\r\n  revalidateTag('posts', 'max')\r\n}",
        "context": "filename=\"app/actions.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import type { NextRequest } from 'next/server'\r\nimport { revalidateTag } from 'next/cache'\r\n\r\nexport async function GET(request: NextRequest) {\r\n  const tag = request.nextUrl.searchParams.get('tag')\r\n\r\n  if (tag) {\r\n    revalidateTag(tag, 'max')\r\n    return Response.json({ revalidated: true, now: Date.now() })\r\n  }\r\n\r\n  return Response.json({\r\n    revalidated: false,\r\n    now: Date.now(),\r\n    message: 'Missing tag to revalidate',\r\n  })\r\n}",
        "context": "filename=\"app/api/revalidate/route.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { revalidateTag } from 'next/cache'\r\n\r\nexport async function GET(request) {\r\n  const tag = request.nextUrl.searchParams.get('tag')\r\n\r\n  if (tag) {\r\n    revalidateTag(tag, 'max')\r\n    return Response.json({ revalidated: true, now: Date.now() })\r\n  }\r\n\r\n  return Response.json({\r\n    revalidated: false,\r\n    now: Date.now(),\r\n    message: 'Missing tag to revalidate',\r\n  })\r\n}",
        "context": "filename=\"app/api/revalidate/route.js\" switcher"
      }
    ],
    "content": "revalidateTag allows you to invalidate cached data on-demand for a specific cache tag. This function is ideal for content where a slight delay in updates is acceptable, such as blog posts, product catalogs, or documentation. Users receive stale content while fresh data loads in the background. Usage revalidateTag can be called in Server Functions and Route Handlers. revalidateTag cannot be called in Client Components or Proxy, as it only works in server environments. Revalidation Behavior The revalidation behavior depends on whether you provide the second argument: - With profile=\"max\" (recommended): The tag entry is marked as stale, and the next time a resource with that tag is visited, it will use stale-while-revalidate semantics. This means the stale content is served while fresh content is fetched in the background. - With a custom cache life profile: For advanced usage, you can specify any cache life profile that your application has defined, allowing for custom revalidation behaviors tailored to your specific caching requirements. - Without the second argument (deprecated): The tag entry is expired immediately, and the next request to that resource will be a blocking revalidate/cache miss. This behavior is now deprecated, and you should either use profile=\"max\" or migrate to updateTag. > Good to know: When using profile=\"max\", revalidateTag marks tagged data as stale, but fresh data is only fetched when pages using that tag are next visited. This means calling revalidateTag will not immediately trigger many revalidations at once. The invalidation only happens when any page using that tag is next visited. Parameters - tag: A string representing the cache tag associated with the data you want to revalidate. Must not exceed 256 characters. This value is case-sensitive. - profile: A string that specifies the revalidation behavior. The recommended value is \"max\" which provides stale-while-revalidate semantics, or any of the other default or custom profiles defined in cacheLife. Alternatively, you can pass an object with an expire property for custom expiration behavior. Tags must first be assigned to cached data. You can do this in two ways: - Using the next.tags option with fetch for caching external API requests: - Using cacheTag inside cached functions or components with the 'use cache' directive: > Good to know: The single-argument form revalidateTag(tag) is deprecated. It currently works if TypeScript errors are suppressed, but this behavior may be removed in a future version. Update to the two-argument signature. Returns revalidateTag does not return a value. Relationship with revalidatePath revalidateTag invalidates data with specific tags across all pages that use those tags, while revalidatePath invalidates specific page or layout paths. > Good to know: These functions serve different purposes and may need to be used together for comprehensive data consistency. For detailed examples and considerations, see relationship with revalidateTag and updateTag for more information. Examples The following examples demonstrate how to use revalidateTag in different contexts. In both cases, we're using profile=\"max\" to mark data as stale and use stale-while-revalidate semantics, which is the recommended approach for most use cases. Server Action Route Handler > Good to know: For webhooks or third-party services that need immediate expiration, you can pass { expire: 0 } as the second argument: revalidateTag(tag, { expire: 0 }). This pattern is necessary when external systems call your Route Handlers and require data to expire immediately. For all other cases, it's recommended to use updateTag in Server Actions for immediate updates instead.",
    "excerpt": "revalidateTag allows you to invalidate cached data on-demand for a specific cache tag. This function is ideal for content where a slight delay in updates is acceptable, such as blog posts, product cat...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/04-functions/revalidateTag"
  },
  {
    "id": "01-app-03-api-reference-04-functions-unauthorized",
    "path": "01-app\\03-api-reference\\04-functions\\unauthorized.mdx",
    "title": "unauthorized",
    "description": "API Reference for the unauthorized function.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Good to know",
        "slug": "good-to-know"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Displaying login UI to unauthenticated users",
        "slug": "displaying-login-ui-to-unauthenticated-users"
      },
      {
        "level": 3,
        "text": "Mutations with Server Actions",
        "slug": "mutations-with-server-actions"
      },
      {
        "level": 3,
        "text": "Fetching data with Route Handlers",
        "slug": "fetching-data-with-route-handlers"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  experimental: {\r\n    authInterrupts: true,\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  experimental: {\r\n    authInterrupts: true,\r\n  },\r\n}",
        "context": "filename=\"next.config.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { verifySession } from '@/app/lib/dal'\r\nimport { unauthorized } from 'next/navigation'\r\n\r\nexport default async function DashboardPage() {\r\n  const session = await verifySession()\r\n\r\n  if (!session) {\r\n    unauthorized()\r\n  }\r\n\r\n  // Render the dashboard for authenticated users\r\n  return (\r\n    <main>\r\n      <h1>Welcome to the Dashboard</h1>\r\n      <p>Hi, {session.user.name}.</p>\r\n    </main>\r\n  )\r\n}",
        "context": "filename=\"app/dashboard/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { verifySession } from '@/app/lib/dal'\r\nimport { unauthorized } from 'next/navigation'\r\n\r\nexport default async function DashboardPage() {\r\n  const session = await verifySession()\r\n\r\n  if (!session) {\r\n    unauthorized()\r\n  }\r\n\r\n  // Render the dashboard for authenticated users\r\n  return (\r\n    <main>\r\n      <h1>Welcome to the Dashboard</h1>\r\n      <p>Hi, {session.user.name}.</p>\r\n    </main>\r\n  )\r\n}",
        "context": "filename=\"app/dashboard/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { verifySession } from '@/app/lib/dal'\r\nimport { unauthorized } from 'next/navigation'\r\n\r\nexport default async function DashboardPage() {\r\n  const session = await verifySession()\r\n\r\n  if (!session) {\r\n    unauthorized()\r\n  }\r\n\r\n  return <div>Dashboard</div>\r\n}",
        "context": "filename=\"app/dashboard/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { verifySession } from '@/app/lib/dal'\r\nimport { unauthorized } from 'next/navigation'\r\n\r\nexport default async function DashboardPage() {\r\n  const session = await verifySession()\r\n\r\n  if (!session) {\r\n    unauthorized()\r\n  }\r\n\r\n  return <div>Dashboard</div>\r\n}",
        "context": "filename=\"app/dashboard/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Login from '@/app/components/Login'\r\n\r\nexport default function UnauthorizedPage() {\r\n  return (\r\n    <main>\r\n      <h1>401 - Unauthorized</h1>\r\n      <p>Please log in to access this page.</p>\r\n      <Login />\r\n    </main>\r\n  )\r\n}",
        "context": "filename=\"app/unauthorized.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Login from '@/app/components/Login'\r\n\r\nexport default function UnauthorizedPage() {\r\n  return (\r\n    <main>\r\n      <h1>401 - Unauthorized</h1>\r\n      <p>Please log in to access this page.</p>\r\n      <Login />\r\n    </main>\r\n  )\r\n}",
        "context": "filename=\"app/unauthorized.js\" switcher"
      },
      {
        "language": "ts",
        "code": "'use server'\r\n\r\nimport { verifySession } from '@/app/lib/dal'\r\nimport { unauthorized } from 'next/navigation'\r\nimport db from '@/app/lib/db'\r\n\r\nexport async function updateProfile(data: FormData) {\r\n  const session = await verifySession()\r\n\r\n  // If the user is not authenticated, return a 401\r\n  if (!session) {\r\n    unauthorized()\r\n  }\r\n\r\n  // Proceed with mutation\r\n  // ...\r\n}",
        "context": "filename=\"app/actions/update-profile.ts\" switcher"
      },
      {
        "language": "js",
        "code": "'use server'\r\n\r\nimport { verifySession } from '@/app/lib/dal'\r\nimport { unauthorized } from 'next/navigation'\r\nimport db from '@/app/lib/db'\r\n\r\nexport async function updateProfile(data) {\r\n  const session = await verifySession()\r\n\r\n  // If the user is not authenticated, return a 401\r\n  if (!session) {\r\n    unauthorized()\r\n  }\r\n\r\n  // Proceed with mutation\r\n  // ...\r\n}",
        "context": "filename=\"app/actions/update-profile.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { NextRequest, NextResponse } from 'next/server'\r\nimport { verifySession } from '@/app/lib/dal'\r\nimport { unauthorized } from 'next/navigation'\r\n\r\nexport async function GET(req: NextRequest): Promise<NextResponse> {\r\n  // Verify the user's session\r\n  const session = await verifySession()\r\n\r\n  // If no session exists, return a 401 and render unauthorized.tsx\r\n  if (!session) {\r\n    unauthorized()\r\n  }\r\n\r\n  // Fetch data\r\n  // ...\r\n}",
        "context": "filename=\"app/api/profile/route.ts\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { verifySession } from '@/app/lib/dal'\r\nimport { unauthorized } from 'next/navigation'\r\n\r\nexport async function GET() {\r\n  const session = await verifySession()\r\n\r\n  // If the user is not authenticated, return a 401 and render unauthorized.tsx\r\n  if (!session) {\r\n    unauthorized()\r\n  }\r\n\r\n  // Fetch data\r\n  // ...\r\n}",
        "context": "filename=\"app/api/profile/route.js\" switcher"
      }
    ],
    "content": "The unauthorized function throws an error that renders a Next.js 401 error page. It's useful for handling authorization errors in your application. You can customize the UI using the unauthorized.js file. To start using unauthorized, enable the experimental authInterrupts configuration option in your next.config.js file: unauthorized can be invoked in Server Components, Server Actions, and Route Handlers. Good to know - The unauthorized function cannot be called in the root layout. Examples Displaying login UI to unauthenticated users You can use unauthorized function to display the unauthorized.js file with a login UI. Mutations with Server Actions You can invoke unauthorized in Server Actions to ensure only authenticated users can perform specific mutations. Fetching data with Route Handlers You can use unauthorized in Route Handlers to ensure only authenticated users can access the endpoint. Version History | Version | Changes | | --------- | -------------------------- | | v15.1.0 | unauthorized introduced. |",
    "excerpt": "The unauthorized function throws an error that renders a Next.js 401 error page. It's useful for handling authorization errors in your application. You can customize the UI using the unauthorized.js f...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/04-functions/unauthorized"
  },
  {
    "id": "01-app-03-api-reference-04-functions-unstable_cache",
    "path": "01-app\\03-api-reference\\04-functions\\unstable_cache.mdx",
    "title": "unstable_cache",
    "description": "API Reference for the unstable_cache function.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Parameters",
        "slug": "parameters"
      },
      {
        "level": 2,
        "text": "Returns",
        "slug": "returns"
      },
      {
        "level": 2,
        "text": "Example",
        "slug": "example"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "jsx",
        "code": "import { getUser } from './data';\r\nimport { unstable_cache } from 'next/cache';\r\n\r\nconst getCachedUser = unstable_cache(\r\n  async (id) => getUser(id),\r\n  ['my-app-user']\r\n);\r\n\r\nexport default async function Component({ userID }) {\r\n  const user = await getCachedUser(userID);\r\n  ...\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "const data = unstable_cache(fetchData, keyParts, options)()",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "import { unstable_cache } from 'next/cache'\r\n\r\nexport default async function Page({\r\n  params,\r\n}: {\r\n  params: Promise<{ userId: string }>\r\n}) {\r\n  const { userId } = await params\r\n  const getCachedUser = unstable_cache(\r\n    async () => {\r\n      return { id: userId }\r\n    },\r\n    [userId], // add the user ID to the cache key\r\n    {\r\n      tags: ['users'],\r\n      revalidate: 60,\r\n    }\r\n  )\r\n\r\n  //...\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { unstable_cache } from 'next/cache';\r\n\r\nexport default async function Page({ params } }) {\r\n  const { userId } = await params\r\n  const getCachedUser = unstable_cache(\r\n    async () => {\r\n      return { id: userId };\r\n    },\r\n    [userId], // add the user ID to the cache key\r\n    {\r\n      tags: [\"users\"],\r\n      revalidate: 60,\r\n    }\r\n  );\r\n\r\n  //...\r\n}",
        "context": "filename=\"app/page.jsx\" switcher"
      }
    ],
    "content": "> Warning: This API will be replaced by use cache when it reaches stability. unstablecache allows you to cache the results of expensive operations, like database queries, and reuse them across multiple requests. > Good to know: > > - Accessing dynamic data sources such as headers or cookies inside a cache scope is not supported. If you need this data inside a cached function use headers outside of the cached function and pass the required dynamic data in as an argument. > - This API uses Next.js' built-in Data Cache to persist the result across requests and deployments. Parameters - fetchData: This is an asynchronous function that fetches the data you want to cache. It must be a function that returns a Promise. - keyParts: This is an extra array of keys that further adds identification to the cache. By default, unstablecache already uses the arguments and the stringified version of your function as the cache key. It is optional in most cases; the only time you need to use it is when you use external variables without passing them as parameters. However, it is important to add closures used within the function if you do not pass them as parameters. - options: This is an object that controls how the cache behaves. It can contain the following properties: - tags: An array of tags that can be used to control cache invalidation. Next.js will not use this to uniquely identify the function. - revalidate: The number of seconds after which the cache should be revalidated. Omit or pass false to cache indefinitely or until matching revalidateTag() or revalidatePath() methods are called. Returns unstablecache returns a function that when invoked, returns a Promise that resolves to the cached data. If the data is not in the cache, the provided function will be invoked, and its result will be cached and returned. Example Version History | Version | Changes | | --------- | ---------------------------- | | v14.0.0 | unstablecache introduced. |",
    "excerpt": "> Warning: This API will be replaced by use cache when it reaches stability. unstablecache allows you to cache the results of expensive operations, like database queries, and reuse them across multipl...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/04-functions/unstable_cache"
  },
  {
    "id": "01-app-03-api-reference-04-functions-unstable_noStore",
    "path": "01-app\\03-api-reference\\04-functions\\unstable_noStore.mdx",
    "title": "unstable_noStore",
    "description": "API Reference for the unstable_noStore function.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Usage",
        "slug": "usage"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "jsx",
        "code": "import { unstable_noStore as noStore } from 'next/cache';\r\n\r\nexport default async function ServerComponent() {\r\n  noStore();\r\n  const result = await db.query(...);\r\n  ...\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import { unstable_noStore as noStore } from 'next/cache';\r\n\r\nexport default async function ServerComponent() {\r\n  noStore();\r\n  const result = await db.query(...);\r\n  ...\r\n}",
        "context": ""
      }
    ],
    "content": "In version 15, we recommend using connection instead of unstablenoStore. unstablenoStore can be used to declaratively opt out of static rendering and indicate a particular component should not be cached. > Good to know: > > - unstablenoStore is equivalent to cache: 'no-store' on a fetch > - unstablenoStore is preferred over export const dynamic = 'force-dynamic' as it is more granular and can be used on a per-component basis - Using unstablenoStore inside unstablecache will not opt out of static generation. Instead, it will defer to the cache configuration to determine whether to cache the result or not. Usage If you prefer not to pass additional options to fetch, like cache: 'no-store', next: { revalidate: 0 } or in cases where fetch is not available, you can use noStore() as a replacement for all of these use cases. Version History | Version | Changes | | --------- | ----------------------------------------------- | | v15.0.0 | unstablenoStore deprecated for connection. | | v14.0.0 | unstablenoStore introduced. |",
    "excerpt": "In version 15, we recommend using connection instead of unstablenoStore. unstablenoStore can be used to declaratively opt out of static rendering and indicate a particular component should not be cach...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/04-functions/unstable_noStore"
  },
  {
    "id": "01-app-03-api-reference-04-functions-unstable_rethrow",
    "path": "01-app\\03-api-reference\\04-functions\\unstable_rethrow.mdx",
    "title": "unstable_rethrow",
    "description": "API Reference for the unstable_rethrow function.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "import { notFound } from 'next/navigation'\r\n\r\nexport default async function Page() {\r\n  try {\r\n    const post = await fetch('https://.../posts/1').then((res) => {\r\n      if (res.status === 404) notFound()\r\n      if (!res.ok) throw new Error(res.statusText)\r\n      return res.json()\r\n    })\r\n  } catch (err) {\r\n    console.error(err)\r\n  }\r\n}",
        "context": "filename=\"@/app/ui/component.tsx\""
      },
      {
        "language": "tsx",
        "code": "import { notFound, unstable_rethrow } from 'next/navigation'\r\n\r\nexport default async function Page() {\r\n  try {\r\n    const post = await fetch('https://.../posts/1').then((res) => {\r\n      if (res.status === 404) notFound()\r\n      if (!res.ok) throw new Error(res.statusText)\r\n      return res.json()\r\n    })\r\n  } catch (err) {\r\n    unstable_rethrow(err)\r\n    console.error(err)\r\n  }\r\n}",
        "context": "filename=\"@/app/ui/component.tsx\""
      }
    ],
    "content": "unstablerethrow can be used to avoid catching internal errors thrown by Next.js when attempting to handle errors thrown in your application code. For example, calling the notFound function will throw an internal Next.js error and render the not-found.js component. However, if used inside the try block of a try/catch statement, the error will be caught, preventing not-found.js from rendering: You can use unstablerethrow API to re-throw the internal error and continue with the expected behavior: The following Next.js APIs rely on throwing an error which should be rethrown and handled by Next.js itself: - notFound() - redirect() - permanentRedirect() If a route segment is marked to throw an error unless it's static, a Dynamic API call will also throw an error that should similarly not be caught by the developer. Note that Partial Prerendering (PPR) affects this behavior as well. These APIs are: - cookies - headers - searchParams - fetch(..., { cache: 'no-store' }) - fetch(..., { next: { revalidate: 0 } }) > Good to know: > > - This method should be called at the top of the catch block, passing the error object as its only argument. It can also be used within a .catch handler of a promise. > - You may be able to avoid using unstablerethrow if you encapsulate your API calls that throw and let the caller handle the exception. > - Only use unstablerethrow if your caught exceptions may include both application errors and framework-controlled exceptions (like redirect() or notFound()). > - Any resource cleanup (like clearing intervals, timers, etc) would have to either happen prior to the call to unstablerethrow or within a finally block.",
    "excerpt": "unstablerethrow can be used to avoid catching internal errors thrown by Next.js when attempting to handle errors thrown in your application code. For example, calling the notFound function will throw...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/04-functions/unstable_rethrow"
  },
  {
    "id": "01-app-03-api-reference-04-functions-updateTag",
    "path": "01-app\\03-api-reference\\04-functions\\updateTag.mdx",
    "title": "updateTag",
    "description": "API Reference for the updateTag function.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Usage",
        "slug": "usage"
      },
      {
        "level": 2,
        "text": "Parameters",
        "slug": "parameters"
      },
      {
        "level": 2,
        "text": "Returns",
        "slug": "returns"
      },
      {
        "level": 2,
        "text": "Differences from revalidateTag",
        "slug": "differences-from-revalidatetag"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Server Action with Read-Your-Own-Writes",
        "slug": "server-action-with-read-your-own-writes"
      },
      {
        "level": 3,
        "text": "Error when used outside Server Actions",
        "slug": "error-when-used-outside-server-actions"
      },
      {
        "level": 2,
        "text": "When to use updateTag",
        "slug": "when-to-use-updatetag"
      },
      {
        "level": 2,
        "text": "Related",
        "slug": "related"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "updateTag(tag: string): void;",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "fetch(url, { next: { tags: ['posts'] } })",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "import { cacheTag } from 'next/cache'\r\n\r\nasync function getData() {\r\n  'use cache'\r\n  cacheTag('posts')\r\n  // ...\r\n}",
        "context": ""
      },
      {
        "language": "ts",
        "code": "'use server'\r\n\r\nimport { updateTag } from 'next/cache'\r\nimport { redirect } from 'next/navigation'\r\n\r\nexport async function createPost(formData: FormData) {\r\n  const title = formData.get('title')\r\n  const content = formData.get('content')\r\n\r\n  // Create the post in your database\r\n  const post = await db.post.create({\r\n    data: { title, content },\r\n  })\r\n\r\n  // Invalidate cache tags so the new post is immediately visible\r\n  // 'posts' tag: affects any page that displays a list of posts\r\n  updateTag('posts')\r\n  // 'post-{id}' tag: affects the individual post detail page\r\n  updateTag(`post-${post.id}`)\r\n\r\n  // Redirect to the new post - user will see fresh data, not cached\r\n  redirect(`/posts/${post.id}`)\r\n}",
        "context": "filename=\"app/actions.ts\" switcher"
      },
      {
        "language": "js",
        "code": "'use server'\r\n\r\nimport { updateTag } from 'next/cache'\r\nimport { redirect } from 'next/navigation'\r\n\r\nexport async function createPost(formData) {\r\n  const title = formData.get('title')\r\n  const content = formData.get('content')\r\n\r\n  // Create the post in your database\r\n  const post = await db.post.create({\r\n    data: { title, content },\r\n  })\r\n\r\n  // Invalidate cache tags so the new post is immediately visible\r\n  // 'posts' tag: affects any page that displays a list of posts\r\n  updateTag('posts')\r\n  // 'post-{id}' tag: affects the individual post detail page\r\n  updateTag(`post-${post.id}`)\r\n\r\n  // Redirect to the new post - user will see fresh data, not cached\r\n  redirect(`/posts/${post.id}`)\r\n}",
        "context": "filename=\"app/actions.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { updateTag } from 'next/cache'\r\n\r\nexport async function POST() {\r\n  // This will throw an error\r\n  updateTag('posts')\r\n  // Error: updateTag can only be called from within a Server Action\r\n\r\n  // Use revalidateTag instead in Route Handlers\r\n  revalidateTag('posts', 'max')\r\n}",
        "context": "filename=\"app/api/posts/route.ts\" switcher"
      }
    ],
    "content": "updateTag allows you to update cached data on-demand for a specific cache tag from within Server Actions. This function is designed for read-your-own-writes scenarios, where a user makes a change (like creating a post), and the UI immediately shows the change, rather than stale data. Usage updateTag can only be called from within Server Actions. It cannot be used in Route Handlers, Client Components, or any other context. If you need to invalidate cache tags in Route Handlers or other contexts, use revalidateTag instead. > Good to know: updateTag immediately expires the cached data for the specified tag. The next request will wait to fetch fresh data rather than serving stale content from the cache, ensuring users see their changes immediately. Parameters - tag: A string representing the cache tag associated with the data you want to update. Must not exceed 256 characters. This value is case-sensitive. Tags must first be assigned to cached data. You can do this in two ways: - Using the next.tags option with fetch for caching external API requests: - Using cacheTag inside cached functions or components with the 'use cache' directive: Returns updateTag does not return a value. Differences from revalidateTag While both updateTag and revalidateTag invalidate cached data, they serve different purposes: - updateTag: - Can only be used in Server Actions - Next request waits for fresh data (no stale content served) - Designed for read-your-own-writes scenarios - revalidateTag: - Can be used in Server Actions and Route Handlers - With profile=\"max\" (recommended): Serves cached data while fetching fresh data in the background (stale-while-revalidate) - With custom profile: Can be configured to any cache life profile for advanced usage - Without profile: legacy behavior which is equivalent to updateTag Examples Server Action with Read-Your-Own-Writes Error when used outside Server Actions When to use updateTag Use updateTag when: - You're in a Server Action - You need immediate cache invalidation for read-your-own-writes - You want to ensure the next request sees updated data Use revalidateTag instead when: - You're in a Route Handler or other non-action context - You want stale-while-revalidate semantics - You're building a webhook or API endpoint for cache invalidation Related - revalidateTag - For invalidating tags in Route Handlers - revalidatePath - For invalidating specific paths",
    "excerpt": "updateTag allows you to update cached data on-demand for a specific cache tag from within Server Actions. This function is designed for read-your-own-writes scenarios, where a user makes a change (lik...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/04-functions/updateTag"
  },
  {
    "id": "01-app-03-api-reference-04-functions-use-link-status",
    "path": "01-app\\03-api-reference\\04-functions\\use-link-status.mdx",
    "title": "useLinkStatus",
    "description": "API Reference for the useLinkStatus hook.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "You might not need ",
        "slug": "you-might-not-need-"
      },
      {
        "level": 2,
        "text": "Parameters",
        "slug": "parameters"
      },
      {
        "level": 2,
        "text": "Returns",
        "slug": "returns"
      },
      {
        "level": 2,
        "text": "Example",
        "slug": "example"
      },
      {
        "level": 3,
        "text": "Inline link hint",
        "slug": "inline-link-hint"
      },
      {
        "level": 2,
        "text": "Gracefully handling fast navigation",
        "slug": "gracefully-handling-fast-navigation"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport Link from 'next/link'\r\nimport { useLinkStatus } from 'next/link'\r\n\r\nfunction Hint() {\r\n  const { pending } = useLinkStatus()\r\n  return (\r\n    <span aria-hidden className={`link-hint ${pending ? 'is-pending' : ''}`} />\r\n  )\r\n}\r\n\r\nexport default function Header() {\r\n  return (\r\n    <header>\r\n      <Link href=\"/dashboard\" prefetch={false}>\r\n        <span className=\"label\">Dashboard</span> <Hint />\r\n      </Link>\r\n    </header>\r\n  )\r\n}",
        "context": "filename=\"app/hint.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport Link from 'next/link'\r\nimport { useLinkStatus } from 'next/link'\r\n\r\nfunction Hint() {\r\n  const { pending } = useLinkStatus()\r\n  return (\r\n    <span aria-hidden className={`link-hint ${pending ? 'is-pending' : ''}`} />\r\n  )\r\n}\r\n\r\nexport default function Header() {\r\n  return (\r\n    <header>\r\n      <Link href=\"/dashboard\" prefetch={false}>\r\n        <span className=\"label\">Dashboard</span> <Hint />\r\n      </Link>\r\n    </header>\r\n  )\r\n}",
        "context": "filename=\"app/hint.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "const { pending } = useLinkStatus()",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { useLinkStatus } from 'next/link'\r\n\r\nexport default function LoadingIndicator() {\r\n  const { pending } = useLinkStatus()\r\n  return (\r\n    <span aria-hidden className={`link-hint ${pending ? 'is-pending' : ''}`} />\r\n  )\r\n}",
        "context": "filename=\"app/components/loading-indicator.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { useLinkStatus } from 'next/link'\r\n\r\nexport default function LoadingIndicator() {\r\n  const { pending } = useLinkStatus()\r\n  return (\r\n    <span aria-hidden className={`link-hint ${pending ? 'is-pending' : ''}`} />\r\n  )\r\n}",
        "context": "filename=\"app/components/loading-indicator.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\nimport LoadingIndicator from './components/loading-indicator'\r\n\r\nconst links = [\r\n  { href: '/shop/electronics', label: 'Electronics' },\r\n  { href: '/shop/clothing', label: 'Clothing' },\r\n  { href: '/shop/books', label: 'Books' },\r\n]\r\n\r\nfunction Menubar() {\r\n  return (\r\n    <div>\r\n      {links.map((link) => (\r\n        <Link key={link.label} href={link.href}>\r\n          <span className=\"label\">{link.label}</span> <LoadingIndicator />\r\n        </Link>\r\n      ))}\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default function Layout({ children }: { children: React.ReactNode }) {\r\n  return (\r\n    <div>\r\n      <Menubar />\r\n      {children}\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/shop/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\nimport LoadingIndicator from './components/loading-indicator'\r\n\r\nconst links = [\r\n  { href: '/shop/electronics', label: 'Electronics' },\r\n  { href: '/shop/clothing', label: 'Clothing' },\r\n  { href: '/shop/books', label: 'Books' },\r\n]\r\n\r\nfunction Menubar() {\r\n  return (\r\n    <div>\r\n      {links.map((link) => (\r\n        <Link key={link.label} href={link.href}>\r\n          <span className=\"label\">{link.label}</span> <LoadingIndicator />\r\n        </Link>\r\n      ))}\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default function Layout({ children }) {\r\n  return (\r\n    <div>\r\n      <Menubar />\r\n      {children}\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/shop/layout.js\" switcher"
      },
      {
        "language": "css",
        "code": ".link-hint {\r\n  display: inline-block;\r\n  width: 0.6em;\r\n  height: 0.6em;\r\n  margin-left: 0.25rem;\r\n  border-radius: 9999px;\r\n  background: currentColor;\r\n  opacity: 0;\r\n  visibility: hidden; /* reserve space without showing the hint */\r\n}\r\n\r\n.link-hint.is-pending {\r\n  /* Animation 1: fade in after 100ms and keep final opacity */\r\n  /* Animation 2: subtle pulsing while pending */\r\n  visibility: visible;\r\n  animation-name: fadeIn, pulse;\r\n  animation-duration: 200ms, 1s;\r\n  /* Appear only if navigation actually takes time */\r\n  animation-delay: 100ms, 100ms;\r\n  animation-timing-function: ease, ease-in-out;\r\n  animation-iteration-count: 1, infinite;\r\n  animation-fill-mode: forwards, none;\r\n}\r\n\r\n@keyframes fadeIn {\r\n  to {\r\n    opacity: 0.35;\r\n  }\r\n}\r\n@keyframes pulse {\r\n  50% {\r\n    opacity: 0.15;\r\n  }\r\n}",
        "context": "filename=\"app/styles/global.css\""
      }
    ],
    "content": "The useLinkStatus hook lets you track the pending state of a . Use it for subtle, inline feedback, for example a shimmer effect over the clicked link, while navigation completes. Prefer route-level fallbacks with loading.js, and prefetching for instant transitions. useLinkStatus is useful when: - Prefetching is disabled or in progress meaning navigation is blocked. - The destination route is dynamic and doesn't include a loading.js file that would allow an instant navigation. > Good to know: > > - useLinkStatus must be used within a descendant component of a Link component > - The hook is most useful when prefetch={false} is set on the Link component > - If the linked route has been prefetched, the pending state will be skipped > - When clicking multiple links in quick succession, only the last link's pending state is shown > - This hook is not supported in the Pages Router and always returns { pending: false } > - Inline indicators can easily introduce layout shifts. Prefer a fixed-size, always-rendered hint element and toggle its opacity, or use an animation. You might not need useLinkStatus Before adding inline feedback, consider if: - The destination is static and prefetched in production, so the pending phase may be skipped. - The route has a loading.js file, enabling instant transitions with a route-level fallback. Navigation is typically fast. Use useLinkStatus as a quick patch when you identify a slow transition, then iterate to fix the root cause with prefetching or a loading.js fallback. Parameters useLinkStatus does not take any parameters. Returns useLinkStatus returns an object with a single property: | Property | Type | Description | | -------- | ------- | -------------------------------------------- | | pending | boolean | true before history updates, false after | Example Inline link hint Add a subtle, fixed-size hint that doesn’t affect layout to confirm a click when prefetching hasn’t completed. Gracefully handling fast navigation If the navigation to a new route is fast, users may see an unnecessary flash of the hint. One way to improve the user experience and only show the hint when the navigation takes time to complete is to add an initial animation delay (e.g. 100ms) and start the animation as invisible (e.g. opacity: 0). Version History | Version | Changes | | --------- | --------------------------- | | v15.3.0 | useLinkStatus introduced. |",
    "excerpt": "The useLinkStatus hook lets you track the pending state of a . Use it for subtle, inline feedback, for example a shimmer effect over the clicked link, while navigation completes. Prefer route-level fa...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/04-functions/use-link-status"
  },
  {
    "id": "01-app-03-api-reference-04-functions-use-params",
    "path": "01-app\\03-api-reference\\04-functions\\use-params.mdx",
    "title": "useParams",
    "description": "API Reference for the useParams hook.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Parameters",
        "slug": "parameters"
      },
      {
        "level": 2,
        "text": "Returns",
        "slug": "returns"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { useParams } from 'next/navigation'\r\n\r\nexport default function ExampleClientComponent() {\r\n  const params = useParams<{ tag: string; item: string }>()\r\n\r\n  // Route -> /shop/[tag]/[item]\r\n  // URL -> /shop/shoes/nike-air-max-97\r\n  // `params` -> { tag: 'shoes', item: 'nike-air-max-97' }\r\n  console.log(params)\r\n\r\n  return '...'\r\n}",
        "context": "filename=\"app/example-client-component.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { useParams } from 'next/navigation'\r\n\r\nexport default function ExampleClientComponent() {\r\n  const params = useParams()\r\n\r\n  // Route -> /shop/[tag]/[item]\r\n  // URL -> /shop/shoes/nike-air-max-97\r\n  // `params` -> { tag: 'shoes', item: 'nike-air-max-97' }\r\n  console.log(params)\r\n\r\n  return '...'\r\n}",
        "context": "filename=\"app/example-client-component.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "const params = useParams()",
        "context": ""
      }
    ],
    "content": "useParams is a Client Component hook that lets you read a route's dynamic params filled in by the current URL. Parameters useParams does not take any parameters. Returns useParams returns an object containing the current route's filled in dynamic parameters. - Each property in the object is an active dynamic segment. - The properties name is the segment's name, and the properties value is what the segment is filled in with. - The properties value will either be a string or array of string's depending on the type of dynamic segment. - If the route contains no dynamic parameters, useParams returns an empty object. - If used in Pages Router, useParams will return null on the initial render and updates with properties following the rules above once the router is ready. For example: | Route | URL | useParams() | | ------------------------------- | ----------- | ------------------------- | | app/shop/page.js | /shop | {} | | app/shop/[slug]/page.js | /shop/1 | { slug: '1' } | | app/shop/[tag]/[item]/page.js | /shop/1/2 | { tag: '1', item: '2' } | | app/shop/[...slug]/page.js | /shop/1/2 | { slug: ['1', '2'] } | Version History | Version | Changes | | --------- | ----------------------- | | v13.3.0 | useParams introduced. |",
    "excerpt": "useParams is a Client Component hook that lets you read a route's dynamic params filled in by the current URL. Parameters useParams does not take any parameters. Returns useParams returns an object co...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/04-functions/use-params"
  },
  {
    "id": "01-app-03-api-reference-04-functions-use-pathname",
    "path": "01-app\\03-api-reference\\04-functions\\use-pathname.mdx",
    "title": "usePathname",
    "description": "API Reference for the usePathname hook.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Parameters",
        "slug": "parameters"
      },
      {
        "level": 2,
        "text": "Returns",
        "slug": "returns"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Do something in response to a route change",
        "slug": "do-something-in-response-to-a-route-change"
      },
      {
        "level": 3,
        "text": "Avoid hydration mismatch with rewrites",
        "slug": "avoid-hydration-mismatch-with-rewrites"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { usePathname } from 'next/navigation'\r\n\r\nexport default function ExampleClientComponent() {\r\n  const pathname = usePathname()\r\n  return <p>Current pathname: {pathname}</p>\r\n}",
        "context": "filename=\"app/example-client-component.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { usePathname } from 'next/navigation'\r\n\r\nexport default function ExampleClientComponent() {\r\n  const pathname = usePathname()\r\n  return <p>Current pathname: {pathname}</p>\r\n}",
        "context": "filename=\"app/example-client-component.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "const pathname = usePathname()",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { useEffect } from 'react'\r\nimport { usePathname, useSearchParams } from 'next/navigation'\r\n\r\nfunction ExampleClientComponent() {\r\n  const pathname = usePathname()\r\n  const searchParams = useSearchParams()\r\n  useEffect(() => {\r\n    // Do something here...\r\n  }, [pathname, searchParams])\r\n}",
        "context": "filename=\"app/example-client-component.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { useEffect } from 'react'\r\nimport { usePathname, useSearchParams } from 'next/navigation'\r\n\r\nfunction ExampleClientComponent() {\r\n  const pathname = usePathname()\r\n  const searchParams = useSearchParams()\r\n  useEffect(() => {\r\n    // Do something here...\r\n  }, [pathname, searchParams])\r\n}",
        "context": "filename=\"app/example-client-component.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { useEffect, useState } from 'react'\r\nimport { usePathname } from 'next/navigation'\r\n\r\nexport default function PathnameBadge() {\r\n  const pathname = usePathname()\r\n  const [clientPathname, setClientPathname] = useState('')\r\n\r\n  useEffect(() => {\r\n    setClientPathname(pathname)\r\n  }, [pathname])\r\n\r\n  return (\r\n    <p>\r\n      Current pathname: <span>{clientPathname}</span>\r\n    </p>\r\n  )\r\n}",
        "context": "filename=\"app/example-client-component.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { useEffect, useState } from 'react'\r\nimport { usePathname } from 'next/navigation'\r\n\r\nexport default function PathnameBadge() {\r\n  const pathname = usePathname()\r\n  const [clientPathname, setClientPathname] = useState('')\r\n\r\n  useEffect(() => {\r\n    setClientPathname(pathname)\r\n  }, [pathname])\r\n\r\n  return (\r\n    <p>\r\n      Current pathname: <span>{clientPathname}</span>\r\n    </p>\r\n  )\r\n}",
        "context": "filename=\"app/example-client-component.js\" switcher"
      }
    ],
    "content": "usePathname is a Client Component hook that lets you read the current URL's pathname. > Good to know: When cacheComponents is enabled usePathname may require a Suspense boundary around it if your route has a dynamic param. If you use generateStaticParams the Suspense boundary is optional usePathname intentionally requires using a Client Component. It's important to note Client Components are not a de-optimization. They are an integral part of the Server Components architecture. For example, a Client Component with usePathname will be rendered into HTML on the initial page load. When navigating to a new route, this component does not need to be re-fetched. Instead, the component is downloaded once (in the client JavaScript bundle), and re-renders based on the current state. > Good to know: > > - Reading the current URL from a Server Component is not supported. This design is intentional to support layout state being preserved across page navigations. > - If your page is being statically pre-rendered and your app has rewrites in next.config or a Proxy file, reading the pathname with usePathname() can result in hydration mismatch errors—because the initial value comes from the server and may not match the actual browser pathname after routing. See our example for a way to mitigate this issue. Compatibility with Pages Router If you have components that use usePathname and they are imported into routes within the Pages Router, be aware that usePathname may return null if the router is not yet initialized. This can occur in cases such as fallback routes or during Automatic Static Optimization in the Pages Router. To enhance compatibility between routing systems, if your project contains both an app and a pages directory, Next.js will automatically adjust the return type of usePathname. Parameters usePathname does not take any parameters. Returns usePathname returns a string of the current URL's pathname. For example: | URL | Returned value | | ------------------- | --------------------- | | / | '/' | | /dashboard | '/dashboard' | | /dashboard?v=2 | '/dashboard' | | /blog/hello-world | '/blog/hello-world' | Examples Do something in response to a route change Avoid hydration mismatch with rewrites When a page is pre-rendered, the HTML is generated for the source pathname. If the page is then reached through a rewrite using next.config or Proxy, the browser URL may differ, and usePathname() will read the rewritten pathname on the client. To avoid hydration mismatches, design the UI so that only a small, isolated part depends on the client pathname. Render a stable fallback on the server and update that part after mount. | Version | Changes | | --------- | ------------------------- | | v13.0.0 | usePathname introduced. |",
    "excerpt": "usePathname is a Client Component hook that lets you read the current URL's pathname. > Good to know: When cacheComponents is enabled usePathname may require a Suspense boundary around it if your rout...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/04-functions/use-pathname"
  },
  {
    "id": "01-app-03-api-reference-04-functions-use-report-web-vitals",
    "path": "01-app\\03-api-reference\\04-functions\\use-report-web-vitals.mdx",
    "title": "useReportWebVitals",
    "description": "API Reference for the useReportWebVitals function.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "useReportWebVitals",
        "slug": "usereportwebvitals"
      },
      {
        "level": 2,
        "text": "Web Vitals",
        "slug": "web-vitals"
      },
      {
        "level": 2,
        "text": "Custom Metrics",
        "slug": "custom-metrics"
      },
      {
        "level": 2,
        "text": "Sending results to external systems",
        "slug": "sending-results-to-external-systems"
      }
    ],
    "codeBlocks": [
      {
        "language": "jsx",
        "code": "import { useReportWebVitals } from 'next/web-vitals'\r\n\r\nconst logWebVitals = (metric) => {\r\n  console.log(metric)\r\n}\r\n\r\nfunction MyApp({ Component, pageProps }) {\r\n  useReportWebVitals(logWebVitals)\r\n\r\n  return <Component {...pageProps} />\r\n}",
        "context": "filename=\"pages/_app.js\""
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { useReportWebVitals } from 'next/web-vitals'\r\n\r\nconst logWebVitals = (metric) => {\r\n  console.log(metric)\r\n}\r\n\r\nexport function WebVitals() {\r\n  useReportWebVitals(logWebVitals)\r\n\r\n  return null\r\n}",
        "context": "filename=\"app/_components/web-vitals.js\""
      },
      {
        "language": "jsx",
        "code": "import { WebVitals } from './_components/web-vitals'\r\n\r\nexport default function Layout({ children }) {\r\n  return (\r\n    <html>\r\n      <body>\r\n        <WebVitals />\r\n        {children}\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\""
      },
      {
        "language": "jsx",
        "code": "import { useReportWebVitals } from 'next/web-vitals'\r\n\r\nconst handleWebVitals = (metric) => {\r\n  switch (metric.name) {\r\n    case 'FCP': {\r\n      // handle FCP results\r\n    }\r\n    case 'LCP': {\r\n      // handle LCP results\r\n    }\r\n    // ...\r\n  }\r\n}\r\n\r\nfunction MyApp({ Component, pageProps }) {\r\n  useReportWebVitals(handleWebVitals)\r\n\r\n  return <Component {...pageProps} />\r\n}",
        "context": "filename=\"pages/_app.js\""
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { useReportWebVitals } from 'next/web-vitals'\r\n\r\ntype ReportWebVitalsCallback = Parameters<typeof useReportWebVitals>[0]\r\n\r\nconst handleWebVitals: ReportWebVitalsCallback = (metric) => {\r\n  switch (metric.name) {\r\n    case 'FCP': {\r\n      // handle FCP results\r\n    }\r\n    case 'LCP': {\r\n      // handle LCP results\r\n    }\r\n    // ...\r\n  }\r\n}\r\n\r\nexport function WebVitals() {\r\n  useReportWebVitals(handleWebVitals)\r\n}",
        "context": "filename=\"app/components/web-vitals.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { useReportWebVitals } from 'next/web-vitals'\r\n\r\nconst handleWebVitals = (metric) => {\r\n  switch (metric.name) {\r\n    case 'FCP': {\r\n      // handle FCP results\r\n    }\r\n    case 'LCP': {\r\n      // handle LCP results\r\n    }\r\n    // ...\r\n  }\r\n}\r\n\r\nexport function WebVitals() {\r\n  useReportWebVitals(handleWebVitals)\r\n}",
        "context": "filename=\"app/components/web-vitals.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { useReportWebVitals } from 'next/web-vitals'\r\n\r\nfunction handleCustomMetrics(metrics) {\r\n  switch (metric.name) {\r\n    case 'Next.js-hydration':\r\n      // handle hydration results\r\n      break\r\n    case 'Next.js-route-change-to-render':\r\n      // handle route-change to render results\r\n      break\r\n    case 'Next.js-render':\r\n      // handle render results\r\n      break\r\n    default:\r\n      break\r\n  }\r\n}\r\n\r\nfunction MyApp({ Component, pageProps }) {\r\n  useReportWebVitals(handleCustomMetrics)\r\n\r\n  return <Component {...pageProps} />\r\n}",
        "context": "filename=\"pages/_app.js\""
      },
      {
        "language": "js",
        "code": "function postWebVitals(metrics) {\r\n  const body = JSON.stringify(metric)\r\n  const url = 'https://example.com/analytics'\r\n\r\n  // Use `navigator.sendBeacon()` if available, falling back to `fetch()`.\r\n  if (navigator.sendBeacon) {\r\n    navigator.sendBeacon(url, body)\r\n  } else {\r\n    fetch(url, { body, method: 'POST', keepalive: true })\r\n  }\r\n}\r\n\r\nuseReportWebVitals(postWebVitals)",
        "context": ""
      },
      {
        "language": "js",
        "code": "useReportWebVitals(metric => {\r\n  // Use `window.gtag` if you initialized Google Analytics as this example:\r\n  // https://github.com/vercel/next.js/blob/canary/examples/with-google-analytics\r\n  window.gtag('event', metric.name, {\r\n    value: Math.round(metric.name === 'CLS' ? metric.value * 1000 : metric.value), // values must be integers\r\n    event_label: metric.id, // id unique to current page load\r\n    non_interaction: true, // avoids affecting bounce rate.\r\n  });\r\n}",
        "context": ""
      }
    ],
    "content": "The useReportWebVitals hook allows you to report Core Web Vitals, and can be used in combination with your analytics service. New functions passed to useReportWebVitals are called with the available metrics up to that point. To prevent reporting duplicated data, ensure that the callback function reference does not change (as shown in the code examples below). > Since the useReportWebVitals hook requires the 'use client' directive, the most performant approach is to create a separate component that the root layout imports. This confines the client boundary exclusively to the WebVitals component. useReportWebVitals The metric object passed as the hook's argument consists of a number of properties: - id: Unique identifier for the metric in the context of the current page load - name: The name of the performance metric. Possible values include names of Web Vitals metrics (TTFB, FCP, LCP, FID, CLS) specific to a web application. - delta: The difference between the current value and the previous value of the metric. The value is typically in milliseconds and represents the change in the metric's value over time. - entries: An array of Performance Entries associated with the metric. These entries provide detailed information about the performance events related to the metric. - navigationType: Indicates the type of navigation that triggered the metric collection. Possible values include \"navigate\", \"reload\", \"backforward\", and \"prerender\". - rating: A qualitative rating of the metric value, providing an assessment of the performance. Possible values are \"good\", \"needs-improvement\", and \"poor\". The rating is typically determined by comparing the metric value against predefined thresholds that indicate acceptable or suboptimal performance. - value: The actual value or duration of the performance entry, typically in milliseconds. The value provides a quantitative measure of the performance aspect being tracked by the metric. The source of the value depends on the specific metric being measured and can come from various Performance APIs. Web Vitals Web Vitals are a set of useful metrics that aim to capture the user experience of a web page. The following web vitals are all included: - Time to First Byte (TTFB) - First Contentful Paint (FCP) - Largest Contentful Paint (LCP) - First Input Delay (FID) - Cumulative Layout Shift (CLS) - Interaction to Next Paint (INP) You can handle all the results of these metrics using the name property. Custom Metrics In addition to the core metrics listed above, there are some additional custom metrics that measure the time it takes for the page to hydrate and render: - Next.js-hydration: Length of time it takes for the page to start and finish hydrating (in ms) - Next.js-route-change-to-render: Length of time it takes for a page to start rendering after a route change (in ms) - Next.js-render: Length of time it takes for a page to finish render after a route change (in ms) You can handle all the results of these metrics separately: These metrics work in all browsers that support the User Timing API. Sending results to external systems You can send results to any endpoint to measure and track real user performance on your site. For example: > Good to know: If you use Google Analytics, using the > id value can allow you to construct metric distributions manually (to calculate percentiles, > etc.) > > > Read more about sending results to Google Analytics.",
    "excerpt": "The useReportWebVitals hook allows you to report Core Web Vitals, and can be used in combination with your analytics service. New functions passed to useReportWebVitals are called with the available m...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/04-functions/use-report-web-vitals"
  },
  {
    "id": "01-app-03-api-reference-04-functions-use-router",
    "path": "01-app\\03-api-reference\\04-functions\\use-router.mdx",
    "title": "useRouter",
    "description": "API reference for the useRouter hook.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 3,
        "text": "Migrating from ",
        "slug": "migrating-from-"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Router events",
        "slug": "router-events"
      },
      {
        "level": 3,
        "text": "Disabling scroll to top",
        "slug": "disabling-scroll-to-top"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { useRouter } from 'next/navigation'\r\n\r\nexport default function Page() {\r\n  const router = useRouter()\r\n\r\n  return (\r\n    <button type=\"button\" onClick={() => router.push('/dashboard')}>\r\n      Dashboard\r\n    </button>\r\n  )\r\n}",
        "context": "filename=\"app/example-client-component.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { useRouter } from 'next/navigation'\r\n\r\nexport default function Page() {\r\n  const router = useRouter()\r\n\r\n  return (\r\n    <button type=\"button\" onClick={() => router.push('/dashboard')}>\r\n      Dashboard\r\n    </button>\r\n  )\r\n}",
        "context": "filename=\"app/example-client-component.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { useEffect } from 'react'\r\nimport { usePathname, useSearchParams } from 'next/navigation'\r\n\r\nexport function NavigationEvents() {\r\n  const pathname = usePathname()\r\n  const searchParams = useSearchParams()\r\n\r\n  useEffect(() => {\r\n    const url = `${pathname}?${searchParams}`\r\n    console.log(url)\r\n    // You can now use the current URL\r\n    // ...\r\n  }, [pathname, searchParams])\r\n\r\n  return '...'\r\n}",
        "context": "filename=\"app/components/navigation-events.js\""
      },
      {
        "language": "jsx",
        "code": "import { Suspense } from 'react'\r\nimport { NavigationEvents } from './components/navigation-events'\r\n\r\nexport default function Layout({ children }) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>\r\n        {children}\r\n\r\n        <Suspense fallback={null}>\r\n          <NavigationEvents />\r\n        </Suspense>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "context": "filename=\"app/layout.js\" highlight={2,10-12}"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { useRouter } from 'next/navigation'\r\n\r\nexport default function Page() {\r\n  const router = useRouter()\r\n\r\n  return (\r\n    <button\r\n      type=\"button\"\r\n      onClick={() => router.push('/dashboard', { scroll: false })}\r\n    >\r\n      Dashboard\r\n    </button>\r\n  )\r\n}",
        "context": "filename=\"app/example-client-component.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { useRouter } from 'next/navigation'\r\n\r\nexport default function Page() {\r\n  const router = useRouter()\r\n\r\n  return (\r\n    <button\r\n      type=\"button\"\r\n      onClick={() => router.push('/dashboard', { scroll: false })}\r\n    >\r\n      Dashboard\r\n    </button>\r\n  )\r\n}",
        "context": "filename=\"app/example-client-component.jsx\" switcher"
      }
    ],
    "content": "The useRouter hook allows you to programmatically change routes inside Client Components. > Recommendation: Use the component for navigation unless you have a specific requirement for using useRouter. useRouter() - router.push(href: string, { scroll: boolean }): Perform a client-side navigation to the provided route. Adds a new entry into the browser's history stack. - router.replace(href: string, { scroll: boolean }): Perform a client-side navigation to the provided route without adding a new entry into the browser’s history stack. - router.refresh(): Refresh the current route. Making a new request to the server, re-fetching data requests, and re-rendering Server Components. The client will merge the updated React Server Component payload without losing unaffected client-side React (e.g. useState) or browser state (e.g. scroll position). - router.prefetch(href: string, options?: { onInvalidate?: () => void }): Prefetch the provided route for faster client-side transitions. The optional onInvalidate callback is called when the prefetched data becomes stale. - router.back(): Navigate back to the previous route in the browser’s history stack. - router.forward(): Navigate forwards to the next page in the browser’s history stack. > Good to know: > > - You must not send untrusted or unsanitized URLs to router.push or router.replace, as this can open your site to cross-site scripting (XSS) vulnerabilities. For example, javascript: URLs sent to router.push or router.replace will be executed in the context of your page. > - The component automatically prefetch routes as they become visible in the viewport. > - refresh() could re-produce the same result if fetch requests are cached. Other Dynamic APIs like cookies and headers could also change the response. > - The onInvalidate callback is called at most once per prefetch request. It signals when you may want to trigger a new prefetch for updated route data. Migrating from next/router - The useRouter hook should be imported from next/navigation and not next/router when using the App Router - The pathname string has been removed and is replaced by usePathname() - The query object has been removed and is replaced by useSearchParams() - router.events has been replaced. See below. View the full migration guide. Examples Router events You can listen for page changes by composing other Client Component hooks like usePathname and useSearchParams. Which can be imported into a layout. > Good to know: is wrapped in a Suspense boundary becauseuseSearchParams() causes client-side rendering up to the closest Suspense boundary during static rendering. Learn more. Disabling scroll to top By default, Next.js will scroll to the top of the page when navigating to a new route. You can disable this behavior by passing scroll: false to router.push() or router.replace(). Version History | Version | Changes | | --------- | ----------------------------------------------------------------- | | v15.4.0 | Optional onInvalidate callback for router.prefetch introduced | | v13.0.0 | useRouter from next/navigation introduced. |",
    "excerpt": "The useRouter hook allows you to programmatically change routes inside Client Components. > Recommendation: Use the component for navigation unless you have a specific requirement for using useRouter....",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/04-functions/use-router"
  },
  {
    "id": "01-app-03-api-reference-04-functions-use-search-params",
    "path": "01-app\\03-api-reference\\04-functions\\use-search-params.mdx",
    "title": "useSearchParams",
    "description": "API Reference for the useSearchParams hook.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Parameters",
        "slug": "parameters"
      },
      {
        "level": 2,
        "text": "Returns",
        "slug": "returns"
      },
      {
        "level": 2,
        "text": "Behavior",
        "slug": "behavior"
      },
      {
        "level": 3,
        "text": "Static Rendering",
        "slug": "static-rendering"
      },
      {
        "level": 3,
        "text": "Dynamic Rendering",
        "slug": "dynamic-rendering"
      },
      {
        "level": 3,
        "text": "Server Components",
        "slug": "server-components"
      },
      {
        "level": 4,
        "text": "Pages",
        "slug": "pages"
      },
      {
        "level": 4,
        "text": "Layouts",
        "slug": "layouts"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Updating ",
        "slug": "updating-"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { useSearchParams } from 'next/navigation'\r\n\r\nexport default function SearchBar() {\r\n  const searchParams = useSearchParams()\r\n\r\n  const search = searchParams.get('search')\r\n\r\n  // URL -> `/dashboard?search=my-project`\r\n  // `search` -> 'my-project'\r\n  return <>Search: {search}</>\r\n}",
        "context": "filename=\"app/dashboard/search-bar.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { useSearchParams } from 'next/navigation'\r\n\r\nexport default function SearchBar() {\r\n  const searchParams = useSearchParams()\r\n\r\n  const search = searchParams.get('search')\r\n\r\n  // URL -> `/dashboard?search=my-project`\r\n  // `search` -> 'my-project'\r\n  return <>Search: {search}</>\r\n}",
        "context": "filename=\"app/dashboard/search-bar.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "const searchParams = useSearchParams()",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { useSearchParams } from 'next/navigation'\r\n\r\nexport default function SearchBar() {\r\n  const searchParams = useSearchParams()\r\n\r\n  const search = searchParams.get('search')\r\n\r\n  // This will not be logged on the server when using static rendering\r\n  console.log(search)\r\n\r\n  return <>Search: {search}</>\r\n}",
        "context": "filename=\"app/dashboard/search-bar.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { useSearchParams } from 'next/navigation'\r\n\r\nexport default function SearchBar() {\r\n  const searchParams = useSearchParams()\r\n\r\n  const search = searchParams.get('search')\r\n\r\n  // This will not be logged on the server when using static rendering\r\n  console.log(search)\r\n\r\n  return <>Search: {search}</>\r\n}",
        "context": "filename=\"app/dashboard/search-bar.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { Suspense } from 'react'\r\nimport SearchBar from './search-bar'\r\n\r\n// This component passed as a fallback to the Suspense boundary\r\n// will be rendered in place of the search bar in the initial HTML.\r\n// When the value is available during React hydration the fallback\r\n// will be replaced with the `<SearchBar>` component.\r\nfunction SearchBarFallback() {\r\n  return <>placeholder</>\r\n}\r\n\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <nav>\r\n        <Suspense fallback={<SearchBarFallback />}>\r\n          <SearchBar />\r\n        </Suspense>\r\n      </nav>\r\n      <h1>Dashboard</h1>\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/dashboard/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { Suspense } from 'react'\r\nimport SearchBar from './search-bar'\r\n\r\n// This component passed as a fallback to the Suspense boundary\r\n// will be rendered in place of the search bar in the initial HTML.\r\n// When the value is available during React hydration the fallback\r\n// will be replaced with the `<SearchBar>` component.\r\nfunction SearchBarFallback() {\r\n  return <>placeholder</>\r\n}\r\n\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <nav>\r\n        <Suspense fallback={<SearchBarFallback />}>\r\n          <SearchBar />\r\n        </Suspense>\r\n      </nav>\r\n      <h1>Dashboard</h1>\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/dashboard/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { useSearchParams } from 'next/navigation'\r\n\r\nexport default function SearchBar() {\r\n  const searchParams = useSearchParams()\r\n\r\n  const search = searchParams.get('search')\r\n\r\n  // This will be logged on the server during the initial render\r\n  // and on the client on subsequent navigations.\r\n  console.log(search)\r\n\r\n  return <>Search: {search}</>\r\n}",
        "context": "filename=\"app/dashboard/search-bar.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { useSearchParams } from 'next/navigation'\r\n\r\nexport default function SearchBar() {\r\n  const searchParams = useSearchParams()\r\n\r\n  const search = searchParams.get('search')\r\n\r\n  // This will be logged on the server during the initial render\r\n  // and on the client on subsequent navigations.\r\n  console.log(search)\r\n\r\n  return <>Search: {search}</>\r\n}",
        "context": "filename=\"app/dashboard/search-bar.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { connection } from 'next/server'\r\nimport SearchBar from './search-bar'\r\n\r\nexport default async function Page() {\r\n  await connection()\r\n  return (\r\n    <>\r\n      <nav>\r\n        <SearchBar />\r\n      </nav>\r\n      <h1>Dashboard</h1>\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/dashboard/page.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { connection } from 'next/server'\r\nimport SearchBar from './search-bar'\r\n\r\nexport default async function Page() {\r\n  await connection()\r\n  return (\r\n    <>\r\n      <nav>\r\n        <SearchBar />\r\n      </nav>\r\n      <h1>Dashboard</h1>\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/dashboard/page.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nexport default function ExampleClientComponent() {\r\n  const router = useRouter()\r\n  const pathname = usePathname()\r\n  const searchParams = useSearchParams()\r\n\r\n  // Get a new searchParams string by merging the current\r\n  // searchParams with a provided key/value pair\r\n  const createQueryString = useCallback(\r\n    (name: string, value: string) => {\r\n      const params = new URLSearchParams(searchParams.toString())\r\n      params.set(name, value)\r\n\r\n      return params.toString()\r\n    },\r\n    [searchParams]\r\n  )\r\n\r\n  return (\r\n    <>\r\n      <p>Sort By</p>\r\n\r\n      {/* using useRouter */}\r\n      <button\r\n        onClick={() => {\r\n          // <pathname>?sort=asc\r\n          router.push(pathname + '?' + createQueryString('sort', 'asc'))\r\n        }}\r\n      >\r\n        ASC\r\n      </button>\r\n\r\n      {/* using <Link> */}\r\n      <Link\r\n        href={\r\n          // <pathname>?sort=desc\r\n          pathname + '?' + createQueryString('sort', 'desc')\r\n        }\r\n      >\r\n        DESC\r\n      </Link>\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/example-client-component.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nexport default function ExampleClientComponent() {\r\n  const router = useRouter()\r\n  const pathname = usePathname()\r\n  const searchParams = useSearchParams()\r\n\r\n  // Get a new searchParams string by merging the current\r\n  // searchParams with a provided key/value pair\r\n  const createQueryString = useCallback(\r\n    (name, value) => {\r\n      const params = new URLSearchParams(searchParams)\r\n      params.set(name, value)\r\n\r\n      return params.toString()\r\n    },\r\n    [searchParams]\r\n  )\r\n\r\n  return (\r\n    <>\r\n      <p>Sort By</p>\r\n\r\n      {/* using useRouter */}\r\n      <button\r\n        onClick={() => {\r\n          // <pathname>?sort=asc\r\n          router.push(pathname + '?' + createQueryString('sort', 'asc'))\r\n        }}\r\n      >\r\n        ASC\r\n      </button>\r\n\r\n      {/* using <Link> */}\r\n      <Link\r\n        href={\r\n          // <pathname>?sort=desc\r\n          pathname + '?' + createQueryString('sort', 'desc')\r\n        }\r\n      >\r\n        DESC\r\n      </Link>\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/example-client-component.js\" switcher"
      }
    ],
    "content": "useSearchParams is a Client Component hook that lets you read the current URL's query string. useSearchParams returns a read-only version of the URLSearchParams interface. Parameters useSearchParams does not take any parameters. Returns useSearchParams returns a read-only version of the URLSearchParams interface, which includes utility methods for reading the URL's query string: - URLSearchParams.get(): Returns the first value associated with the search parameter. For example: | URL | searchParams.get(\"a\") | | -------------------- | --------------------------------------------------------------------------------------------------------------- | | /dashboard?a=1 | '1' | | /dashboard?a= | '' | | /dashboard?b=3 | null | | /dashboard?a=1&a=2 | '1' - use getAll() to get all values | - URLSearchParams.has(): Returns a boolean value indicating if the given parameter exists. For example: | URL | searchParams.has(\"a\") | | ---------------- | ----------------------- | | /dashboard?a=1 | true | | /dashboard?b=3 | false | - Learn more about other read-only methods of URLSearchParams, including the getAll(), keys(), values(), entries(), forEach(), and toString(). > Good to know: > > - useSearchParams is a Client Component hook and is not supported in Server Components to prevent stale values during partial rendering. > - If you want to fetch data in a Server Component based on search params, it's often a better option to read the searchParams prop of the corresponding Page. You can then pass it down by props to any component (Server or Client) within that Page. > - If an application includes the /pages directory, useSearchParams will return ReadonlyURLSearchParams | null. The null value is for compatibility during migration since search params cannot be known during pre-rendering of a page that doesn't use getServerSideProps Behavior Static Rendering If a route is statically rendered, calling useSearchParams will cause the Client Component tree up to the closest Suspense boundary to be client-side rendered. This allows a part of the route to be statically rendered while the dynamic part that uses useSearchParams is client-side rendered. We recommend wrapping the Client Component that uses useSearchParams in a boundary. This will allow any Client Components above it to be statically rendered and sent as part of initial HTML. Example. For example: > Good to know: > > - In development, routes are rendered on-demand, so useSearchParams doesn't suspend and things may appear to work without Suspense. > - During production builds, a static page that calls useSearchParams from a Client Component must be wrapped in a Suspense boundary, otherwise the build fails with the Missing Suspense boundary with useSearchParams error. > - If you intend the route to be dynamically rendered, prefer using the connection function first in a Server Component to wait for an incoming request, this excludes everything below from prerendering. See what makes a route dynamic in the Dynamic Rendering guide. > - If you're already in a Server Component Page, consider using the searchParams prop and passing the values to Client Components. > - You can also pass the Page searchParams prop directly to a Client Component and unwrap it with React's use(). Although this will suspend, so the Client Component should be wrapped with a Suspense boundary. Dynamic Rendering If a route is dynamically rendered, useSearchParams will be available on the server during the initial server render of the Client Component. For example: > Good to know: > > - Previously, setting export const dynamic = 'force-dynamic' on the page was used to force dynamic rendering. Prefer using connection() instead, as it semantically ties dynamic rendering to the incoming request. Server Components Pages To access search params in Pages (Server Components), use the searchParams prop. Layouts Unlike Pages, Layouts (Server Components) do not receive the searchParams prop. This is because a shared layout is not re-rendered during navigation which could lead to stale searchParams between navigations. View detailed explanation. Instead, use the Page searchParams prop or the useSearchParams hook in a Client Component, which is re-rendered on the client with the latest searchParams. Examples Updating searchParams You can use useRouter or Link to set new searchParams. After a navigation is performed, the current page.js will receive an updated searchParams prop. Version History | Version | Changes | | --------- | ----------------------------- | | v13.0.0 | useSearchParams introduced. |",
    "excerpt": "useSearchParams is a Client Component hook that lets you read the current URL's query string. useSearchParams returns a read-only version of the URLSearchParams interface. Parameters useSearchParams d...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/04-functions/use-search-params"
  },
  {
    "id": "01-app-03-api-reference-04-functions-use-selected-layout-segment",
    "path": "01-app\\03-api-reference\\04-functions\\use-selected-layout-segment.mdx",
    "title": "useSelectedLayoutSegment",
    "description": "API Reference for the useSelectedLayoutSegment hook.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Parameters",
        "slug": "parameters"
      },
      {
        "level": 2,
        "text": "Returns",
        "slug": "returns"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Creating an active link component",
        "slug": "creating-an-active-link-component"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { useSelectedLayoutSegment } from 'next/navigation'\r\n\r\nexport default function ExampleClientComponent() {\r\n  const segment = useSelectedLayoutSegment()\r\n\r\n  return <p>Active segment: {segment}</p>\r\n}",
        "context": "filename=\"app/example-client-component.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { useSelectedLayoutSegment } from 'next/navigation'\r\n\r\nexport default function ExampleClientComponent() {\r\n  const segment = useSelectedLayoutSegment()\r\n\r\n  return <p>Active segment: {segment}</p>\r\n}",
        "context": "filename=\"app/example-client-component.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "const segment = useSelectedLayoutSegment(parallelRoutesKey?: string)",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport Link from 'next/link'\r\nimport { useSelectedLayoutSegment } from 'next/navigation'\r\n\r\n// This *client* component will be imported into a blog layout\r\nexport default function BlogNavLink({\r\n  slug,\r\n  children,\r\n}: {\r\n  slug: string\r\n  children: React.ReactNode\r\n}) {\r\n  // Navigating to `/blog/hello-world` will return 'hello-world'\r\n  // for the selected layout segment\r\n  const segment = useSelectedLayoutSegment()\r\n  const isActive = slug === segment\r\n\r\n  return (\r\n    <Link\r\n      href={`/blog/${slug}`}\r\n      // Change style depending on whether the link is active\r\n      style={{ fontWeight: isActive ? 'bold' : 'normal' }}\r\n    >\r\n      {children}\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"app/blog/blog-nav-link.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport Link from 'next/link'\r\nimport { useSelectedLayoutSegment } from 'next/navigation'\r\n\r\n// This *client* component will be imported into a blog layout\r\nexport default function BlogNavLink({ slug, children }) {\r\n  // Navigating to `/blog/hello-world` will return 'hello-world'\r\n  // for the selected layout segment\r\n  const segment = useSelectedLayoutSegment()\r\n  const isActive = slug === segment\r\n\r\n  return (\r\n    <Link\r\n      href={`/blog/${slug}`}\r\n      // Change style depending on whether the link is active\r\n      style={{ fontWeight: isActive ? 'bold' : 'normal' }}\r\n    >\r\n      {children}\r\n    </Link>\r\n  )\r\n}",
        "context": "filename=\"app/blog/blog-nav-link.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "// Import the Client Component into a parent Layout (Server Component)\r\nimport { BlogNavLink } from './blog-nav-link'\r\nimport getFeaturedPosts from './get-featured-posts'\r\n\r\nexport default async function Layout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode\r\n}) {\r\n  const featuredPosts = await getFeaturedPosts()\r\n  return (\r\n    <div>\r\n      {featuredPosts.map((post) => (\r\n        <div key={post.id}>\r\n          <BlogNavLink slug={post.slug}>{post.title}</BlogNavLink>\r\n        </div>\r\n      ))}\r\n      <div>{children}</div>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/blog/layout.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "// Import the Client Component into a parent Layout (Server Component)\r\nimport { BlogNavLink } from './blog-nav-link'\r\nimport getFeaturedPosts from './get-featured-posts'\r\n\r\nexport default async function Layout({ children }) {\r\n  const featuredPosts = await getFeaturedPosts()\r\n  return (\r\n    <div>\r\n      {featuredPosts.map((post) => (\r\n        <div key={post.id}>\r\n          <BlogNavLink slug={post.slug}>{post.title}</BlogNavLink>\r\n        </div>\r\n      ))}\r\n      <div>{children}</div>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"app/blog/layout.js\" switcher"
      }
    ],
    "content": "useSelectedLayoutSegment is a Client Component hook that lets you read the active route segment one level below the Layout it is called from. It is useful for navigation UI, such as tabs inside a parent layout that change style depending on the active child segment. > Good to know: > > - Since useSelectedLayoutSegment is a Client Component hook, and Layouts are Server Components by default, useSelectedLayoutSegment is usually called via a Client Component that is imported into a Layout. > - useSelectedLayoutSegment only returns the segment one level down. To return all active segments, see useSelectedLayoutSegments Parameters useSelectedLayoutSegment optionally accepts a parallelRoutesKey, which allows you to read the active route segment within that slot. Returns useSelectedLayoutSegment returns a string of the active segment or null if one doesn't exist. For example, given the Layouts and URLs below, the returned segment would be: | Layout | Visited URL | Returned Segment | | ------------------------- | ------------------------------ | ---------------- | | app/layout.js | / | null | | app/layout.js | /dashboard | 'dashboard' | | app/dashboard/layout.js | /dashboard | null | | app/dashboard/layout.js | /dashboard/settings | 'settings' | | app/dashboard/layout.js | /dashboard/analytics | 'analytics' | | app/dashboard/layout.js | /dashboard/analytics/monthly | 'analytics' | Examples Creating an active link component You can use useSelectedLayoutSegment to create an active link component that changes style depending on the active segment. For example, a featured posts list in the sidebar of a blog: Version History | Version | Changes | | --------- | -------------------------------------- | | v13.0.0 | useSelectedLayoutSegment introduced. |",
    "excerpt": "useSelectedLayoutSegment is a Client Component hook that lets you read the active route segment one level below the Layout it is called from. It is useful for navigation UI, such as tabs inside a pare...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/04-functions/use-selected-layout-segment"
  },
  {
    "id": "01-app-03-api-reference-04-functions-use-selected-layout-segments",
    "path": "01-app\\03-api-reference\\04-functions\\use-selected-layout-segments.mdx",
    "title": "useSelectedLayoutSegments",
    "description": "API Reference for the useSelectedLayoutSegments hook.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Parameters",
        "slug": "parameters"
      },
      {
        "level": 2,
        "text": "Returns",
        "slug": "returns"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport { useSelectedLayoutSegments } from 'next/navigation'\r\n\r\nexport default function ExampleClientComponent() {\r\n  const segments = useSelectedLayoutSegments()\r\n\r\n  return (\r\n    <ul>\r\n      {segments.map((segment, index) => (\r\n        <li key={index}>{segment}</li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}",
        "context": "filename=\"app/example-client-component.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "'use client'\r\n\r\nimport { useSelectedLayoutSegments } from 'next/navigation'\r\n\r\nexport default function ExampleClientComponent() {\r\n  const segments = useSelectedLayoutSegments()\r\n\r\n  return (\r\n    <ul>\r\n      {segments.map((segment, index) => (\r\n        <li key={index}>{segment}</li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}",
        "context": "filename=\"app/example-client-component.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "const segments = useSelectedLayoutSegments(parallelRoutesKey?: string)",
        "context": ""
      }
    ],
    "content": "useSelectedLayoutSegments is a Client Component hook that lets you read the active route segments below the Layout it is called from. It is useful for creating UI in parent Layouts that need knowledge of active child segments such as breadcrumbs. > Good to know: > > - Since useSelectedLayoutSegments is a Client Component hook, and Layouts are Server Components by default, useSelectedLayoutSegments is usually called via a Client Component that is imported into a Layout. > - The returned segments include Route Groups, which you might not want to be included in your UI. You can use the filter array method to remove items that start with a bracket. Parameters useSelectedLayoutSegments optionally accepts a parallelRoutesKey, which allows you to read the active route segment within that slot. Returns useSelectedLayoutSegments returns an array of strings containing the active segments one level down from the layout the hook was called from. Or an empty array if none exist. For example, given the Layouts and URLs below, the returned segments would be: | Layout | Visited URL | Returned Segments | | ------------------------- | --------------------- | --------------------------- | | app/layout.js | / | [] | | app/layout.js | /dashboard | ['dashboard'] | | app/layout.js | /dashboard/settings | ['dashboard', 'settings'] | | app/dashboard/layout.js | /dashboard | [] | | app/dashboard/layout.js | /dashboard/settings | ['settings'] | Version History | Version | Changes | | --------- | --------------------------------------- | | v13.0.0 | useSelectedLayoutSegments introduced. |",
    "excerpt": "useSelectedLayoutSegments is a Client Component hook that lets you read the active route segments below the Layout it is called from. It is useful for creating UI in parent Layouts that need knowledge...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/04-functions/use-selected-layout-segments"
  },
  {
    "id": "01-app-03-api-reference-04-functions-userAgent",
    "path": "01-app\\03-api-reference\\04-functions\\userAgent.mdx",
    "title": "userAgent",
    "description": "The userAgent helper extends the Web Request API with additional properties and methods to interact with the user agent object from the request.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "import { NextRequest, NextResponse, userAgent } from 'next/server'\r\n\r\nexport function proxy(request: NextRequest) {\r\n  const url = request.nextUrl\r\n  const { device } = userAgent(request)\r\n\r\n  // device.type can be: 'mobile', 'tablet', 'console', 'smarttv',\r\n  // 'wearable', 'embedded', or undefined (for desktop browsers)\r\n  const viewport = device.type || 'desktop'\r\n\r\n  url.searchParams.set('viewport', viewport)\r\n  return NextResponse.rewrite(url)\r\n}",
        "context": "filename=\"proxy.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { NextResponse, userAgent } from 'next/server'\r\n\r\nexport function proxy(request) {\r\n  const url = request.nextUrl\r\n  const { device } = userAgent(request)\r\n\r\n  // device.type can be: 'mobile', 'tablet', 'console', 'smarttv',\r\n  // 'wearable', 'embedded', or undefined (for desktop browsers)\r\n  const viewport = device.type || 'desktop'\r\n\r\n  url.searchParams.set('viewport', viewport)\r\n  return NextResponse.rewrite(url)\r\n}",
        "context": "filename=\"proxy.js\" switcher"
      }
    ],
    "content": "The userAgent helper extends the Web Request API with additional properties and methods to interact with the user agent object from the request. isBot A boolean indicating whether the request comes from a known bot. browser An object containing information about the browser used in the request. - name: A string representing the browser's name, or undefined if not identifiable. - version: A string representing the browser's version, or undefined. device An object containing information about the device used in the request. - model: A string representing the model of the device, or undefined. - type: A string representing the type of the device, such as console, mobile, tablet, smarttv, wearable, embedded, or undefined. - vendor: A string representing the vendor of the device, or undefined. engine An object containing information about the browser's engine. - name: A string representing the engine's name. Possible values include: Amaya, Blink, EdgeHTML, Flow, Gecko, Goanna, iCab, KHTML, Links, Lynx, NetFront, NetSurf, Presto, Tasman, Trident, w3m, WebKit or undefined. - version: A string representing the engine's version, or undefined. os An object containing information about the operating system. - name: A string representing the name of the OS, or undefined. - version: A string representing the version of the OS, or undefined. cpu An object containing information about the CPU architecture. - architecture: A string representing the architecture of the CPU. Possible values include: 68k, amd64, arm, arm64, armhf, avr, ia32, ia64, irix, irix64, mips, mips64, pa-risc, ppc, sparc, sparc64 or undefined",
    "excerpt": "The userAgent helper extends the Web Request API with additional properties and methods to interact with the user agent object from the request. isBot A boolean indicating whether the request comes fr...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/04-functions/userAgent"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-adapterPath",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\adapterPath.mdx",
    "title": "experimental.adapterPath",
    "description": "Configure a custom adapter for Next.js to hook into the build process with modifyConfig and onBuildComplete callbacks.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Configuration",
        "slug": "configuration"
      },
      {
        "level": 2,
        "text": "Creating an Adapter",
        "slug": "creating-an-adapter"
      },
      {
        "level": 3,
        "text": "Basic Adapter Structure",
        "slug": "basic-adapter-structure"
      },
      {
        "level": 2,
        "text": "API Reference",
        "slug": "api-reference"
      },
      {
        "level": 2,
        "text": "Output Types",
        "slug": "output-types"
      },
      {
        "level": 3,
        "text": "Pages ()",
        "slug": "pages-"
      },
      {
        "level": 3,
        "text": "API Routes ()",
        "slug": "api-routes-"
      },
      {
        "level": 3,
        "text": "App Pages ()",
        "slug": "app-pages-"
      },
      {
        "level": 3,
        "text": "App Routes ()",
        "slug": "app-routes-"
      },
      {
        "level": 3,
        "text": "Prerenders ()",
        "slug": "prerenders-"
      },
      {
        "level": 3,
        "text": "Static Files ()",
        "slug": "static-files-"
      },
      {
        "level": 3,
        "text": "Middleware ()",
        "slug": "middleware-"
      },
      {
        "level": 2,
        "text": "Routes Information",
        "slug": "routes-information"
      },
      {
        "level": 3,
        "text": "Headers",
        "slug": "headers"
      },
      {
        "level": 3,
        "text": "Redirects",
        "slug": "redirects"
      },
      {
        "level": 3,
        "text": "Rewrites",
        "slug": "rewrites"
      },
      {
        "level": 3,
        "text": "Dynamic Routes",
        "slug": "dynamic-routes"
      },
      {
        "level": 2,
        "text": "Use Cases",
        "slug": "use-cases"
      }
    ],
    "codeBlocks": [
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  experimental: {\r\n    adapterPath: require.resolve('./my-adapter.js'),\r\n  },\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "typescript",
        "code": "export interface NextAdapter {\r\n  name: string\r\n  modifyConfig?: (\r\n    config: NextConfigComplete,\r\n    ctx: {\r\n      phase: PHASE_TYPE\r\n    }\r\n  ) => Promise<NextConfigComplete> | NextConfigComplete\r\n  onBuildComplete?: (ctx: {\r\n    routes: {\r\n      headers: Array<ManifestHeaderRoute>\r\n      redirects: Array<ManifestRedirectRoute>\r\n      rewrites: {\r\n        beforeFiles: Array<ManifestRewriteRoute>\r\n        afterFiles: Array<ManifestRewriteRoute>\r\n        fallback: Array<ManifestRewriteRoute>\r\n      }\r\n      dynamicRoutes: ReadonlyArray<ManifestRoute>\r\n    }\r\n    outputs: AdapterOutputs\r\n    projectDir: string\r\n    repoRoot: string\r\n    distDir: string\r\n    config: NextConfigComplete\r\n    nextVersion: string\r\n  }) => Promise<void> | void\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextAdapter} */\r\nconst adapter = {\r\n  name: 'my-custom-adapter',\r\n\r\n  async modifyConfig(config, { phase }) {\r\n    // Modify the Next.js config based on the build phase\r\n    if (phase === 'phase-production-build') {\r\n      return {\r\n        ...config,\r\n        // Add your modifications\r\n      }\r\n    }\r\n    return config\r\n  },\r\n\r\n  async onBuildComplete({\r\n    routes,\r\n    outputs,\r\n    projectDir,\r\n    repoRoot,\r\n    distDir,\r\n    config,\r\n    nextVersion,\r\n  }) {\r\n    // Process the build output\r\n    console.log('Build completed with', outputs.pages.length, 'pages')\r\n\r\n    // Access different output types\r\n    for (const page of outputs.pages) {\r\n      console.log('Page:', page.pathname, 'at', page.filePath)\r\n    }\r\n\r\n    for (const apiRoute of outputs.pagesApi) {\r\n      console.log('API Route:', apiRoute.pathname, 'at', apiRoute.filePath)\r\n    }\r\n\r\n    for (const appPage of outputs.appPages) {\r\n      console.log('App Page:', appPage.pathname, 'at', appPage.filePath)\r\n    }\r\n\r\n    for (const prerender of outputs.prerenders) {\r\n      console.log('Prerendered:', prerender.pathname)\r\n    }\r\n  },\r\n}\r\n\r\nmodule.exports = adapter",
        "context": "filename=\"my-adapter.js\""
      },
      {
        "language": "typescript",
        "code": "{\r\n  type: 'PAGES'\r\n  id: string           // Route identifier\r\n  filePath: string     // Path to the built file\r\n  pathname: string     // URL pathname\r\n  sourcePage: string   // Original source file path in pages/ directory\r\n  runtime: 'nodejs' | 'edge'\r\n  assets: Record<string, string>  // Traced dependencies (key: relative path from repo root, value: absolute path)\r\n  wasmAssets?: Record<string, string>  // Bundled wasm files (key: name, value: absolute path)\r\n  config: {\r\n    maxDuration?: number\r\n    preferredRegion?: string | string[]\r\n    env?: Record<string, string>  // Environment variables (edge runtime only)\r\n  }\r\n}",
        "context": ""
      },
      {
        "language": "typescript",
        "code": "{\r\n  type: 'PAGES_API'\r\n  id: string\r\n  filePath: string\r\n  pathname: string\r\n  sourcePage: string   // Original relative source file path\r\n  runtime: 'nodejs' | 'edge'\r\n  assets: Record<string, string>\r\n  wasmAssets?: Record<string, string>\r\n  config: {\r\n    maxDuration?: number\r\n    preferredRegion?: string | string[]\r\n    env?: Record<string, string>\r\n  }\r\n}",
        "context": ""
      },
      {
        "language": "typescript",
        "code": "{\r\n  type: 'APP_PAGE'\r\n  id: string\r\n  filePath: string\r\n  pathname: string     // Includes .rsc suffix for RSC routes\r\n  sourcePage: string   // Original relative source file path\r\n  runtime: 'nodejs' | 'edge'\r\n  assets: Record<string, string>\r\n  wasmAssets?: Record<string, string>\r\n  config: {\r\n    maxDuration?: number\r\n    preferredRegion?: string | string[]\r\n    env?: Record<string, string>\r\n  }\r\n}",
        "context": ""
      },
      {
        "language": "typescript",
        "code": "{\r\n  type: 'APP_ROUTE'\r\n  id: string\r\n  filePath: string\r\n  pathname: string\r\n  sourcePage: string\r\n  runtime: 'nodejs' | 'edge'\r\n  assets: Record<string, string>\r\n  wasmAssets?: Record<string, string>\r\n  config: {\r\n    maxDuration?: number\r\n    preferredRegion?: string | string[]\r\n    env?: Record<string, string>\r\n  }\r\n}",
        "context": ""
      },
      {
        "language": "typescript",
        "code": "{\r\n  type: 'PRERENDER'\r\n  id: string\r\n  pathname: string\r\n  parentOutputId: string  // ID of the source page/route\r\n  groupId: number        // Revalidation group identifier (prerenders with same groupId revalidate together)\r\n  pprChain?: {\r\n    headers: Record<string, string>  // PPR chain headers (e.g., 'x-nextjs-resume': '1')\r\n  }\r\n  parentFallbackMode?: 'blocking' | false | null  // Fallback mode from getStaticPaths\r\n  fallback?: {\r\n    filePath: string\r\n    initialStatus?: number\r\n    initialHeaders?: Record<string, string | string[]>\r\n    initialExpiration?: number\r\n    initialRevalidate?: number\r\n    postponedState?: string  // PPR postponed state\r\n  }\r\n  config: {\r\n    allowQuery?: string[]     // Allowed query parameters\r\n    allowHeader?: string[]    // Allowed headers for ISR\r\n    bypassFor?: RouteHas[]    // Cache bypass conditions\r\n    renderingMode?: RenderingMode\r\n    bypassToken?: string\r\n  }\r\n}",
        "context": ""
      },
      {
        "language": "typescript",
        "code": "{\r\n  type: 'STATIC_FILE'\r\n  id: string\r\n  filePath: string\r\n  pathname: string\r\n}",
        "context": ""
      },
      {
        "language": "typescript",
        "code": "{\r\n  type: 'MIDDLEWARE'\r\n  id: string\r\n  filePath: string\r\n  pathname: string      // Always '/_middleware'\r\n  sourcePage: string    // Always 'middleware'\r\n  runtime: 'nodejs' | 'edge'\r\n  assets: Record<string, string>\r\n  wasmAssets?: Record<string, string>\r\n  config: {\r\n    maxDuration?: number\r\n    preferredRegion?: string | string[]\r\n    env?: Record<string, string>\r\n    matchers?: Array<{\r\n      source: string\r\n      sourceRegex: string\r\n      has: RouteHas[] | undefined\r\n      missing: RouteHas[] | undefined\r\n    }>\r\n  }\r\n}",
        "context": ""
      }
    ],
    "content": "Next.js provides an experimental API that allows you to create custom adapters to hook into the build process. This is useful for deployment platforms or custom build integrations that need to modify the Next.js configuration or process the build output. Configuration To use an adapter, specify the path to your adapter module in experimental.adapterPath: Creating an Adapter An adapter is a module that exports an object implementing the NextAdapter interface: Basic Adapter Structure Here's a minimal adapter example: API Reference modifyConfig(config, context) Called for any CLI command that loads the next.config to allow modification of the configuration. Parameters: - config: The complete Next.js configuration object - context.phase: The current build phase (see phases) Returns: The modified configuration object (can be async) onBuildComplete(context) Called after the build process completes with detailed information about routes and outputs. Parameters: - routes: Object containing route manifests for headers, redirects, rewrites, and dynamic routes - routes.headers: Array of header route objects with source, sourceRegex, headers, has, missing, and optional priority fields - routes.redirects: Array of redirect route objects with source, sourceRegex, destination, statusCode, has, missing, and optional priority fields - routes.rewrites: Object with beforeFiles, afterFiles, and fallback arrays, each containing rewrite route objects with source, sourceRegex, destination, has, and missing fields - routes.dynamicRoutes: Array of dynamic route objects with source, sourceRegex, destination, has, and missing fields - outputs: Detailed information about all build outputs organized by type - projectDir: Absolute path to the Next.js project directory - repoRoot: Absolute path to the detected repository root - distDir: Absolute path to the build output directory - config: The final Next.js configuration (with modifyConfig applied) - nextVersion: Version of Next.js being used - buildId: Unique identifier for the current build Output Types The outputs object contains arrays of different output types: Pages (outputs.pages) React pages from the pages/ directory: API Routes (outputs.pagesApi) API routes from pages/api/: App Pages (outputs.appPages) React pages from the app/ directory with page.{js,ts,jsx,tsx}: App Routes (outputs.appRoutes) API and metadata routes from app/ with route.{js,ts,jsx,tsx}: Prerenders (outputs.prerenders) ISR-enabled routes and static prerenders: Static Files (outputs.staticFiles) Static assets and auto-statically optimized pages: Middleware (outputs.middleware) Middleware function (if present): Routes Information The routes object in onBuildComplete provides complete routing information with processed patterns ready for deployment: Headers Each header route includes: - source: Original route pattern (e.g., /about) - sourceRegex: Compiled regex for matching requests - headers: Key-value pairs of headers to apply - has: Optional conditions that must be met - missing: Optional conditions that must not be met - priority: Optional flag for internal routes Redirects Each redirect route includes: - source: Original route pattern - sourceRegex: Compiled regex for matching - destination: Target URL (can include captured groups) - statusCode: HTTP status code (301, 302, 307, 308) - has: Optional positive conditions - missing: Optional negative conditions - priority: Optional flag for internal routes Rewrites Rewrites are categorized into three phases: - beforeFiles: Checked before filesystem (including pages and public files) - afterFiles: Checked after pages/public files but before dynamic routes - fallback: Checked after all other routes Each rewrite includes source, sourceRegex, destination, has, and missing. Dynamic Routes Generated from dynamic route segments (e.g., [slug], [...path]). Each includes: - source: Route pattern - sourceRegex: Compiled regex with named capture groups - destination: Internal destination with parameter substitution - has: Optional positive conditions - missing: Optional negative conditions Use Cases Common use cases for adapters include: - Deployment Platform Integration: Automatically configure build outputs for specific hosting platforms - Asset Processing: Transform or optimize build outputs - Monitoring Integration: Collect build metrics and route information - Custom Bundling: Package outputs in platform-specific formats - Build Validation: Ensure outputs meet specific requirements - Route Generation: Use processed route information to generate platform-specific routing configs",
    "excerpt": "Next.js provides an experimental API that allows you to create custom adapters to hook into the build process. This is useful for deployment platforms or custom build integrations that need to modify...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/adapterPath"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-allowedDevOrigins",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\allowedDevOrigins.mdx",
    "title": "allowedDevOrigins",
    "description": "Use `allowedDevOrigins` to configure additional origins that can request the dev server.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [
      {
        "language": "js",
        "code": "module.exports = {\r\n  allowedDevOrigins: ['local-origin.dev', '*.local-origin.dev'],\r\n}",
        "context": "filename=\"next.config.js\""
      }
    ],
    "content": "Next.js does not automatically block cross-origin requests during development, but will block by default in a future major version of Next.js to prevent unauthorized requesting of internal assets/endpoints that are available in development mode. To configure a Next.js application to allow requests from origins other than the hostname the server was initialized with (localhost by default) you can use the allowedDevOrigins config option. allowedDevOrigins allows you to set additional origins that can be used in development mode. For example, to use local-origin.dev instead of only localhost, open next.config.js and add the allowedDevOrigins config:",
    "excerpt": "Next.js does not automatically block cross-origin requests during development, but will block by default in a future major version of Next.js to prevent unauthorized requesting of internal assets/endp...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/allowedDevOrigins"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-appDir",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\appDir.mdx",
    "title": "appDir",
    "description": "Enable the App Router to use layouts, streaming, and more.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "> Good to know: This option is no longer needed as of Next.js 13.4. The App Router is now stable. The App Router (app directory) enables support for layouts, Server Components, streaming, and colocated data fetching. Using the app directory will automatically enable React Strict Mode. Learn how to incrementally adopt app.",
    "excerpt": "> Good to know: This option is no longer needed as of Next.js 13.4. The App Router is now stable. The App Router (app directory) enables support for layouts, Server Components, streaming, and colocate...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/appDir"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-assetPrefix",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\assetPrefix.mdx",
    "title": "assetPrefix",
    "description": "Learn how to use the assetPrefix config option to configure your CDN.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Set up a CDN",
        "slug": "set-up-a-cdn"
      }
    ],
    "codeBlocks": [
      {
        "language": "js",
        "code": "// @ts-check\r\nimport { PHASE_DEVELOPMENT_SERVER } from 'next/constants'\r\n\r\nexport default (phase) => {\r\n  const isDev = phase === PHASE_DEVELOPMENT_SERVER\r\n  /**\r\n   * @type {import('next').NextConfig}\r\n   */\r\n  const nextConfig = {\r\n    assetPrefix: isDev ? undefined : 'https://cdn.mydomain.com',\r\n  }\r\n  return nextConfig\r\n}",
        "context": "filename=\"next.config.mjs\""
      },
      {
        "language": "text",
        "code": "/_next/static/chunks/4b9b41aaa062cbbfeff4add70f256968c51ece5d.4d708494b3aed70c04f0.js",
        "context": ""
      },
      {
        "language": "text",
        "code": "https://cdn.mydomain.com/_next/static/chunks/4b9b41aaa062cbbfeff4add70f256968c51ece5d.4d708494b3aed70c04f0.js",
        "context": ""
      }
    ],
    "content": "> Attention: Deploying to Vercel automatically configures a global CDN for your Next.js project. > You do not need to manually setup an Asset Prefix. > Attention: Deploying to Vercel automatically configures a global CDN for your Next.js project. > You do not need to manually setup an Asset Prefix. > Good to know: Next.js 9.5+ added support for a customizable Base Path, which is better > suited for hosting your application on a sub-path like /docs. > We do not suggest you use a custom Asset Prefix for this use case. Set up a CDN To set up a CDN, you can set up an asset prefix and configure your CDN's origin to resolve to the domain that Next.js is hosted on. Open next.config.mjs and add the assetPrefix config based on the phase: Next.js will automatically use your asset prefix for the JavaScript and CSS files it loads from the /next/ path (.next/static/ folder). For example, with the above configuration, the following request for a JS chunk: Would instead become: The exact configuration for uploading your files to a given CDN will depend on your CDN of choice. The only folder you need to host on your CDN is the contents of .next/static/, which should be uploaded as next/static/ as the above URL request indicates. Do not upload the rest of your .next/ folder, as you should not expose your server code and other configuration to the public. While assetPrefix covers requests to next/static, it does not influence the following paths: - Files in the public folder; if you want to serve those assets over a CDN, you'll have to introduce the prefix yourself - Files in the public folder; if you want to serve those assets over a CDN, you'll have to introduce the prefix yourself - /next/data/ requests for getServerSideProps pages. These requests will always be made against the main domain since they're not static. - /next/data/ requests for getStaticProps pages. These requests will always be made against the main domain to support Incremental Static Generation, even if you're not using it (for consistency).",
    "excerpt": "> Attention: Deploying to Vercel automatically configures a global CDN for your Next.js project. > You do not need to manually setup an Asset Prefix. > Attention: Deploying to Vercel automatically con...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/assetPrefix"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-authInterrupts",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\authInterrupts.mdx",
    "title": "authInterrupts",
    "description": "Learn how to enable the experimental `authInterrupts` configuration option to use `forbidden` and `unauthorized`.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  experimental: {\r\n    authInterrupts: true,\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  experimental: {\r\n    authInterrupts: true,\r\n  },\r\n}",
        "context": "filename=\"next.config.js\" switcher"
      }
    ],
    "content": "The authInterrupts configuration option allows you to use forbidden and unauthorized APIs in your application. While these functions are experimental, you must enable the authInterrupts option in your next.config.js file to use them:",
    "excerpt": "The authInterrupts configuration option allows you to use forbidden and unauthorized APIs in your application. While these functions are experimental, you must enable the authInterrupts option in your...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/authInterrupts"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-basePath",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\basePath.mdx",
    "title": "basePath",
    "description": "Use `basePath` to deploy a Next.js application under a sub-path of a domain.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 3,
        "text": "Links",
        "slug": "links"
      },
      {
        "level": 3,
        "text": "Images",
        "slug": "images"
      }
    ],
    "codeBlocks": [
      {
        "language": "js",
        "code": "module.exports = {\r\n  basePath: '/docs',\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "export default function HomePage() {\r\n  return (\r\n    <>\r\n      <Link href=\"/about\">About Page</Link>\r\n    </>\r\n  )\r\n}",
        "context": ""
      },
      {
        "language": "html",
        "code": "<a href=\"/docs/about\">About Page</a>",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import Image from 'next/image'\r\n\r\nfunction Home() {\r\n  return (\r\n    <>\r\n      <h1>My Homepage</h1>\r\n      <Image\r\n        src=\"/docs/me.png\"\r\n        alt=\"Picture of the author\"\r\n        width={500}\r\n        height={500}\r\n      />\r\n      <p>Welcome to my homepage!</p>\r\n    </>\r\n  )\r\n}\r\n\r\nexport default Home",
        "context": ""
      }
    ],
    "content": "To deploy a Next.js application under a sub-path of a domain you can use the basePath config option. basePath allows you to set a path prefix for the application. For example, to use /docs instead of '' (an empty string, the default), open next.config.js and add the basePath config: > Good to know: This value must be set at build time and cannot be changed without re-building as the value is inlined in the client-side bundles. Links When linking to other pages using next/link and next/router the basePath will be automatically applied. For example, using /about will automatically become /docs/about when basePath is set to /docs. Output html: This makes sure that you don't have to change all links in your application when changing the basePath value. Images When using the next/image component, you will need to add the basePath in front of src. When using the next/image component, you will need to add the basePath in front of src. For example, using /docs/me.png will properly serve your image when basePath is set to /docs.",
    "excerpt": "To deploy a Next.js application under a sub-path of a domain you can use the basePath config option. basePath allows you to set a path prefix for the application. For example, to use /docs instead of...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/basePath"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-browserDebugInfoInTerminal",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\browserDebugInfoInTerminal.mdx",
    "title": "browserDebugInfoInTerminal",
    "description": "Forward browser console logs and errors to your terminal during development.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Usage",
        "slug": "usage"
      },
      {
        "level": 3,
        "text": "Serialization limits",
        "slug": "serialization-limits"
      },
      {
        "level": 3,
        "text": "Source location",
        "slug": "source-location"
      }
    ],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  experimental: {\r\n    browserDebugInfoInTerminal: true,\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  experimental: {\r\n    browserDebugInfoInTerminal: true,\r\n  },\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  experimental: {\r\n    browserDebugInfoInTerminal: {\r\n      depthLimit: 5,\r\n      edgeLimit: 100,\r\n    },\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  experimental: {\r\n    browserDebugInfoInTerminal: {\r\n      depthLimit: 5,\r\n      edgeLimit: 100,\r\n    },\r\n  },\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nexport default function Home() {\r\n  return (\r\n    <button\r\n      type=\"button\"\r\n      onClick={() => {\r\n        console.log('Hello World')\r\n      }}\r\n    >\r\n      Click me\r\n    </button>\r\n  )\r\n}",
        "context": "filename=\"app/page.tsx\" highlight={8}"
      },
      {
        "language": "bash",
        "code": "[browser] Hello World (app/page.tsx:8:17)",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  experimental: {\r\n    browserDebugInfoInTerminal: {\r\n      showSourceLocation: false,\r\n    },\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  experimental: {\r\n    browserDebugInfoInTerminal: {\r\n      showSourceLocation: false,\r\n    },\r\n  },\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\" switcher"
      }
    ],
    "content": "The experimental.browserDebugInfoInTerminal option forwards console output and runtime errors originating in the browser to the dev server terminal. This option is disabled by default. When enabled it only works in development mode. Usage Enable forwarding: Serialization limits Deeply nested objects/arrays are truncated using sensible defaults. You can tweak these limits: - depthLimit: (optional) Limit stringification depth for nested objects/arrays. Default: 5 - edgeLimit: (optional) Max number of properties or elements to include per object or array. Default: 100 Source location Source locations are included by default when this feature is enabled. Clicking the button prints this message to the terminal. To suppress them, set showSourceLocation: false. - showSourceLocation: Include source location info when available. | Version | Changes | | --------- | ---------------------------------------------------- | | v15.4.0 | experimental browserDebugInfoInTerminal introduced |",
    "excerpt": "The experimental.browserDebugInfoInTerminal option forwards console output and runtime errors originating in the browser to the dev server terminal. This option is disabled by default. When enabled it...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/browserDebugInfoInTerminal"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-cacheComponents",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\cacheComponents.mdx",
    "title": "cacheComponents",
    "description": "Learn how to enable the cacheComponents flag in Next.js.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Usage",
        "slug": "usage"
      },
      {
        "level": 2,
        "text": "Notes",
        "slug": "notes"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  cacheComponents: true,\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\""
      }
    ],
    "content": "The cacheComponents flag is a feature in Next.js that causes data fetching operations in the App Router to be excluded from pre-renders unless they are explicitly cached. This can be useful for optimizing the performance of dynamic data fetching in Server Components. It is useful if your application requires fresh data fetching during runtime rather than serving from a pre-rendered cache. It is expected to be used in conjunction with use cache so that your data fetching happens at runtime by default unless you define specific parts of your application to be cached with use cache at the page, function, or component level. Usage To enable the cacheComponents flag, set it to true in your next.config.ts file: When cacheComponents is enabled, you can use the following cache functions and configurations: - The use cache directive - The cacheLife function with use cache - The cacheTag function Notes - While cacheComponents can optimize performance by ensuring fresh data fetching during runtime, it may also introduce additional latency compared to serving pre-rendered content. Version History | Version | Change | | ------- | --------------------------------------------------------------------------------------------------------------------------------- | | 16.0.0 | cacheComponents introduced. This flag controls the ppr, useCache, and dynamicIO flags as a single, unified configuration. |",
    "excerpt": "The cacheComponents flag is a feature in Next.js that causes data fetching operations in the App Router to be excluded from pre-renders unless they are explicitly cached. This can be useful for optimi...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/cacheComponents"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-cacheLife",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\cacheLife.mdx",
    "title": "cacheLife",
    "description": "Learn how to set up cacheLife configurations in Next.js.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Usage",
        "slug": "usage"
      },
      {
        "level": 2,
        "text": "Reference",
        "slug": "reference"
      }
    ],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  cacheComponents: true,\r\n  cacheLife: {\r\n    blog: {\r\n      stale: 3600, // 1 hour\r\n      revalidate: 900, // 15 minutes\r\n      expire: 86400, // 1 day\r\n    },\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  cacheComponents: true,\r\n  cacheLife: {\r\n    blog: {\r\n      stale: 3600, // 1 hour\r\n      revalidate: 900, // 15 minutes\r\n      expire: 86400, // 1 day\r\n    },\r\n  },\r\n}",
        "context": "filename=\"next.config.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { cacheLife } from 'next/cache'\r\n\r\nexport async function getCachedData() {\r\n  'use cache'\r\n  cacheLife('blog')\r\n  const data = await fetch('/api/data')\r\n  return data\r\n}",
        "context": "filename=\"app/actions.ts\" highlight={4,5} switcher"
      },
      {
        "language": "jsx",
        "code": "import { cacheLife } from 'next/cache'\r\n\r\nexport async function getCachedData() {\r\n  'use cache'\r\n  cacheLife('blog')\r\n  const data = await fetch('/api/data')\r\n  return data\r\n}",
        "context": "filename=\"app/actions.js\" highlight={4,5} switcher"
      }
    ],
    "content": "The cacheLife option allows you to define custom cache profiles when using the cacheLife function inside components or functions, and within the scope of the use cache directive. Usage To define a profile, enable the cacheComponents flag and add the cache profile in the cacheLife object in the next.config.js file. For example, a blog profile: You can now use this custom blog configuration in your component or function as follows: Reference The configuration object has key values with the following format: | Property | Value | Description | Requirement | | ------------ | --------- | --------------------------------------------------------------------------------------------------------- | ------------------------------------------- | | stale | number | Duration the client should cache a value without checking the server. | Optional | | revalidate | number | Frequency at which the cache should refresh on the server; stale values may be served while revalidating. | Optional | | expire | number | Maximum duration for which a value can remain stale before switching to dynamic. | Optional - Must be longer than revalidate |",
    "excerpt": "The cacheLife option allows you to define custom cache profiles when using the cacheLife function inside components or functions, and within the scope of the use cache directive. Usage To define a pro...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/cacheLife"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-compress",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\compress.mdx",
    "title": "compress",
    "description": "Next.js provides gzip compression to compress rendered content and static files, it only works with the server target. Learn more about it here.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Disabling compression",
        "slug": "disabling-compression"
      }
    ],
    "codeBlocks": [
      {
        "language": "js",
        "code": "module.exports = {\r\n  compress: false,\r\n}",
        "context": "filename=\"next.config.js\""
      }
    ],
    "content": "By default, Next.js uses gzip to compress rendered content and static files when using next start or a custom server. This is an optimization for applications that do not have compression configured. If compression is already configured in your application via a custom server, Next.js will not add compression. You can check if compression is enabled and which algorithm is used by looking at the Accept-Encoding (browser accepted options) and Content-Encoding (currently used) headers in the response. Disabling compression To disable compression, set the compress config option to false: We do not recommend disabling compression unless you have compression configured on your server, as compression reduces bandwidth usage and improves the performance of your application. For example, you're using nginx and want to switch to brotli, set the compress option to false to allow nginx to handle compression.",
    "excerpt": "By default, Next.js uses gzip to compress rendered content and static files when using next start or a custom server. This is an optimization for applications that do not have compression configured....",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/compress"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-crossOrigin",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\crossOrigin.mdx",
    "title": "crossOrigin",
    "description": "Use the `crossOrigin` option to add a crossOrigin tag on the `script` tags generated by `next/script`.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Options",
        "slug": "options"
      }
    ],
    "codeBlocks": [
      {
        "language": "js",
        "code": "module.exports = {\r\n  crossOrigin: 'anonymous',\r\n}",
        "context": "filename=\"next.config.js\""
      }
    ],
    "content": "Use the crossOrigin option to add a crossOrigin attribute in all tags generated by the next/script component next/script and next/headcomponents, and define how cross-origin requests should be handled. Options - 'anonymous': Adds crossOrigin=\"anonymous\" attribute. - 'use-credentials': Adds crossOrigin=\"use-credentials\".",
    "excerpt": "Use the crossOrigin option to add a crossOrigin attribute in all tags generated by the next/script component next/script and next/headcomponents, and define how cross-origin requests should be handled...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/crossOrigin"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-cssChunking",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\cssChunking.mdx",
    "title": "cssChunking",
    "description": "Use the `cssChunking` option to control how CSS files are chunked in your Next.js application.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Options",
        "slug": "options"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig = {\r\n  experimental: {\r\n    cssChunking: true, // default\r\n  },\r\n} satisfies NextConfig\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  experimental: {\r\n    cssChunking: true, // default\r\n  },\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\" switcher"
      }
    ],
    "content": "CSS Chunking is a strategy used to improve the performance of your web application by splitting and re-ordering CSS files into chunks. This allows you to load only the CSS that is needed for a specific route, instead of loading all the application's CSS at once. You can control how CSS files are chunked using the experimental.cssChunking option in your next.config.js file: Options - true (default): Next.js will try to merge CSS files whenever possible, determining explicit and implicit dependencies between files from import order to reduce the number of chunks and therefore the number of requests. - false: Next.js will not attempt to merge or re-order your CSS files. - 'strict': Next.js will load CSS files in the correct order they are imported into your files, which can lead to more chunks and requests. You may consider using 'strict' if you run into unexpected CSS behavior. For example, if you import a.css and b.css in different files using a different import order (a before b, or b before a), true will merge the files in any order and assume there are no dependencies between them. However, if b.css depends on a.css, you may want to use 'strict' to prevent the files from being merged, and instead, load them in the order they are imported - which can result in more chunks and requests. For most applications, we recommend true as it leads to fewer requests and better performance.",
    "excerpt": "CSS Chunking is a strategy used to improve the performance of your web application by splitting and re-ordering CSS files into chunks. This allows you to load only the CSS that is needed for a specifi...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/cssChunking"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-devIndicators",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\devIndicators.mdx",
    "title": "devIndicators",
    "description": "Configuration options for the on-screen indicator that gives context about the current route you're viewing during development.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Troubleshooting",
        "slug": "troubleshooting"
      },
      {
        "level": 3,
        "text": "Indicator not marking a route as static",
        "slug": "indicator-not-marking-a-route-as-static"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "  devIndicators: false | {\r\n    position?: 'bottom-right'\r\n    | 'bottom-left'\r\n    | 'top-right'\r\n    | 'top-left', // defaults to 'bottom-left',\r\n  },",
        "context": "filename=\"Types\""
      },
      {
        "language": "bash",
        "code": "Route (app)\r\n┌ ○ /_not-found\r\n└ ƒ /products/[id]\r\n\r\n○  (Static)   prerendered as static content\r\nƒ  (Dynamic)  server-rendered on demand",
        "context": "filename=\"Build Output\""
      }
    ],
    "content": "devIndicators allows you to configure the on-screen indicator that gives context about the current route you're viewing during development. Setting devIndicators to false will hide the indicator, however Next.js will continue to surface any build or runtime errors that were encountered. Troubleshooting Indicator not marking a route as static If you expect a route to be static and the indicator has marked it as dynamic, it's likely the route has opted out of static rendering. You can confirm if a route is static or dynamic by building your application using next build --debug, and checking the output in your terminal. Static (or prerendered) routes will display a ○ symbol, whereas dynamic routes will display a ƒ symbol. For example: There are two reasons a route might opt out of static rendering: - The presence of Dynamic APIs which rely on runtime information. - An uncached data request, like a call to an ORM or database driver. Check your route for any of these conditions, and if you are not able to statically render the route, then consider using loading.js or to leverage streaming. When exporting getServerSideProps or getInitialProps from a page, it will be marked as dynamic. Version History | Version | Changes | | --------- | --------------------------------------------------------------------------------------------------------------------------------------------------- | | v16.0.0 | appIsrStatus, buildActivity, and buildActivityPosition options have been removed. | | v15.2.0 | Improved on-screen indicator with new position option. appIsrStatus, buildActivity, and buildActivityPosition options have been deprecated. | | v15.0.0 | Static on-screen indicator added with appIsrStatus option. |",
    "excerpt": "devIndicators allows you to configure the on-screen indicator that gives context about the current route you're viewing during development. Setting devIndicators to false will hide the indicator, howe...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/devIndicators"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-distDir",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\distDir.mdx",
    "title": "distDir",
    "description": "Set a custom build directory to use instead of the default .next directory.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [
      {
        "language": "js",
        "code": "module.exports = {\r\n  distDir: 'build',\r\n}",
        "context": "filename=\"next.config.js\""
      }
    ],
    "content": "You can specify a name to use for a custom build directory to use instead of .next. Open next.config.js and add the distDir config: Now if you run next build Next.js will use build instead of the default .next folder. > distDir should not leave your project directory. For example, ../build is an invalid directory.",
    "excerpt": "You can specify a name to use for a custom build directory to use instead of .next. Open next.config.js and add the distDir config: Now if you run next build Next.js will use build instead of the defa...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/distDir"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-env",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\env.mdx",
    "title": "env",
    "description": "Learn to add and access environment variables in your Next.js application at build time.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [
      {
        "language": "js",
        "code": "module.exports = {\r\n  env: {\r\n    customKey: 'my-value',\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "jsx",
        "code": "function Page() {\r\n  return <h1>The value of customKey is: {process.env.customKey}</h1>\r\n}\r\n\r\nexport default Page",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "return <h1>The value of customKey is: {process.env.customKey}</h1>",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "return <h1>The value of customKey is: {'my-value'}</h1>",
        "context": ""
      }
    ],
    "content": "> Since the release of Next.js 9.4 we now have a more intuitive and ergonomic experience for adding environment variables. Give it a try! > Since the release of Next.js 9.4 we now have a more intuitive and ergonomic experience for adding environment variables. Give it a try! > Good to know: environment variables specified in this way will always be included in the JavaScript bundle, prefixing the environment variable name with NEXTPUBLIC only has an effect when specifying them through the environment or .env files. > Good to know: environment variables specified in this way will always be included in the JavaScript bundle, prefixing the environment variable name with NEXTPUBLIC only has an effect when specifying them through the environment or .env files. To add environment variables to the JavaScript bundle, open next.config.js and add the env config: Now you can access process.env.customKey in your code. For example: Next.js will replace process.env.customKey with 'my-value' at build time. Trying to destructure process.env variables won't work due to the nature of webpack DefinePlugin. For example, the following line: Will end up being:",
    "excerpt": "> Since the release of Next.js 9.4 we now have a more intuitive and ergonomic experience for adding environment variables. Give it a try! > Since the release of Next.js 9.4 we now have a more intuitiv...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/env"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-expireTime",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\expireTime.mdx",
    "title": "expireTime",
    "description": "Customize stale-while-revalidate expire time for ISR enabled pages.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [
      {
        "language": "js",
        "code": "module.exports = {\r\n  // one hour in seconds\r\n  expireTime: 3600,\r\n}",
        "context": "filename=\"next.config.js\""
      }
    ],
    "content": "You can specify a custom stale-while-revalidate expire time for CDNs to consume in the Cache-Control header for ISR enabled pages. Open next.config.js and add the expireTime config: Now when sending the Cache-Control header the expire time will be calculated depending on the specific revalidate period. For example, if you have a revalidate of 15 minutes on a path and the expire time is one hour the generated Cache-Control header will be s-maxage=900, stale-while-revalidate=2700 so that it can stay stale for 15 minutes less than the configured expire time.",
    "excerpt": "You can specify a custom stale-while-revalidate expire time for CDNs to consume in the Cache-Control header for ISR enabled pages. Open next.config.js and add the expireTime config: Now when sending t...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/expireTime"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-exportPathMap",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\exportPathMap.mdx",
    "title": "exportPathMap",
    "description": "Customize the pages that will be exported as HTML files when using `next export`.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Adding a trailing slash",
        "slug": "adding-a-trailing-slash"
      },
      {
        "level": 2,
        "text": "Customizing the output directory",
        "slug": "customizing-the-output-directory"
      }
    ],
    "codeBlocks": [
      {
        "language": "js",
        "code": "module.exports = {\r\n  exportPathMap: async function (\r\n    defaultPathMap,\r\n    { dev, dir, outDir, distDir, buildId }\r\n  ) {\r\n    return {\r\n      '/': { page: '/' },\r\n      '/about': { page: '/about' },\r\n      '/p/hello-nextjs': { page: '/post', query: { title: 'hello-nextjs' } },\r\n      '/p/learn-nextjs': { page: '/post', query: { title: 'learn-nextjs' } },\r\n      '/p/deploy-nextjs': { page: '/post', query: { title: 'deploy-nextjs' } },\r\n    }\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  trailingSlash: true,\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "bash",
        "code": "next export -o outdir",
        "context": "filename=\"Terminal\""
      }
    ],
    "content": "> This feature is exclusive to next export and currently deprecated in favor of getStaticPaths with pages or generateStaticParams with app. exportPathMap allows you to specify a mapping of request paths to page destinations, to be used during export. Paths defined in exportPathMap will also be available when using next dev. Let's start with an example, to create a custom exportPathMap for an app with the following pages: - pages/index.js - pages/about.js - pages/post.js Open next.config.js and add the following exportPathMap config: > Good to know: the query field in exportPathMap cannot be used with automatically statically optimized pages or getStaticProps pages as they are rendered to HTML files at build-time and additional query information cannot be provided during next export. The pages will then be exported as HTML files, for example, /about will become /about.html. exportPathMap is an async function that receives 2 arguments: the first one is defaultPathMap, which is the default map used by Next.js. The second argument is an object with: - dev - true when exportPathMap is being called in development. false when running next export. In development exportPathMap is used to define routes. - dir - Absolute path to the project directory - outDir - Absolute path to the out/ directory (configurable with -o). When dev is true the value of outDir will be null. - distDir - Absolute path to the .next/ directory (configurable with the distDir config) - buildId - The generated build id The returned object is a map of pages where the key is the pathname and the value is an object that accepts the following fields: - page: String - the page inside the pages directory to render - query: Object - the query object passed to getInitialProps when prerendering. Defaults to {} > The exported pathname can also be a filename (for example, /readme.md), but you may need to set the Content-Type header to text/html when serving its content if it is different than .html. Adding a trailing slash It is possible to configure Next.js to export pages as index.html files and require trailing slashes, /about becomes /about/index.html and is routable via /about/. This was the default behavior prior to Next.js 9. To switch back and add a trailing slash, open next.config.js and enable the trailingSlash config: Customizing the output directory next export will use out as the default output directory, you can customize this using the -o argument, like so: next export will use out as the default output directory, you can customize this using the -o argument, like so: > Warning: Using exportPathMap is deprecated and is overridden by getStaticPaths inside pages. We don't recommend using them together.",
    "excerpt": "> This feature is exclusive to next export and currently deprecated in favor of getStaticPaths with pages or generateStaticParams with app. exportPathMap allows you to specify a mapping of request pat...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/exportPathMap"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-generateBuildId",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\generateBuildId.mdx",
    "title": "generateBuildId",
    "description": "Configure the build id, which is used to identify the current build in which your application is being served.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [
      {
        "language": "jsx",
        "code": "module.exports = {\r\n  generateBuildId: async () => {\r\n    // This could be anything, using the latest git hash\r\n    return process.env.GIT_HASH\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      }
    ],
    "content": "Next.js generates an ID during next build to identify which version of your application is being served. The same build should be used and boot up multiple containers. If you are rebuilding for each stage of your environment, you will need to generate a consistent build ID to use between containers. Use the generateBuildId command in next.config.js:",
    "excerpt": "Next.js generates an ID during next build to identify which version of your application is being served. The same build should be used and boot up multiple containers. If you are rebuilding for each s...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/generateBuildId"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-generateEtags",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\generateEtags.mdx",
    "title": "generateEtags",
    "description": "Next.js will generate etags for every page by default. Learn more about how to disable etag generation here.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [
      {
        "language": "js",
        "code": "module.exports = {\r\n  generateEtags: false,\r\n}",
        "context": "filename=\"next.config.js\""
      }
    ],
    "content": "Next.js will generate etags for every page by default. You may want to disable etag generation for HTML pages depending on your cache strategy. Open next.config.js and disable the generateEtags option:",
    "excerpt": "Next.js will generate etags for every page by default. You may want to disable etag generation for HTML pages depending on your cache strategy. Open next.config.js and disable the generateEtags option...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/generateEtags"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-headers",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\headers.mdx",
    "title": "headers",
    "description": "Add custom HTTP headers to your Next.js app.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Header Overriding Behavior",
        "slug": "header-overriding-behavior"
      },
      {
        "level": 2,
        "text": "Path Matching",
        "slug": "path-matching"
      },
      {
        "level": 3,
        "text": "Wildcard Path Matching",
        "slug": "wildcard-path-matching"
      },
      {
        "level": 3,
        "text": "Regex Path Matching",
        "slug": "regex-path-matching"
      },
      {
        "level": 2,
        "text": "Header, Cookie, and Query Matching",
        "slug": "header-cookie-and-query-matching"
      },
      {
        "level": 2,
        "text": "Headers with basePath support",
        "slug": "headers-with-basepath-support"
      },
      {
        "level": 2,
        "text": "Headers with i18n support",
        "slug": "headers-with-i18n-support"
      },
      {
        "level": 2,
        "text": "Cache-Control",
        "slug": "cache-control"
      },
      {
        "level": 2,
        "text": "Options",
        "slug": "options"
      },
      {
        "level": 3,
        "text": "CORS",
        "slug": "cors"
      },
      {
        "level": 3,
        "text": "X-DNS-Prefetch-Control",
        "slug": "x-dns-prefetch-control"
      },
      {
        "level": 3,
        "text": "Strict-Transport-Security",
        "slug": "strict-transport-security"
      },
      {
        "level": 3,
        "text": "X-Frame-Options",
        "slug": "x-frame-options"
      },
      {
        "level": 3,
        "text": "Permissions-Policy",
        "slug": "permissions-policy"
      },
      {
        "level": 3,
        "text": "X-Content-Type-Options",
        "slug": "x-content-type-options"
      },
      {
        "level": 3,
        "text": "Referrer-Policy",
        "slug": "referrer-policy"
      },
      {
        "level": 3,
        "text": "Content-Security-Policy",
        "slug": "content-security-policy"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "js",
        "code": "module.exports = {\r\n  async headers() {\r\n    return [\r\n      {\r\n        source: '/about',\r\n        headers: [\r\n          {\r\n            key: 'x-custom-header',\r\n            value: 'my custom header value',\r\n          },\r\n          {\r\n            key: 'x-another-custom-header',\r\n            value: 'my other custom header value',\r\n          },\r\n        ],\r\n      },\r\n    ]\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  async headers() {\r\n    return [\r\n      {\r\n        source: '/:path*',\r\n        headers: [\r\n          {\r\n            key: 'x-hello',\r\n            value: 'there',\r\n          },\r\n        ],\r\n      },\r\n      {\r\n        source: '/hello',\r\n        headers: [\r\n          {\r\n            key: 'x-hello',\r\n            value: 'world',\r\n          },\r\n        ],\r\n      },\r\n    ]\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  async headers() {\r\n    return [\r\n      {\r\n        source: '/blog/:slug',\r\n        headers: [\r\n          {\r\n            key: 'x-slug',\r\n            value: ':slug', // Matched parameters can be used in the value\r\n          },\r\n          {\r\n            key: 'x-slug-:slug', // Matched parameters can be used in the key\r\n            value: 'my other custom header value',\r\n          },\r\n        ],\r\n      },\r\n    ]\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  async headers() {\r\n    return [\r\n      {\r\n        source: '/blog/:slug*',\r\n        headers: [\r\n          {\r\n            key: 'x-slug',\r\n            value: ':slug*', // Matched parameters can be used in the value\r\n          },\r\n          {\r\n            key: 'x-slug-:slug*', // Matched parameters can be used in the key\r\n            value: 'my other custom header value',\r\n          },\r\n        ],\r\n      },\r\n    ]\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  async headers() {\r\n    return [\r\n      {\r\n        source: '/blog/:post(\\\\d{1,})',\r\n        headers: [\r\n          {\r\n            key: 'x-post',\r\n            value: ':post',\r\n          },\r\n        ],\r\n      },\r\n    ]\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  async headers() {\r\n    return [\r\n      {\r\n        // this will match `/english(default)/something` being requested\r\n        source: '/english\\\\(default\\\\)/:slug',\r\n        headers: [\r\n          {\r\n            key: 'x-header',\r\n            value: 'value',\r\n          },\r\n        ],\r\n      },\r\n    ]\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  async headers() {\r\n    return [\r\n      // if the header `x-add-header` is present,\r\n      // the `x-another-header` header will be applied\r\n      {\r\n        source: '/:path*',\r\n        has: [\r\n          {\r\n            type: 'header',\r\n            key: 'x-add-header',\r\n          },\r\n        ],\r\n        headers: [\r\n          {\r\n            key: 'x-another-header',\r\n            value: 'hello',\r\n          },\r\n        ],\r\n      },\r\n      // if the header `x-no-header` is not present,\r\n      // the `x-another-header` header will be applied\r\n      {\r\n        source: '/:path*',\r\n        missing: [\r\n          {\r\n            type: 'header',\r\n            key: 'x-no-header',\r\n          },\r\n        ],\r\n        headers: [\r\n          {\r\n            key: 'x-another-header',\r\n            value: 'hello',\r\n          },\r\n        ],\r\n      },\r\n      // if the source, query, and cookie are matched,\r\n      // the `x-authorized` header will be applied\r\n      {\r\n        source: '/specific/:path*',\r\n        has: [\r\n          {\r\n            type: 'query',\r\n            key: 'page',\r\n            // the page value will not be available in the\r\n            // header key/values since value is provided and\r\n            // doesn't use a named capture group e.g. (?<page>home)\r\n            value: 'home',\r\n          },\r\n          {\r\n            type: 'cookie',\r\n            key: 'authorized',\r\n            value: 'true',\r\n          },\r\n        ],\r\n        headers: [\r\n          {\r\n            key: 'x-authorized',\r\n            value: ':authorized',\r\n          },\r\n        ],\r\n      },\r\n      // if the header `x-authorized` is present and\r\n      // contains a matching value, the `x-another-header` will be applied\r\n      {\r\n        source: '/:path*',\r\n        has: [\r\n          {\r\n            type: 'header',\r\n            key: 'x-authorized',\r\n            value: '(?<authorized>yes|true)',\r\n          },\r\n        ],\r\n        headers: [\r\n          {\r\n            key: 'x-another-header',\r\n            value: ':authorized',\r\n          },\r\n        ],\r\n      },\r\n      // if the host is `example.com`,\r\n      // this header will be applied\r\n      {\r\n        source: '/:path*',\r\n        has: [\r\n          {\r\n            type: 'host',\r\n            value: 'example.com',\r\n          },\r\n        ],\r\n        headers: [\r\n          {\r\n            key: 'x-another-header',\r\n            value: ':authorized',\r\n          },\r\n        ],\r\n      },\r\n    ]\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  basePath: '/docs',\r\n\r\n  async headers() {\r\n    return [\r\n      {\r\n        source: '/with-basePath', // becomes /docs/with-basePath\r\n        headers: [\r\n          {\r\n            key: 'x-hello',\r\n            value: 'world',\r\n          },\r\n        ],\r\n      },\r\n      {\r\n        source: '/without-basePath', // is not modified since basePath: false is set\r\n        headers: [\r\n          {\r\n            key: 'x-hello',\r\n            value: 'world',\r\n          },\r\n        ],\r\n        basePath: false,\r\n      },\r\n    ]\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  i18n: {\r\n    locales: ['en', 'fr', 'de'],\r\n    defaultLocale: 'en',\r\n  },\r\n\r\n  async headers() {\r\n    return [\r\n      {\r\n        source: '/with-locale', // automatically handles all locales\r\n        headers: [\r\n          {\r\n            key: 'x-hello',\r\n            value: 'world',\r\n          },\r\n        ],\r\n      },\r\n      {\r\n        // does not handle locales automatically since locale: false is set\r\n        source: '/nl/with-locale-manual',\r\n        locale: false,\r\n        headers: [\r\n          {\r\n            key: 'x-hello',\r\n            value: 'world',\r\n          },\r\n        ],\r\n      },\r\n      {\r\n        // this matches '/' since `en` is the defaultLocale\r\n        source: '/en',\r\n        locale: false,\r\n        headers: [\r\n          {\r\n            key: 'x-hello',\r\n            value: 'world',\r\n          },\r\n        ],\r\n      },\r\n      {\r\n        // this gets converted to /(en|fr|de)/(.*) so will not match the top-level\r\n        // `/` or `/fr` routes like /:path* would\r\n        source: '/(.*)',\r\n        headers: [\r\n          {\r\n            key: 'x-hello',\r\n            value: 'world',\r\n          },\r\n        ],\r\n      },\r\n    ]\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "ts",
        "code": "import type { NextApiRequest, NextApiResponse } from 'next'\r\n\r\ntype ResponseData = {\r\n  message: string\r\n}\r\n\r\nexport default function handler(\r\n  req: NextApiRequest,\r\n  res: NextApiResponse<ResponseData>\r\n) {\r\n  res.setHeader('Cache-Control', 's-maxage=86400')\r\n  res.status(200).json({ message: 'Hello from Next.js!' })\r\n}",
        "context": "filename=\"pages/api/hello.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export default function handler(req, res) {\r\n  res.setHeader('Cache-Control', 's-maxage=86400')\r\n  res.status(200).json({ message: 'Hello from Next.js!' })\r\n}",
        "context": "filename=\"pages/api/hello.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { GetStaticProps, GetStaticPaths, GetServerSideProps } from 'next'\r\n\r\n// This value is considered fresh for ten seconds (s-maxage=10).\r\n// If a request is repeated within the next 10 seconds, the previously\r\n// cached value will still be fresh. If the request is repeated before 59 seconds,\r\n// the cached value will be stale but still render (stale-while-revalidate=59).\r\n//\r\n// In the background, a revalidation request will be made to populate the cache\r\n// with a fresh value. If you refresh the page, you will see the new value.\r\nexport const getServerSideProps = (async (context) => {\r\n  context.res.setHeader(\r\n    'Cache-Control',\r\n    'public, s-maxage=10, stale-while-revalidate=59'\r\n  )\r\n\r\n  return {\r\n    props: {},\r\n  }\r\n}) satisfies GetServerSideProps",
        "context": "filename=\"pages/index.tsx\" switcher"
      },
      {
        "language": "js",
        "code": "// This value is considered fresh for ten seconds (s-maxage=10).\r\n// If a request is repeated within the next 10 seconds, the previously\r\n// cached value will still be fresh. If the request is repeated before 59 seconds,\r\n// the cached value will be stale but still render (stale-while-revalidate=59).\r\n//\r\n// In the background, a revalidation request will be made to populate the cache\r\n// with a fresh value. If you refresh the page, you will see the new value.\r\nexport async function getServerSideProps({ req, res }) {\r\n  res.setHeader(\r\n    'Cache-Control',\r\n    'public, s-maxage=10, stale-while-revalidate=59'\r\n  )\r\n\r\n  return {\r\n    props: {},\r\n  }\r\n}",
        "context": "filename=\"pages/index.js\" switcher"
      },
      {
        "language": "js",
        "code": "async headers() {\r\n    return [\r\n      {\r\n        source: \"/api/:path*\",\r\n        headers: [\r\n          {\r\n            key: \"Access-Control-Allow-Origin\",\r\n            value: \"*\", // Set your origin\r\n          },\r\n          {\r\n            key: \"Access-Control-Allow-Methods\",\r\n            value: \"GET, POST, PUT, DELETE, OPTIONS\",\r\n          },\r\n          {\r\n            key: \"Access-Control-Allow-Headers\",\r\n            value: \"Content-Type, Authorization\",\r\n          },\r\n        ],\r\n      },\r\n    ];\r\n  },",
        "context": ""
      },
      {
        "language": "js",
        "code": "{\r\n  key: 'X-DNS-Prefetch-Control',\r\n  value: 'on'\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "{\r\n  key: 'Strict-Transport-Security',\r\n  value: 'max-age=63072000; includeSubDomains; preload'\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "{\r\n  key: 'X-Frame-Options',\r\n  value: 'SAMEORIGIN'\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "{\r\n  key: 'Permissions-Policy',\r\n  value: 'camera=(), microphone=(), geolocation=(), browsing-topics=()'\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "{\r\n  key: 'X-Content-Type-Options',\r\n  value: 'nosniff'\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "{\r\n  key: 'Referrer-Policy',\r\n  value: 'origin-when-cross-origin'\r\n}",
        "context": ""
      }
    ],
    "content": "Headers allow you to set custom HTTP headers on the response to an incoming request on a given path. To set custom HTTP headers you can use the headers key in next.config.js: headers is an async function that expects an array to be returned holding objects with source and headers properties: - source is the incoming request path pattern. - headers is an array of response header objects, with key and value properties. - basePath: false or undefined - if false the basePath won't be included when matching, can be used for external rewrites only. - locale: false or undefined - whether the locale should not be included when matching. - has is an array of has objects with the type, key and value properties. - missing is an array of missing objects with the type, key and value properties. Headers are checked before the filesystem which includes pages and /public files. Header Overriding Behavior If two headers match the same path and set the same header key, the last header key will override the first. Using the below headers, the path /hello will result in the header x-hello being world due to the last header value set being world. Path Matching Path matches are allowed, for example /blog/:slug will match /blog/hello-world (no nested paths): Wildcard Path Matching To match a wildcard path you can use after a parameter, for example /blog/:slug will match /blog/a/b/c/d/hello-world: Regex Path Matching To match a regex path you can wrap the regex in parenthesis after a parameter, for example /blog/:slug(\\\\d{1,}) will match /blog/123 but not /blog/abc: The following characters (, ), {, }, :, , +, ? are used for regex path matching, so when used in the source as non-special values they must be escaped by adding \\\\ before them: Header, Cookie, and Query Matching To only apply a header when header, cookie, or query values also match the has field or don't match the missing field can be used. Both the source and all has items must match and all missing items must not match for the header to be applied. has and missing items can have the following fields: - type: String - must be either header, cookie, host, or query. - key: String - the key from the selected type to match against. - value: String or undefined - the value to check for, if undefined any value will match. A regex like string can be used to capture a specific part of the value, e.g. if the value first-(?.) is used for first-second then second will be usable in the destination with :paramName. Headers with basePath support When leveraging basePath support with headers each source is automatically prefixed with the basePath unless you add basePath: false to the header: Headers with i18n support When leveraging i18n support with headers each source is automatically prefixed to handle the configured locales unless you add locale: false to the header. If locale: false is used you must prefix the source with a locale for it to be matched correctly. When leveraging i18n support with headers each source is automatically prefixed to handle the configured locales unless you add locale: false to the header. If locale: false is used you must prefix the source with a locale for it to be matched correctly. Cache-Control Next.js sets the Cache-Control header of public, max-age=31536000, immutable for truly immutable assets. It cannot be overridden. These immutable files contain a SHA-hash in the file name, so they can be safely cached indefinitely. For example, Static Image Imports. You cannot set Cache-Control headers in next.config.js for these assets. However, you can set Cache-Control headers for other responses or data. Learn more about caching with the App Router. If you need to revalidate the cache of a page that has been statically generated, you can do so by setting the revalidate prop in the page's getStaticProps function. To cache the response from an API Route, you can use res.setHeader: You can also use caching headers (Cache-Control) inside getServerSideProps to cache dynamic responses. For example, using stale-while-revalidate. Options CORS Cross-Origin Resource Sharing (CORS) is a security feature that allows you to control which sites can access your resources. You can set the Access-Control-Allow-Origin header to allow a specific origin to access your API EndpointsRoute Handlers. X-DNS-Prefetch-Control This header controls DNS prefetching, allowing browsers to proactively perform domain name resolution on external links, images, CSS, JavaScript, and more. This prefetching is performed in the background, so the DNS is more likely to be resolved by the time the referenced items are needed. This reduces latency when the user clicks a link. Strict-Transport-Security This header informs browsers it should only be accessed using HTTPS, instead of using HTTP. Using the configuration below, all present and future subdomains will use HTTPS for a max-age of 2 years. This blocks access to pages or subdomains that can only be served over HTTP. X-Frame-Options This header indicates whether the site should be allowed to be displayed within an iframe. This can prevent against clickjacking attacks. This header has been superseded by CSP's frame-ancestors option, which has better support in modern browsers (see Content Security Policy for configuration details). Permissions-Policy This header allows you to control which features and APIs can be used in the browser. It was previously named Feature-Policy. X-Content-Type-Options This header prevents the browser from attempting to guess the type of content if the Content-Type header is not explicitly set. This can prevent XSS exploits for websites that allow users to upload and share files. For example, a user trying to download an image, but having it treated as a different Content-Type like an executable, which could be malicious. This header also applies to downloading browser extensions. The only valid value for this header is nosniff. Referrer-Policy This header controls how much information the browser includes when navigating from the current website (origin) to another. Content-Security-Policy Learn more about adding a Content Security Policy to your application. Version History | Version | Changes | | --------- | ---------------- | | v13.3.0 | missing added. | | v10.2.0 | has added. | | v9.5.0 | Headers added. |",
    "excerpt": "Headers allow you to set custom HTTP headers on the response to an incoming request on a given path. To set custom HTTP headers you can use the headers key in next.config.js: headers is an async funct...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/headers"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-htmlLimitedBots",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\htmlLimitedBots.mdx",
    "title": "htmlLimitedBots",
    "description": "Specify a list of user agents that should receive blocking metadata.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Default list",
        "slug": "default-list"
      },
      {
        "level": 2,
        "text": "Disabling",
        "slug": "disabling"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst config: NextConfig = {\r\n  htmlLimitedBots: /MySpecialBot|MyAnotherSpecialBot|SimpleCrawler/,\r\n}\r\n\r\nexport default config",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  htmlLimitedBots: /MySpecialBot|MyAnotherSpecialBot|SimpleCrawler/,\r\n}",
        "context": "filename=\"next.config.js\" switcher"
      },
      {
        "language": "ts",
        "code": "const config: NextConfig = {\r\n  htmlLimitedBots: /MySpecialBot|MyAnotherSpecialBot|SimpleCrawler/,\r\n}\r\n\r\nexport default config",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  htmlLimitedBots: /MySpecialBot|MyAnotherSpecialBot|SimpleCrawler/,\r\n}",
        "context": "filename=\"next.config.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst config: NextConfig = {\r\n  htmlLimitedBots: /.*/,\r\n}\r\n\r\nexport default config",
        "context": "filename=\"next.config.ts\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  htmlLimitedBots: /.*/,\r\n}",
        "context": "filename=\"next.config.js\" switcher"
      }
    ],
    "content": "The htmlLimitedBots config allows you to specify a list of user agents that should receive blocking metadata instead of streaming metadata. Default list Next.js includes a default list of HTML limited bots, including: - Google crawlers (e.g. Mediapartners-Google, AdsBot-Google, Google-PageRenderer) - Bingbot - Twitterbot - Slackbot See the full list here. Specifying a htmlLimitedBots config will override the Next.js' default list. However, this is advanced behavior, and the default should be sufficient for most cases. Disabling To fully disable streaming metadata: Version History | Version | Changes | | ------- | ------------------------------------ | | 15.2.0 | htmlLimitedBots option introduced. |",
    "excerpt": "The htmlLimitedBots config allows you to specify a list of user agents that should receive blocking metadata instead of streaming metadata. Default list Next.js includes a default list of HTML limited...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/htmlLimitedBots"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-httpAgentOptions",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\httpAgentOptions.mdx",
    "title": "httpAgentOptions",
    "description": "Next.js will automatically use HTTP Keep-Alive by default. Learn more about how to disable HTTP Keep-Alive here.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [
      {
        "language": "js",
        "code": "module.exports = {\r\n  httpAgentOptions: {\r\n    keepAlive: false,\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      }
    ],
    "content": "In Node.js versions prior to 18, Next.js automatically polyfills fetch() with undici and enables HTTP Keep-Alive by default. To disable HTTP Keep-Alive for all fetch() calls on the server-side, open next.config.js and add the httpAgentOptions config:",
    "excerpt": "In Node.js versions prior to 18, Next.js automatically polyfills fetch() with undici and enables HTTP Keep-Alive by default. To disable HTTP Keep-Alive for all fetch() calls on the server-side, open n...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/httpAgentOptions"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-images",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\images.mdx",
    "title": "images",
    "description": "Custom configuration for the next/image loader",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Example Loader Configuration",
        "slug": "example-loader-configuration"
      },
      {
        "level": 3,
        "text": "Akamai",
        "slug": "akamai"
      },
      {
        "level": 3,
        "text": "AWS CloudFront",
        "slug": "aws-cloudfront"
      },
      {
        "level": 3,
        "text": "Cloudinary",
        "slug": "cloudinary"
      },
      {
        "level": 3,
        "text": "Cloudflare",
        "slug": "cloudflare"
      },
      {
        "level": 3,
        "text": "Contentful",
        "slug": "contentful"
      },
      {
        "level": 3,
        "text": "Fastly",
        "slug": "fastly"
      },
      {
        "level": 3,
        "text": "Gumlet",
        "slug": "gumlet"
      },
      {
        "level": 3,
        "text": "ImageEngine",
        "slug": "imageengine"
      },
      {
        "level": 3,
        "text": "Imgix",
        "slug": "imgix"
      },
      {
        "level": 3,
        "text": "PixelBin",
        "slug": "pixelbin"
      },
      {
        "level": 3,
        "text": "Sanity",
        "slug": "sanity"
      },
      {
        "level": 3,
        "text": "Sirv",
        "slug": "sirv"
      },
      {
        "level": 3,
        "text": "Supabase",
        "slug": "supabase"
      },
      {
        "level": 3,
        "text": "Thumbor",
        "slug": "thumbor"
      },
      {
        "level": 3,
        "text": "ImageKit.io",
        "slug": "imagekitio"
      },
      {
        "level": 3,
        "text": "Nitrogen AIO",
        "slug": "nitrogen-aio"
      }
    ],
    "codeBlocks": [
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    loader: 'custom',\r\n    loaderFile: './my/image/loader.js',\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "'use client'\r\n\r\nexport default function myImageLoader({ src, width, quality }) {\r\n  return `https://example.com/${src}?w=${width}&q=${quality || 75}`\r\n}",
        "context": "filename=\"my/image/loader.js\""
      },
      {
        "language": "js",
        "code": "export default function myImageLoader({ src, width, quality }) {\r\n  return `https://example.com/${src}?w=${width}&q=${quality || 75}`\r\n}",
        "context": "filename=\"my/image/loader.js\""
      },
      {
        "language": "js",
        "code": "// Docs: https://techdocs.akamai.com/ivm/reference/test-images-on-demand\r\nexport default function akamaiLoader({ src, width, quality }) {\r\n  return `https://example.com/${src}?imwidth=${width}`\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "// Docs: https://aws.amazon.com/developer/application-security-performance/articles/image-optimization\r\nexport default function cloudfrontLoader({ src, width, quality }) {\r\n  const url = new URL(`https://example.com${src}`)\r\n  url.searchParams.set('format', 'auto')\r\n  url.searchParams.set('width', width.toString())\r\n  url.searchParams.set('quality', (quality || 75).toString())\r\n  return url.href\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "// Demo: https://res.cloudinary.com/demo/image/upload/w_300,c_limit,q_auto/turtles.jpg\r\nexport default function cloudinaryLoader({ src, width, quality }) {\r\n  const params = ['f_auto', 'c_limit', `w_${width}`, `q_${quality || 'auto'}`]\r\n  return `https://example.com/${params.join(',')}${src}`\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "// Docs: https://developers.cloudflare.com/images/transform-images\r\nexport default function cloudflareLoader({ src, width, quality }) {\r\n  const params = [`width=${width}`, `quality=${quality || 75}`, 'format=auto']\r\n  return `https://example.com/cdn-cgi/image/${params.join(',')}/${src}`\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "// Docs: https://www.contentful.com/developers/docs/references/images-api/\r\nexport default function contentfulLoader({ src, width, quality }) {\r\n  const url = new URL(`https://example.com${src}`)\r\n  url.searchParams.set('fm', 'webp')\r\n  url.searchParams.set('w', width.toString())\r\n  url.searchParams.set('q', (quality || 75).toString())\r\n  return url.href\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "// Docs: https://developer.fastly.com/reference/io/\r\nexport default function fastlyLoader({ src, width, quality }) {\r\n  const url = new URL(`https://example.com${src}`)\r\n  url.searchParams.set('auto', 'webp')\r\n  url.searchParams.set('width', width.toString())\r\n  url.searchParams.set('quality', (quality || 75).toString())\r\n  return url.href\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "// Docs: https://docs.gumlet.com/reference/image-transform-size\r\nexport default function gumletLoader({ src, width, quality }) {\r\n  const url = new URL(`https://example.com${src}`)\r\n  url.searchParams.set('format', 'auto')\r\n  url.searchParams.set('w', width.toString())\r\n  url.searchParams.set('q', (quality || 75).toString())\r\n  return url.href\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "// Docs: https://support.imageengine.io/hc/en-us/articles/360058880672-Directives\r\nexport default function imageengineLoader({ src, width, quality }) {\r\n  const compression = 100 - (quality || 50)\r\n  const params = [`w_${width}`, `cmpr_${compression}`)]\r\n  return `https://example.com${src}?imgeng=/${params.join('/')`\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "// Demo: https://static.imgix.net/daisy.png?format=auto&fit=max&w=300\r\nexport default function imgixLoader({ src, width, quality }) {\r\n  const url = new URL(`https://example.com${src}`)\r\n  const params = url.searchParams\r\n  params.set('auto', params.getAll('auto').join(',') || 'format')\r\n  params.set('fit', params.get('fit') || 'max')\r\n  params.set('w', params.get('w') || width.toString())\r\n  params.set('q', (quality || 50).toString())\r\n  return url.href\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "// Doc (Resize): https://www.pixelbin.io/docs/transformations/basic/resize/#width-w\r\n// Doc (Optimise): https://www.pixelbin.io/docs/optimizations/quality/#image-quality-when-delivering\r\n// Doc (Auto Format Delivery): https://www.pixelbin.io/docs/optimizations/format/#automatic-format-selection-with-f_auto-url-parameter\r\nexport default function pixelBinLoader({ src, width, quality }) {\r\n  const name = '<your-cloud-name>'\r\n  const opt = `t.resize(w:${width})~t.compress(q:${quality || 75})`\r\n  return `https://cdn.pixelbin.io/v2/${name}/${opt}/${src}?f_auto=true`\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "// Docs: https://www.sanity.io/docs/image-urls\r\nexport default function sanityLoader({ src, width, quality }) {\r\n  const prj = 'zp7mbokg'\r\n  const dataset = 'production'\r\n  const url = new URL(`https://cdn.sanity.io/images/${prj}/${dataset}${src}`)\r\n  url.searchParams.set('auto', 'format')\r\n  url.searchParams.set('fit', 'max')\r\n  url.searchParams.set('w', width.toString())\r\n  if (quality) {\r\n    url.searchParams.set('q', quality.toString())\r\n  }\r\n  return url.href\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "// Docs: https://sirv.com/help/articles/dynamic-imaging/\r\nexport default function sirvLoader({ src, width, quality }) {\r\n  const url = new URL(`https://example.com${src}`)\r\n  const params = url.searchParams\r\n  params.set('format', params.getAll('format').join(',') || 'optimal')\r\n  params.set('w', params.get('w') || width.toString())\r\n  params.set('q', (quality || 85).toString())\r\n  return url.href\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "// Docs: https://supabase.com/docs/guides/storage/image-transformations#nextjs-loader\r\nexport default function supabaseLoader({ src, width, quality }) {\r\n  const url = new URL(`https://example.com${src}`)\r\n  url.searchParams.set('width', width.toString())\r\n  url.searchParams.set('quality', (quality || 75).toString())\r\n  return url.href\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "// Docs: https://thumbor.readthedocs.io/en/latest/\r\nexport default function thumborLoader({ src, width, quality }) {\r\n  const params = [`${width}x0`, `filters:quality(${quality || 75})`]\r\n  return `https://example.com${params.join('/')}${src}`\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "// Docs: https://imagekit.io/docs/image-transformation\r\nexport default function imageKitLoader({ src, width, quality }) {\r\n  const params = [`w-${width}`, `q-${quality || 80}`]\r\n  return `https://ik.imagekit.io/your_imagekit_id/${src}?tr=${params.join(',')}`\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "// Docs: https://docs.n7.io/aio/intergrations/\r\nexport default function aioLoader({ src, width, quality }) {\r\n  const url = new URL(src, window.location.href)\r\n  const params = url.searchParams\r\n  const aioParams = params.getAll('aio')\r\n  aioParams.push(`w-${width}`)\r\n  if (quality) {\r\n    aioParams.push(`q-${quality.toString()}`)\r\n  }\r\n  params.set('aio', aioParams.join(';'))\r\n  return url.href\r\n}",
        "context": ""
      }
    ],
    "content": "If you want to use a cloud provider to optimize images instead of using the Next.js built-in Image Optimization API, you can configure next.config.js with the following: This loaderFile must point to a file relative to the root of your Next.js application. The file must export a default function that returns a string, for example: Alternatively, you can use the loader prop to pass the function to each instance of next/image. > Good to know: Customizing the image loader file, which accepts a function, requires using Client Components to serialize the provided function. To learn more about configuring the behavior of the built-in Image Optimization API and the Image Component, see Image Configuration Options for available options. Alternatively, you can use the loader prop to pass the function to each instance of next/image. To learn more about configuring the behavior of the built-in Image Optimization API and the Image Component, see Image Configuration Options for available options. Example Loader Configuration - Akamai - AWS CloudFront - Cloudinary - Cloudflare - Contentful - Fastly - Gumlet - ImageEngine - Imgix - PixelBin - Sanity - Sirv - Supabase - Thumbor - Imagekit - Nitrogen AIO Akamai AWS CloudFront Cloudinary Cloudflare Contentful Fastly Gumlet ImageEngine Imgix PixelBin Sanity Sirv Supabase Thumbor ImageKit.io Nitrogen AIO",
    "excerpt": "If you want to use a cloud provider to optimize images instead of using the Next.js built-in Image Optimization API, you can configure next.config.js with the following: This loaderFile must point to...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/images"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-incrementalCacheHandlerPath",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\incrementalCacheHandlerPath.mdx",
    "title": "Custom Next.js Cache Handler",
    "description": "Configure the Next.js cache used for storing and revalidating data to use any external service like Redis, Memcached, or others.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "API Reference",
        "slug": "api-reference"
      },
      {
        "level": 2,
        "text": "Platform Support",
        "slug": "platform-support"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "js",
        "code": "module.exports = {\r\n  cacheHandler: require.resolve('./cache-handler.js'),\r\n  cacheMaxMemorySize: 0, // disable default in-memory caching\r\n}",
        "context": "filename=\"next.config.js\""
      }
    ],
    "content": "You can configure the Next.js cache location if you want to persist cached pages and data to durable storage, or share the cache across multiple containers or instances of your Next.js application. > Good to know: The cacheHandler configuration is specifically used by Next.js for server cache operations such as storing and revalidating ISR and route handler responses. It is not used by 'use cache', 'use cache: remote', nor 'use cache: private', which manage their own cache independently. View an example of a custom cache handler and learn more about the implementation. API Reference The cache handler can implement the following methods: get, set, revalidateTag, and resetRequestCache. get() | Parameter | Type | Description | | --------- | -------- | ---------------------------- | | key | string | The key to the cached value. | Returns the cached value or null if not found. set() | Parameter | Type | Description | | --------- | -------------- | -------------------------------- | | key | string | The key to store the data under. | | data | Data or null | The data to be cached. | | ctx | { tags: [] } | The cache tags provided. | Returns Promise. revalidateTag() | Parameter | Type | Description | | --------- | ---------------------- | ----------------------------- | | tag | string or string[] | The cache tags to revalidate. | Returns Promise. Learn more about revalidating data or the revalidateTag() function. resetRequestCache() This method resets the temporary in-memory cache for a single request before the next request. Returns void. Good to know: - revalidatePath is a convenience layer on top of cache tags. Calling revalidatePath will call your revalidateTag function, which you can then choose if you want to tag cache keys based on the path. Platform Support | Deployment Option | Supported | | ------------------------------------------------------------------- | ----------------- | | Node.js server | Yes | | Docker container | Yes | | Static export | No | | Adapters | Platform-specific | Learn how to configure ISR when self-hosting Next.js. Version History | Version | Changes | | --------- | ------------------------------------------------------------ | | v14.1.0 | Renamed to cacheHandler and became stable. | | v13.4.0 | incrementalCacheHandlerPath support for revalidateTag. | | v13.4.0 | incrementalCacheHandlerPath support for standalone output. | | v12.2.0 | Experimental incrementalCacheHandlerPath added. |",
    "excerpt": "You can configure the Next.js cache location if you want to persist cached pages and data to durable storage, or share the cache across multiple containers or instances of your Next.js application. >...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/incrementalCacheHandlerPath"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-index",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\index.mdx",
    "title": "next.config.js",
    "description": "Learn how to configure your application with next.config.js.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "ECMAScript Modules",
        "slug": "ecmascript-modules"
      },
      {
        "level": 2,
        "text": "Configuration as a Function",
        "slug": "configuration-as-a-function"
      },
      {
        "level": 3,
        "text": "Async Configuration",
        "slug": "async-configuration"
      },
      {
        "level": 3,
        "text": "Phase",
        "slug": "phase"
      },
      {
        "level": 2,
        "text": "TypeScript",
        "slug": "typescript"
      },
      {
        "level": 2,
        "text": "Unit Testing (experimental)",
        "slug": "unit-testing-experimental"
      }
    ],
    "codeBlocks": [
      {
        "language": "js",
        "code": "// @ts-check\r\n\r\n/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  /* config options here */\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "// @ts-check\r\n\r\n/**\r\n * @type {import('next').NextConfig}\r\n */\r\nconst nextConfig = {\r\n  /* config options here */\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.mjs\""
      },
      {
        "language": "js",
        "code": "// @ts-check\r\n\r\nexport default (phase, { defaultConfig }) => {\r\n  /**\r\n   * @type {import('next').NextConfig}\r\n   */\r\n  const nextConfig = {\r\n    /* config options here */\r\n  }\r\n  return nextConfig\r\n}",
        "context": "filename=\"next.config.mjs\""
      },
      {
        "language": "js",
        "code": "// @ts-check\r\n\r\nmodule.exports = async (phase, { defaultConfig }) => {\r\n  /**\r\n   * @type {import('next').NextConfig}\r\n   */\r\n  const nextConfig = {\r\n    /* config options here */\r\n  }\r\n  return nextConfig\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "// @ts-check\r\n\r\nconst { PHASE_DEVELOPMENT_SERVER } = require('next/constants')\r\n\r\nmodule.exports = (phase, { defaultConfig }) => {\r\n  if (phase === PHASE_DEVELOPMENT_SERVER) {\r\n    return {\r\n      /* development only config options here */\r\n    }\r\n  }\r\n\r\n  return {\r\n    /* config options for all phases except development here */\r\n  }\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  /* config options here */\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\""
      },
      {
        "language": "js",
        "code": "import {\r\n  getRedirectUrl,\r\n  unstable_getResponseFromNextConfig,\r\n} from 'next/experimental/testing/server'\r\n\r\nconst response = await unstable_getResponseFromNextConfig({\r\n  url: 'https://nextjs.org/test',\r\n  nextConfig: {\r\n    async redirects() {\r\n      return [{ source: '/test', destination: '/test2', permanent: false }]\r\n    },\r\n  },\r\n})\r\nexpect(response.status).toEqual(307)\r\nexpect(getRedirectUrl(response)).toEqual('https://nextjs.org/test2')",
        "context": ""
      }
    ],
    "content": "Next.js can be configured through a next.config.js file in the root of your project directory (for example, by package.json) with a default export. ECMAScript Modules next.config.js is a regular Node.js module, not a JSON file. It gets used by the Next.js server and build phases, and it's not included in the browser build. If you need ECMAScript modules, you can use next.config.mjs: > Good to know: next.config with the .cjs, .cts, or .mts extensions are currently not supported. Configuration as a Function You can also use a function: Async Configuration Since Next.js 12.1.0, you can use an async function: Phase phase is the current context in which the configuration is loaded. You can see the available phases. Phases can be imported from next/constants: TypeScript If you are using TypeScript in your project, you can use next.config.ts to use TypeScript in your configuration: The commented lines are the place where you can put the configs allowed by next.config.js, which are defined in this file. However, none of the configs are required, and it's not necessary to understand what each config does. Instead, search for the features you need to enable or modify in this section and they will show you what to do. > Avoid using new JavaScript features not available in your target Node.js version. next.config.js will not be parsed by Webpack or Babel. This page documents all the available configuration options: Unit Testing (experimental) Starting in Next.js 15.1, the next/experimental/testing/server package contains utilities to help unit test next.config.js files. The unstablegetResponseFromNextConfig function runs the headers, redirects, and rewrites functions from next.config.js with the provided request information and returns NextResponse with the results of the routing. > The response from unstablegetResponseFromNextConfig only considers next.config.js fields and does not consider proxy or filesystem routes, so the result in production may be different than the unit test.",
    "excerpt": "Next.js can be configured through a next.config.js file in the root of your project directory (for example, by package.json) with a default export. ECMAScript Modules next.config.js is a regular Node....",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-inlineCss",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\inlineCss.mdx",
    "title": "inlineCss",
    "description": "Enable inline CSS support.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Usage",
        "slug": "usage"
      },
      {
        "level": 2,
        "text": "Trade-Offs",
        "slug": "trade-offs"
      },
      {
        "level": 3,
        "text": "When to Use Inline CSS",
        "slug": "when-to-use-inline-css"
      },
      {
        "level": 3,
        "text": "When Not to Use Inline CSS",
        "slug": "when-not-to-use-inline-css"
      }
    ],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  experimental: {\r\n    inlineCss: true,\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  experimental: {\r\n    inlineCss: true,\r\n  },\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\" switcher"
      }
    ],
    "content": "Usage Experimental support for inlining CSS in the . When this flag is enabled, all places where we normally generate a tag will instead have a generated tag. Trade-Offs When to Use Inline CSS Inlining CSS can be beneficial in several scenarios: - First-Time Visitors: Since CSS files are render-blocking resources, inlining eliminates the initial download delay that first-time visitors experience, improving page load performance. - Performance Metrics: By removing the additional network requests for CSS files, inlining can significantly improve key metrics like First Contentful Paint (FCP) and Largest Contentful Paint (LCP). - Slow Connections: For users on slower networks where each request adds considerable latency, inlining CSS can provide a noticeable performance boost by reducing network roundtrips. - Atomic CSS Bundles (e.g., Tailwind): With utility-first frameworks like Tailwind CSS, the size of the styles required for a page is often O(1) relative to the complexity of the design. This makes inlining a compelling choice because the entire set of styles for the current page is lightweight and doesn’t grow with the page size. Inlining Tailwind styles ensures minimal payload and eliminates the need for additional network requests, which can further enhance performance. When Not to Use Inline CSS While inlining CSS offers significant benefits for performance, there are scenarios where it may not be the best choice: - Large CSS Bundles: If your CSS bundle is too large, inlining it may significantly increase the size of the HTML, resulting in slower Time to First Byte (TTFB) and potentially worse performance for users with slow connections. - Dynamic or Page-Specific CSS: For applications with highly dynamic styles or pages that use different sets of CSS, inlining may lead to redundancy and bloat, as the full CSS for all pages may need to be inlined repeatedly. - Browser Caching: In cases where visitors frequently return to your site, external CSS files allow browsers to cache styles efficiently, reducing data transfer for subsequent visits. Inlining CSS eliminates this benefit. Evaluate these trade-offs carefully, and consider combining inlining with other strategies, such as critical CSS extraction or a hybrid approach, for the best results tailored to your site's needs. > Good to know: > > This feature is currently experimental and has some known limitations: > > - CSS inlining is applied globally and cannot be configured on a per-page basis > - Styles are duplicated during initial page load - once within tags for SSR and once in the RSC payload > - When navigating to statically rendered pages, styles will use tags instead of inline CSS to avoid duplication > - This feature is not available in development mode and only works in production builds",
    "excerpt": "Usage Experimental support for inlining CSS in the . When this flag is enabled, all places where we normally generate a tag will instead have a generated tag. Trade-Offs When to Use Inline CSS Inlinin...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/inlineCss"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-isolatedDevBuild",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\isolatedDevBuild.mdx",
    "title": "isolatedDevBuild",
    "description": "Use isolated build outputs for development server to prevent conflicts with production builds.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Configuration",
        "slug": "configuration"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  experimental: {\r\n    isolatedDevBuild: false, // defaults to true\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  experimental: {\r\n    isolatedDevBuild: false, // defaults to true\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.mjs\" switcher"
      }
    ],
    "content": "The experimental isolatedDevBuild option separates development and production build outputs into different directories. When enabled, the development server (next dev) writes its output to .next/dev instead of .next, preventing conflicts when running next dev and next build concurrently. This is especially helpful when automated tools (for example, AI agents) run next build to validate changes while your development server is running, ensuring the dev server is not affected by changes made by the build process. This feature is enabled by default to keep development and production outputs separate and prevent conflicts. Configuration To opt out of this feature, set isolatedDevBuild to false in your configuration: Version History | Version | Changes | | --------- | ---------------------------------------------- | | v16.0.0 | experimental.isolatedDevBuild is introduced. |",
    "excerpt": "The experimental isolatedDevBuild option separates development and production build outputs into different directories. When enabled, the development server (next dev) writes its output to .next/dev i...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/isolatedDevBuild"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-logging",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\logging.mdx",
    "title": "logging",
    "description": "Configure how data fetches are logged to the console when running Next.js in development mode.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Options",
        "slug": "options"
      },
      {
        "level": 3,
        "text": "Fetching",
        "slug": "fetching"
      },
      {
        "level": 3,
        "text": "Incoming Requests",
        "slug": "incoming-requests"
      },
      {
        "level": 3,
        "text": "Disabling Logging",
        "slug": "disabling-logging"
      }
    ],
    "codeBlocks": [
      {
        "language": "js",
        "code": "module.exports = {\r\n  logging: {\r\n    fetches: {\r\n      fullUrl: true,\r\n    },\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  logging: {\r\n    fetches: {\r\n      hmrRefreshes: true,\r\n    },\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  logging: {\r\n    incomingRequests: {\r\n      ignore: [/\\api\\/v1\\/health/],\r\n    },\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  logging: {\r\n    incomingRequests: false,\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  logging: false,\r\n}",
        "context": "filename=\"next.config.js\""
      }
    ],
    "content": "Options Fetching You can configure the logging level and whether the full URL is logged to the console when running Next.js in development mode. Currently, logging only applies to data fetching using the fetch API. It does not yet apply to other logs inside of Next.js. Any fetch requests that are restored from the Server Components HMR cache are not logged by default. However, this can be enabled by setting logging.fetches.hmrRefreshes to true. Incoming Requests By default all the incoming requests will be logged in the console during development. You can use the incomingRequests option to decide which requests to ignore. Since this is only logged in development, this option doesn't affect production builds. Or you can disable incoming request logging by setting incomingRequests to false. Disabling Logging In addition, you can disable the development logging by setting logging to false.",
    "excerpt": "Options Fetching You can configure the logging level and whether the full URL is logged to the console when running Next.js in development mode. Currently, logging only applies to data fetching using...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/logging"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-mdxRs",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\mdxRs.mdx",
    "title": "mdxRs",
    "description": "Use the new Rust compiler to compile MDX files in the App Router.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [
      {
        "language": "js",
        "code": "const withMDX = require('@next/mdx')()\r\n\r\n/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  pageExtensions: ['ts', 'tsx', 'mdx'],\r\n  experimental: {\r\n    mdxRs: true,\r\n  },\r\n}\r\n\r\nmodule.exports = withMDX(nextConfig)",
        "context": "filename=\"next.config.js\""
      }
    ],
    "content": "For experimental use with @next/mdx. Compiles MDX files using the new Rust compiler.",
    "excerpt": "For experimental use with @next/mdx. Compiles MDX files using the new Rust compiler.",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/mdxRs"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-onDemandEntries",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\onDemandEntries.mdx",
    "title": "onDemandEntries",
    "description": "Configure how Next.js will dispose and keep in memory pages created in development.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [
      {
        "language": "js",
        "code": "module.exports = {\r\n  onDemandEntries: {\r\n    // period (in ms) where the server will keep pages in the buffer\r\n    maxInactiveAge: 25 * 1000,\r\n    // number of pages that should be kept simultaneously without being disposed\r\n    pagesBufferLength: 2,\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      }
    ],
    "content": "Next.js exposes some options that give you some control over how the server will dispose or keep in memory built pages in development. To change the defaults, open next.config.js and add the onDemandEntries config:",
    "excerpt": "Next.js exposes some options that give you some control over how the server will dispose or keep in memory built pages in development. To change the defaults, open next.config.js and add the onDemandE...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/onDemandEntries"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-optimizePackageImports",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\optimizePackageImports.mdx",
    "title": "optimizePackageImports",
    "description": "API Reference for optimizePackageImports Next.js Config Option",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [
      {
        "language": "js",
        "code": "module.exports = {\r\n  experimental: {\r\n    optimizePackageImports: ['package-name'],\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      }
    ],
    "content": "Some packages can export hundreds or thousands of modules, which can cause performance issues in development and production. Adding a package to experimental.optimizePackageImports will only load the modules you are actually using, while still giving you the convenience of writing import statements with many named exports. The following libraries are optimized by default: - lucide-react - date-fns - lodash-es - ramda - antd - react-bootstrap - ahooks - @ant-design/icons - @headlessui/react - @headlessui-float/react - @heroicons/react/20/solid - @heroicons/react/24/solid - @heroicons/react/24/outline - @visx/visx - @tremor/react - rxjs - @mui/material - @mui/icons-material - recharts - react-use - @material-ui/core - @material-ui/icons - @tabler/icons-react - mui-core - react-icons/ - effect - @effect/",
    "excerpt": "Some packages can export hundreds or thousands of modules, which can cause performance issues in development and production. Adding a package to experimental.optimizePackageImports will only load the...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/optimizePackageImports"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-output",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\output.mdx",
    "title": "output",
    "description": "Next.js automatically traces which files are needed by each page to allow for easy deployment of your application. Learn how it works here.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "How it Works",
        "slug": "how-it-works"
      },
      {
        "level": 2,
        "text": "Automatically Copying Traced Files",
        "slug": "automatically-copying-traced-files"
      },
      {
        "level": 2,
        "text": "Caveats",
        "slug": "caveats"
      }
    ],
    "codeBlocks": [
      {
        "language": "js",
        "code": "module.exports = {\r\n  output: 'standalone',\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "bash",
        "code": "cp -r public .next/standalone/ && cp -r .next/static .next/standalone/.next/",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "node .next/standalone/server.js",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "js",
        "code": "const path = require('path')\r\n\r\nmodule.exports = {\r\n  // this includes files from the monorepo base two directories up\r\n  outputFileTracingRoot: path.join(__dirname, '../../'),\r\n}",
        "context": "filename=\"packages/web-app/next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  outputFileTracingExcludes: {\r\n    '/api/hello': ['./un-necessary-folder/**/*'],\r\n  },\r\n  outputFileTracingIncludes: {\r\n    '/api/another': ['./necessary-folder/**/*'],\r\n    '/api/login/\\\\[\\\\[\\\\.\\\\.\\\\.slug\\\\]\\\\]': [\r\n      './node_modules/aws-crt/dist/bin/**/*',\r\n    ],\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  outputFileTracingIncludes: {\r\n    '/products/*': ['src/lib/payments/**/*'],\r\n    '/*': ['src/config/runtime/**/*.json'],\r\n  },\r\n  outputFileTracingExcludes: {\r\n    '/api/*': ['src/temp/**/*', 'public/large-logs/**/*'],\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  outputFileTracingIncludes: {\r\n    '/*': ['src/i18n/locales/**/*.json'],\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "const path = require('path')\r\n\r\nmodule.exports = {\r\n  // Trace from the monorepo root\r\n  outputFileTracingRoot: path.join(__dirname, '../../'),\r\n  outputFileTracingIncludes: {\r\n    '/route1': ['../shared/assets/**/*'],\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  outputFileTracingIncludes: {\r\n    '/*': ['node_modules/sharp/**/*', 'node_modules/aws-crt/dist/bin/**/*'],\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      }
    ],
    "content": "During a build, Next.js will automatically trace each page and its dependencies to determine all of the files that are needed for deploying a production version of your application. This feature helps reduce the size of deployments drastically. Previously, when deploying with Docker you would need to have all files from your package's dependencies installed to run next start. Starting with Next.js 12, you can leverage Output File Tracing in the .next/ directory to only include the necessary files. Furthermore, this removes the need for the deprecated serverless target which can cause various issues and also creates unnecessary duplication. How it Works During next build, Next.js will use @vercel/nft to statically analyze import, require, and fs usage to determine all files that a page might load. Next.js' production server is also traced for its needed files and output at .next/next-server.js.nft.json which can be leveraged in production. To leverage the .nft.json files emitted to the .next output directory, you can read the list of files in each trace that are relative to the .nft.json file and then copy them to your deployment location. Automatically Copying Traced Files Next.js can automatically create a standalone folder that copies only the necessary files for a production deployment including select files in nodemodules. To leverage this automatic copying you can enable it in your next.config.js: This will create a folder at .next/standalone which can then be deployed on its own without installing nodemodules. Additionally, a minimal server.js file is also output which can be used instead of next start. This minimal server does not copy the public or .next/static folders by default as these should ideally be handled by a CDN instead, although these folders can be copied to the standalone/public and standalone/.next/static folders manually, after which server.js file will serve these automatically. To copy these manually, you can use the cp command-line tool after you next build: To start your minimal server.js file locally, run the following command: > Good to know: > > - If your project needs to listen to a specific port or hostname, you can define PORT or HOSTNAME environment variables before running server.js. For example, run PORT=8080 HOSTNAME=0.0.0.0 node server.js to start the server on http://0.0.0.0:8080. > Good to know: > > - next.config.js is read during next build and serialized into the server.js output file. > - If your project needs to listen to a specific port or hostname, you can define PORT or HOSTNAME environment variables before running server.js. For example, run PORT=8080 HOSTNAME=0.0.0.0 node server.js to start the server on http://0.0.0.0:8080. Caveats - While tracing in monorepo setups, the project directory is used for tracing by default. For next build packages/web-app, packages/web-app would be the tracing root and any files outside of that folder will not be included. To include files outside of this folder you can set outputFileTracingRoot in your next.config.js. - There are some cases in which Next.js might fail to include required files, or might incorrectly include unused files. In those cases, you can leverage outputFileTracingExcludes and outputFileTracingIncludes respectively in next.config.js. Each option accepts an object whose keys are route globs (matched with picomatch against the route path, e.g. /api/hello) and whose values are glob patterns resolved from the project root that specify files to include or exclude in the trace. > Good to know: > In a monorepo, project root refers to the Next.js project root (the folder containing next.config.js, e.g., packages/web-app), not necessarily the monorepo root. Using a src/ directory does not change how you write these options: - Keys still match the route path ('/api/hello', '/products/[id]', etc.). - Values can reference paths under src/ since they are resolved relative to the project root. You can also target all routes using a global key like '/': These options are applied to server traces and do not affect routes that do not produce a server trace file: - Edge Runtime routes are not affected. - Fully static pages are not affected. In monorepos or when you need to include files outside the app folder, combine outputFileTracingRoot with includes: > Good to know: > > - Prefer forward slashes (/) in patterns for cross-platform compatibility. > - Keep patterns as narrow as possible to avoid oversized traces (avoid / at the repo root). Common include patterns for native/runtime assets:",
    "excerpt": "During a build, Next.js will automatically trace each page and its dependencies to determine all of the files that are needed for deploying a production version of your application. This feature helps...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/output"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-pageExtensions",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\pageExtensions.mdx",
    "title": "pageExtensions",
    "description": "Extend the default page extensions used by Next.js when resolving pages in the Pages Router.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Including non-page files in the  directory",
        "slug": "including-non-page-files-in-the-directory"
      }
    ],
    "codeBlocks": [
      {
        "language": "js",
        "code": "const withMDX = require('@next/mdx')()\r\n\r\n/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  pageExtensions: ['js', 'jsx', 'ts', 'tsx', 'md', 'mdx'],\r\n}\r\n\r\nmodule.exports = withMDX(nextConfig)",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  pageExtensions: ['mdx', 'md', 'jsx', 'js', 'tsx', 'ts'],\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  pageExtensions: ['page.tsx', 'page.ts', 'page.jsx', 'page.js'],\r\n}",
        "context": "filename=\"next.config.js\""
      }
    ],
    "content": "By default, Next.js accepts files with the following extensions: .tsx, .ts, .jsx, .js. This can be modified to allow other extensions like markdown (.md, .mdx). You can extend the default Page extensions (.tsx, .ts, .jsx, .js) used by Next.js. Inside next.config.js, add the pageExtensions config: Changing these values affects all Next.js pages, including the following: - proxy.js - instrumentation.js - pages/document.js - pages/app.js - pages/api/ For example, if you reconfigure .ts page extensions to .page.ts, you would need to rename pages like proxy.page.ts, instrumentation.page.ts, app.page.ts. Including non-page files in the pages directory You can colocate test files or other files used by components in the pages directory. Inside next.config.js, add the pageExtensions config: Then, rename your pages to have a file extension that includes .page (e.g. rename MyPage.tsx to MyPage.page.tsx). Ensure you rename all Next.js pages, including the files mentioned above.",
    "excerpt": "By default, Next.js accepts files with the following extensions: .tsx, .ts, .jsx, .js. This can be modified to allow other extensions like markdown (.md, .mdx). You can extend the default Page extensi...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/pageExtensions"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-poweredByHeader",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\poweredByHeader.mdx",
    "title": "poweredByHeader",
    "description": "Next.js will add the `x-powered-by` header by default. Learn to opt-out of it here.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [
      {
        "language": "js",
        "code": "module.exports = {\r\n  poweredByHeader: false,\r\n}",
        "context": "filename=\"next.config.js\""
      }
    ],
    "content": "By default Next.js will add the x-powered-by header. To opt-out of it, open next.config.js and disable the poweredByHeader config:",
    "excerpt": "By default Next.js will add the x-powered-by header. To opt-out of it, open next.config.js and disable the poweredByHeader config:",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/poweredByHeader"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-productionBrowserSourceMaps",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\productionBrowserSourceMaps.mdx",
    "title": "productionBrowserSourceMaps",
    "description": "Enables browser source map generation during the production build.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [
      {
        "language": "js",
        "code": "module.exports = {\r\n  productionBrowserSourceMaps: true,\r\n}",
        "context": "filename=\"next.config.js\""
      }
    ],
    "content": "Source Maps are enabled by default during development. During production builds, they are disabled to prevent you leaking your source on the client, unless you specifically opt-in with the configuration flag. Next.js provides a configuration flag you can use to enable browser source map generation during the production build: When the productionBrowserSourceMaps option is enabled, the source maps will be output in the same directory as the JavaScript files. Next.js will automatically serve these files when requested. - Adding source maps can increase next build time - Increases memory usage during next build",
    "excerpt": "Source Maps are enabled by default during development. During production builds, they are disabled to prevent you leaking your source on the client, unless you specifically opt-in with the configurati...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/productionBrowserSourceMaps"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-proxyClientMaxBodySize",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\proxyClientMaxBodySize.mdx",
    "title": "proxyClientMaxBodySize",
    "description": "Configure the maximum request body size when using proxy.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Options",
        "slug": "options"
      },
      {
        "level": 3,
        "text": "String format (recommended)",
        "slug": "string-format-recommended"
      },
      {
        "level": 3,
        "text": "Number format",
        "slug": "number-format"
      },
      {
        "level": 2,
        "text": "Behavior",
        "slug": "behavior"
      },
      {
        "level": 2,
        "text": "Example",
        "slug": "example"
      },
      {
        "level": 2,
        "text": "Good to know",
        "slug": "good-to-know"
      }
    ],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  experimental: {\r\n    proxyClientMaxBodySize: '1mb',\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  experimental: {\r\n    proxyClientMaxBodySize: '1mb',\r\n  },\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  experimental: {\r\n    proxyClientMaxBodySize: 1048576, // 1MB in bytes\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  experimental: {\r\n    proxyClientMaxBodySize: 1048576, // 1MB in bytes\r\n  },\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { NextRequest, NextResponse } from 'next/server'\r\n\r\nexport async function proxy(request: NextRequest) {\r\n  // Next.js automatically buffers the body with the configured size limit\r\n  // You can read the body in proxy...\r\n  const body = await request.text()\r\n\r\n  // If the body exceeded the limit, only partial data will be available\r\n  console.log('Body size:', body.length)\r\n\r\n  return NextResponse.next()\r\n}",
        "context": "filename=\"proxy.ts\""
      },
      {
        "language": "ts",
        "code": "import { NextRequest, NextResponse } from 'next/server'\r\n\r\nexport async function POST(request: NextRequest) {\r\n  // ...and the body is still available in your route handler\r\n  const body = await request.text()\r\n\r\n  console.log('Body in route handler:', body.length)\r\n\r\n  return NextResponse.json({ received: body.length })\r\n}",
        "context": "filename=\"app/api/upload/route.ts\""
      }
    ],
    "content": "When proxy is used, Next.js automatically clones the request body and buffers it in memory to enable multiple reads - both in proxy and the underlying route handler. To prevent excessive memory usage, this configuration option sets a size limit on the buffered body. By default, the maximum body size is 10MB. If a request body exceeds this limit, the body will only be buffered up to the limit, and a warning will be logged indicating which route exceeded the limit. Options String format (recommended) Specify the size using a human-readable string format: Supported units: b, kb, mb, gb Number format Alternatively, specify the size in bytes as a number: Behavior When a request body exceeds the configured limit: 1. Next.js will buffer only the first N bytes (up to the limit) 2. A warning will be logged to the console indicating the route that exceeded the limit 3. The request will continue processing normally, but only the partial body will be available 4. The request will not fail or return an error to the client If your application needs to process the full request body, you should either: - Increase the proxyClientMaxBodySize limit - Handle the partial body gracefully in your application logic Example Good to know - This setting only applies when proxy is used in your application - The default limit of 10MB is designed to balance memory usage and typical use cases - The limit applies per-request, not globally across all concurrent requests - For applications handling large file uploads, consider increasing the limit accordingly",
    "excerpt": "When proxy is used, Next.js automatically clones the request body and buffers it in memory to enable multiple reads - both in proxy and the underlying route handler. To prevent excessive memory usage,...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/proxyClientMaxBodySize"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-reactCompiler",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\reactCompiler.mdx",
    "title": "reactCompiler",
    "description": "Enable the React Compiler to automatically optimize component rendering.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "How It Works",
        "slug": "how-it-works"
      },
      {
        "level": 2,
        "text": "Annotations",
        "slug": "annotations"
      }
    ],
    "codeBlocks": [
      {
        "language": "bash",
        "code": "npm install -D babel-plugin-react-compiler",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  reactCompiler: true,\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  reactCompiler: true,\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  reactCompiler: {\r\n    compilationMode: 'annotation',\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  reactCompiler: {\r\n    compilationMode: 'annotation',\r\n  },\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\" switcher"
      },
      {
        "language": "ts",
        "code": "export default function Page() {\r\n  'use memo'\r\n  // ...\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "js",
        "code": "export default function Page() {\r\n  'use memo'\r\n  // ...\r\n}",
        "context": "filename=\"app/page.js\" switcher"
      }
    ],
    "content": "Next.js includes support for the React Compiler, a tool designed to improve performance by automatically optimizing component rendering. This reduces the need for manual memoization using useMemo and useCallback. Next.js includes a custom performance optimization written in SWC that makes the React Compiler more efficient. Instead of running the compiler on every file, Next.js analyzes your project and only applies the React Compiler to relevant files. This avoids unnecessary work and leads to faster builds compared to using the Babel plugin on its own. How It Works The React Compiler runs through a Babel plugin. To keep builds fast, Next.js uses a custom SWC optimization that only applies the React Compiler to relevant files—like those with JSX or React Hooks. This avoids compiling everything and keeps the performance cost minimal. You may still see slightly slower builds compared to the default Rust-based compiler, but the impact is small and localized. To use it, install the babel-plugin-react-compiler: Then, add reactCompiler option in next.config.js: Annotations You can configure the compiler to run in \"opt-in\" mode as follows: Then, you can annotate specific components or hooks with the \"use memo\" directive from React to opt-in: > Note: You can also use the \"use no memo\" directive from React for the opposite effect, to opt-out a component or hook.",
    "excerpt": "Next.js includes support for the React Compiler, a tool designed to improve performance by automatically optimizing component rendering. This reduces the need for manual memoization using useMemo and...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/reactCompiler"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-reactMaxHeadersLength",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\reactMaxHeadersLength.mdx",
    "title": "reactMaxHeadersLength",
    "description": "The maximum length of the headers that are emitted by React and added to the response.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [
      {
        "language": "js",
        "code": "module.exports = {\r\n  reactMaxHeadersLength: 1000,\r\n}",
        "context": "filename=\"next.config.js\""
      }
    ],
    "content": "During static rendering, React can emit headers that can be added to the response. These can be used to improve performance by allowing the browser to preload resources like fonts, scripts, and stylesheets. The default value is 6000, but you can override this value by configuring the reactMaxHeadersLength option in next.config.js: > Good to know: This option is only available in App Router. Depending on the type of proxy between the browser and the server, the headers can be truncated. For example, if you are using a reverse proxy that doesn't support long headers, you should set a lower value to ensure that the headers are not truncated.",
    "excerpt": "During static rendering, React can emit headers that can be added to the response. These can be used to improve performance by allowing the browser to preload resources like fonts, scripts, and styles...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/reactMaxHeadersLength"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-reactStrictMode",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\reactStrictMode.mdx",
    "title": "reactStrictMode",
    "description": "The complete Next.js runtime is now Strict Mode-compliant, learn how to opt-in",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [
      {
        "language": "js",
        "code": "module.exports = {\r\n  reactStrictMode: true,\r\n}",
        "context": "filename=\"next.config.js\""
      }
    ],
    "content": "> Good to know: Since Next.js 13.5.1, Strict Mode is true by default with app router, so the above configuration is only necessary for pages. You can still disable Strict Mode by setting reactStrictMode: false. > Suggested: We strongly suggest you enable Strict Mode in your Next.js application to better prepare your application for the future of React. React's Strict Mode is a development mode only feature for highlighting potential problems in an application. It helps to identify unsafe lifecycles, legacy API usage, and a number of other features. The Next.js runtime is Strict Mode-compliant. To opt-in to Strict Mode, configure the following option in your next.config.js: If you or your team are not ready to use Strict Mode in your entire application, that's OK! You can incrementally migrate on a page-by-page basis using .",
    "excerpt": "> Good to know: Since Next.js 13.5.1, Strict Mode is true by default with app router, so the above configuration is only necessary for pages. You can still disable Strict Mode by setting reactStrictMo...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/reactStrictMode"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-redirects",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\redirects.mdx",
    "title": "redirects",
    "description": "Add redirects to your Next.js app.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Path Matching",
        "slug": "path-matching"
      },
      {
        "level": 3,
        "text": "Wildcard Path Matching",
        "slug": "wildcard-path-matching"
      },
      {
        "level": 3,
        "text": "Regex Path Matching",
        "slug": "regex-path-matching"
      },
      {
        "level": 2,
        "text": "Header, Cookie, and Query Matching",
        "slug": "header-cookie-and-query-matching"
      },
      {
        "level": 3,
        "text": "Redirects with basePath support",
        "slug": "redirects-with-basepath-support"
      },
      {
        "level": 3,
        "text": "Redirects with i18n support",
        "slug": "redirects-with-i18n-support"
      },
      {
        "level": 2,
        "text": "Other Redirects",
        "slug": "other-redirects"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "js",
        "code": "module.exports = {\r\n  async redirects() {\r\n    return [\r\n      {\r\n        source: '/about',\r\n        destination: '/',\r\n        permanent: true,\r\n      },\r\n    ]\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "{\r\n  source: '/old-blog/:path*',\r\n  destination: '/blog/:path*',\r\n  permanent: false\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  async redirects() {\r\n    return [\r\n      {\r\n        source: '/old-blog/:slug',\r\n        destination: '/news/:slug', // Matched parameters can be used in the destination\r\n        permanent: true,\r\n      },\r\n    ]\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  async redirects() {\r\n    return [\r\n      {\r\n        source: '/blog/:slug*',\r\n        destination: '/news/:slug*', // Matched parameters can be used in the destination\r\n        permanent: true,\r\n      },\r\n    ]\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  async redirects() {\r\n    return [\r\n      {\r\n        source: '/post/:slug(\\\\d{1,})',\r\n        destination: '/news/:slug', // Matched parameters can be used in the destination\r\n        permanent: false,\r\n      },\r\n    ]\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  async redirects() {\r\n    return [\r\n      {\r\n        // this will match `/english(default)/something` being requested\r\n        source: '/english\\\\(default\\\\)/:slug',\r\n        destination: '/en-us/:slug',\r\n        permanent: false,\r\n      },\r\n    ]\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  async redirects() {\r\n    return [\r\n      // if the header `x-redirect-me` is present,\r\n      // this redirect will be applied\r\n      {\r\n        source: '/:path((?!another-page$).*)',\r\n        has: [\r\n          {\r\n            type: 'header',\r\n            key: 'x-redirect-me',\r\n          },\r\n        ],\r\n        permanent: false,\r\n        destination: '/another-page',\r\n      },\r\n      // if the header `x-dont-redirect` is present,\r\n      // this redirect will NOT be applied\r\n      {\r\n        source: '/:path((?!another-page$).*)',\r\n        missing: [\r\n          {\r\n            type: 'header',\r\n            key: 'x-do-not-redirect',\r\n          },\r\n        ],\r\n        permanent: false,\r\n        destination: '/another-page',\r\n      },\r\n      // if the source, query, and cookie are matched,\r\n      // this redirect will be applied\r\n      {\r\n        source: '/specific/:path*',\r\n        has: [\r\n          {\r\n            type: 'query',\r\n            key: 'page',\r\n            // the page value will not be available in the\r\n            // destination since value is provided and doesn't\r\n            // use a named capture group e.g. (?<page>home)\r\n            value: 'home',\r\n          },\r\n          {\r\n            type: 'cookie',\r\n            key: 'authorized',\r\n            value: 'true',\r\n          },\r\n        ],\r\n        permanent: false,\r\n        destination: '/another/:path*',\r\n      },\r\n      // if the header `x-authorized` is present and\r\n      // contains a matching value, this redirect will be applied\r\n      {\r\n        source: '/',\r\n        has: [\r\n          {\r\n            type: 'header',\r\n            key: 'x-authorized',\r\n            value: '(?<authorized>yes|true)',\r\n          },\r\n        ],\r\n        permanent: false,\r\n        destination: '/home?authorized=:authorized',\r\n      },\r\n      // if the host is `example.com`,\r\n      // this redirect will be applied\r\n      {\r\n        source: '/:path((?!another-page$).*)',\r\n        has: [\r\n          {\r\n            type: 'host',\r\n            value: 'example.com',\r\n          },\r\n        ],\r\n        permanent: false,\r\n        destination: '/another-page',\r\n      },\r\n    ]\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  basePath: '/docs',\r\n\r\n  async redirects() {\r\n    return [\r\n      {\r\n        source: '/with-basePath', // automatically becomes /docs/with-basePath\r\n        destination: '/another', // automatically becomes /docs/another\r\n        permanent: false,\r\n      },\r\n      {\r\n        // does not add /docs since basePath: false is set\r\n        source: '/without-basePath',\r\n        destination: 'https://example.com',\r\n        basePath: false,\r\n        permanent: false,\r\n      },\r\n    ]\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  async redirects() {\r\n    return [\r\n      {\r\n        // Manually handle locale prefixes for App Router\r\n        source: '/en/old-path',\r\n        destination: '/en/new-path',\r\n        permanent: false,\r\n      },\r\n      {\r\n        // Redirect for all locales using a parameter\r\n        source: '/:locale/old-path',\r\n        destination: '/:locale/new-path',\r\n        permanent: false,\r\n      },\r\n      {\r\n        // Redirect from one locale to another\r\n        source: '/de/old-path',\r\n        destination: '/en/new-path',\r\n        permanent: false,\r\n      },\r\n      {\r\n        // Catch-all redirect for multiple locales\r\n        source: '/:locale(en|fr|de)/:path*',\r\n        destination: '/:locale/new-section/:path*',\r\n        permanent: false,\r\n      },\r\n    ]\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  i18n: {\r\n    locales: ['en', 'fr', 'de'],\r\n    defaultLocale: 'en',\r\n  },\r\n\r\n  async redirects() {\r\n    return [\r\n      {\r\n        source: '/with-locale', // automatically handles all locales\r\n        destination: '/another', // automatically passes the locale on\r\n        permanent: false,\r\n      },\r\n      {\r\n        // does not handle locales automatically since locale: false is set\r\n        source: '/nl/with-locale-manual',\r\n        destination: '/nl/another',\r\n        locale: false,\r\n        permanent: false,\r\n      },\r\n      {\r\n        // this matches '/' since `en` is the defaultLocale\r\n        source: '/en',\r\n        destination: '/en/another',\r\n        locale: false,\r\n        permanent: false,\r\n      },\r\n      // it's possible to match all locales even when locale: false is set\r\n      {\r\n        source: '/:locale/page',\r\n        destination: '/en/newpage',\r\n        permanent: false,\r\n        locale: false,\r\n      },\r\n      {\r\n        // this gets converted to /(en|fr|de)/(.*) so will not match the top-level\r\n        // `/` or `/fr` routes like /:path* would\r\n        source: '/(.*)',\r\n        destination: '/another',\r\n        permanent: false,\r\n      },\r\n    ]\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      }
    ],
    "content": "Redirects allow you to redirect an incoming request path to a different destination path. To use redirects you can use the redirects key in next.config.js: redirects is an async function that expects an array to be returned holding objects with source, destination, and permanent properties: - source is the incoming request path pattern. - destination is the path you want to route to. - permanent true or false - if true will use the 308 status code which instructs clients/search engines to cache the redirect forever, if false will use the 307 status code which is temporary and is not cached. > Why does Next.js use 307 and 308? Traditionally a 302 was used for a temporary redirect, and a 301 for a permanent redirect, but many browsers changed the request method of the redirect to GET, regardless of the original method. For example, if the browser made a request to POST /v1/users which returned status code 302 with location /v2/users, the subsequent request might be GET /v2/users instead of the expected POST /v2/users. Next.js uses the 307 temporary redirect, and 308 permanent redirect status codes to explicitly preserve the request method used. - basePath: false or undefined - if false the basePath won't be included when matching, can be used for external redirects only. - locale: false or undefined - whether the locale should not be included when matching. - has is an array of has objects with the type, key and value properties. - missing is an array of missing objects with the type, key and value properties. Redirects are checked before the filesystem which includes pages and /public files. When using the Pages Router, redirects are not applied to client-side routing (Link, router.push) unless Proxy is present and matches the path. When a redirect is applied, any query values provided in the request will be passed through to the redirect destination. For example, see the following redirect configuration: > Good to know: Remember to include the forward slash / before the colon : in path parameters of the source and destination paths, otherwise the path will be treated as a literal string and you run the risk of causing infinite redirects. When /old-blog/post-1?hello=world is requested, the client will be redirected to /blog/post-1?hello=world. Path Matching Path matches are allowed, for example /old-blog/:slug will match /old-blog/hello-world (no nested paths): Wildcard Path Matching To match a wildcard path you can use after a parameter, for example /blog/:slug will match /blog/a/b/c/d/hello-world: Regex Path Matching To match a regex path you can wrap the regex in parentheses after a parameter, for example /post/:slug(\\\\d{1,}) will match /post/123 but not /post/abc: The following characters (, ), {, }, :, , +, ? are used for regex path matching, so when used in the source as non-special values they must be escaped by adding \\\\ before them: Header, Cookie, and Query Matching To only match a redirect when header, cookie, or query values also match the has field or don't match the missing field can be used. Both the source and all has items must match and all missing items must not match for the redirect to be applied. has and missing items can have the following fields: - type: String - must be either header, cookie, host, or query. - key: String - the key from the selected type to match against. - value: String or undefined - the value to check for, if undefined any value will match. A regex like string can be used to capture a specific part of the value, e.g. if the value first-(?.) is used for first-second then second will be usable in the destination with :paramName. Redirects with basePath support When leveraging basePath support with redirects each source and destination is automatically prefixed with the basePath unless you add basePath: false to the redirect: Redirects with i18n support When implementing redirects with internationalization in the App Router, you can include locales in next.config.js redirects, but only as hardcoded paths. For dynamic or per-request locale handling, use dynamic route segments and proxy, which can redirect based on the user's preferred language. When leveraging i18n support with redirects each source and destination is automatically prefixed to handle the configured locales unless you add locale: false to the redirect. If locale: false is used you must prefix the source and destination with a locale for it to be matched correctly. In some rare cases, you might need to assign a custom status code for older HTTP Clients to properly redirect. In these cases, you can use the statusCode property instead of the permanent property, but not both. To ensure IE11 compatibility, a Refresh header is automatically added for the 308 status code. Other Redirects - Inside API Routes and Route Handlers, you can redirect based on the incoming request. - Inside getStaticProps and getServerSideProps, you can redirect specific pages at request-time. Version History | Version | Changes | | --------- | ------------------ | | v13.3.0 | missing added. | | v10.2.0 | has added. | | v9.5.0 | redirects added. |",
    "excerpt": "Redirects allow you to redirect an incoming request path to a different destination path. To use redirects you can use the redirects key in next.config.js: redirects is an async function that expects...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/redirects"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-rewrites",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\rewrites.mdx",
    "title": "rewrites",
    "description": "Add rewrites to your Next.js app.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Rewrite parameters",
        "slug": "rewrite-parameters"
      },
      {
        "level": 2,
        "text": "Path Matching",
        "slug": "path-matching"
      },
      {
        "level": 3,
        "text": "Wildcard Path Matching",
        "slug": "wildcard-path-matching"
      },
      {
        "level": 3,
        "text": "Regex Path Matching",
        "slug": "regex-path-matching"
      },
      {
        "level": 2,
        "text": "Header, Cookie, and Query Matching",
        "slug": "header-cookie-and-query-matching"
      },
      {
        "level": 2,
        "text": "Rewriting to an external URL",
        "slug": "rewriting-to-an-external-url"
      },
      {
        "level": 3,
        "text": "Incremental adoption of Next.js",
        "slug": "incremental-adoption-of-nextjs"
      },
      {
        "level": 3,
        "text": "Rewrites with basePath support",
        "slug": "rewrites-with-basepath-support"
      },
      {
        "level": 3,
        "text": "Rewrites with i18n support",
        "slug": "rewrites-with-i18n-support"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "js",
        "code": "module.exports = {\r\n  async rewrites() {\r\n    return [\r\n      {\r\n        source: '/about',\r\n        destination: '/',\r\n      },\r\n    ]\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  async rewrites() {\r\n    return {\r\n      beforeFiles: [\r\n        // These rewrites are checked after headers/redirects\r\n        // and before all files including _next/public files which\r\n        // allows overriding page files\r\n        {\r\n          source: '/some-page',\r\n          destination: '/somewhere-else',\r\n          has: [{ type: 'query', key: 'overrideMe' }],\r\n        },\r\n      ],\r\n      afterFiles: [\r\n        // These rewrites are checked after pages/public files\r\n        // are checked but before dynamic routes\r\n        {\r\n          source: '/non-existent',\r\n          destination: '/somewhere-else',\r\n        },\r\n      ],\r\n      fallback: [\r\n        // These rewrites are checked after both pages/public files\r\n        // and dynamic routes are checked\r\n        {\r\n          source: '/:path*',\r\n          destination: `https://my-old-site.com/:path*`,\r\n        },\r\n      ],\r\n    }\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  async rewrites() {\r\n    return [\r\n      {\r\n        source: '/old-about/:path*',\r\n        destination: '/about', // The :path parameter isn't used here so will be automatically passed in the query\r\n      },\r\n    ]\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  async rewrites() {\r\n    return [\r\n      {\r\n        source: '/docs/:path*',\r\n        destination: '/:path*', // The :path parameter is used here so will not be automatically passed in the query\r\n      },\r\n    ]\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  async rewrites() {\r\n    return [\r\n      {\r\n        source: '/:first/:second',\r\n        destination: '/:first?second=:second',\r\n        // Since the :first parameter is used in the destination the :second parameter\r\n        // will not automatically be added in the query although we can manually add it\r\n        // as shown above\r\n      },\r\n    ]\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  async rewrites() {\r\n    return [\r\n      {\r\n        source: '/blog/:slug',\r\n        destination: '/news/:slug', // Matched parameters can be used in the destination\r\n      },\r\n    ]\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  async rewrites() {\r\n    return [\r\n      {\r\n        source: '/blog/:slug*',\r\n        destination: '/news/:slug*', // Matched parameters can be used in the destination\r\n      },\r\n    ]\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  async rewrites() {\r\n    return [\r\n      {\r\n        source: '/old-blog/:post(\\\\d{1,})',\r\n        destination: '/blog/:post', // Matched parameters can be used in the destination\r\n      },\r\n    ]\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  async rewrites() {\r\n    return [\r\n      {\r\n        // this will match `/english(default)/something` being requested\r\n        source: '/english\\\\(default\\\\)/:slug',\r\n        destination: '/en-us/:slug',\r\n      },\r\n    ]\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  async rewrites() {\r\n    return [\r\n      // if the header `x-rewrite-me` is present,\r\n      // this rewrite will be applied\r\n      {\r\n        source: '/:path*',\r\n        has: [\r\n          {\r\n            type: 'header',\r\n            key: 'x-rewrite-me',\r\n          },\r\n        ],\r\n        destination: '/another-page',\r\n      },\r\n      // if the header `x-rewrite-me` is not present,\r\n      // this rewrite will be applied\r\n      {\r\n        source: '/:path*',\r\n        missing: [\r\n          {\r\n            type: 'header',\r\n            key: 'x-rewrite-me',\r\n          },\r\n        ],\r\n        destination: '/another-page',\r\n      },\r\n      // if the source, query, and cookie are matched,\r\n      // this rewrite will be applied\r\n      {\r\n        source: '/specific/:path*',\r\n        has: [\r\n          {\r\n            type: 'query',\r\n            key: 'page',\r\n            // the page value will not be available in the\r\n            // destination since value is provided and doesn't\r\n            // use a named capture group e.g. (?<page>home)\r\n            value: 'home',\r\n          },\r\n          {\r\n            type: 'cookie',\r\n            key: 'authorized',\r\n            value: 'true',\r\n          },\r\n        ],\r\n        destination: '/:path*/home',\r\n      },\r\n      // if the header `x-authorized` is present and\r\n      // contains a matching value, this rewrite will be applied\r\n      {\r\n        source: '/:path*',\r\n        has: [\r\n          {\r\n            type: 'header',\r\n            key: 'x-authorized',\r\n            value: '(?<authorized>yes|true)',\r\n          },\r\n        ],\r\n        destination: '/home?authorized=:authorized',\r\n      },\r\n      // if the host is `example.com`,\r\n      // this rewrite will be applied\r\n      {\r\n        source: '/:path*',\r\n        has: [\r\n          {\r\n            type: 'host',\r\n            value: 'example.com',\r\n          },\r\n        ],\r\n        destination: '/another-page',\r\n      },\r\n    ]\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  async rewrites() {\r\n    return [\r\n      {\r\n        source: '/blog',\r\n        destination: 'https://example.com/blog',\r\n      },\r\n      {\r\n        source: '/blog/:slug',\r\n        destination: 'https://example.com/blog/:slug', // Matched parameters can be used in the destination\r\n      },\r\n    ]\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  trailingSlash: true,\r\n  async rewrites() {\r\n    return [\r\n      {\r\n        source: '/blog/',\r\n        destination: 'https://example.com/blog/',\r\n      },\r\n      {\r\n        source: '/blog/:path*/',\r\n        destination: 'https://example.com/blog/:path*/',\r\n      },\r\n    ]\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  async rewrites() {\r\n    return {\r\n      fallback: [\r\n        {\r\n          source: '/:path*',\r\n          destination: `https://custom-routes-proxying-endpoint.vercel.app/:path*`,\r\n        },\r\n      ],\r\n    }\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  basePath: '/docs',\r\n\r\n  async rewrites() {\r\n    return [\r\n      {\r\n        source: '/with-basePath', // automatically becomes /docs/with-basePath\r\n        destination: '/another', // automatically becomes /docs/another\r\n      },\r\n      {\r\n        // does not add /docs to /without-basePath since basePath: false is set\r\n        // Note: this can not be used for internal rewrites e.g. `destination: '/another'`\r\n        source: '/without-basePath',\r\n        destination: 'https://example.com',\r\n        basePath: false,\r\n      },\r\n    ]\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  i18n: {\r\n    locales: ['en', 'fr', 'de'],\r\n    defaultLocale: 'en',\r\n  },\r\n\r\n  async rewrites() {\r\n    return [\r\n      {\r\n        source: '/with-locale', // automatically handles all locales\r\n        destination: '/another', // automatically passes the locale on\r\n      },\r\n      {\r\n        // does not handle locales automatically since locale: false is set\r\n        source: '/nl/with-locale-manual',\r\n        destination: '/nl/another',\r\n        locale: false,\r\n      },\r\n      {\r\n        // this matches '/' since `en` is the defaultLocale\r\n        source: '/en',\r\n        destination: '/en/another',\r\n        locale: false,\r\n      },\r\n      {\r\n        // it's possible to match all locales even when locale: false is set\r\n        source: '/:locale/api-alias/:path*',\r\n        destination: '/api/:path*',\r\n        locale: false,\r\n      },\r\n      {\r\n        // this gets converted to /(en|fr|de)/(.*) so will not match the top-level\r\n        // `/` or `/fr` routes like /:path* would\r\n        source: '/(.*)',\r\n        destination: '/another',\r\n      },\r\n    ]\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      }
    ],
    "content": "Rewrites allow you to map an incoming request path to a different destination path. Rewrites act as a URL proxy and mask the destination path, making it appear the user hasn't changed their location on the site. In contrast, redirects will reroute to a new page and show the URL changes. Rewrites act as a URL proxy and mask the destination path, making it appear the user hasn't changed their location on the site. In contrast, redirects will reroute to a new page and show the URL changes. To use rewrites you can use the rewrites key in next.config.js: Rewrites are applied to client-side routing. In the example above, navigating to will serve content from / while keeping the URL as /about. rewrites is an async function that expects to return either an array or an object of arrays (see below) holding objects with source and destination properties: - source: String - is the incoming request path pattern. - destination: String is the path you want to route to. - basePath: false or undefined - if false the basePath won't be included when matching, can be used for external rewrites only. - locale: false or undefined - whether the locale should not be included when matching. - has is an array of has objects with the type, key and value properties. - missing is an array of missing objects with the type, key and value properties. When the rewrites function returns an array, rewrites are applied after checking the filesystem (pages and /public files) and before dynamic routes. When the rewrites function returns an object of arrays with a specific shape, this behavior can be changed and more finely controlled, as of v10.1 of Next.js: > Good to know: rewrites in beforeFiles do not check the filesystem/dynamic routes immediately after matching a source, they continue until all beforeFiles have been checked. The order Next.js routes are checked is: 1. headers are checked/applied 2. redirects are checked/applied 3. proxy 4. beforeFiles rewrites are checked/applied 5. static files from the public directory, next/static files, and non-dynamic pages are checked/served 6. afterFiles rewrites are checked/applied, if one of these rewrites is matched we check dynamic routes/static files after each match 7. fallback rewrites are checked/applied, these are applied before rendering the 404 page and after dynamic routes/all static assets have been checked. If you use fallback: true/'blocking' in getStaticPaths, the fallback rewrites defined in your next.config.js will not be run. 1. headers are checked/applied 2. redirects are checked/applied 3. beforeFiles rewrites are checked/applied 4. static files from the public directory, next/static files, and non-dynamic pages are checked/served 5. afterFiles rewrites are checked/applied, if one of these rewrites is matched we check dynamic routes/static files after each match 6. fallback rewrites are checked/applied, these are applied before rendering the 404 page and after dynamic routes/all static assets have been checked. If you use fallback: true/'blocking' in getStaticPaths, the fallback rewrites defined in your next.config.js will not be run. Rewrite parameters When using parameters in a rewrite the parameters will be passed in the query by default when none of the parameters are used in the destination. If a parameter is used in the destination none of the parameters will be automatically passed in the query. You can still pass the parameters manually in the query if one is already used in the destination by specifying the query in the destination. > Good to know: Static pages from Automatic Static Optimization or prerendering params from rewrites will be parsed on the client after hydration and provided in the query. Path Matching Path matches are allowed, for example /blog/:slug will match /blog/hello-world (no nested paths): Wildcard Path Matching To match a wildcard path you can use after a parameter, for example /blog/:slug will match /blog/a/b/c/d/hello-world: Regex Path Matching To match a regex path you can wrap the regex in parenthesis after a parameter, for example /blog/:slug(\\\\d{1,}) will match /blog/123 but not /blog/abc: The following characters (, ), {, }, [, ], |, \\, ^, ., :, , +, -, ?, $ are used for regex path matching, so when used in the source as non-special values they must be escaped by adding \\\\ before them: Header, Cookie, and Query Matching To only match a rewrite when header, cookie, or query values also match the has field or don't match the missing field can be used. Both the source and all has items must match and all missing items must not match for the rewrite to be applied. has and missing items can have the following fields: - type: String - must be either header, cookie, host, or query. - key: String - the key from the selected type to match against. - value: String or undefined - the value to check for, if undefined any value will match. A regex like string can be used to capture a specific part of the value, e.g. if the value first-(?.) is used for first-second then second will be usable in the destination with :paramName. Rewriting to an external URL Examples - Using Multiple Zones Rewrites allow you to rewrite to an external URL. This is especially useful for incrementally adopting Next.js. The following is an example rewrite for redirecting the /blog route of your main app to an external site. If you're using trailingSlash: true, you also need to insert a trailing slash in the source parameter. If the destination server is also expecting a trailing slash it should be included in the destination parameter as well. Incremental adoption of Next.js You can also have Next.js fall back to proxying to an existing website after checking all Next.js routes. This way you don't have to change the rewrites configuration when migrating more pages to Next.js Rewrites with basePath support When leveraging basePath support with rewrites each source and destination is automatically prefixed with the basePath unless you add basePath: false to the rewrite: Rewrites with i18n support When leveraging i18n support with rewrites each source and destination is automatically prefixed to handle the configured locales unless you add locale: false to the rewrite. If locale: false is used you must prefix the source and destination with a locale for it to be matched correctly. Version History | Version | Changes | | --------- | ---------------- | | v13.3.0 | missing added. | | v10.2.0 | has added. | | v9.5.0 | Headers added. |",
    "excerpt": "Rewrites allow you to map an incoming request path to a different destination path. Rewrites act as a URL proxy and mask the destination path, making it appear the user hasn't changed their location o...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/rewrites"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-sassOptions",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\sassOptions.mdx",
    "title": "sassOptions",
    "description": "Configure Sass options.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst sassOptions = {\r\n  additionalData: `\r\n    $var: red;\r\n  `,\r\n}\r\n\r\nconst nextConfig: NextConfig = {\r\n  sassOptions: {\r\n    ...sassOptions,\r\n    implementation: 'sass-embedded',\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\n\r\nconst sassOptions = {\r\n  additionalData: `\r\n    $var: red;\r\n  `,\r\n}\r\n\r\nconst nextConfig = {\r\n  sassOptions: {\r\n    ...sassOptions,\r\n    implementation: 'sass-embedded',\r\n  },\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\" switcher"
      }
    ],
    "content": "sassOptions allow you to configure the Sass compiler. > Good to know: > > - sassOptions are not typed outside of implementation because Next.js does not maintain the other possible properties. > - The functions property for defining custom Sass functions is only supported with webpack. When using Turbopack, custom Sass functions are not available because Turbopack's Rust-based architecture cannot directly execute JavaScript functions passed through this option.",
    "excerpt": "sassOptions allow you to configure the Sass compiler. > Good to know: > > - sassOptions are not typed outside of implementation because Next.js does not maintain the other possible properties. > - The...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/sassOptions"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-serverActions",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\serverActions.mdx",
    "title": "serverActions",
    "description": "Configure Server Actions behavior in your Next.js application.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Enabling Server Actions (v13)",
        "slug": "enabling-server-actions-v13"
      }
    ],
    "codeBlocks": [
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\n\r\nmodule.exports = {\r\n  experimental: {\r\n    serverActions: {\r\n      allowedOrigins: ['my-proxy.com', '*.my-proxy.com'],\r\n    },\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\n\r\nmodule.exports = {\r\n  experimental: {\r\n    serverActions: {\r\n      bodySizeLimit: '2mb',\r\n    },\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst config = {\r\n  experimental: {\r\n    serverActions: true,\r\n  },\r\n}\r\n\r\nmodule.exports = config",
        "context": "filename=\"next.config.js\""
      }
    ],
    "content": "Options for configuring Server Actions behavior in your Next.js application. allowedOrigins A list of extra safe origin domains from which Server Actions can be invoked. Next.js compares the origin of a Server Action request with the host domain, ensuring they match to prevent CSRF attacks. If not provided, only the same origin is allowed. bodySizeLimit By default, the maximum size of the request body sent to a Server Action is 1MB, to prevent the consumption of excessive server resources in parsing large amounts of data, as well as potential DDoS attacks. However, you can configure this limit using the serverActions.bodySizeLimit option. It can take the number of bytes or any string format supported by bytes, for example 1000, '500kb' or '3mb'. Enabling Server Actions (v13) Server Actions became a stable feature in Next.js 14, and are enabled by default. However, if you are using an earlier version of Next.js, you can enable them by setting experimental.serverActions to true.",
    "excerpt": "Options for configuring Server Actions behavior in your Next.js application. allowedOrigins A list of extra safe origin domains from which Server Actions can be invoked. Next.js compares the origin of...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/serverActions"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-serverComponentsHmrCache",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\serverComponentsHmrCache.mdx",
    "title": "serverComponentsHmrCache",
    "description": "Configure whether fetch responses in Server Components are cached across HMR refresh requests.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  experimental: {\r\n    serverComponentsHmrCache: false, // defaults to true\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  experimental: {\r\n    serverComponentsHmrCache: false, // defaults to true\r\n  },\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\" switcher"
      }
    ],
    "content": "The experimental serverComponentsHmrCache option allows you to cache fetch responses in Server Components across Hot Module Replacement (HMR) refreshes in local development. This results in faster responses and reduced costs for billed API calls. By default, the HMR cache applies to all fetch requests, including those with the cache: 'no-store' option. This means uncached requests will not show fresh data between HMR refreshes. However, the cache will be cleared on navigation or full-page reloads. You can disable the HMR cache by setting serverComponentsHmrCache to false in your next.config.js file: > Good to know: For better observability, we recommend using the logging.fetches option which logs fetch cache hits and misses in the console during development.",
    "excerpt": "The experimental serverComponentsHmrCache option allows you to cache fetch responses in Server Components across Hot Module Replacement (HMR) refreshes in local development. This results in faster res...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/serverComponentsHmrCache"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-serverExternalPackages",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\serverExternalPackages.mdx",
    "title": "serverExternalPackages",
    "description": "Opt-out specific dependencies from the Server Components bundling and use native Node.js `require`.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  serverExternalPackages: ['@acme/ui'],\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\""
      }
    ],
    "content": "Dependencies used inside Server Components and Route Handlers will automatically be bundled by Next.js. If a dependency is using Node.js specific features, you can choose to opt-out specific dependencies from the Server Components bundling and use native Node.js require. Next.js includes a short list of popular packages that currently are working on compatibility and automatically opt-ed out: - @appsignal/nodejs - @aws-sdk/client-s3 - @aws-sdk/s3-presigned-post - @blockfrost/blockfrost-js - @highlight-run/node - @huggingface/transformers - @jpg-store/lucid-cardano - @libsql/client - @mikro-orm/core - @mikro-orm/knex - @node-rs/argon2 - @node-rs/bcrypt - @prisma/client - @react-pdf/renderer - @sentry/profiling-node - @sparticuz/chromium - @sparticuz/chromium-min - @statsig/statsig-node-core - @swc/core - @xenova/transformers - argon2 - autoprefixer - aws-crt - bcrypt - better-sqlite3 - canvas - chromadb-default-embed - config - cpu-features - cypress - dd-trace - eslint - express - firebase-admin - htmlrewriter - import-in-the-middle - isolated-vm - jest - jsdom - keyv - libsql - mdx-bundler - mongodb - mongoose - newrelic - next-mdx-remote - next-seo - node-cron - node-pty - node-web-audio-api - onnxruntime-node - oslo - pg - playwright - playwright-core - postcss - prettier - prisma - puppeteer-core - puppeteer - ravendb - require-in-the-middle - rimraf - sharp - shiki - sqlite3 - ts-node - ts-morph - typescript - vscode-oniguruma - webpack - websocket - zeromq | Version | Changes | | --------- | -------------------------------------------------------------------------------------------------------------- | | v15.0.0 | Moved from experimental to stable. Renamed from serverComponentsExternalPackages to serverExternalPackages |",
    "excerpt": "Dependencies used inside Server Components and Route Handlers will automatically be bundled by Next.js. If a dependency is using Node.js specific features, you can choose to opt-out specific dependenc...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/serverExternalPackages"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-staleTimes",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\staleTimes.mdx",
    "title": "staleTimes",
    "description": "Learn how to override the invalidation time of the Client Router Cache.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 3,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  experimental: {\r\n    staleTimes: {\r\n      dynamic: 30,\r\n      static: 180,\r\n    },\r\n  },\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\""
      }
    ],
    "content": "staleTimes is an experimental feature that enables caching of page segments in the client-side router cache. You can enable this experimental feature and provide custom revalidation times by setting the experimental staleTimes flag: The static and dynamic properties correspond with the time period (in seconds) based on different types of link prefetching. - The dynamic property is used when the page is neither statically generated nor fully prefetched (e.g. with prefetch={true}). - Default: 0 seconds (not cached) - The static property is used for statically generated pages, or when the prefetch prop on Link is set to true, or when calling router.prefetch. - Default: 5 minutes > Good to know: > > - Loading boundaries are considered reusable for the static period defined in this configuration. > - This doesn't affect partial rendering, meaning shared layouts won't automatically be refetched on every navigation, only the page segment that changes. > - This doesn't change back/forward caching behavior to prevent layout shift and to prevent losing the browser scroll position. You can learn more about the Client Router Cache here. Version History | Version | Changes | | --------- | ---------------------------------------------------------- | | v15.0.0 | The dynamic staleTimes default changed from 30s to 0s. | | v14.2.0 | Experimental staleTimes introduced. |",
    "excerpt": "staleTimes is an experimental feature that enables caching of page segments in the client-side router cache. You can enable this experimental feature and provide custom revalidation times by setting t...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/staleTimes"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-staticGeneration",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\staticGeneration.mdx",
    "title": "staticGeneration*",
    "description": "Learn how to configure static generation in your Next.js application.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Config Options",
        "slug": "config-options"
      }
    ],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  experimental: {\r\n    staticGenerationRetryCount: 1,\r\n    staticGenerationMaxConcurrency: 8,\r\n    staticGenerationMinPagesPerWorker: 25,\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "const nextConfig = {\r\n  experimental: {\r\n    staticGenerationRetryCount: 1,\r\n    staticGenerationMaxConcurrency: 8,\r\n    staticGenerationMinPagesPerWorker: 25,\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.js\" switcher"
      }
    ],
    "content": "The staticGeneration options allow you to configure the Static Generation process for advanced use cases. Config Options The following options are available: - staticGenerationRetryCount: The number of times to retry a failed page generation before failing the build. - staticGenerationMaxConcurrency: The maximum number of pages to be processed per worker. - staticGenerationMinPagesPerWorker: The minimum number of pages to be processed before starting a new worker.",
    "excerpt": "The staticGeneration options allow you to configure the Static Generation process for advanced use cases. Config Options The following options are available: - staticGenerationRetryCount: The number o...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/staticGeneration"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-taint",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\taint.mdx",
    "title": "taint",
    "description": "Enable tainting Objects and Values.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Usage",
        "slug": "usage"
      },
      {
        "level": 2,
        "text": "Caveats",
        "slug": "caveats"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Tainting an object reference",
        "slug": "tainting-an-object-reference"
      },
      {
        "level": 3,
        "text": "Tainting a unique value",
        "slug": "tainting-a-unique-value"
      }
    ],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  experimental: {\r\n    taint: true,\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  experimental: {\r\n    taint: true,\r\n  },\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import { experimental_taintObjectReference } from 'react'\r\n\r\nfunction getUserDetails(id: string): UserDetails {\r\n  const user = await db.queryUserById(id)\r\n\r\n  experimental_taintObjectReference(\r\n    'Do not use the entire user info object. Instead, select only the fields you need.',\r\n    user\r\n  )\r\n\r\n  return user\r\n}",
        "context": "switcher"
      },
      {
        "language": "js",
        "code": "import { experimental_taintObjectReference } from 'react'\r\n\r\nfunction getUserDetails(id) {\r\n  const user = await db.queryUserById(id)\r\n\r\n  experimental_taintObjectReference(\r\n    'Do not use the entire user info object. Instead, select only the fields you need.',\r\n    user\r\n  )\r\n\r\n  return user\r\n}",
        "context": "switcher"
      },
      {
        "language": "tsx",
        "code": "export async function ContactPage({\r\n  params,\r\n}: {\r\n  params: Promise<{ id: string }>\r\n}) {\r\n  const { id } = await params\r\n  const userDetails = await getUserDetails(id)\r\n\r\n  return (\r\n    <UserCard\r\n      firstName={userDetails.firstName}\r\n      lastName={userDetails.lastName}\r\n    />\r\n  )\r\n}",
        "context": "filename=\"app/contact/page.tsx switcher"
      },
      {
        "language": "jsx",
        "code": "export async function ContactPage({ params }) {\r\n  const { id } = await params\r\n  const userDetails = await getUserDetails(id)\r\n\r\n  return (\r\n    <UserCard\r\n      firstName={userDetails.firstName}\r\n      lastName={userDetails.lastName}\r\n    />\r\n  )\r\n}",
        "context": "filename=\"app/contact/page.js switcher"
      },
      {
        "language": "tsx",
        "code": "export async function ContactPage({\r\n  params,\r\n}: {\r\n  params: Promise<{ id: string }>\r\n}) {\r\n  const userDetails = await getUserDetails(id)\r\n\r\n  // Throws an error\r\n  return <UserCard user={userDetails} />\r\n}",
        "context": "switcher"
      },
      {
        "language": "jsx",
        "code": "export async function ContactPage({ params }) {\r\n  const { id } = await params\r\n  const userDetails = await getUserDetails(id)\r\n\r\n  // Throws an error\r\n  return <UserCard user={userDetails} />\r\n}",
        "context": "switcher"
      },
      {
        "language": "ts",
        "code": "import { experimental_taintUniqueValue } from 'react'\r\n\r\nfunction getSystemConfig(): SystemConfig {\r\n  const config = await config.getConfigDetails()\r\n\r\n  experimental_taintUniqueValue(\r\n    'Do not pass configuration tokens to the client',\r\n    config,\r\n    config.SERVICE_API_KEY\r\n  )\r\n\r\n  return config\r\n}",
        "context": "switcher"
      },
      {
        "language": "js",
        "code": "import { experimental_taintUniqueValue } from 'react'\r\n\r\nfunction getSystemConfig() {\r\n  const config = await config.getConfigDetails()\r\n\r\n  experimental_taintUniqueValue(\r\n    'Do not pass configuration tokens to the client',\r\n    config,\r\n    config.SERVICE_API_KEY\r\n  )\r\n\r\n  return config\r\n}",
        "context": "switcher"
      },
      {
        "language": "tsx",
        "code": "export async function Dashboard() {\r\n  const systemConfig = await getSystemConfig()\r\n\r\n  return <ClientDashboard version={systemConfig.SERVICE_API_VERSION} />\r\n}",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "export async function Dashboard() {\r\n  const systemConfig = await getSystemConfig()\r\n  // Someone makes a mistake in a PR\r\n  const version = systemConfig.SERVICE_API_KEY\r\n\r\n  return <ClientDashboard version={version} />\r\n}",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "export async function Dashboard() {\r\n  const systemConfig = await getSystemConfig()\r\n  // Someone makes a mistake in a PR\r\n  const version = `version::${systemConfig.SERVICE_API_KEY}`\r\n\r\n  return <ClientDashboard version={version} />\r\n}",
        "context": ""
      }
    ],
    "content": "Usage The taint option enables support for experimental React APIs for tainting objects and values. This feature helps prevent sensitive data from being accidentally passed to the client. When enabled, you can use: - experimentaltaintObjectReference taint objects references. - experimentaltaintUniqueValue to taint unique values. > Good to know: Activating this flag also enables the React experimental channel for app directory. > Warning: Do not rely on the taint API as your only mechanism to prevent exposing sensitive data to the client. See our security recommendations. The taint APIs allows you to be defensive, by declaratively and explicitly marking data that is not allowed to pass through the Server-Client boundary. When an object or value, is passed through the Server-Client boundary, React throws an error. This is helpful for cases where: - The methods to read data are out of your control - You have to work with sensitive data shapes not defined by you - Sensitive data is accessed during Server Component rendering It is recommended to model your data and APIs so that sensitive data is not returned to contexts where it is not needed. Caveats - Tainting can only keep track of objects by reference. Copying an object creates an untainted version, which loses all guarantees given by the API. You'll need to taint the copy. - Tainting cannot keep track of data derived from a tainted value. You also need to taint the derived value. - Values are tainted for as long as their lifetime reference is within scope. See the experimentaltaintUniqueValue parameters reference, for more information. Examples Tainting an object reference In this case, the getUserDetails function returns data about a given user. We taint the user object reference, so that it cannot cross a Server-Client boundary. For example, assuming UserCard is a Client Component. We can still access individual fields from the tainted userDetails object. Now, passing the entire object to the Client Component will throw an error. Tainting a unique value In this case, we can access the server configuration by awaiting calls to config.getConfigDetails. However, the system configuration contains the SERVICEAPIKEY that we don't want to expose to clients. We can taint the config.SERVICEAPIKEY value. We can still access other properties of the systemConfig object. However, passing SERVICEAPIKEY to ClientDashboard throws an error. Note that, even though, systemConfig.SERVICEAPIKEY is reassigned to a new variable. Passing it to a Client Component still throws an error. Whereas, a value derived from a tainted unique value, will be exposed to the client. A better approach is to remove SERVICEAPIKEY from the data returned by getSystemConfig.",
    "excerpt": "Usage The taint option enables support for experimental React APIs for tainting objects and values. This feature helps prevent sensitive data from being accidentally passed to the client. When enabled...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/taint"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-trailingSlash",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\trailingSlash.mdx",
    "title": "trailingSlash",
    "description": "Configure Next.js pages to resolve with or without a trailing slash.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "js",
        "code": "module.exports = {\r\n  trailingSlash: true,\r\n}",
        "context": "filename=\"next.config.js\""
      }
    ],
    "content": "By default Next.js will redirect URLs with trailing slashes to their counterpart without a trailing slash. For example /about/ will redirect to /about. You can configure this behavior to act the opposite way, where URLs without trailing slashes are redirected to their counterparts with trailing slashes. Open next.config.js and add the trailingSlash config: With this option set, URLs like /about will redirect to /about/. When using trailingSlash: true, certain URLs are exceptions and will not have a trailing slash appended: - Static file URLs, such as files with extensions. - Any paths under .well-known/. For example, the following URLs will remain unchanged: /file.txt, images/photos/picture.png, and .well-known/subfolder/config.json. When used with output: \"export\" configuration, the /about page will output /about/index.html (instead of the default /about.html). Version History | Version | Changes | | -------- | ---------------------- | | v9.5.0 | trailingSlash added. |",
    "excerpt": "By default Next.js will redirect URLs with trailing slashes to their counterpart without a trailing slash. For example /about/ will redirect to /about. You can configure this behavior to act the oppos...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/trailingSlash"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-transpilePackages",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\transpilePackages.mdx",
    "title": "transpilePackages",
    "description": "Automatically transpile and bundle dependencies from local packages (like monorepos) or from external dependencies (`node_modules`).",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  transpilePackages: ['package-name'],\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\""
      }
    ],
    "content": "Next.js can automatically transpile and bundle dependencies from local packages (like monorepos) or from external dependencies (nodemodules). This replaces the next-transpile-modules package. Version History | Version | Changes | | --------- | -------------------------- | | v13.0.0 | transpilePackages added. |",
    "excerpt": "Next.js can automatically transpile and bundle dependencies from local packages (like monorepos) or from external dependencies (nodemodules). This replaces the next-transpile-modules package. Version...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/transpilePackages"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-turbopack",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\turbopack.mdx",
    "title": "turbopack",
    "description": "Configure Next.js with Turbopack-specific options",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Reference",
        "slug": "reference"
      },
      {
        "level": 3,
        "text": "Options",
        "slug": "options"
      },
      {
        "level": 3,
        "text": "Supported loaders",
        "slug": "supported-loaders"
      },
      {
        "level": 4,
        "text": "Missing Webpack loader features",
        "slug": "missing-webpack-loader-features"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Root directory",
        "slug": "root-directory"
      },
      {
        "level": 3,
        "text": "Configuring webpack loaders",
        "slug": "configuring-webpack-loaders"
      },
      {
        "level": 3,
        "text": "Advanced webpack loader conditions",
        "slug": "advanced-webpack-loader-conditions"
      },
      {
        "level": 3,
        "text": "Resolving aliases",
        "slug": "resolving-aliases"
      },
      {
        "level": 3,
        "text": "Resolving custom extensions",
        "slug": "resolving-custom-extensions"
      },
      {
        "level": 3,
        "text": "Debug IDs",
        "slug": "debug-ids"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  turbopack: {\r\n    // ...\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  turbopack: {\r\n    // ...\r\n  },\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\" switcher"
      },
      {
        "language": "js",
        "code": "const path = require('path')\r\nmodule.exports = {\r\n  turbopack: {\r\n    root: path.join(__dirname, '..'),\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  turbopack: {\r\n    rules: {\r\n      '*.svg': {\r\n        loaders: ['@svgr/webpack'],\r\n        as: '*.js',\r\n      },\r\n    },\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  turbopack: {\r\n    rules: {\r\n      '*.svg': {\r\n        loaders: [\r\n          {\r\n            loader: '@svgr/webpack',\r\n            options: {\r\n              icon: true,\r\n            },\r\n          },\r\n        ],\r\n        as: '*.js',\r\n      },\r\n    },\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  turbopack: {\r\n    rules: {\r\n      // '*' will match all file paths, but we restrict where our\r\n      // rule runs with a condition.\r\n      '*': {\r\n        condition: {\r\n          all: [\r\n            // 'foreign' is a built-in condition.\r\n            { not: 'foreign' },\r\n            // 'path' can be a RegExp or a glob string. A RegExp matches\r\n            // anywhere in the full project-relative file path.\r\n            { path: /^img\\/[0-9]{3}\\// },\r\n            {\r\n              any: [\r\n                { path: '*.svg' },\r\n                // 'content' is always a RegExp, and can match\r\n                // anywhere in the file.\r\n                { content: /\\<svg\\W/ },\r\n              ],\r\n            },\r\n          ],\r\n        },\r\n        loaders: ['@svgr/webpack'],\r\n        as: '*.js',\r\n      },\r\n    },\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  turbopack: {\r\n    rules: {\r\n      '*.svg': [\r\n        {\r\n          condition: 'browser',\r\n          loaders: ['@svgr/webpack'],\r\n          as: '*.js',\r\n        },\r\n        {\r\n          condition: { not: 'browser' },\r\n          loaders: [require.resolve('./custom-svg-loader.js')],\r\n          as: '*.js',\r\n        },\r\n      ],\r\n    },\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  turbopack: {\r\n    resolveAlias: {\r\n      underscore: 'lodash',\r\n      mocha: { browser: 'mocha/browser-entry.js' },\r\n    },\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  turbopack: {\r\n    resolveExtensions: ['.mdx', '.tsx', '.ts', '.jsx', '.js', '.mjs', '.json'],\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  turbopack: {\r\n    debugIds: true,\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      }
    ],
    "content": "The turbopack option lets you customize Turbopack to transform different files and change how modules are resolved. > Good to know: The turbopack option was previously named experimental.turbo in Next.js versions 13.0.0 to 15.2.x. The experimental.turbo option will be removed in Next.js 16. > > If you are using an older version of Next.js, run npx @next/codemod@latest next-experimental-turbo-to-turbopack . to automatically migrate your configuration. > Good to know: > > - Turbopack for Next.js does not require loaders or loader configuration for built-in functionality. Turbopack has built-in support for CSS and compiling modern JavaScript, so there's no need for css-loader, postcss-loader, or babel-loader if you're using @babel/preset-env. Reference Options The following options are available for the turbopack configuration: | Option | Description | | ------------------- | ---------------------------------------------------------------------------------------------------------------------------------------- | | root | Sets the application root directory. Should be an absolute path. | | rules | List of supported webpack loaders to apply when running with Turbopack. | | resolveAlias | Map aliased imports to modules to load in their place. | | resolveExtensions | List of extensions to resolve when importing files. | | debugIds | Enable generation of debug IDs in JavaScript bundles and source maps. | Supported loaders The following loaders have been tested to work with Turbopack's webpack loader implementation, but many other webpack loaders should work as well even if not listed here: - babel-loader (Configured automatically if a Babel configuration file is found) - @svgr/webpack - svg-inline-loader - yaml-loader - string-replace-loader - raw-loader - sass-loader (Configured automatically) - graphql-tag/loader Missing Webpack loader features Turbopack uses the loader-runner library to execute webpack loaders, which provides most of the standard loader API. However, some features are not supported: Module loading: - importModule - No support - loadModule - No support File system and output: - fs - Partial support: only fs.readFile is currently implemented. - emitFile - No support Context properties: - version - No support - mode - No support - target - No support Utilities: - utils - No support - resolve - No support (use getResolve instead) If you have a loader that is critically dependent upon one of these features please file an issue. Examples Root directory Turbopack uses the root directory to resolve modules. Files outside of the project root are not resolved. Next.js automatically detects the root directory of your project. It does so by looking for one of these files: - pnpm-lock.yaml - package-lock.json - yarn.lock - bun.lock - bun.lockb If you have a different project structure, for example if you don't use workspaces, you can manually set the root option: Configuring webpack loaders If you need loader support beyond what's built in, many webpack loaders already work with Turbopack. There are currently some limitations: - Only a core subset of the webpack loader API is implemented. Currently, there is enough coverage for some popular loaders, and we'll expand our API support in the future. - Only loaders that return JavaScript code are supported. Loaders that transform files like stylesheets or images are not currently supported. - Options passed to webpack loaders must be plain JavaScript primitives, objects, and arrays. For example, it's not possible to pass require() plugin modules as option values. To configure loaders, add the names of the loaders you've installed and any options in next.config.js, mapping file extensions to a list of loaders. Rules are evaluated in order. Here is an example below using the @svgr/webpack loader, which enables importing .svg files and rendering them as React components. > Good to know: Globs used in the rules object match based on file name, unless the glob contains a / character, which will cause it to match based on the full project-relative file path. Windows file paths are normalized to use unix-style / path separators. > > Turbopack uses a modified version of the Rust globset library. For loaders that require configuration options, you can use an object format instead of a string: > Good to know: Prior to Next.js version 13.4.4, turbopack.rules was named turbo.loaders and only accepted file extensions like .mdx instead of .mdx. Advanced webpack loader conditions You can further restrict where a loader runs using the advanced condition syntax: - Supported boolean operators are {all: [...]}, {any: [...]} and {not: ...}. - Supported customizable operators are {path: string | RegExp} and {content: RegExp}. If path and content are specified in the same object, it acts as an implicit and. In addition, a number of built-in conditions are supported: - browser: Matches code that will execute on the client. Server code can be matched using {not: 'browser'}. - foreign: Matches code in nodemodules, as well as some Next.js internals. Usually you'll want to restrict loaders to {not: 'foreign'}. This can improve performance by reducing the number of files the loader is invoked on. - development: Matches when using next dev. - production: Matches when using next build. - node: Matches code that will run on the default Node.js runtime. - edge-light: Matches code that will run on the Edge runtime. Rules can be an object or an array of objects. An array is often useful for modeling disjoint conditions: > Good to know: All matching rules are executed in order. Resolving aliases Turbopack can be configured to modify module resolution through aliases, similar to webpack's resolve.alias configuration. To configure resolve aliases, map imported patterns to their new destination in next.config.js: This aliases imports of the underscore package to the lodash package. In other words, import underscore from 'underscore' will load the lodash module instead of underscore. Turbopack also supports conditional aliasing through this field, similar to Node.js' conditional exports. At the moment only the browser condition is supported. In the case above, imports of the mocha module will be aliased to mocha/browser-entry.js when Turbopack targets browser environments. Resolving custom extensions Turbopack can be configured to resolve modules with custom extensions, similar to webpack's resolve.extensions configuration. To configure resolve extensions, use the resolveExtensions field in next.config.js: This overwrites the original resolve extensions with the provided list. Make sure to include the default extensions. For more information and guidance for how to migrate your app to Turbopack from webpack, see Turbopack's documentation on webpack compatibility. Debug IDs Turbopack can be configured to generate debug IDs in JavaScript bundles and source maps. To configure debug IDs, use the debugIds field in next.config.js: The option automatically adds a polyfill for debug IDs to the JavaScript bundle to ensure compatibility. The debug IDs are available in the globalThis.debugIds global variable. Version History | Version | Changes | | -------- | ----------------------------------------------- | | 16.0.0 | turbopack.debugIds was added. | | 16.0.0 | turbopack.rules..condition was added. | | 15.3.0 | experimental.turbo is changed to turbopack. | | 13.0.0 | experimental.turbo introduced. |",
    "excerpt": "The turbopack option lets you customize Turbopack to transform different files and change how modules are resolved. > Good to know: The turbopack option was previously named experimental.turbo in Next...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/turbopack"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-turbopackFileSystemCache",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\turbopackFileSystemCache.mdx",
    "title": "Turbopack FileSystem Caching",
    "description": "Learn how to enable FileSystem Caching for Turbopack builds",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Usage",
        "slug": "usage"
      },
      {
        "level": 2,
        "text": "Version Changes",
        "slug": "version-changes"
      }
    ],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  experimental: {\r\n    // Enable filesystem caching for `next dev`\r\n    turbopackFileSystemCacheForDev: true,\r\n    // Enable filesystem caching for `next build`\r\n    turbopackFileSystemCacheForBuild: true,\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  experimental: {\r\n    // Enable filesystem caching for `next dev`\r\n    turbopackFileSystemCacheForDev: true,\r\n    // Enable filesystem caching for `next build`\r\n    turbopackFileSystemCacheForBuild: true,\r\n  },\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\" switcher"
      }
    ],
    "content": "Usage Turbopack FileSystem Cache enables Turbopack to reduce work across next dev or next build commands. When enabled, Turbopack will save and restore data to the .next folder between builds, which can greatly speed up subsequent builds and dev sessions. > Good to know: The FileSystem Cache feature is Beta and is still under development. Users adopting should expect some stability issues. We recommend first adopting it for development. Version Changes | Version | Changes | | --------- | -------------------------------------------------------------- | | v16.0.0 | Beta release with separate flags for build and dev | | v15.5.0 | Persistent caching released as experimental on canary releases |",
    "excerpt": "Usage Turbopack FileSystem Cache enables Turbopack to reduce work across next dev or next build commands. When enabled, Turbopack will save and restore data to the .next folder between builds, which c...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/turbopackFileSystemCache"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-typedRoutes",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\typedRoutes.mdx",
    "title": "typedRoutes",
    "description": "Enable support for statically typed links.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  typedRoutes: true,\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\""
      }
    ],
    "content": "> Note: This option has been marked as stable, so you should use typedRoutes instead of experimental.typedRoutes. Support for statically typed links. This feature requires using TypeScript in your project.",
    "excerpt": "> Note: This option has been marked as stable, so you should use typedRoutes instead of experimental.typedRoutes. Support for statically typed links. This feature requires using TypeScript in your pro...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/typedRoutes"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-typescript",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\typescript.mdx",
    "title": "typescript",
    "description": "Next.js reports TypeScript errors by default. Learn to opt-out of this behavior here.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [
      {
        "language": "js",
        "code": "module.exports = {\r\n  typescript: {\r\n    // !! WARN !!\r\n    // Dangerously allow production builds to successfully complete even if\r\n    // your project has type errors.\r\n    // !! WARN !!\r\n    ignoreBuildErrors: true,\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      }
    ],
    "content": "Next.js fails your production build (next build) when TypeScript errors are present in your project. If you'd like Next.js to dangerously produce production code even when your application has errors, you can disable the built-in type checking step. If disabled, be sure you are running type checks as part of your build or deploy process, otherwise this can be very dangerous. Open next.config.js and enable the ignoreBuildErrors option in the typescript config:",
    "excerpt": "Next.js fails your production build (next build) when TypeScript errors are present in your project. If you'd like Next.js to dangerously produce production code even when your application has errors,...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/typescript"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-urlImports",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\urlImports.mdx",
    "title": "urlImports",
    "description": "Configure Next.js to allow importing modules from external URLs.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Security Model",
        "slug": "security-model"
      },
      {
        "level": 2,
        "text": "Lockfile",
        "slug": "lockfile"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Skypack",
        "slug": "skypack"
      },
      {
        "level": 3,
        "text": "Static Image Imports",
        "slug": "static-image-imports"
      },
      {
        "level": 3,
        "text": "URLs in CSS",
        "slug": "urls-in-css"
      },
      {
        "level": 3,
        "text": "Asset Imports",
        "slug": "asset-imports"
      }
    ],
    "codeBlocks": [
      {
        "language": "js",
        "code": "module.exports = {\r\n  experimental: {\r\n    urlImports: ['https://example.com/assets/', 'https://cdn.skypack.dev'],\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "import { a, b, c } from 'https://example.com/assets/some/module.js'",
        "context": ""
      },
      {
        "language": "js",
        "code": "import confetti from 'https://cdn.skypack.dev/canvas-confetti'\r\nimport { useEffect } from 'react'\r\n\r\nexport default () => {\r\n  useEffect(() => {\r\n    confetti()\r\n  })\r\n  return <p>Hello</p>\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "import Image from 'next/image'\r\nimport logo from 'https://example.com/assets/logo.png'\r\n\r\nexport default () => (\r\n  <div>\r\n    <Image src={logo} placeholder=\"blur\" />\r\n  </div>\r\n)",
        "context": ""
      },
      {
        "language": "css",
        "code": ".className {\r\n  background: url('https://example.com/assets/hero.jpg');\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "const logo = new URL('https://example.com/assets/file.txt', import.meta.url)\r\n\r\nconsole.log(logo.pathname)\r\n\r\n// prints \"/_next/static/media/file.a9727b5d.txt\"",
        "context": ""
      }
    ],
    "content": "URL imports are an experimental feature that allows you to import modules directly from external servers (instead of from the local disk). > Warning: Only use domains that you trust to download and execute on your machine. Please exercise discretion, and caution until the feature is flagged as stable. To opt-in, add the allowed URL prefixes inside next.config.js: Then, you can import modules directly from URLs: URL Imports can be used everywhere normal package imports can be used. Security Model This feature is being designed with security as the top priority. To start, we added an experimental flag forcing you to explicitly allow the domains you accept URL imports from. We're working to take this further by limiting URL imports to execute in the browser sandbox using the Edge Runtime. Lockfile When using URL imports, Next.js will create a next.lock directory containing a lockfile and fetched assets. This directory must be committed to Git, not ignored by .gitignore. - When running next dev, Next.js will download and add all newly discovered URL Imports to your lockfile. - When running next build, Next.js will use only the lockfile to build the application for production. Typically, no network requests are needed and any outdated lockfile will cause the build to fail. One exception is resources that respond with Cache-Control: no-cache. These resources will have a no-cache entry in the lockfile and will always be fetched from the network on each build. Examples Skypack Static Image Imports URLs in CSS Asset Imports",
    "excerpt": "URL imports are an experimental feature that allows you to import modules directly from external servers (instead of from the local disk). > Warning: Only use domains that you trust to download and ex...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/urlImports"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-useLightningcss",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\useLightningcss.mdx",
    "title": "useLightningcss",
    "description": "Enable experimental support for Lightning CSS.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  experimental: {\r\n    useLightningcss: false, // default, ignored on Turbopack\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\" switcher"
      },
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  experimental: {\r\n    useLightningcss: true, // disables PostCSS on webpack\r\n  },\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\" switcher"
      }
    ],
    "content": "Experimental support for using Lightning CSS with webpack. Lightning CSS is a fast CSS transformer and minifier, written in Rust. If this option is not set, Next.js on webpack uses PostCSS with postcss-preset-env by default. Turbopack uses Lightning CSS by default since Next 14.2. This configuration option has no effect on Turbopack. Turbopack always uses Lightning CSS. Version History | Version | Changes | | -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | 15.1.0 | Support for useSwcCss was removed from Turbopack. | | 14.2.0 | Turbopack's default CSS processor was changed from @swc/css to Lightning CSS. useLightningcss became ignored on Turbopack, and a legacy experimental.turbo.useSwcCss option was added. |",
    "excerpt": "Experimental support for using Lightning CSS with webpack. Lightning CSS is a fast CSS transformer and minifier, written in Rust. If this option is not set, Next.js on webpack uses PostCSS with postcs...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/useLightningcss"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-viewTransition",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\viewTransition.mdx",
    "title": "viewTransition",
    "description": "Enable ViewTransition API from React in App Router",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Usage",
        "slug": "usage"
      },
      {
        "level": 3,
        "text": "Live Demo",
        "slug": "live-demo"
      }
    ],
    "codeBlocks": [
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  experimental: {\r\n    viewTransition: true,\r\n  },\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "jsx",
        "code": "import { ViewTransition } from 'react'",
        "context": ""
      }
    ],
    "content": "viewTransition is an experimental flag that enables the new View Transitions API in React. This API allows you to leverage the native View Transitions browser API to create seamless transitions between UI states. To enable this feature, you need to set the viewTransition property to true in your next.config.js file. > Important Notice: The Component is already available in React's Canary release channel. > experimental.viewTransition is only required to enable deeper integration with Next.js features e.g. automatically > adding Transition types for navigations. Next.js specific transition types are not implemented yet. Usage You can import the Component from React in your application: Live Demo Check out our Next.js View Transition Demo to see this feature in action. As this API evolves, we will update our documentation and share more examples. However, for now, we strongly advise against using this feature in production.",
    "excerpt": "viewTransition is an experimental flag that enables the new View Transitions API in React. This API allows you to leverage the native View Transitions browser API to create seamless transitions betwee...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/viewTransition"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-webpack",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\webpack.mdx",
    "title": "Custom Webpack Config",
    "description": "Learn how to customize the webpack config used by Next.js",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [
      {
        "language": "js",
        "code": "module.exports = {\r\n  webpack: (\r\n    config,\r\n    { buildId, dev, isServer, defaultLoaders, nextRuntime, webpack }\r\n  ) => {\r\n    // Important: return the modified config\r\n    return config\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "// Example config for adding a loader that depends on babel-loader\r\n// This source was taken from the @next/mdx plugin source:\r\n// https://github.com/vercel/next.js/tree/canary/packages/next-mdx\r\nmodule.exports = {\r\n  webpack: (config, options) => {\r\n    config.module.rules.push({\r\n      test: /\\.mdx/,\r\n      use: [\r\n        options.defaultLoaders.babel,\r\n        {\r\n          loader: '@mdx-js/loader',\r\n          options: pluginOptions.options,\r\n        },\r\n      ],\r\n    })\r\n\r\n    return config\r\n  },\r\n}",
        "context": ""
      }
    ],
    "content": "> Good to know: changes to webpack config are not covered by semver so proceed at your own risk Before continuing to add custom webpack configuration to your application make sure Next.js doesn't already support your use-case: - CSS imports - CSS modules - Sass/SCSS imports - Sass/SCSS modules - CSS imports - CSS modules - Sass/SCSS imports - Sass/SCSS modules - Customizing babel configuration Some commonly asked for features are available as plugins: - @next/mdx - @next/bundle-analyzer In order to extend our usage of webpack, you can define a function that extends its config inside next.config.js, like so: > The webpack function is executed three times, twice for the server (nodejs / edge runtime) and once for the client. This allows you to distinguish between client and server configuration using the isServer property. The second argument to the webpack function is an object with the following properties: - buildId: String - The build id, used as a unique identifier between builds. - dev: Boolean - Indicates if the compilation will be done in development. - isServer: Boolean - It's true for server-side compilation, and false for client-side compilation. - nextRuntime: String | undefined - The target runtime for server-side compilation; either \"edge\" or \"nodejs\", it's undefined for client-side compilation. - defaultLoaders: Object - Default loaders used internally by Next.js: - babel: Object - Default babel-loader configuration. Example usage of defaultLoaders.babel: nextRuntime Notice that isServer is true when nextRuntime is \"edge\" or \"nodejs\", nextRuntime \"edge\" is currently for proxy and Server Components in edge runtime only.",
    "excerpt": "> Good to know: changes to webpack config are not covered by semver so proceed at your own risk Before continuing to add custom webpack configuration to your application make sure Next.js doesn't alre...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/webpack"
  },
  {
    "id": "01-app-03-api-reference-05-config-01-next-config-js-webVitalsAttribution",
    "path": "01-app\\03-api-reference\\05-config\\01-next-config-js\\webVitalsAttribution.mdx",
    "title": "webVitalsAttribution",
    "description": "Learn how to use the webVitalsAttribution option to pinpoint the source of Web Vitals issues.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [
      {
        "language": "js",
        "code": "module.exports = {\r\n  experimental: {\r\n    webVitalsAttribution: ['CLS', 'LCP'],\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      }
    ],
    "content": "When debugging issues related to Web Vitals, it is often helpful if we can pinpoint the source of the problem. For example, in the case of Cumulative Layout Shift (CLS), we might want to know the first element that shifted when the single largest layout shift occurred. Or, in the case of Largest Contentful Paint (LCP), we might want to identify the element corresponding to the LCP for the page. If the LCP element is an image, knowing the URL of the image resource can help us locate the asset we need to optimize. Pinpointing the biggest contributor to the Web Vitals score, aka attribution, allows us to obtain more in-depth information like entries for PerformanceEventTiming, PerformanceNavigationTiming and PerformanceResourceTiming. Attribution is disabled by default in Next.js but can be enabled per metric by specifying the following in next.config.js. Valid attribution values are all web-vitals metrics specified in the NextWebVitalsMetric type.",
    "excerpt": "When debugging issues related to Web Vitals, it is often helpful if we can pinpoint the source of the problem. For example, in the case of Cumulative Layout Shift (CLS), we might want to know the firs...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/01-next-config-js/webVitalsAttribution"
  },
  {
    "id": "01-app-03-api-reference-05-config-02-typescript",
    "path": "01-app\\03-api-reference\\05-config\\02-typescript.mdx",
    "title": "TypeScript",
    "description": "Next.js provides a TypeScript-first development experience for building your React application.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "IDE Plugin",
        "slug": "ide-plugin"
      },
      {
        "level": 2,
        "text": "End-to-End Type Safety",
        "slug": "end-to-end-type-safety"
      },
      {
        "level": 2,
        "text": "Route-Aware Type Helpers",
        "slug": "route-aware-type-helpers"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Type Checking Next.js Configuration Files",
        "slug": "type-checking-nextjs-configuration-files"
      },
      {
        "level": 3,
        "text": "Using Node.js Native TypeScript Resolver for ",
        "slug": "using-nodejs-native-typescript-resolver-for-"
      },
      {
        "level": 4,
        "text": "For CommonJS Projects (Default)",
        "slug": "for-commonjs-projects-default"
      },
      {
        "level": 4,
        "text": "For ESM Projects",
        "slug": "for-esm-projects"
      },
      {
        "level": 3,
        "text": "Statically Typed Links",
        "slug": "statically-typed-links"
      },
      {
        "level": 3,
        "text": "Type IntelliSense for Environment Variables",
        "slug": "type-intellisense-for-environment-variables"
      },
      {
        "level": 3,
        "text": "With Async Server Components",
        "slug": "with-async-server-components"
      },
      {
        "level": 3,
        "text": "Static Generation and Server-side Rendering",
        "slug": "static-generation-and-server-side-rendering"
      },
      {
        "level": 3,
        "text": "With API Routes",
        "slug": "with-api-routes"
      },
      {
        "level": 3,
        "text": "With custom ",
        "slug": "with-custom-"
      },
      {
        "level": 3,
        "text": "Incremental type checking",
        "slug": "incremental-type-checking"
      },
      {
        "level": 3,
        "text": "Custom  path",
        "slug": "custom-path"
      },
      {
        "level": 3,
        "text": "Disabling TypeScript errors in production",
        "slug": "disabling-typescript-errors-in-production"
      },
      {
        "level": 3,
        "text": "Custom type declarations",
        "slug": "custom-type-declarations"
      },
      {
        "level": 2,
        "text": "Version Changes",
        "slug": "version-changes"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "async function getData() {\r\n  const res = await fetch('https://api.example.com/...')\r\n  // The return value is *not* serialized\r\n  // You can return Date, Map, Set, etc.\r\n  return res.json()\r\n}\r\n\r\nexport default async function Page() {\r\n  const name = await getData()\r\n\r\n  return '...'\r\n}",
        "context": "filename=\"app/page.tsx\" switcher"
      },
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  /* config options here */\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\""
      },
      {
        "language": "js",
        "code": "// @ts-check\r\n\r\n/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  /* config options here */\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "bash",
        "code": "NODE_OPTIONS=--experimental-transform-types next <command>",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\n// Top-level await and dynamic import are supported\r\nconst flags = await import('./flags.js').then((m) => m.default ?? m)\r\n\r\nconst nextConfig: NextConfig = {\r\n  /* config options here */\r\n  typedRoutes: Boolean(flags?.typedRoutes),\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.mts\""
      },
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  typedRoutes: true,\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\""
      },
      {
        "language": "json",
        "code": "{\r\n  \"include\": [\r\n    \"next-env.d.ts\",\r\n    \".next/types/**/*.ts\",\r\n    \"**/*.ts\",\r\n    \"**/*.tsx\"\r\n  ],\r\n  \"exclude\": [\"node_modules\"]\r\n}",
        "context": "filename=\"tsconfig.json\" highlight={4}"
      },
      {
        "language": "tsx",
        "code": "'use client'\r\n\r\nimport type { Route } from 'next'\r\nimport Link from 'next/link'\r\nimport { useRouter } from 'next/navigation'\r\n\r\nexport default function Example() {\r\n  const router = useRouter()\r\n  const slug = 'nextjs'\r\n\r\n  return (\r\n    <>\r\n      {/* Link: literal and dynamic */}\r\n      <Link href=\"/about\" />\r\n      <Link href={`/blog/${slug}`} />\r\n      <Link href={('/blog/' + slug) as Route} />\r\n      {/* TypeScript error if href is not a valid route */}\r\n      <Link href=\"/aboot\" />\r\n\r\n      {/* Router: literal and dynamic strings are validated */}\r\n      <button onClick={() => router.push('/about')}>Push About</button>\r\n      <button onClick={() => router.replace(`/blog/${slug}`)}>\r\n        Replace Blog\r\n      </button>\r\n      <button onClick={() => router.prefetch('/contact')}>\r\n        Prefetch Contact\r\n      </button>\r\n\r\n      {/* For non-literal strings, cast to Route */}\r\n      <button onClick={() => router.push(('/blog/' + slug) as Route)}>\r\n        Push Non-literal Blog\r\n      </button>\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"app/example-client.tsx\""
      },
      {
        "language": "ts",
        "code": "import { NextRequest, NextResponse } from 'next/server'\r\n\r\nexport function proxy(request: NextRequest) {\r\n  if (request.nextUrl.pathname === '/proxy-redirect') {\r\n    return NextResponse.redirect(new URL('/', request.url))\r\n  }\r\n\r\n  return NextResponse.next()\r\n}",
        "context": "filename=\"proxy.ts\""
      },
      {
        "language": "tsx",
        "code": "import type { Route } from 'next'\r\n\r\nexport default function Page() {\r\n  return <Link href={'/proxy-redirect' as Route}>Link Text</Link>\r\n}",
        "context": "filename=\"app/some/page.tsx\""
      },
      {
        "language": "tsx",
        "code": "import type { Route } from 'next'\r\nimport Link from 'next/link'\r\n\r\nfunction Card<T extends string>({ href }: { href: Route<T> | URL }) {\r\n  return (\r\n    <Link href={href}>\r\n      <div>My Card</div>\r\n    </Link>\r\n  )\r\n}",
        "context": ""
      },
      {
        "language": "ts",
        "code": "import type { Route } from 'next'\r\n\r\ntype NavItem<T extends string = string> = {\r\n  href: T\r\n  label: string\r\n}\r\n\r\nexport const navItems: NavItem<Route>[] = [\r\n  { href: '/', label: 'Home' },\r\n  { href: '/about', label: 'About' },\r\n  { href: '/blog', label: 'Blog' },\r\n]",
        "context": "filename=\"components/nav-items.ts\""
      },
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\nimport { navItems } from './nav-items'\r\n\r\nexport function Nav() {\r\n  return (\r\n    <nav>\r\n      {navItems.map((item) => (\r\n        <Link key={item.href} href={item.href}>\r\n          {item.label}\r\n        </Link>\r\n      ))}\r\n    </nav>\r\n  )\r\n}",
        "context": "filename=\"components/nav.tsx\""
      },
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  experimental: {\r\n    typedEnv: true,\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\""
      },
      {
        "language": "tsx",
        "code": "import type { GetStaticProps, GetStaticPaths, GetServerSideProps } from 'next'\r\n\r\nexport const getStaticProps = (async (context) => {\r\n  // ...\r\n}) satisfies GetStaticProps\r\n\r\nexport const getStaticPaths = (async () => {\r\n  // ...\r\n}) satisfies GetStaticPaths\r\n\r\nexport const getServerSideProps = (async (context) => {\r\n  // ...\r\n}) satisfies GetServerSideProps",
        "context": "filename=\"pages/blog/[slug].tsx\""
      },
      {
        "language": "ts",
        "code": "import type { NextApiRequest, NextApiResponse } from 'next'\r\n\r\nexport default function handler(req: NextApiRequest, res: NextApiResponse) {\r\n  res.status(200).json({ name: 'John Doe' })\r\n}",
        "context": "filename=\"pages/api/hello.ts\""
      },
      {
        "language": "ts",
        "code": "import type { NextApiRequest, NextApiResponse } from 'next'\r\n\r\ntype Data = {\r\n  name: string\r\n}\r\n\r\nexport default function handler(\r\n  req: NextApiRequest,\r\n  res: NextApiResponse<Data>\r\n) {\r\n  res.status(200).json({ name: 'John Doe' })\r\n}",
        "context": "filename=\"pages/api/hello.ts\""
      },
      {
        "language": "ts",
        "code": "import type { AppProps } from 'next/app'\r\n\r\nexport default function MyApp({ Component, pageProps }: AppProps) {\r\n  return <Component {...pageProps} />\r\n}",
        "context": ""
      },
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  typescript: {\r\n    tsconfigPath: 'tsconfig.build.json',\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\""
      },
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst isProd = process.env.NODE_ENV === 'production'\r\n\r\nconst nextConfig: NextConfig = {\r\n  typescript: {\r\n    tsconfigPath: isProd ? 'tsconfig.build.json' : 'tsconfig.json',\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\""
      },
      {
        "language": "json",
        "code": "{\r\n  \"extends\": \"./tsconfig.json\",\r\n  \"compilerOptions\": {\r\n    \"useUnknownInCatchVariables\": false\r\n  }\r\n}",
        "context": "filename=\"tsconfig.build.json\""
      },
      {
        "language": "ts",
        "code": "import type { NextConfig } from 'next'\r\n\r\nconst nextConfig: NextConfig = {\r\n  typescript: {\r\n    // !! WARN !!\r\n    // Dangerously allow production builds to successfully complete even if\r\n    // your project has type errors.\r\n    // !! WARN !!\r\n    ignoreBuildErrors: true,\r\n  },\r\n}\r\n\r\nexport default nextConfig",
        "context": "filename=\"next.config.ts\""
      },
      {
        "language": "json",
        "code": "{\r\n  \"compilerOptions\": {\r\n    \"skipLibCheck\": true\r\n    //...truncated...\r\n  },\r\n  \"include\": [\r\n    \"new-types.d.ts\",\r\n    \"next-env.d.ts\",\r\n    \".next/types/**/*.ts\",\r\n    \"**/*.ts\",\r\n    \"**/*.tsx\"\r\n  ],\r\n  \"exclude\": [\"node_modules\"]\r\n}",
        "context": "filename=\"tsconfig.json\""
      }
    ],
    "content": "Next.js comes with built-in TypeScript, automatically installing the necessary packages and configuring the proper settings when you create a new project with create-next-app. To add TypeScript to an existing project, rename a file to .ts / .tsx. Run next dev and next build to automatically install the necessary dependencies and add a tsconfig.json file with the recommended config options. > Good to know: If you already have a jsconfig.json file, copy the paths compiler option from the old jsconfig.json into the new tsconfig.json file, and delete the old jsconfig.json file. IDE Plugin Next.js includes a custom TypeScript plugin and type checker, which VSCode and other code editors can use for advanced type-checking and auto-completion. You can enable the plugin in VS Code by: 1. Opening the command palette (Ctrl/⌘ + Shift + P) 2. Searching for \"TypeScript: Select TypeScript Version\" 3. Selecting \"Use Workspace Version\" Now, when editing files, the custom plugin will be enabled. When running next build, the custom type checker will be used. The TypeScript plugin can help with: - Warning if the invalid values for segment config options are passed. - Showing available options and in-context documentation. - Ensuring the 'use client' directive is used correctly. - Ensuring client hooks (like useState) are only used in Client Components. > 🎥 Watch: Learn about the built-in TypeScript plugin → YouTube (3 minutes) End-to-End Type Safety The Next.js App Router has enhanced type safety. This includes: 1. No serialization of data between fetching function and page: You can fetch directly in components, layouts, and pages on the server. This data does not need to be serialized (converted to a string) to be passed to the client side for consumption in React. Instead, since app uses Server Components by default, we can use values like Date, Map, Set, and more without any extra steps. Previously, you needed to manually type the boundary between server and client with Next.js-specific types. 2. Streamlined data flow between components: With the removal of app in favor of root layouts, it is now easier to visualize the data flow between components and pages. Previously, data flowing between individual pages and app were difficult to type and could introduce confusing bugs. With colocated data fetching in the App Router, this is no longer an issue. Data Fetching in Next.js now provides as close to end-to-end type safety as possible without being prescriptive about your database or content provider selection. We're able to type the response data as you would expect with normal TypeScript. For example: For complete end-to-end type safety, this also requires your database or content provider to support TypeScript. This could be through using an ORM or type-safe query builder. Route-Aware Type Helpers Next.js generates global helpers for App Router route types. These are available without imports and are generated during next dev, next build, or via next typegen: - PageProps - LayoutProps - RouteContext Examples Type Checking Next.js Configuration Files You can use TypeScript and import types in your Next.js configuration by using next.config.ts. Module resolution in next.config.ts is currently limited to CommonJS. However, ECMAScript Modules (ESM) syntax is available when using Node.js native TypeScript resolver for Node.js v22.10.0 and higher. When using the next.config.js file, you can add some type checking in your IDE using JSDoc as below: Using Node.js Native TypeScript Resolver for next.config.ts > Note: Available on Node.js v22.10.0+ and only when the feature is enabled. Next.js does not enable it. Next.js detects the Node.js native TypeScript resolver via process.features.typescript, added in v22.10.0. When present, next.config.ts can use native ESM, including top‑level await and dynamic import(). This mechanism inherits the capabilities and limitations of Node's resolver. In Node.js versions v22.18.0+, process.features.typescript is enabled by default. For versions between v22.10.0 and 22.17.x, opt in with NODEOPTIONS=--experimental-transform-types: For CommonJS Projects (Default) Although next.config.ts supports native ESM syntax on CommonJS projects, Node.js will still assume next.config.ts is a CommonJS file by default, resulting in Node.js reparsing the file as ESM when module syntax is detected. Therefore, we recommend using the next.config.mts file for CommonJS projects to explicitly indicate it's an ESM module: For ESM Projects When \"type\" is set to \"module\" in package.json, your project uses ESM. Learn more about this setting in the Node.js docs. In this case, you can write next.config.ts directly with ESM syntax. > Good to know: When using \"type\": \"module\" in your package.json, all .js and .ts files in your project are treated as ESM modules by default. You may need to rename files with CommonJS syntax to .cjs or .cts extensions if needed. Statically Typed Links Next.js can statically type links to prevent typos and other errors when using next/link, improving type safety when navigating between pages. Works in both the Pages and App Router for the href prop in next/link. In the App Router, it also types next/navigation methods like push, replace, and prefetch. It does not type next/router methods in Pages Router. Literal href strings are validated, while non-literal hrefs may require a cast with as Route. To opt-into this feature, typedRoutes need to be enabled and the project needs to be using TypeScript. Next.js will generate a link definition in .next/types that contains information about all existing routes in your application, which TypeScript can then use to provide feedback in your editor about invalid links. > Good to know: If you set up your project without create-next-app, ensure the generated Next.js types are included by adding .next/types//.ts to the include array in your tsconfig.json: Currently, support includes any string literal, including dynamic segments. For non-literal strings, you need to manually cast with as Route. The example below shows both next/link and next/navigation usage: The same applies for redirecting routes defined by proxy: To accept href in a custom component wrapping next/link, use a generic: You can also type a simple data structure and iterate to render links: Then, map over the items to render Links: > How does it work? > > When running next dev or next build, Next.js generates a hidden .d.ts file inside .next that contains information about all existing routes in your application (all valid routes as the href type of Link). This .d.ts file is included in tsconfig.json and the TypeScript compiler will check that .d.ts and provide feedback in your editor about invalid links. Type IntelliSense for Environment Variables During development, Next.js generates a .d.ts file in .next/types that contains information about the loaded environment variables for your editor's IntelliSense. If the same environment variable key is defined in multiple files, it is deduplicated according to the Environment Variable Load Order. To opt-into this feature, experimental.typedEnv needs to be enabled and the project needs to be using TypeScript. > Good to know: Types are generated based on the environment variables loaded at development runtime, which excludes variables from .env.production files by default. To include production-specific variables, run next dev with NODEENV=production. With Async Server Components To use an async Server Component with TypeScript, ensure you are using TypeScript 5.1.3 or higher and @types/react 18.2.8 or higher. If you are using an older version of TypeScript, you may see a 'Promise' is not a valid JSX element type error. Updating to the latest version of TypeScript and @types/react should resolve this issue. Static Generation and Server-side Rendering For getStaticProps, getStaticPaths, and getServerSideProps, you can use the GetStaticProps, GetStaticPaths, and GetServerSideProps types respectively: > Good to know: satisfies was added to TypeScript in 4.9. We recommend upgrading to the latest version of TypeScript. With API Routes The following is an example of how to use the built-in types for API routes: You can also type the response data: With custom App If you have a custom App, you can use the built-in type AppProps and change file name to ./pages/app.tsx like so: Incremental type checking Since v10.2.1 Next.js supports incremental type checking when enabled in your tsconfig.json, this can help speed up type checking in larger applications. Custom tsconfig path In some cases, you might want to use a different TypeScript configuration for builds or tooling. To do that, set typescript.tsconfigPath in next.config.ts to point Next.js to another tsconfig file. For example, switch to a different config for production builds: Why you might use a separate tsconfig for builds You might need to relax checks in scenarios like monorepos, where the build also validates shared dependencies that don't match your project's standards, or when loosening checks in CI to continue delivering while migrating locally to stricter TypeScript settings (and still wanting your IDE to highlight misuse). For example, if your project uses useUnknownInCatchVariables but some monorepo dependencies still assume any: This keeps your editor strict via tsconfig.json while allowing the production build to use relaxed settings. > Good to know: > > - IDEs typically read tsconfig.json for diagnostics and IntelliSense, so you can still see IDE warnings while production builds use the alternate config. Mirror critical options if you want parity in the editor. > - In development, only tsconfig.json is watched for changes. If you edit a different file name via typescript.tsconfigPath, restart the dev server to apply changes. > - The configured file is used in next dev, next build, and next typegen. Disabling TypeScript errors in production Next.js fails your production build (next build) when TypeScript errors are present in your project. If you'd like Next.js to dangerously produce production code even when your application has errors, you can disable the built-in type checking step. If disabled, be sure you are running type checks as part of your build or deploy process, otherwise this can be very dangerous. Open next.config.ts and enable the ignoreBuildErrors option in the typescript config: > Good to know: You can run tsc --noEmit to check for TypeScript errors yourself before building. This is useful for CI/CD pipelines where you'd like to check for TypeScript errors before deploying. Custom type declarations When you need to declare custom types, you might be tempted to modify next-env.d.ts. However, this file is automatically generated, so any changes you make will be overwritten. Instead, you should create a new file, let's call it new-types.d.ts, and reference it in your tsconfig.json: Version Changes | Version | Changes | | --------- | ------------------------------------------------------------------------------------------------------------------------------------ | | v15.0.0 | next.config.ts support added for TypeScript projects. | | v13.2.0 | Statically typed links are available in beta. | | v12.0.0 | SWC is now used by default to compile TypeScript and TSX for faster builds. | | v10.2.1 | Incremental type checking support added when enabled in your tsconfig.json. |",
    "excerpt": "Next.js comes with built-in TypeScript, automatically installing the necessary packages and configuring the proper settings when you create a new project with create-next-app. To add TypeScript to an...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/02-typescript"
  },
  {
    "id": "01-app-03-api-reference-05-config-03-eslint",
    "path": "01-app\\03-api-reference\\05-config\\03-eslint.mdx",
    "title": "ESLint Plugin",
    "description": "Learn how to use and configure the ESLint plugin to catch common issues and problems in a Next.js application.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Setup ESLint",
        "slug": "setup-eslint"
      },
      {
        "level": 2,
        "text": "Reference",
        "slug": "reference"
      },
      {
        "level": 3,
        "text": "Rules",
        "slug": "rules"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Specifying a root directory within a monorepo",
        "slug": "specifying-a-root-directory-within-a-monorepo"
      },
      {
        "level": 3,
        "text": "Disabling rules",
        "slug": "disabling-rules"
      },
      {
        "level": 3,
        "text": "With Core Web Vitals",
        "slug": "with-core-web-vitals"
      },
      {
        "level": 3,
        "text": "With TypeScript",
        "slug": "with-typescript"
      },
      {
        "level": 3,
        "text": "With Prettier",
        "slug": "with-prettier"
      },
      {
        "level": 3,
        "text": "Running lint on staged files",
        "slug": "running-lint-on-staged-files"
      },
      {
        "level": 3,
        "text": "Migrating existing config",
        "slug": "migrating-existing-config"
      },
      {
        "level": 4,
        "text": "Recommended plugin ruleset",
        "slug": "recommended-plugin-ruleset"
      },
      {
        "level": 4,
        "text": "Additional configurations",
        "slug": "additional-configurations"
      }
    ],
    "codeBlocks": [
      {
        "language": "bash",
        "code": "pnpm add -D eslint eslint-config-next",
        "context": "package=\"pnpm\""
      },
      {
        "language": "bash",
        "code": "npm i -D eslint eslint-config-next",
        "context": "package=\"npm\""
      },
      {
        "language": "bash",
        "code": "yarn add --dev eslint eslint-config-next",
        "context": "package=\"yarn\""
      },
      {
        "language": "bash",
        "code": "bun add -d eslint eslint-config-next",
        "context": "package=\"bun\""
      },
      {
        "language": "js",
        "code": "import { defineConfig, globalIgnores } from 'eslint/config'\r\nimport nextVitals from 'eslint-config-next/core-web-vitals'\r\n\r\nconst eslintConfig = defineConfig([\r\n  ...nextVitals,\r\n  // Override default ignores of eslint-config-next.\r\n  globalIgnores([\r\n    // Default ignores of eslint-config-next:\r\n    '.next/**',\r\n    'out/**',\r\n    'build/**',\r\n    'next-env.d.ts',\r\n  ]),\r\n])\r\n\r\nexport default eslintConfig",
        "context": "filename=\"eslint.config.mjs\""
      },
      {
        "language": "bash",
        "code": "pnpm exec eslint .",
        "context": "package=\"pnpm\""
      },
      {
        "language": "bash",
        "code": "npx eslint .",
        "context": "package=\"npm\""
      },
      {
        "language": "bash",
        "code": "yarn eslint .",
        "context": "package=\"yarn\""
      },
      {
        "language": "bash",
        "code": "bunx eslint .",
        "context": "package=\"bun\""
      },
      {
        "language": "js",
        "code": "import { defineConfig } from 'eslint/config'\r\nimport eslintNextPlugin from '@next/eslint-plugin-next'\r\n\r\nconst eslintConfig = defineConfig([\r\n  {\r\n    plugins: {\r\n      next: eslintNextPlugin,\r\n    },\r\n    settings: {\r\n      next: {\r\n        rootDir: 'packages/my-app/',\r\n      },\r\n    },\r\n    files: [\r\n      // ...files\r\n    ],\r\n    ignores: [\r\n      // ...ignores\r\n    ],\r\n  },\r\n])\r\n\r\nexport default eslintConfig",
        "context": "filename=\"eslint.config.mjs\""
      },
      {
        "language": "js",
        "code": "import { defineConfig, globalIgnores } from 'eslint/config'\r\nimport nextVitals from 'eslint-config-next/core-web-vitals'\r\n\r\nconst eslintConfig = defineConfig([\r\n  ...nextVitals,\r\n  {\r\n    rules: {\r\n      'react/no-unescaped-entities': 'off',\r\n      '@next/next/no-page-custom-font': 'off',\r\n    },\r\n  },\r\n  // Override default ignores of eslint-config-next.\r\n  globalIgnores([\r\n    // Default ignores of eslint-config-next:\r\n    '.next/**',\r\n    'out/**',\r\n    'build/**',\r\n    'next-env.d.ts',\r\n  ]),\r\n])\r\n\r\nexport default eslintConfig",
        "context": "filename=\"eslint.config.mjs\""
      },
      {
        "language": "js",
        "code": "import { defineConfig, globalIgnores } from 'eslint/config'\r\nimport nextVitals from 'eslint-config-next/core-web-vitals'\r\n\r\nconst eslintConfig = defineConfig([\r\n  ...nextVitals,\r\n  // Override default ignores of eslint-config-next.\r\n  globalIgnores([\r\n    // Default ignores of eslint-config-next:\r\n    '.next/**',\r\n    'out/**',\r\n    'build/**',\r\n    'next-env.d.ts',\r\n  ]),\r\n])\r\n\r\nexport default eslintConfig",
        "context": "filename=\"eslint.config.mjs\""
      },
      {
        "language": "js",
        "code": "import { defineConfig, globalIgnores } from 'eslint/config'\r\nimport nextVitals from 'eslint-config-next/core-web-vitals'\r\nimport nextTs from 'eslint-config-next/typescript'\r\n\r\nconst eslintConfig = defineConfig([\r\n  ...nextVitals,\r\n  ...nextTs,\r\n  // Override default ignores of eslint-config-next.\r\n  globalIgnores([\r\n    // Default ignores of eslint-config-next:\r\n    '.next/**',\r\n    'out/**',\r\n    'build/**',\r\n    'next-env.d.ts',\r\n  ]),\r\n])\r\n\r\nexport default eslintConfig",
        "context": "filename=\"eslint.config.mjs\""
      },
      {
        "language": "bash",
        "code": "pnpm add -D eslint-config-prettier",
        "context": "package=\"pnpm\""
      },
      {
        "language": "bash",
        "code": "npm i -D eslint-config-prettier",
        "context": "package=\"npm\""
      },
      {
        "language": "bash",
        "code": "yarn add --dev eslint-config-prettier",
        "context": "package=\"yarn\""
      },
      {
        "language": "bash",
        "code": "bun add -d eslint-config-prettier",
        "context": "package=\"bun\""
      },
      {
        "language": "js",
        "code": "import { defineConfig, globalIgnores } from 'eslint/config'\r\nimport nextVitals from 'eslint-config-next/core-web-vitals'\r\nimport prettier from 'eslint-config-prettier/flat'\r\n\r\nconst eslintConfig = defineConfig([\r\n  ...nextVitals,\r\n  prettier,\r\n  // Override default ignores of eslint-config-next.\r\n  globalIgnores([\r\n    // Default ignores of eslint-config-next:\r\n    '.next/**',\r\n    'out/**',\r\n    'build/**',\r\n    'next-env.d.ts',\r\n  ]),\r\n])\r\n\r\nexport default eslintConfig",
        "context": "filename=\"eslint.config.mjs\""
      },
      {
        "language": "js",
        "code": "const path = require('path')\r\n\r\nconst buildEslintCommand = (filenames) =>\r\n  `eslint --fix ${filenames\r\n    .map((f) => `\"${path.relative(process.cwd(), f)}\"`)\r\n    .join(' ')}`\r\n\r\nmodule.exports = {\r\n  '*.{js,jsx,ts,tsx}': [buildEslintCommand],\r\n}",
        "context": "filename=\".lintstagedrc.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  extends: [\r\n    //...\r\n    'plugin:@next/next/recommended',\r\n  ],\r\n}",
        "context": ""
      },
      {
        "language": "bash",
        "code": "pnpm add -D @next/eslint-plugin-next",
        "context": "package=\"pnpm\""
      },
      {
        "language": "bash",
        "code": "npm i -D @next/eslint-plugin-next",
        "context": "package=\"npm\""
      },
      {
        "language": "bash",
        "code": "yarn add --dev @next/eslint-plugin-next",
        "context": "package=\"yarn\""
      },
      {
        "language": "bash",
        "code": "bun add -d @next/eslint-plugin-next",
        "context": "package=\"bun\""
      },
      {
        "language": "js",
        "code": "import { defineConfig, globalIgnores } from 'eslint/config'\r\nimport nextPlugin from '@next/eslint-plugin-next'\r\n\r\nconst eslintConfig = defineConfig([\r\n  nextPlugin.configs['core-web-vitals'],\r\n  // List of ignore patterns.\r\n  globalIgnores([]),\r\n])\r\n\r\nexport default eslintConfig",
        "context": "filename=\"eslint.config.mjs\""
      }
    ],
    "content": "Next.js provides an ESLint plugin, @next/eslint-plugin-next, already bundled within the base configuration that makes it possible to catch common issues and problems in a Next.js application. Setup ESLint Get linting working quickly with the ESLint CLI (flat config): 1. Install ESLint and the Next.js config: 2. Create eslint.config.mjs with the Next.js config: 3. Run ESLint: Reference Recommended rule-sets from the following ESLint plugins are all used within eslint-config-next: - eslint-plugin-react - eslint-plugin-react-hooks - @next/eslint-plugin-next Rules The full set of rules is as follows: | Enabled in recommended config | Rule | Description | | :---------------------------: | ------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------- | | | @next/next/google-font-display | Enforce font-display behavior with Google Fonts. | | | @next/next/google-font-preconnect | Ensure preconnect is used with Google Fonts. | | | @next/next/inline-script-id | Enforce id attribute on next/script components with inline content. | | | @next/next/next-script-for-ga | Prefer next/script component when using the inline script for Google Analytics. | | | @next/next/no-assign-module-variable | Prevent assignment to the module variable. | | | @next/next/no-async-client-component | Prevent Client Components from being async functions. | | | @next/next/no-before-interactive-script-outside-document | Prevent usage of next/script's beforeInteractive strategy outside of pages/document.js. | | | @next/next/no-css-tags | Prevent manual stylesheet tags. | | | @next/next/no-document-import-in-page | Prevent importing next/document outside of pages/document.js. | | | @next/next/no-duplicate-head | Prevent duplicate usage of in pages/document.js. | | | @next/next/no-head-element | Prevent usage of element. | | | @next/next/no-head-import-in-document | Prevent usage of next/head in pages/document.js. | | | @next/next/no-html-link-for-pages | Prevent usage of elements to navigate to internal Next.js pages. | | | @next/next/no-img-element | Prevent usage of element due to slower LCP and higher bandwidth. | | | @next/next/no-page-custom-font | Prevent page-only custom fonts. | | | @next/next/no-script-component-in-head | Prevent usage of next/script in next/head component. | | | @next/next/no-styled-jsx-in-document | Prevent usage of styled-jsx in pages/document.js. | | | @next/next/no-sync-scripts | Prevent synchronous scripts. | | | @next/next/no-title-in-document-head | Prevent usage of with Head component from next/document. | | | @next/next/no-typos | Prevent common typos in Next.js's data fetching functions | | | @next/next/no-unwanted-polyfillio | Prevent duplicate polyfills from Polyfill.io. | We recommend using an appropriate integration to view warnings and errors directly in your code editor during development. next lint removal Starting with Next.js 16, next lint is removed. As part of the removal, the eslint option in your Next config file is no longer needed and can be safely removed. Examples Specifying a root directory within a monorepo If you're using @next/eslint-plugin-next in a project where Next.js isn't installed in your root directory (such as a monorepo), you can tell @next/eslint-plugin-next where to find your Next.js application using the settings property in your eslint.config.mjs: rootDir can be a path (relative or absolute), a glob (i.e. \"packages//\"), or an array of paths and/or globs. Disabling rules If you would like to modify or disable any rules provided by the supported plugins (react, react-hooks, next), you can directly change them using the rules property in your eslint.config.mjs: With Core Web Vitals Enable the next/core-web-vitals rule set by extending it in your ESLint config. next/core-web-vitals updates @next/eslint-plugin-next to error on a number of rules that are warnings by default if they affect Core Web Vitals. > The next/core-web-vitals entry point is automatically included for new applications built with Create Next App. With TypeScript In addition to the Next.js ESLint rules, create-next-app --typescript will also add TypeScript-specific lint rules with next/typescript to your config: Those rules are based on plugin:@typescript-eslint/recommended. See typescript-eslint > Configs for more details. With Prettier ESLint also contains code formatting rules, which can conflict with your existing Prettier setup. We recommend including eslint-config-prettier in your ESLint config to make ESLint and Prettier work together. First, install the dependency: Then, add prettier to your existing ESLint config: Running lint on staged files If you would like to use ESLint with lint-staged to run the linter on staged git files, add the following to the .lintstagedrc.js file in the root of your project: Migrating existing config If you already have ESLint configured in your application, we recommend extending from this plugin directly instead of including eslint-config-next unless a few conditions are met. Recommended plugin ruleset If the following conditions are true: - You have one or more of the following plugins already installed (either separately or through a different config such as airbnb or react-app): - react - react-hooks - jsx-a11y - import - You've defined specific parserOptions that are different from how Babel is configured within Next.js (this is not recommended unless you have customized your Babel configuration) - You have eslint-plugin-import installed with Node.js and/or TypeScript resolvers defined to handle imports Then we recommend either removing these settings if you prefer how these properties have been configured within eslint-config-next or extending directly from the Next.js ESLint plugin instead: The plugin can be installed normally in your project: This eliminates the risk of collisions or errors that can occur due to importing the same plugin or parser across multiple configurations. Additional configurations If you already use a separate ESLint configuration and want to include eslint-config-next, ensure that it is extended last after other configurations. For example: The next configuration already handles setting default values for the parser, plugins and settings properties. There is no need to manually re-declare any of these properties unless you need a different configuration for your use case. If you include any other shareable configurations, you will need to make sure that these properties are not overwritten or modified. Otherwise, we recommend removing any configurations that share behavior with the next configuration or extending directly from the Next.js ESLint plugin as mentioned above. | Version | Changes | | --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | v16.0.0 | next lint and the eslint next.config.js option were removed in favor of the ESLint CLI. A codemod is available to help you migrate. |",
    "excerpt": "Next.js provides an ESLint plugin, @next/eslint-plugin-next, already bundled within the base configuration that makes it possible to catch common issues and problems in a Next.js application. Setup ES...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config/03-eslint"
  },
  {
    "id": "01-app-03-api-reference-05-config-index",
    "path": "01-app\\03-api-reference\\05-config\\index.mdx",
    "title": "Configuration",
    "description": "Learn how to configure Next.js applications.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/05-config"
  },
  {
    "id": "01-app-03-api-reference-06-cli-create-next-app",
    "path": "01-app\\03-api-reference\\06-cli\\create-next-app.mdx",
    "title": "create-next-app",
    "description": "Create Next.js apps using one command with the create-next-app CLI.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Reference",
        "slug": "reference"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "With the default template",
        "slug": "with-the-default-template"
      },
      {
        "level": 3,
        "text": "Linter Options",
        "slug": "linter-options"
      },
      {
        "level": 3,
        "text": "With an official Next.js example",
        "slug": "with-an-official-nextjs-example"
      },
      {
        "level": 3,
        "text": "With any public GitHub example",
        "slug": "with-any-public-github-example"
      }
    ],
    "codeBlocks": [
      {
        "language": "bash",
        "code": "npx create-next-app@latest [project-name] [options]",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "npx create-next-app@latest",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "txt",
        "code": "What is your project named? my-app\r\nWould you like to use the recommended Next.js defaults?\r\n    Yes, use recommended defaults - TypeScript, ESLint, Tailwind CSS, App Router, Turbopack\r\n    No, reuse previous settings\r\n    No, customize settings - Choose your own preferences",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "txt",
        "code": "Would you like to use TypeScript? No / Yes\r\nWhich linter would you like to use? ESLint / Biome / None\r\nWould you like to use React Compiler? No / Yes\r\nWould you like to use Tailwind CSS? No / Yes\r\nWould you like your code inside a `src/` directory? No / Yes\r\nWould you like to use App Router? (recommended) No / Yes\r\nWould you like to customize the import alias (`@/*` by default)? No / Yes\r\nWhat import alias would you like configured? @/*",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "npx create-next-app@latest --example [example-name] [your-project-name]",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "npx create-next-app@latest --example \"https://github.com/.../\" [your-project-name]",
        "context": "filename=\"Terminal\""
      }
    ],
    "content": "The create-next-app CLI allow you to create a new Next.js application using the default template or an example from a public GitHub repository. It is the easiest way to get started with Next.js. Basic usage: Reference The following options are available: | Options | Description | | --------------------------------------- | --------------------------------------------------------------------- | | -h or --help | Show all available options | | -v or --version | Output the version number | | --no- | Negate default options. E.g. --no-ts | | --ts or --typescript | Initialize as a TypeScript project (default) | | --js or --javascript | Initialize as a JavaScript project | | --tailwind | Initialize with Tailwind CSS config (default) | | --react-compiler | Initialize with React Compiler enabled | | --eslint | Initialize with ESLint config | | --biome | Initialize with Biome config | | --no-linter | Skip linter configuration | | --app | Initialize as an App Router project | | --api | Initialize a project with only route handlers | | --src-dir | Initialize inside a src/ directory | | --turbopack | Force enable Turbopack in generated package.json (enabled by default) | | --webpack | Force enable Webpack in generated package.json | | --import-alias | Specify import alias to use (default \"@/\\\") | | --empty | Initialize an empty project | | --use-npm | Explicitly tell the CLI to bootstrap the application using npm | | --use-pnpm | Explicitly tell the CLI to bootstrap the application using pnpm | | --use-yarn | Explicitly tell the CLI to bootstrap the application using Yarn | | --use-bun | Explicitly tell the CLI to bootstrap the application using Bun | | -e or --example [name] [github-url] | An example to bootstrap the app with | | --example-path | Specify the path to the example separately | | --reset-preferences | Explicitly tell the CLI to reset any stored preferences | | --skip-install | Explicitly tell the CLI to skip installing packages | | --disable-git | Explicitly tell the CLI to disable git initialization | | --yes | Use previous preferences or defaults for all options | Examples With the default template To create a new app using the default template, run the following command in your terminal: On installation, you'll see the following prompts: If you choose to customize settings, you'll see the following prompts: After the prompts, create-next-app will create a folder with your project name and install the required dependencies. Linter Options ESLint: The traditional and most popular JavaScript linter. Includes Next.js-specific rules from @next/eslint-plugin-next. Biome: A fast, modern linter and formatter that combines the functionality of ESLint and Prettier. Includes built-in Next.js and React domain support for optimal performance. None: Skip linter configuration entirely. You can always add a linter later. Once you've answered the prompts, a new project will be created with your chosen configuration. With an official Next.js example To create a new app using an official Next.js example, use the --example flag. For example: You can view a list of all available examples along with setup instructions in the Next.js repository. With any public GitHub example To create a new app using any public GitHub example, use the --example option with the GitHub repo's URL. For example:",
    "excerpt": "The create-next-app CLI allow you to create a new Next.js application using the default template or an example from a public GitHub repository. It is the easiest way to get started with Next.js. Basic...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/06-cli/create-next-app"
  },
  {
    "id": "01-app-03-api-reference-06-cli-index",
    "path": "01-app\\03-api-reference\\06-cli\\index.mdx",
    "title": "CLI",
    "description": "API Reference for the Next.js Command Line Interface (CLI) tools.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "Next.js comes with two Command Line Interface (CLI) tools: - create-next-app: Quickly create a new Next.js application using the default template or an example from a public GitHub repository. - next: Run the Next.js development server, build your application, and more.",
    "excerpt": "Next.js comes with two Command Line Interface (CLI) tools: - create-next-app: Quickly create a new Next.js application using the default template or an example from a public GitHub repository. - next:...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/06-cli"
  },
  {
    "id": "01-app-03-api-reference-06-cli-next",
    "path": "01-app\\03-api-reference\\06-cli\\next.mdx",
    "title": "next CLI",
    "description": "Learn how to run and build your application with the Next.js CLI.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Reference",
        "slug": "reference"
      },
      {
        "level": 3,
        "text": "Commands",
        "slug": "commands"
      },
      {
        "level": 3,
        "text": " options",
        "slug": "-options"
      },
      {
        "level": 3,
        "text": " options",
        "slug": "-options"
      },
      {
        "level": 3,
        "text": " options",
        "slug": "-options"
      },
      {
        "level": 3,
        "text": " options",
        "slug": "-options"
      },
      {
        "level": 3,
        "text": " options",
        "slug": "-options"
      },
      {
        "level": 3,
        "text": " Options",
        "slug": "-options"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Debugging prerender errors",
        "slug": "debugging-prerender-errors"
      },
      {
        "level": 3,
        "text": "Building specific routes",
        "slug": "building-specific-routes"
      },
      {
        "level": 3,
        "text": "Changing the default port",
        "slug": "changing-the-default-port"
      },
      {
        "level": 3,
        "text": "Using HTTPS during development",
        "slug": "using-https-during-development"
      },
      {
        "level": 3,
        "text": "Configuring a timeout for downstream proxies",
        "slug": "configuring-a-timeout-for-downstream-proxies"
      },
      {
        "level": 3,
        "text": "Passing Node.js arguments",
        "slug": "passing-nodejs-arguments"
      }
    ],
    "codeBlocks": [
      {
        "language": "bash",
        "code": "npx next [command] [options]",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "Route (app)\r\n┌ ○ /_not-found\r\n└ ƒ /products/[id]\r\n\r\n○  (Static)   prerendered as static content\r\nƒ  (Dynamic)  server-rendered on demand",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "Operating System:\r\n  Platform: darwin\r\n  Arch: arm64\r\n  Version: Darwin Kernel Version 23.6.0\r\n  Available memory (MB): 65536\r\n  Available CPU cores: 10\r\nBinaries:\r\n  Node: 20.12.0\r\n  npm: 10.5.0\r\n  Yarn: 1.22.19\r\n  pnpm: 9.6.0\r\nRelevant Packages:\r\n  next: 15.0.0-canary.115 // Latest available version is detected (15.0.0-canary.115).\r\n  eslint-config-next: 14.2.5\r\n  react: 19.0.0-rc\r\n  react-dom: 19.0.0\r\n  typescript: 5.5.4\r\nNext.js Config:\r\n  output: N/A",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "# Generate route types first, then validate with TypeScript\r\nnext typegen && tsc --noEmit\r\n\r\n# Or in CI workflows for type checking without building\r\nnext typegen && npm run type-check",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "next typegen\r\n# or for a specific app\r\nnext typegen ./apps/web",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "next build --debug-prerender",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "# Build a specific route\r\nnext build --debug-build-paths=\"app/page.tsx\"\r\n\r\n# Build more than one route\r\nnext build --debug-build-paths=\"app/page.tsx,pages/index.tsx\"\r\n\r\n# Use glob patterns\r\nnext build --debug-build-paths=\"app/**/page.tsx\"\r\nnext build --debug-build-paths=\"pages/*.tsx\"",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "next dev -p 4000",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "PORT=4000 next dev",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "next dev --experimental-https",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "next dev --experimental-https --experimental-https-key ./certificates/localhost-key.pem --experimental-https-cert ./certificates/localhost.pem",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "next start --keepAliveTimeout 70000",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "NODE_OPTIONS='--throw-deprecation' next\r\nNODE_OPTIONS='-r esm' next\r\nNODE_OPTIONS='--inspect' next",
        "context": "filename=\"Terminal\""
      }
    ],
    "content": "The Next.js CLI allows you to develop, build, start your application, and more. Basic usage: Reference The following options are available: | Options | Description | | ------------------- | ---------------------------------- | | -h or --help | Shows all available options | | -v or --version | Outputs the Next.js version number | Commands The following commands are available: | Command | Description | | -------------------------------------- | ------------------------------------------------------------------------------------------------------------- | | dev | Starts Next.js in development mode with Hot Module Reloading, error reporting, and more. | | build | Creates an optimized production build of your application. Displaying information about each route. | | start | Starts Next.js in production mode. The application should be compiled with next build first. | | info | Prints relevant details about the current system which can be used to report Next.js bugs. | | telemetry | Allows you to enable or disable Next.js' completely anonymous telemetry collection. | | typegen | Generates TypeScript definitions for routes, pages, layouts, and route handlers without running a full build. | > Good to know: Running next without a command is an alias for next dev. next dev options next dev starts the application in development mode with Hot Module Reloading (HMR), error reporting, and more. The following options are available when running next dev: | Option | Description | | ---------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- | | -h, --help | Show all available options. | | [directory] | A directory in which to build the application. If not provided, current directory is used. | | --turbopack | Force enable Turbopack (enabled by default). Also available as --turbo. | | --webpack | Use Webpack instead of the default Turbopack bundler for development. | | -p or --port | Specify a port number on which to start the application. Default: 3000, env: PORT | | -Hor --hostname | Specify a hostname on which to start the application. Useful for making the application available for other devices on the network. Default: 0.0.0.0 | | --experimental-https | Starts the server with HTTPS and generates a self-signed certificate. | | --experimental-https-key | Path to a HTTPS key file. | | --experimental-https-cert | Path to a HTTPS certificate file. | | --experimental-https-ca | Path to a HTTPS certificate authority file. | | --experimental-upload-trace | Reports a subset of the debugging trace to a remote HTTP URL. | next build options next build creates an optimized production build of your application. The output displays information about each route. For example: The following options are available for the next build command: | Option | Description | | ---------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | -h, --help | Show all available options. | | [directory] | A directory on which to build the application. If not provided, the current directory will be used. | | --turbopack | Force enable Turbopack (enabled by default). Also available as --turbo. | | --webpack | Build using Webpack. | | -d or --debug | Enables a more verbose build output. With this flag enabled additional build output like rewrites, redirects, and headers will be shown. | | | | --profile | Enables production profiling for React. | | --no-lint | Disables linting. Note: linting will be removed from next build in Next 16. If you're using Next 15.5+ with a linter other than eslint, linting during build will not occur. | | --no-mangling | Disables mangling. This may affect performance and should only be used for debugging purposes. | | --experimental-app-only | Builds only App Router routes. | | --experimental-build-mode [mode] | Uses an experimental build mode. (choices: \"compile\", \"generate\", default: \"default\") | | --debug-prerender | Debug prerender errors in development. | | --debug-build-paths= | Build only specific routes for debugging. | next start options next start starts the application in production mode. The application should be compiled with next build first. The following options are available for the next start command: | Option | Description | | --------------------------------------- | --------------------------------------------------------------------------------------------------------------- | | -h or --help | Show all available options. | | [directory] | A directory on which to start the application. If no directory is provided, the current directory will be used. | | -p or --port | Specify a port number on which to start the application. (default: 3000, env: PORT) | | -H or --hostname | Specify a hostname on which to start the application (default: 0.0.0.0). | | --keepAliveTimeout | Specify the maximum amount of milliseconds to wait before closing the inactive connections. | next info options next info prints relevant details about the current system which can be used to report Next.js bugs when opening a GitHub issue. This information includes Operating System platform/arch/version, Binaries (Node.js, npm, Yarn, pnpm), package versions (next, react, react-dom), and more. The output should look like this: The following options are available for the next info command: | Option | Description | | ---------------- | ---------------------------------------------- | | -h or --help | Show all available options | | --verbose | Collects additional information for debugging. | next telemetry options Next.js collects completely anonymous telemetry data about general usage. Participation in this anonymous program is optional, and you can opt-out if you prefer not to share information. The following options are available for the next telemetry command: | Option | Description | | ------------ | --------------------------------------- | | -h, --help | Show all available options. | | --enable | Enables Next.js' telemetry collection. | | --disable | Disables Next.js' telemetry collection. | Learn more about Telemetry. next typegen Options next typegen generates TypeScript definitions for your application's routes without performing a full build. This is useful for IDE autocomplete and CI type-checking of route usage. Previously, route types were only generated during next dev or next build, which meant running tsc --noEmit directly wouldn't validate your route types. Now you can generate types independently and validate them externally: The following options are available for the next typegen command: | Option | Description | | ------------- | -------------------------------------------------------------------------------------------- | | -h, --help | Show all available options. | | [directory] | A directory on which to generate types. If not provided, the current directory will be used. | Output files are written to /types (typically: .next/dev/types or .next/types, see isolatedDevBuild): Additionally, next typegen generates a next-env.d.ts file. We recommend adding next-env.d.ts to your .gitignore file. The next-env.d.ts file is included into your tsconfig.json file, to make Next.js types available to your project. To ensure next-env.d.ts is present before type-checking run next typegen. The commands next dev and next build also generate the next-env.d.ts file, but it is often undesirable to run these just to type-check, for example in CI/CD environments. > Good to know: next typegen loads your Next.js config (next.config.js, next.config.mjs, or next.config.ts) using the production build phase. Ensure any required environment variables and dependencies are available so the config can load correctly. Examples Debugging prerender errors If you encounter prerendering errors during next build, you can pass the --debug-prerender flag to get more detailed output: This enables several experimental options to make debugging easier: - Disables server code minification: - experimental.serverMinification = false - experimental.turbopackMinify = false - Generates source maps for server bundles: - experimental.serverSourceMaps = true - Enables source map consumption in child processes used for prerendering: - enablePrerenderSourceMaps = true - Continues building even after the first prerender error, so you can see all issues at once: - experimental.prerenderEarlyExit = false This helps surface more readable stack traces and code frames in the build output. > Warning: --debug-prerender is for debugging in development only. Do not deploy builds generated with --debug-prerender to production, as it may impact performance. Building specific routes You can build only specific routes in the App and Pages Routers using the --debug-build-paths option. This is useful for faster debugging when working with large applications. The --debug-build-paths option accepts comma-separated file paths and supports glob patterns: Changing the default port By default, Next.js uses http://localhost:3000 during development and with next start. The default port can be changed with the -p option, like so: Or using the PORT environment variable: > Good to know: PORT cannot be set in .env as booting up the HTTP server happens before any other code is initialized. Using HTTPS during development For certain use cases like webhooks or authentication, you can use HTTPS to have a secure environment on localhost. Next.js can generate a self-signed certificate with next dev using the --experimental-https flag: With the generated certificate, the Next.js development server will exist at https://localhost:3000. The default port 3000 is used unless a port is specified with -p, --port, or PORT. You can also provide a custom certificate and key with --experimental-https-key and --experimental-https-cert. Optionally, you can provide a custom CA certificate with --experimental-https-ca as well. next dev --experimental-https is only intended for development and creates a locally trusted certificate with mkcert. In production, use properly issued certificates from trusted authorities. Configuring a timeout for downstream proxies When deploying Next.js behind a downstream proxy (e.g. a load-balancer like AWS ELB/ALB), it's important to configure Next's underlying HTTP server with keep-alive timeouts that are larger than the downstream proxy's timeouts. Otherwise, once a keep-alive timeout is reached for a given TCP connection, Node.js will immediately terminate that connection without notifying the downstream proxy. This results in a proxy error whenever it attempts to reuse a connection that Node.js has already terminated. To configure the timeout values for the production Next.js server, pass --keepAliveTimeout (in milliseconds) to next start, like so: Passing Node.js arguments You can pass any node arguments to next commands. For example: | Version | Changes | | --------- | ------------------------------------------------------------------------------- | | v16.0.0 | The JS bundle size metrics have been removed from next build | | v15.5.0 | Add the next typegen command | | v15.4.0 | Add --debug-prerender option for next build to help debug prerender errors. |",
    "excerpt": "The Next.js CLI allows you to develop, build, start your application, and more. Basic usage: Reference The following options are available: | Options | Description | | ------------------- | ----------...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/06-cli/next"
  },
  {
    "id": "01-app-03-api-reference-07-edge",
    "path": "01-app\\03-api-reference\\07-edge.mdx",
    "title": "Edge Runtime",
    "description": "API Reference for the Edge Runtime.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Caveats",
        "slug": "caveats"
      },
      {
        "level": 2,
        "text": "Reference",
        "slug": "reference"
      },
      {
        "level": 3,
        "text": "Network APIs",
        "slug": "network-apis"
      },
      {
        "level": 3,
        "text": "Encoding APIs",
        "slug": "encoding-apis"
      },
      {
        "level": 3,
        "text": "Stream APIs",
        "slug": "stream-apis"
      },
      {
        "level": 3,
        "text": "Crypto APIs",
        "slug": "crypto-apis"
      },
      {
        "level": 3,
        "text": "Web Standard APIs",
        "slug": "web-standard-apis"
      },
      {
        "level": 3,
        "text": "Next.js Specific Polyfills",
        "slug": "nextjs-specific-polyfills"
      },
      {
        "level": 3,
        "text": "Environment Variables",
        "slug": "environment-variables"
      },
      {
        "level": 3,
        "text": "Unsupported APIs",
        "slug": "unsupported-apis"
      }
    ],
    "codeBlocks": [
      {
        "language": "javascript",
        "code": "export const config = {\r\n  unstable_allowDynamic: [\r\n    // allows a single file\r\n    '/lib/utilities.js',\r\n    // use a glob to allow anything in the function-bind 3rd party module\r\n    '**/node_modules/function-bind/**',\r\n  ],\r\n}",
        "context": "filename=\"proxy.ts\""
      }
    ],
    "content": "Next.js has two server runtimes you can use in your application: - The Node.js Runtime (default), which has access to all Node.js APIs and is used for rendering your application. - The Edge Runtime which contains a more limited set of APIs, used in Proxy. Caveats - The Edge Runtime does not support all Node.js APIs. Some packages may not work as expected. - The Edge Runtime does not support Incremental Static Regeneration (ISR). - Both runtimes can support streaming depending on your deployment adapter. Reference The Edge Runtime supports the following APIs: Network APIs | API | Description | | ------------------------------------------------------------------------------- | --------------------------------- | | Blob | Represents a blob | | fetch | Fetches a resource | | FetchEvent | Represents a fetch event | | File | Represents a file | | FormData | Represents form data | | Headers | Represents HTTP headers | | Request | Represents an HTTP request | | Response | Represents an HTTP response | | URLSearchParams | Represents URL search parameters | | WebSocket | Represents a websocket connection | Encoding APIs | API | Description | | ----------------------------------------------------------------------------------- | ---------------------------------- | | atob | Decodes a base-64 encoded string | | btoa | Encodes a string in base-64 | | TextDecoder | Decodes a Uint8Array into a string | | TextDecoderStream | Chainable decoder for streams | | TextEncoder | Encodes a string into a Uint8Array | | TextEncoderStream | Chainable encoder for streams | Stream APIs | API | Description | | ------------------------------------------------------------------------------------------------------- | --------------------------------------- | | ReadableStream | Represents a readable stream | | ReadableStreamBYOBReader | Represents a reader of a ReadableStream | | ReadableStreamDefaultReader | Represents a reader of a ReadableStream | | TransformStream | Represents a transform stream | | WritableStream | Represents a writable stream | | WritableStreamDefaultWriter | Represents a writer of a WritableStream | Crypto APIs | API | Description | | ------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------- | | crypto | Provides access to the cryptographic functionality of the platform | | CryptoKey | Represents a cryptographic key | | SubtleCrypto | Provides access to common cryptographic primitives, like hashing, signing, encryption or decryption | Web Standard APIs | API | Description | | --------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | AbortController | Allows you to abort one or more DOM requests as and when desired | | Array | Represents an array of values | | ArrayBuffer | Represents a generic, fixed-length raw binary data buffer | | Atomics | Provides atomic operations as static methods | | BigInt | Represents a whole number with arbitrary precision | | BigInt64Array | Represents a typed array of 64-bit signed integers | | BigUint64Array | Represents a typed array of 64-bit unsigned integers | | Boolean | Represents a logical entity and can have two values: true and false | | clearInterval | Cancels a timed, repeating action which was previously established by a call to setInterval() | | clearTimeout | Cancels a timed, repeating action which was previously established by a call to setTimeout() | | console | Provides access to the browser's debugging console | | DataView | Represents a generic view of an ArrayBuffer | | Date | Represents a single moment in time in a platform-independent format | | decodeURI | Decodes a Uniform Resource Identifier (URI) previously created by encodeURI or by a similar routine | | decodeURIComponent | Decodes a Uniform Resource Identifier (URI) component previously created by encodeURIComponent or by a similar routine | | DOMException | Represents an error that occurs in the DOM | | encodeURI | Encodes a Uniform Resource Identifier (URI) by replacing each instance of certain characters by one, two, three, or four escape sequences representing the UTF-8 encoding of the character | | encodeURIComponent | Encodes a Uniform Resource Identifier (URI) component by replacing each instance of certain characters by one, two, three, or four escape sequences representing the UTF-8 encoding of the character | | Error | Represents an error when trying to execute a statement or accessing a property | | EvalError | Represents an error that occurs regarding the global function eval() | | Float32Array | Represents a typed array of 32-bit floating point numbers | | Float64Array | Represents a typed array of 64-bit floating point numbers | | Function | Represents a function | | Infinity | Represents the mathematical Infinity value | | Int8Array | Represents a typed array of 8-bit signed integers | | Int16Array | Represents a typed array of 16-bit signed integers | | Int32Array | Represents a typed array of 32-bit signed integers | | Intl | Provides access to internationalization and localization functionality | | isFinite | Determines whether a value is a finite number | | isNaN | Determines whether a value is NaN or not | | JSON | Provides functionality to convert JavaScript values to and from the JSON format | | Map | Represents a collection of values, where each value may occur only once | | Math | Provides access to mathematical functions and constants | | Number | Represents a numeric value | | Object | Represents the object that is the base of all JavaScript objects | | parseFloat | Parses a string argument and returns a floating point number | | parseInt | Parses a string argument and returns an integer of the specified radix | | Promise | Represents the eventual completion (or failure) of an asynchronous operation, and its resulting value | | Proxy | Represents an object that is used to define custom behavior for fundamental operations (e.g. property lookup, assignment, enumeration, function invocation, etc) | | queueMicrotask | Queues a microtask to be executed | | RangeError | Represents an error when a value is not in the set or range of allowed values | | ReferenceError | Represents an error when a non-existent variable is referenced | | Reflect | Provides methods for interceptable JavaScript operations | | RegExp | Represents a regular expression, allowing you to match combinations of characters | | Set | Represents a collection of values, where each value may occur only once | | setInterval | Repeatedly calls a function, with a fixed time delay between each call | | setTimeout | Calls a function or evaluates an expression after a specified number of milliseconds | | SharedArrayBuffer | Represents a generic, fixed-length raw binary data buffer | | String | Represents a sequence of characters | | structuredClone | Creates a deep copy of a value | | Symbol | Represents a unique and immutable data type that is used as the key of an object property | | SyntaxError | Represents an error when trying to interpret syntactically invalid code | | TypeError | Represents an error when a value is not of the expected type | | Uint8Array | Represents a typed array of 8-bit unsigned integers | | Uint8ClampedArray | Represents a typed array of 8-bit unsigned integers clamped to 0-255 | | Uint32Array | Represents a typed array of 32-bit unsigned integers | | URIError | Represents an error when a global URI handling function was used in a wrong way | | URL | Represents an object providing static methods used for creating object URLs | | URLPattern | Represents a URL pattern | | URLSearchParams | Represents a collection of key/value pairs | | WeakMap | Represents a collection of key/value pairs in which the keys are weakly referenced | | WeakSet | Represents a collection of objects in which each object may occur only once | | WebAssembly | Provides access to WebAssembly | Next.js Specific Polyfills - AsyncLocalStorage Environment Variables You can use process.env to access Environment Variables for both next dev and next build. Unsupported APIs The Edge Runtime has some restrictions including: - Native Node.js APIs are not supported. For example, you can't read or write to the filesystem. - nodemodules can be used, as long as they implement ES Modules and do not use native Node.js APIs. - Calling require directly is not allowed. Use ES Modules instead. The following JavaScript language features are disabled, and will not work: | API | Description | | ------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------- | | eval | Evaluates JavaScript code represented as a string | | new Function(evalString) | Creates a new function with the code provided as an argument | | WebAssembly.compile | Compiles a WebAssembly module from a buffer source | | WebAssembly.instantiate | Compiles and instantiates a WebAssembly module from a buffer source | In rare cases, your code could contain (or import) some dynamic code evaluation statements which can not be reached at runtime and which can not be removed by treeshaking. You can relax the check to allow specific files with your Proxy configuration: unstableallowDynamic is a glob, or an array of globs, ignoring dynamic code evaluation for specific files. The globs are relative to your application root folder. Be warned that if these statements are executed on the Edge, they will throw and cause a runtime error.",
    "excerpt": "Next.js has two server runtimes you can use in your application: - The Node.js Runtime (default), which has access to all Node.js APIs and is used for rendering your application. - The Edge Runtime wh...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/07-edge"
  },
  {
    "id": "01-app-03-api-reference-08-turbopack",
    "path": "01-app\\03-api-reference\\08-turbopack.mdx",
    "title": "Turbopack",
    "description": "Turbopack is an incremental bundler optimized for JavaScript and TypeScript, written in Rust, and built into Next.js.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Why Turbopack?",
        "slug": "why-turbopack"
      },
      {
        "level": 2,
        "text": "Getting started",
        "slug": "getting-started"
      },
      {
        "level": 3,
        "text": "Using Webpack instead",
        "slug": "using-webpack-instead"
      },
      {
        "level": 2,
        "text": "Supported features",
        "slug": "supported-features"
      },
      {
        "level": 3,
        "text": "Language features",
        "slug": "language-features"
      },
      {
        "level": 3,
        "text": "Framework and React features",
        "slug": "framework-and-react-features"
      },
      {
        "level": 3,
        "text": "CSS and styling",
        "slug": "css-and-styling"
      },
      {
        "level": 3,
        "text": "Assets",
        "slug": "assets"
      },
      {
        "level": 3,
        "text": "Module resolution",
        "slug": "module-resolution"
      },
      {
        "level": 3,
        "text": "Performance and Fast Refresh",
        "slug": "performance-and-fast-refresh"
      },
      {
        "level": 2,
        "text": "Known gaps with webpack",
        "slug": "known-gaps-with-webpack"
      },
      {
        "level": 3,
        "text": "CSS Module Ordering",
        "slug": "css-module-ordering"
      },
      {
        "level": 3,
        "text": "Sass node_modules imports",
        "slug": "sass-node_modules-imports"
      },
      {
        "level": 3,
        "text": "Bundle Sizes",
        "slug": "bundle-sizes"
      },
      {
        "level": 3,
        "text": "Build Caching",
        "slug": "build-caching"
      },
      {
        "level": 3,
        "text": "Webpack plugins",
        "slug": "webpack-plugins"
      },
      {
        "level": 2,
        "text": "Unsupported and unplanned features",
        "slug": "unsupported-and-unplanned-features"
      },
      {
        "level": 2,
        "text": "Configuration",
        "slug": "configuration"
      },
      {
        "level": 2,
        "text": "Generating trace files for performance debugging",
        "slug": "generating-trace-files-for-performance-debugging"
      },
      {
        "level": 2,
        "text": "Summary",
        "slug": "summary"
      },
      {
        "level": 2,
        "text": "Version Changes",
        "slug": "version-changes"
      }
    ],
    "codeBlocks": [
      {
        "language": "json",
        "code": "{\r\n  \"scripts\": {\r\n    \"dev\": \"next dev\",\r\n    \"build\": \"next build\",\r\n    \"start\": \"next start\"\r\n  }\r\n}",
        "context": "filename=\"package.json\" highlight={3}"
      },
      {
        "language": "json",
        "code": "{\r\n  \"scripts\": {\r\n    \"dev\": \"next dev --webpack\",\r\n    \"build\": \"next build --webpack\",\r\n    \"start\": \"next start\"\r\n  }\r\n}",
        "context": "filename=\"package.json\""
      },
      {
        "language": "jsx",
        "code": "import utilStyles from './utils.module.css'\r\nimport buttonStyles from './button.module.css'\r\nexport default function BlogPost() {\r\n  return (\r\n    <div className={utilStyles.container}>\r\n      <button className={buttonStyles.primary}>Click me</button>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"components/BlogPost.jsx\""
      },
      {
        "language": "scss",
        "code": "@import '~bootstrap/dist/css/bootstrap.min.css';",
        "context": "filename=\"styles/globals.scss\""
      },
      {
        "language": "scss",
        "code": "@import 'bootstrap/dist/css/bootstrap.min.css';",
        "context": "filename=\"styles/globals.scss\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  turbopack: {\r\n    resolveAlias: {\r\n      '~*': '*',\r\n    },\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "import heavy from 'some-heavy-dependency.js'\r\n\r\nexport function usesHeavy() {\r\n  return heavy.run()\r\n}\r\n\r\nexport const CONSTANT_VALUE = 3",
        "context": "filename=large.module.js"
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  turbopack: {\r\n    // Example: adding an alias and custom file extension\r\n    resolveAlias: {\r\n      underscore: 'lodash',\r\n    },\r\n    resolveExtensions: ['.mdx', '.tsx', '.ts', '.jsx', '.js', '.json'],\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "bash",
        "code": "NEXT_TURBOPACK_TRACING=1 next dev",
        "context": ""
      }
    ],
    "content": "Turbopack is an incremental bundler optimized for JavaScript and TypeScript, written in Rust, and built into Next.js. You can use Turbopack with both the Pages and App Router for a much faster local development experience. Why Turbopack? We built Turbopack to push the performance of Next.js, including: - Unified Graph: Next.js supports multiple output environments (e.g., client and server). Managing multiple compilers and stitching bundles together can be tedious. Turbopack uses a single, unified graph for all environments. - Bundling vs Native ESM: Some tools skip bundling in development and rely on the browser's native ESM. This works well for small apps but can slow down large apps due to excessive network requests. Turbopack bundles in dev, but in an optimized way to keep large apps fast. - Incremental Computation: Turbopack parallelizes work across cores and caches results down to the function level. Once a piece of work is done, Turbopack won’t repeat it. - Lazy Bundling: Turbopack only bundles what is actually requested by the dev server. This lazy approach can reduce initial compile times and memory usage. Getting started Turbopack is now the default bundler in Next.js. No configuration is needed to use Turbopack: Using Webpack instead If you need to use Webpack instead of Turbopack, you can opt-in with the --webpack flag: Supported features Turbopack in Next.js has zero-configuration for the common use cases. Below is a summary of what is supported out of the box, plus some references to how you can configure Turbopack further when needed. Language features | Feature | Status | Notes | | --------------------------- | ------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | JavaScript & TypeScript | Supported | Uses SWC under the hood. Type-checking is not done by Turbopack (run tsc --watch or rely on your IDE for type checks). | | ECMAScript (ESNext) | Supported | Turbopack supports the latest ECMAScript features, matching SWC’s coverage. | | CommonJS | Supported | require() syntax is handled out of the box. | | ESM | Supported | Static and dynamic import are fully supported. | | Babel | Supported | Starting in Next.js 16, Turbopack uses Babel automatically if it detects [a configuration file][babel-config]. Unlike in webpack, SWC is always used for Next.js's internal transforms and downleveling to older ECMAScript revisions. Next.js with webpack disables SWC if a Babel configuration file is present. Files in nodemodules are excluded, unless you [manually configure babel-loader][manual-loader]. | [babel-config]: https://babeljs.io/docs/config-files [manual-loader]: /docs/app/api-reference/config/next-config-js/turbopackconfiguring-webpack-loaders Framework and React features | Feature | Status | Notes | | --------------------------------- | ------------- | ---------------------------------------------------------------------------------------------------------------------- | | JSX / TSX | Supported | SWC handles JSX/TSX compilation. | | Fast Refresh | Supported | No configuration needed. | | React Server Components (RSC) | Supported | For the Next.js App Router. Turbopack ensures correct server/client bundling. | | Root layout creation | Unsupported | Automatic creation of a root layout in App Router is not supported. Turbopack will instruct you to create it manually. | CSS and styling | Feature | Status | Notes | | ------------------ | ----------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | Global CSS | Supported | Import .css files directly in your application. | | CSS Modules | Supported | .module.css files work natively (Lightning CSS). | | CSS Nesting | Supported | Lightning CSS supports modern CSS nesting. | | @import syntax | Supported | Combine multiple CSS files. | | PostCSS | Supported | Automatically processes postcss.config.js in a Node.js worker pool. Useful for Tailwind, Autoprefixer, etc. | | Sass / SCSS | Supported (Next.js) | For Next.js, Sass is supported out of the box. Custom Sass functions (sassOptions.functions) are not supported because Turbopack's Rust-based architecture cannot directly execute JavaScript functions, unlike webpack's Node.js environment. Use webpack if you need this feature. In the future, Turbopack standalone usage will likely require a loader config. | | Less | Planned via plugins | Not yet supported by default. Will likely require a loader config once custom loaders are stable. | | Lightning CSS | In Use | Handles CSS transformations. Some low-usage CSS Modules features (like :local/:global as standalone pseudo-classes) are not yet supported. See below for more details. | Assets | Feature | Status | Notes | | --------------------------------- | ------------- | -------------------------------------------------------------------------------------------------------------------------- | | Static Assets (images, fonts) | Supported | Importing import img from './img.png' works out of the box. In Next.js, returns an object for the component. | | JSON Imports | Supported | Named or default imports from .json are supported. | Module resolution | Feature | Status | Notes | | --------------------- | ------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- | | Path Aliases | Supported | Reads tsconfig.json's paths and baseUrl, matching Next.js behavior. | | Manual Aliases | Supported | Configure resolveAlias in next.config.js (similar to webpack.resolve.alias). | | Custom Extensions | Supported | Configure resolveExtensions in next.config.js. | | AMD | Partially Supported | Basic transforms work; advanced AMD usage is limited. | Performance and Fast Refresh | Feature | Status | Notes | | ------------------------ | ------------- | ---------------------------------------------------------------------------------------- | | Fast Refresh | Supported | Updates JavaScript, TypeScript, and CSS without a full refresh. | | Incremental Bundling | Supported | Turbopack lazily builds only what’s requested by the dev server, speeding up large apps. | Known gaps with webpack There are a number of non-trivial behavior differences between webpack and Turbopack that are important to be aware of when migrating an application. Generally, these are less of a concern for new applications. CSS Module Ordering Turbopack will follow JS import order to order CSS modules which are not otherwise ordered. For example: In this example, Turbopack will ensure that utils.module.css will appear before button.module.css in the produced CSS chunk, following the import order Webpack generally does this as well, but there are cases where it will ignore JS inferred ordering, for example if it infers the JS file is side-effect-free. This can lead to subtle rendering changes when adopting Turbopack, if applications have come to rely on an arbitrary ordering. Generally, the solution is easy, e.g. have button.module.css @import utils.module.css to force the ordering, or identify the conflicting rules and change them to not target the same properties. Sass nodemodules imports Turbopack supports importing nodemodules Sass files out of the box. Webpack supports a legacy tilde ~ syntax for this, which is not supported by Turbopack. From: To: If you can't update the imports, you can add a turbopack.resolveAlias configuration to map the ~ syntax to the actual path: Bundle Sizes From our testing on production applications, we observed that Turbopack generally produces bundles that are similar in size to Webpack. However, the comparison can be difficult since turbopack tends to produce fewer but larger chunks. Our advice is to focus on higher level metrics like Core Web Vitals or your own application level metrics to compare performance across the two bundlers. We are however aware of one gap that can occasionally cause a large regression. Turbopack does not yet have an equivalent to the Inner Graph Optimization in webpack which is enabled by default. This optimization is useful to tree shake large modules. For example: If an application only uses CONSTANTVALUE Turbopack will detect this and delete the usesHeavy export but not the corresponding import. However, with the Inner Graph Optimization, webpack can delete the import too which can drop the dependency as well. We are planning to offer an equivalent to the Inner Graph Optimization in Turbopack but it is still under development. If you are affected by this gap, consider manually splitting modules. Build Caching Webpack supports disk build caching to improve build performance. Turbopack provides a similar opt-in feature, currently in beta. Starting with Next 16, you can enable Turbopack’s filesystem cache by setting the following experimental flags: - experimental.turbopackFileSystemCacheForDev - experimental.turbopackFileSystemCacheForBuild > Good to know: For this reason, when comparing webpack and Turbopack performance, make sure to delete the .next folder between builds to see a fair comparison or enable the turbopack filesystem cache feature. Webpack plugins Turbopack does not support webpack plugins. This affects third-party tools that rely on webpack's plugin system for integration. We do support webpack loaders. If you depend on webpack plugins, you'll need to find Turbopack-compatible alternatives or continue using webpack until equivalent functionality is available. Unsupported and unplanned features Some features are not yet implemented or not planned: - Legacy CSS Modules features - Standalone :local and :global pseudo-classes (only the function variant :global(...) is supported). - The @value rule (superseded by CSS variables). - :import and :export ICSS rules. - composes in .module.css composing a .css file. In webpack this would treat the .css file as a CSS Module, with Turbopack the .css file will always be global. This means that if you want to use composes in a CSS Module, you need to change the .css file to a .module.css file. - @import in CSS Modules importing .css as a CSS Module. In webpack this would treat the .css file as a CSS Module, with Turbopack the .css file will always be global. This means that if you want to use @import in a CSS Module, you need to change the .css file to a .module.css file. - sassOptions.functions Custom Sass functions defined in sassOptions.functions are not supported. This feature allows defining JavaScript functions that can be called from Sass code during compilation. Turbopack's Rust-based architecture cannot directly execute JavaScript functions passed through sassOptions.functions, unlike webpack's Node.js-based sass-loader which runs entirely in JavaScript. If you're using custom Sass functions, you'll need to use webpack instead of Turbopack. - webpack() configuration in next.config.js Turbopack replaces webpack, so webpack() configs are not recognized. Use the turbopack config instead. - Yarn PnP Not planned for Turbopack support in Next.js. - experimental.urlImports Not planned for Turbopack. - experimental.esmExternals Not planned. Turbopack does not support the legacy esmExternals configuration in Next.js. - Some Next.js Experimental Flags - experimental.nextScriptWorkers - experimental.sri.algorithm - experimental.fallbackNodePolyfills We plan to implement these in the future. For a full, detailed breakdown of each feature flag and its status, see the Turbopack API Reference. Configuration Turbopack can be configured via next.config.js (or next.config.ts) under the turbopack key. Configuration options include: - rules Define additional webpack loaders for file transformations. - resolveAlias Create manual aliases (like resolve.alias in webpack). - resolveExtensions Change or extend file extensions for module resolution. For more in-depth configuration examples, see the Turbopack config documentation. Generating trace files for performance debugging If you encounter performance or memory issues and want to help the Next.js team diagnose them, you can generate a trace file by appending NEXTTURBOPACKTRACING=1 to your dev command: This will produce a .next/dev/trace-turbopack file. Include that file when creating a GitHub issue on the Next.js repo to help us investigate. By default the development server outputs to .next/dev. Read more about isolatedDevBuild. Summary Turbopack is a Rust-based, incremental bundler designed to make local development and builds fast—especially for large applications. It is integrated into Next.js, offering zero-config CSS, React, and TypeScript support. Version Changes | Version | Changes | | --------- | ------------------------------------------------------------------------------------------------------------------ | | v16.0.0 | Turbopack becomes the default bundler for Next.js. Automatic support for Babel when a configuration file is found. | | v15.5.0 | Turbopack support for build beta | | v15.3.0 | Experimental support for build | | v15.0.0 | Turbopack for dev stable |",
    "excerpt": "Turbopack is an incremental bundler optimized for JavaScript and TypeScript, written in Rust, and built into Next.js. You can use Turbopack with both the Pages and App Router for a much faster local d...",
    "url": "https://nextjs.org/docs/01-app/03-api-reference/08-turbopack"
  },
  {
    "id": "01-app-03-api-reference-index",
    "path": "01-app\\03-api-reference\\index.mdx",
    "title": "API Reference",
    "description": "Next.js API Reference for the App Router.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/01-app/03-api-reference"
  },
  {
    "id": "01-app-index",
    "path": "01-app\\index.mdx",
    "title": "App Router",
    "description": "The App Router is a file-system based router that uses React's latest features such as Server Components, Suspense, Server Functions, and more.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "The App Router is a file-system based router that uses React's latest features such as Server Components, Suspense, and Server Functions.",
    "excerpt": "The App Router is a file-system based router that uses React's latest features such as Server Components, Suspense, and Server Functions.",
    "url": "https://nextjs.org/docs/01-app"
  },
  {
    "id": "02-pages-01-getting-started-01-installation",
    "path": "02-pages\\01-getting-started\\01-installation.mdx",
    "title": "Create a new Next.js application",
    "description": "How to create a new Next.js application with `create-next-app`. Set up TypeScript, ESLint,and configure your `next.config.js` file.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/01-getting-started/01-installation"
  },
  {
    "id": "02-pages-01-getting-started-02-project-structure",
    "path": "02-pages\\01-getting-started\\02-project-structure.mdx",
    "title": "Project Structure and Organization",
    "description": "Learn about the folder and file conventions in a Next.js project, and how to organize your project.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/01-getting-started/02-project-structure"
  },
  {
    "id": "02-pages-01-getting-started-04-images",
    "path": "02-pages\\01-getting-started\\04-images.mdx",
    "title": "Image Optimization",
    "description": "Optimize your images with the built-in `next/image` component.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/01-getting-started/04-images"
  },
  {
    "id": "02-pages-01-getting-started-05-fonts",
    "path": "02-pages\\01-getting-started\\05-fonts.mdx",
    "title": "How to use fonts",
    "description": "Learn how to use fonts in Next.js",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/01-getting-started/05-fonts"
  },
  {
    "id": "02-pages-01-getting-started-06-css",
    "path": "02-pages\\01-getting-started\\06-css.mdx",
    "title": "How to use CSS in your application",
    "description": "Learn about the different ways to add CSS to your application, including CSS Modules, Global CSS, Tailwind CSS, and more.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/01-getting-started/06-css"
  },
  {
    "id": "02-pages-01-getting-started-11-deploying",
    "path": "02-pages\\01-getting-started\\11-deploying.mdx",
    "title": "How to deploy your Next.js application",
    "description": "Learn how to deploy your Next.js application.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/01-getting-started/11-deploying"
  },
  {
    "id": "02-pages-01-getting-started-index",
    "path": "02-pages\\01-getting-started\\index.mdx",
    "title": "Getting Started - Pages Router",
    "description": "Learn how to create full-stack web applications with Next.js with the Pages Router.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/01-getting-started"
  },
  {
    "id": "02-pages-02-guides-analytics",
    "path": "02-pages\\02-guides\\analytics.mdx",
    "title": "How to set up analytics",
    "description": "Measure and track page performance using Next.js",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/02-guides/analytics"
  },
  {
    "id": "02-pages-02-guides-authentication",
    "path": "02-pages\\02-guides\\authentication.mdx",
    "title": "How to implement authentication in Next.js",
    "description": "Learn how to implement authentication in Next.js, covering best practices, securing routes, authorization techniques, and session management.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/02-guides/authentication"
  },
  {
    "id": "02-pages-02-guides-babel",
    "path": "02-pages\\02-guides\\babel.mdx",
    "title": "How to configure Babel in Next.js",
    "description": "Extend the babel preset added by Next.js with your own configs.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Adding Presets and Plugins",
        "slug": "adding-presets-and-plugins"
      },
      {
        "level": 2,
        "text": "Customizing Presets and Plugins",
        "slug": "customizing-presets-and-plugins"
      }
    ],
    "codeBlocks": [
      {
        "language": "json",
        "code": "{\r\n  \"presets\": [\"next/babel\"],\r\n  \"plugins\": []\r\n}",
        "context": "filename=\".babelrc\""
      },
      {
        "language": "json",
        "code": "{\r\n  \"presets\": [\"next/babel\"],\r\n  \"plugins\": [\"@babel/plugin-proposal-do-expressions\"]\r\n}",
        "context": "filename=\".babelrc\""
      },
      {
        "language": "json",
        "code": "{\r\n  \"presets\": [\r\n    [\r\n      \"next/babel\",\r\n      {\r\n        \"preset-env\": {},\r\n        \"transform-runtime\": {},\r\n        \"styled-jsx\": {},\r\n        \"class-properties\": {}\r\n      }\r\n    ]\r\n  ],\r\n  \"plugins\": []\r\n}",
        "context": "filename=\".babelrc\""
      }
    ],
    "content": "Examples - Customizing babel configuration Next.js includes the next/babel preset to your app, which includes everything needed to compile React applications and server-side code. But if you want to extend the default Babel configs, it's also possible. Adding Presets and Plugins To start, you only need to define a .babelrc file (or babel.config.js) in the root directory of your project. If such a file is found, it will be considered as the source of truth, and therefore it needs to define what Next.js needs as well, which is the next/babel preset. Here's an example .babelrc file: You can take a look at this file to learn about the presets included by next/babel. To add presets/plugins without configuring them, you can do it this way: Customizing Presets and Plugins To add presets/plugins with custom configuration, do it on the next/babel preset like so: To learn more about the available options for each config, visit babel's documentation site. > Good to know: > > - Next.js uses the current Node.js version for server-side compilations. > - The modules option on \"preset-env\" should be kept to false, otherwise webpack code splitting is turned off.",
    "excerpt": "Examples - Customizing babel configuration Next.js includes the next/babel preset to your app, which includes everything needed to compile React applications and server-side code. But if you want to e...",
    "url": "https://nextjs.org/docs/02-pages/02-guides/babel"
  },
  {
    "id": "02-pages-02-guides-ci-build-caching",
    "path": "02-pages\\02-guides\\ci-build-caching.mdx",
    "title": "How to configure Continuous Integration (CI) build caching",
    "description": "Learn how to configure CI to cache Next.js builds",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/02-guides/ci-build-caching"
  },
  {
    "id": "02-pages-02-guides-content-security-policy",
    "path": "02-pages\\02-guides\\content-security-policy.mdx",
    "title": "How to set a Content Security Policy (CSP) for your Next.js application",
    "description": "Learn how to set a Content Security Policy (CSP) for your Next.js application.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/02-guides/content-security-policy"
  },
  {
    "id": "02-pages-02-guides-css-in-js",
    "path": "02-pages\\02-guides\\css-in-js.mdx",
    "title": "How to use CSS-in-JS libraries",
    "description": "Use CSS-in-JS libraries with Next.js",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/02-guides/css-in-js"
  },
  {
    "id": "02-pages-02-guides-custom-server",
    "path": "02-pages\\02-guides\\custom-server.mdx",
    "title": "How to set up a custom server in Next.js",
    "description": "Start a Next.js app programmatically using a custom server.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/02-guides/custom-server"
  },
  {
    "id": "02-pages-02-guides-debugging",
    "path": "02-pages\\02-guides\\debugging.mdx",
    "title": "How to use debugging tools with Next.js",
    "description": "Learn how to debug your Next.js application with VS Code or Chrome DevTools.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/02-guides/debugging"
  },
  {
    "id": "02-pages-02-guides-draft-mode",
    "path": "02-pages\\02-guides\\draft-mode.mdx",
    "title": "How to preview content with Draft Mode in Next.js",
    "description": "Next.js has draft mode to toggle between static and dynamic pages. You can learn how it works with Pages Router.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Step 1: Create and access the API route",
        "slug": "step-1-create-and-access-the-api-route"
      },
      {
        "level": 3,
        "text": "Securely accessing it from your Headless CMS",
        "slug": "securely-accessing-it-from-your-headless-cms"
      },
      {
        "level": 2,
        "text": "Step 2: Update ",
        "slug": "step-2-update-"
      },
      {
        "level": 3,
        "text": "Fetch draft data",
        "slug": "fetch-draft-data"
      },
      {
        "level": 2,
        "text": "More Details",
        "slug": "more-details"
      },
      {
        "level": 3,
        "text": "Clear the Draft Mode cookie",
        "slug": "clear-the-draft-mode-cookie"
      },
      {
        "level": 3,
        "text": "Works with ",
        "slug": "works-with-"
      },
      {
        "level": 3,
        "text": "Works with API Routes",
        "slug": "works-with-api-routes"
      },
      {
        "level": 3,
        "text": "Unique per ",
        "slug": "unique-per-"
      }
    ],
    "codeBlocks": [
      {
        "language": "js",
        "code": "export default function handler(req, res) {\r\n  // ...\r\n  res.setDraftMode({ enable: true })\r\n  // ...\r\n}",
        "context": ""
      },
      {
        "language": "ts",
        "code": "// simple example for testing it manually from your browser.\r\nexport default function handler(req, res) {\r\n  res.setDraftMode({ enable: true })\r\n  res.end('Draft mode is enabled')\r\n}",
        "context": "filename=\"pages/api/draft.ts\""
      },
      {
        "language": "bash",
        "code": "https://<your-site>/api/draft?secret=<token>&slug=<path>",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "js",
        "code": "export default async (req, res) => {\r\n  // Check the secret and next parameters\r\n  // This secret should only be known to this API route and the CMS\r\n  if (req.query.secret !== 'MY_SECRET_TOKEN' || !req.query.slug) {\r\n    return res.status(401).json({ message: 'Invalid token' })\r\n  }\r\n\r\n  // Fetch the headless CMS to check if the provided `slug` exists\r\n  // getPostBySlug would implement the required fetching logic to the headless CMS\r\n  const post = await getPostBySlug(req.query.slug)\r\n\r\n  // If the slug doesn't exist prevent draft mode from being enabled\r\n  if (!post) {\r\n    return res.status(401).json({ message: 'Invalid slug' })\r\n  }\r\n\r\n  // Enable Draft Mode by setting the cookie\r\n  res.setDraftMode({ enable: true })\r\n\r\n  // Redirect to the path from the fetched post\r\n  // We don't redirect to req.query.slug as that might lead to open redirect vulnerabilities\r\n  res.redirect(post.slug)\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "export async function getStaticProps(context) {\r\n  if (context.draftMode) {\r\n    // dynamic data\r\n  }\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "export async function getStaticProps(context) {\r\n  const url = context.draftMode\r\n    ? 'https://draft.example.com'\r\n    : 'https://production.example.com'\r\n  const res = await fetch(url)\r\n  // ...\r\n}",
        "context": ""
      },
      {
        "language": "bash",
        "code": "https://<your-site>/api/draft?secret=<token>&slug=<path>",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "ts",
        "code": "export default function handler(req, res) {\r\n  res.setDraftMode({ enable: false })\r\n}",
        "context": "filename=\"pages/api/disable-draft.ts\""
      },
      {
        "language": "js",
        "code": "export default function myApiRoute(req, res) {\r\n  if (req.draftMode) {\r\n    // get draft data\r\n  }\r\n}",
        "context": ""
      }
    ],
    "content": "In the Pages documentation and the Data Fetching documentation, we talked about how to pre-render a page at build time (Static Generation) using getStaticProps and getStaticPaths. Static Generation is useful when your pages fetch data from a headless CMS. However, it’s not ideal when you’re writing a draft on your headless CMS and want to view the draft immediately on your page. You’d want Next.js to render these pages at request time instead of build time and fetch the draft content instead of the published content. You’d want Next.js to bypass Static Generation only for this specific case. Next.js has a feature called Draft Mode which solves this problem. Here are instructions on how to use it. Step 1: Create and access the API route > Take a look at the API Routes documentation first if you’re not familiar with Next.js API Routes. First, create the API route. It can have any name - e.g. pages/api/draft.ts In this API route, you need to call setDraftMode on the response object. This will set a cookie to enable draft mode. Subsequent requests containing this cookie will trigger Draft Mode changing the behavior for statically generated pages (more on this later). You can test this manually by creating an API route like below and accessing it from your browser manually: If you open your browser’s developer tools and visit /api/draft, you’ll notice a Set-Cookie response header with a cookie named prerenderbypass. Securely accessing it from your Headless CMS In practice, you’d want to call this API route securely from your headless CMS. The specific steps will vary depending on which headless CMS you’re using, but here are some common steps you could take. These steps assume that the headless CMS you’re using supports setting custom draft URLs. If it doesn’t, you can still use this method to secure your draft URLs, but you’ll need to construct and access the draft URL manually. First, you should create a secret token string using a token generator of your choice. This secret will only be known by your Next.js app and your headless CMS. This secret prevents people who don’t have access to your CMS from accessing draft URLs. Second, if your headless CMS supports setting custom draft URLs, specify the following as the draft URL. This assumes that your draft API route is located at pages/api/draft.ts. - should be your deployment domain. - should be replaced with the secret token you generated. - should be the path for the page that you want to view. If you want to view /posts/foo, then you should use &slug=/posts/foo. Your headless CMS might allow you to include a variable in the draft URL so that can be set dynamically based on the CMS’s data like so: &slug=/posts/{entry.fields.slug} Finally, in the draft API route: - Check that the secret matches and that the slug parameter exists (if not, the request should fail). - - Call res.setDraftMode. - Then redirect the browser to the path specified by slug. (The following example uses a 307 redirect). If it succeeds, then the browser will be redirected to the path you want to view with the draft mode cookie. Step 2: Update getStaticProps The next step is to update getStaticProps to support draft mode. If you request a page which has getStaticProps with the cookie set (via res.setDraftMode), then getStaticProps will be called at request time (instead of at build time). Furthermore, it will be called with a context object where context.draftMode will be true. We used res.setDraftMode in the draft API route, so context.draftMode will be true. If you’re also using getStaticPaths, then context.params will also be available. Fetch draft data You can update getStaticProps to fetch different data based on context.draftMode. For example, your headless CMS might have a different API endpoint for draft posts. If so, you can modify the API endpoint URL like below: That’s it! If you access the draft API route (with secret and slug) from your headless CMS or manually, you should now be able to see the draft content. And if you update your draft without publishing, you should be able to view the draft. Set this as the draft URL on your headless CMS or access manually, and you should be able to see the draft. More Details Clear the Draft Mode cookie By default, the Draft Mode session ends when the browser is closed. To clear the Draft Mode cookie manually, create an API route that calls setDraftMode({ enable: false }): Then, send a request to /api/disable-draft to invoke the API Route. If calling this route using next/link, you must pass prefetch={false} to prevent accidentally deleting the cookie on prefetch. Works with getServerSideProps Draft Mode works with getServerSideProps, and is available as a draftMode key in the context object. > Good to know: You shouldn't set the Cache-Control header when using Draft Mode because it cannot be bypassed. Instead, we recommend using ISR. Works with API Routes API Routes will have access to draftMode on the request object. For example: Unique per next build A new bypass cookie value will be generated each time you run next build. This ensures that the bypass cookie can’t be guessed. > Good to know: To test Draft Mode locally over HTTP, your browser will need to allow third-party cookies and local storage access.",
    "excerpt": "In the Pages documentation and the Data Fetching documentation, we talked about how to pre-render a page at build time (Static Generation) using getStaticProps and getStaticPaths. Static Generation is...",
    "url": "https://nextjs.org/docs/02-pages/02-guides/draft-mode"
  },
  {
    "id": "02-pages-02-guides-environment-variables",
    "path": "02-pages\\02-guides\\environment-variables.mdx",
    "title": "How to use environment variables in Next.js",
    "description": "Learn to add and access environment variables in your Next.js application.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/02-guides/environment-variables"
  },
  {
    "id": "02-pages-02-guides-forms",
    "path": "02-pages\\02-guides\\forms.mdx",
    "title": "How to create forms with API Routes",
    "description": "Learn how to handle form submissions and data mutations with Next.js.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Server Forms",
        "slug": "server-forms"
      },
      {
        "level": 2,
        "text": "Form validation",
        "slug": "form-validation"
      },
      {
        "level": 3,
        "text": "Error handling",
        "slug": "error-handling"
      },
      {
        "level": 2,
        "text": "Displaying loading state",
        "slug": "displaying-loading-state"
      },
      {
        "level": 3,
        "text": "Redirecting",
        "slug": "redirecting"
      }
    ],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "import type { NextApiRequest, NextApiResponse } from 'next'\r\n\r\nexport default async function handler(\r\n  req: NextApiRequest,\r\n  res: NextApiResponse\r\n) {\r\n  const data = req.body\r\n  const id = await createItem(data)\r\n  res.status(200).json({ id })\r\n}",
        "context": "filename=\"pages/api/submit.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export default function handler(req, res) {\r\n  const data = req.body\r\n  // call your database, etc.\r\n  // const id = await createItem(data)\r\n  // ...\r\n  res.status(200).json({ data })\r\n}",
        "context": "filename=\"pages/api/submit.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import { FormEvent } from 'react'\r\n\r\nexport default function Page() {\r\n  async function onSubmit(event: FormEvent<HTMLFormElement>) {\r\n    event.preventDefault()\r\n\r\n    const formData = new FormData(event.currentTarget)\r\n    const response = await fetch('/api/submit', {\r\n      method: 'POST',\r\n      body: formData,\r\n    })\r\n\r\n    // Handle response if necessary\r\n    const data = await response.json()\r\n    // ...\r\n  }\r\n\r\n  return (\r\n    <form onSubmit={onSubmit}>\r\n      <input type=\"text\" name=\"name\" />\r\n      <button type=\"submit\">Submit</button>\r\n    </form>\r\n  )\r\n}",
        "context": "filename=\"pages/index.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function Page() {\r\n  async function onSubmit(event) {\r\n    event.preventDefault()\r\n\r\n    const formData = new FormData(event.target)\r\n    const response = await fetch('/api/submit', {\r\n      method: 'POST',\r\n      body: formData,\r\n    })\r\n\r\n    // Handle response if necessary\r\n    const data = await response.json()\r\n    // ...\r\n  }\r\n\r\n  return (\r\n    <form onSubmit={onSubmit}>\r\n      <input type=\"text\" name=\"name\" />\r\n      <button type=\"submit\">Submit</button>\r\n    </form>\r\n  )\r\n}",
        "context": "filename=\"pages/index.jsx\" switcher"
      },
      {
        "language": "ts",
        "code": "import type { NextApiRequest, NextApiResponse } from 'next'\r\nimport { z } from 'zod'\r\n\r\nconst schema = z.object({\r\n  // ...\r\n})\r\n\r\nexport default async function handler(\r\n  req: NextApiRequest,\r\n  res: NextApiResponse\r\n) {\r\n  const parsed = schema.parse(req.body)\r\n  // ...\r\n}",
        "context": "filename=\"pages/api/submit.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { z } from 'zod'\r\n\r\nconst schema = z.object({\r\n  // ...\r\n})\r\n\r\nexport default async function handler(req, res) {\r\n  const parsed = schema.parse(req.body)\r\n  // ...\r\n}",
        "context": "filename=\"pages/api/submit.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import React, { useState, FormEvent } from 'react'\r\n\r\nexport default function Page() {\r\n  const [isLoading, setIsLoading] = useState<boolean>(false)\r\n  const [error, setError] = useState<string | null>(null)\r\n\r\n  async function onSubmit(event: FormEvent<HTMLFormElement>) {\r\n    event.preventDefault()\r\n    setIsLoading(true)\r\n    setError(null) // Clear previous errors when a new request starts\r\n\r\n    try {\r\n      const formData = new FormData(event.currentTarget)\r\n      const response = await fetch('/api/submit', {\r\n        method: 'POST',\r\n        body: formData,\r\n      })\r\n\r\n      if (!response.ok) {\r\n        throw new Error('Failed to submit the data. Please try again.')\r\n      }\r\n\r\n      // Handle response if necessary\r\n      const data = await response.json()\r\n      // ...\r\n    } catch (error) {\r\n      // Capture the error message to display to the user\r\n      setError(error.message)\r\n      console.error(error)\r\n    } finally {\r\n      setIsLoading(false)\r\n    }\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      {error && <div style={{ color: 'red' }}>{error}</div>}\r\n      <form onSubmit={onSubmit}>\r\n        <input type=\"text\" name=\"name\" />\r\n        <button type=\"submit\" disabled={isLoading}>\r\n          {isLoading ? 'Loading...' : 'Submit'}\r\n        </button>\r\n      </form>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"pages/index.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import React, { useState } from 'react'\r\n\r\nexport default function Page() {\r\n  const [isLoading, setIsLoading] = useState(false)\r\n  const [error, setError] = useState(null)\r\n\r\n  async function onSubmit(event) {\r\n    event.preventDefault()\r\n    setIsLoading(true)\r\n    setError(null) // Clear previous errors when a new request starts\r\n\r\n    try {\r\n      const formData = new FormData(event.currentTarget)\r\n      const response = await fetch('/api/submit', {\r\n        method: 'POST',\r\n        body: formData,\r\n      })\r\n\r\n      if (!response.ok) {\r\n        throw new Error('Failed to submit the data. Please try again.')\r\n      }\r\n\r\n      // Handle response if necessary\r\n      const data = await response.json()\r\n      // ...\r\n    } catch (error) {\r\n      // Capture the error message to display to the user\r\n      setError(error.message)\r\n      console.error(error)\r\n    } finally {\r\n      setIsLoading(false)\r\n    }\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      {error && <div style={{ color: 'red' }}>{error}</div>}\r\n      <form onSubmit={onSubmit}>\r\n        <input type=\"text\" name=\"name\" />\r\n        <button type=\"submit\" disabled={isLoading}>\r\n          {isLoading ? 'Loading...' : 'Submit'}\r\n        </button>\r\n      </form>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"pages/index.jsx\" switcher"
      },
      {
        "language": "tsx",
        "code": "import React, { useState, FormEvent } from 'react'\r\n\r\nexport default function Page() {\r\n  const [isLoading, setIsLoading] = useState<boolean>(false)\r\n\r\n  async function onSubmit(event: FormEvent<HTMLFormElement>) {\r\n    event.preventDefault()\r\n    setIsLoading(true) // Set loading to true when the request starts\r\n\r\n    try {\r\n      const formData = new FormData(event.currentTarget)\r\n      const response = await fetch('/api/submit', {\r\n        method: 'POST',\r\n        body: formData,\r\n      })\r\n\r\n      // Handle response if necessary\r\n      const data = await response.json()\r\n      // ...\r\n    } catch (error) {\r\n      // Handle error if necessary\r\n      console.error(error)\r\n    } finally {\r\n      setIsLoading(false) // Set loading to false when the request completes\r\n    }\r\n  }\r\n\r\n  return (\r\n    <form onSubmit={onSubmit}>\r\n      <input type=\"text\" name=\"name\" />\r\n      <button type=\"submit\" disabled={isLoading}>\r\n        {isLoading ? 'Loading...' : 'Submit'}\r\n      </button>\r\n    </form>\r\n  )\r\n}",
        "context": "filename=\"pages/index.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import React, { useState } from 'react'\r\n\r\nexport default function Page() {\r\n  const [isLoading, setIsLoading] = useState(false)\r\n\r\n  async function onSubmit(event) {\r\n    event.preventDefault()\r\n    setIsLoading(true) // Set loading to true when the request starts\r\n\r\n    try {\r\n      const formData = new FormData(event.currentTarget)\r\n      const response = await fetch('/api/submit', {\r\n        method: 'POST',\r\n        body: formData,\r\n      })\r\n\r\n      // Handle response if necessary\r\n      const data = await response.json()\r\n      // ...\r\n    } catch (error) {\r\n      // Handle error if necessary\r\n      console.error(error)\r\n    } finally {\r\n      setIsLoading(false) // Set loading to false when the request completes\r\n    }\r\n  }\r\n\r\n  return (\r\n    <form onSubmit={onSubmit}>\r\n      <input type=\"text\" name=\"name\" />\r\n      <button type=\"submit\" disabled={isLoading}>\r\n        {isLoading ? 'Loading...' : 'Submit'}\r\n      </button>\r\n    </form>\r\n  )\r\n}",
        "context": "filename=\"pages/index.jsx\" switcher"
      },
      {
        "language": "ts",
        "code": "import type { NextApiRequest, NextApiResponse } from 'next'\r\n\r\nexport default async function handler(\r\n  req: NextApiRequest,\r\n  res: NextApiResponse\r\n) {\r\n  const id = await addPost()\r\n  res.redirect(307, `/post/${id}`)\r\n}",
        "context": "filename=\"pages/api/submit.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export default async function handler(req, res) {\r\n  const id = await addPost()\r\n  res.redirect(307, `/post/${id}`)\r\n}",
        "context": "filename=\"pages/api/submit.js\" switcher"
      }
    ],
    "content": "Forms enable you to create and update data in web applications. Next.js provides a powerful way to handle data mutations using API Routes. This guide will walk you through how to handle form submission on the server. Server Forms To handle form submissions on the server, create an API endpoint that securely mutates data. Then, call the API Route from the client with an event handler: > Good to know: > > - API Routes do not specify CORS headers, meaning they are same-origin only by default. > - Since API Routes run on the server, we're able to use sensitive values (like API keys) through Environment Variables without exposing them to the client. This is critical for the security of your application. Form validation We recommend using HTML validation like required and type=\"email\" for basic client-side form validation. For more advanced server-side validation, you can use a schema validation library like zod to validate the form fields before mutating the data: Error handling You can use React state to show an error message when a form submission fails: Displaying loading state You can use React state to show a loading state when a form is submitting on the server: Redirecting If you would like to redirect the user to a different route after a mutation, you can redirect to any absolute or relative URL:",
    "excerpt": "Forms enable you to create and update data in web applications. Next.js provides a powerful way to handle data mutations using API Routes. This guide will walk you through how to handle form submissio...",
    "url": "https://nextjs.org/docs/02-pages/02-guides/forms"
  },
  {
    "id": "02-pages-02-guides-incremental-static-regeneration",
    "path": "02-pages\\02-guides\\incremental-static-regeneration.mdx",
    "title": "How to implement Incremental Static Regeneration (ISR)",
    "description": "Learn how to create or update static pages at runtime with Incremental Static Regeneration.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/02-guides/incremental-static-regeneration"
  },
  {
    "id": "02-pages-02-guides-index",
    "path": "02-pages\\02-guides\\index.mdx",
    "title": "Guides",
    "description": "Learn how to implement common UI patterns and use cases using Next.js",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/02-guides"
  },
  {
    "id": "02-pages-02-guides-instrumentation",
    "path": "02-pages\\02-guides\\instrumentation.mdx",
    "title": "How to set up instrumentation",
    "description": "Learn how to use instrumentation to run code at server startup in your Next.js app",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/02-guides/instrumentation"
  },
  {
    "id": "02-pages-02-guides-internationalization",
    "path": "02-pages\\02-guides\\internationalization.mdx",
    "title": "How to implement internationalization in Next.js",
    "description": "Next.js has built-in support for internationalized routing and language detection. Learn more here.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Getting started",
        "slug": "getting-started"
      },
      {
        "level": 2,
        "text": "Locale Strategies",
        "slug": "locale-strategies"
      },
      {
        "level": 3,
        "text": "Sub-path Routing",
        "slug": "sub-path-routing"
      },
      {
        "level": 3,
        "text": "Domain Routing",
        "slug": "domain-routing"
      },
      {
        "level": 2,
        "text": "Automatic Locale Detection",
        "slug": "automatic-locale-detection"
      },
      {
        "level": 3,
        "text": "Prefixing the Default Locale",
        "slug": "prefixing-the-default-locale"
      },
      {
        "level": 3,
        "text": "Disabling Automatic Locale Detection",
        "slug": "disabling-automatic-locale-detection"
      },
      {
        "level": 2,
        "text": "Accessing the locale information",
        "slug": "accessing-the-locale-information"
      },
      {
        "level": 2,
        "text": "Transition between locales",
        "slug": "transition-between-locales"
      },
      {
        "level": 2,
        "text": "Leveraging the  cookie",
        "slug": "leveraging-the-cookie"
      },
      {
        "level": 2,
        "text": "Search Engine Optimization",
        "slug": "search-engine-optimization"
      },
      {
        "level": 2,
        "text": "How does this work with Static Generation?",
        "slug": "how-does-this-work-with-static-generation"
      },
      {
        "level": 3,
        "text": "Dynamic Routes and  Pages",
        "slug": "dynamic-routes-and-pages"
      },
      {
        "level": 3,
        "text": "Automatically Statically Optimized Pages",
        "slug": "automatically-statically-optimized-pages"
      },
      {
        "level": 3,
        "text": "Non-dynamic getStaticProps Pages",
        "slug": "non-dynamic-getstaticprops-pages"
      },
      {
        "level": 2,
        "text": "Limits for the i18n config",
        "slug": "limits-for-the-i18n-config"
      }
    ],
    "codeBlocks": [
      {
        "language": "js",
        "code": "module.exports = {\r\n  i18n: {\r\n    // These are all the locales you want to support in\r\n    // your application\r\n    locales: ['en-US', 'fr', 'nl-NL'],\r\n    // This is the default locale you want to be used when visiting\r\n    // a non-locale prefixed path e.g. `/hello`\r\n    defaultLocale: 'en-US',\r\n    // This is a list of locale domains and the default locale they\r\n    // should handle (these are only required when setting up domain routing)\r\n    // Note: subdomains must be included in the domain value to be matched e.g. \"fr.example.com\".\r\n    domains: [\r\n      {\r\n        domain: 'example.com',\r\n        defaultLocale: 'en-US',\r\n      },\r\n      {\r\n        domain: 'example.nl',\r\n        defaultLocale: 'nl-NL',\r\n      },\r\n      {\r\n        domain: 'example.fr',\r\n        defaultLocale: 'fr',\r\n        // an optional http field can also be used to test\r\n        // locale domains locally with http instead of https\r\n        http: true,\r\n      },\r\n    ],\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  i18n: {\r\n    locales: ['en-US', 'fr', 'nl-NL'],\r\n    defaultLocale: 'en-US',\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  i18n: {\r\n    locales: ['en-US', 'fr', 'nl-NL', 'nl-BE'],\r\n    defaultLocale: 'en-US',\r\n\r\n    domains: [\r\n      {\r\n        // Note: subdomains must be included in the domain value to be matched\r\n        // e.g. www.example.com should be used if that is the expected hostname\r\n        domain: 'example.com',\r\n        defaultLocale: 'en-US',\r\n      },\r\n      {\r\n        domain: 'example.fr',\r\n        defaultLocale: 'fr',\r\n      },\r\n      {\r\n        domain: 'example.nl',\r\n        defaultLocale: 'nl-NL',\r\n        // specify other locales that should be redirected\r\n        // to this domain\r\n        locales: ['nl-BE'],\r\n      },\r\n    ],\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  i18n: {\r\n    locales: ['default', 'en', 'de', 'fr'],\r\n    defaultLocale: 'default',\r\n    localeDetection: false,\r\n  },\r\n  trailingSlash: true,\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "ts",
        "code": "import { NextRequest, NextResponse } from 'next/server'\r\n\r\nconst PUBLIC_FILE = /\\.(.*)$/\r\n\r\nexport async function proxy(req: NextRequest) {\r\n  if (\r\n    req.nextUrl.pathname.startsWith('/_next') ||\r\n    req.nextUrl.pathname.includes('/api/') ||\r\n    PUBLIC_FILE.test(req.nextUrl.pathname)\r\n  ) {\r\n    return\r\n  }\r\n\r\n  if (req.nextUrl.locale === 'default') {\r\n    const locale = req.cookies.get('NEXT_LOCALE')?.value || 'en'\r\n\r\n    return NextResponse.redirect(\r\n      new URL(`/${locale}${req.nextUrl.pathname}${req.nextUrl.search}`, req.url)\r\n    )\r\n  }\r\n}",
        "context": "filename=\"proxy.ts\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  i18n: {\r\n    localeDetection: false,\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function IndexPage(props) {\r\n  return (\r\n    <Link href=\"/another\" locale=\"fr\">\r\n      To /fr/another\r\n    </Link>\r\n  )\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import { useRouter } from 'next/router'\r\n\r\nexport default function IndexPage(props) {\r\n  const router = useRouter()\r\n\r\n  return (\r\n    <div\r\n      onClick={() => {\r\n        router.push('/another', '/another', { locale: 'fr' })\r\n      }}\r\n    >\r\n      to /fr/another\r\n    </div>\r\n  )\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import { useRouter } from 'next/router'\r\nconst router = useRouter()\r\nconst { pathname, asPath, query } = router\r\n// change just the locale and maintain all other route information including href's query\r\nrouter.push({ pathname, query }, asPath, { locale: nextLocale })",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function IndexPage(props) {\r\n  return (\r\n    <Link href=\"/fr/another\" locale={false}>\r\n      To /fr/another\r\n    </Link>\r\n  )\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "export const getStaticPaths = ({ locales }) => {\r\n  return {\r\n    paths: [\r\n      // if no `locale` is provided only the defaultLocale will be generated\r\n      { params: { slug: 'post-1' }, locale: 'en-US' },\r\n      { params: { slug: 'post-1' }, locale: 'fr' },\r\n    ],\r\n    fallback: true,\r\n  }\r\n}",
        "context": "filename=\"pages/blog/[slug].js\""
      },
      {
        "language": "js",
        "code": "export async function getStaticProps({ locale }) {\r\n  // Call an external API endpoint to get posts.\r\n  // You can use any data fetching library\r\n  const res = await fetch(`https://.../posts?locale=${locale}`)\r\n  const posts = await res.json()\r\n\r\n  if (posts.length === 0) {\r\n    return {\r\n      notFound: true,\r\n    }\r\n  }\r\n\r\n  // By returning { props: posts }, the Blog component\r\n  // will receive `posts` as a prop at build time\r\n  return {\r\n    props: {\r\n      posts,\r\n    },\r\n  }\r\n}",
        "context": ""
      }
    ],
    "content": "Examples - i18n routing Next.js has built-in support for internationalized (i18n) routing since v10.0.0. You can provide a list of locales, the default locale, and domain-specific locales and Next.js will automatically handle the routing. The i18n routing support is currently meant to complement existing i18n library solutions like react-intl, react-i18next, lingui, rosetta, next-intl, next-translate, next-multilingual, tolgee, paraglide-next, next-intlayer, gt-react and others by streamlining the routes and locale parsing. Getting started To get started, add the i18n config to your next.config.js file. Locales are UTS Locale Identifiers, a standardized format for defining locales. Generally a Locale Identifier is made up of a language, region, and script separated by a dash: language-region-script. The region and script are optional. An example: - en-US - English as spoken in the United States - nl-NL - Dutch as spoken in the Netherlands - nl - Dutch, no specific region If user locale is nl-BE and it is not listed in your configuration, they will be redirected to nl if available, or to the default locale otherwise. If you don't plan to support all regions of a country, it is therefore a good practice to include country locales that will act as fallbacks. Locale Strategies There are two locale handling strategies: Sub-path Routing and Domain Routing. Sub-path Routing Sub-path Routing puts the locale in the url path. With the above configuration en-US, fr, and nl-NL will be available to be routed to, and en-US is the default locale. If you have a pages/blog.js the following urls would be available: - /blog - /fr/blog - /nl-nl/blog The default locale does not have a prefix. Domain Routing By using domain routing you can configure locales to be served from different domains: For example if you have pages/blog.js the following urls will be available: - example.com/blog - www.example.com/blog - example.fr/blog - example.nl/blog - example.nl/nl-BE/blog Automatic Locale Detection When a user visits the application root (generally /), Next.js will try to automatically detect which locale the user prefers based on the Accept-Language header and the current domain. If a locale other than the default locale is detected, the user will be redirected to either: - When using Sub-path Routing: The locale prefixed path - When using Domain Routing: The domain with that locale specified as the default When using Domain Routing, if a user with the Accept-Language header fr;q=0.9 visits example.com, they will be redirected to example.fr since that domain handles the fr locale by default. When using Sub-path Routing, the user would be redirected to /fr. Prefixing the Default Locale With Next.js 12 and Proxy, we can add a prefix to the default locale with a workaround. For example, here's a next.config.js file with support for a few languages. Note the \"default\" locale has been added intentionally. Next, we can use Proxy to add custom routing rules: This Proxy skips adding the default prefix to API Routes and public files like fonts or images. If a request is made to the default locale, we redirect to our prefix /en. Disabling Automatic Locale Detection The automatic locale detection can be disabled with: When localeDetection is set to false Next.js will no longer automatically redirect based on the user's preferred locale and will only provide locale information detected from either the locale based domain or locale path as described above. Accessing the locale information You can access the locale information via the Next.js router. For example, using the useRouter() hook the following properties are available: - locale contains the currently active locale. - locales contains all configured locales. - defaultLocale contains the configured default locale. When pre-rendering pages with getStaticProps or getServerSideProps, the locale information is provided in the context provided to the function. When leveraging getStaticPaths, the configured locales are provided in the context parameter of the function under locales and the configured defaultLocale under defaultLocale. Transition between locales You can use next/link or next/router to transition between locales. For next/link, a locale prop can be provided to transition to a different locale from the currently active one. If no locale prop is provided, the currently active locale is used during client-transitions. For example: When using the next/router methods directly, you can specify the locale that should be used via the transition options. For example: Note that to handle switching only the locale while preserving all routing information such as dynamic route query values or hidden href query values, you can provide the href parameter as an object: See here for more information on the object structure for router.push. If you have a href that already includes the locale you can opt-out of automatically handling the locale prefixing: Leveraging the NEXTLOCALE cookie Next.js allows setting a NEXTLOCALE=the-locale cookie, which takes priority over the accept-language header. This cookie can be set using a language switcher and then when a user comes back to the site it will leverage the locale specified in the cookie when redirecting from / to the correct locale location. For example, if a user prefers the locale fr in their accept-language header but a NEXTLOCALE=en cookie is set the en locale when visiting / the user will be redirected to the en locale location until the cookie is removed or expired. Search Engine Optimization Since Next.js knows what language the user is visiting it will automatically add the lang attribute to the tag. Next.js doesn't know about variants of a page so it's up to you to add the hreflang meta tags using next/head. You can learn more about hreflang in the Google Webmasters documentation. How does this work with Static Generation? > Note that Internationalized Routing does not integrate with output: 'export' as it does not leverage the Next.js routing layer. Hybrid Next.js applications that do not use output: 'export' are fully supported. Dynamic Routes and getStaticProps Pages For pages using getStaticProps with Dynamic Routes, all locale variants of the page desired to be prerendered need to be returned from getStaticPaths. Along with the params object returned for paths, you can also return a locale field specifying which locale you want to render. For example: For Automatically Statically Optimized and non-dynamic getStaticProps pages, a version of the page will be generated for each locale. This is important to consider because it can increase build times depending on how many locales are configured inside getStaticProps. For example, if you have 50 locales configured with 10 non-dynamic pages using getStaticProps, this means getStaticProps will be called 500 times. 50 versions of the 10 pages will be generated during each build. To decrease the build time of dynamic pages with getStaticProps, use a fallback mode. This allows you to return only the most popular paths and locales from getStaticPaths for prerendering during the build. Then, Next.js will build the remaining pages at runtime as they are requested. Automatically Statically Optimized Pages For pages that are automatically statically optimized, a version of the page will be generated for each locale. Non-dynamic getStaticProps Pages For non-dynamic getStaticProps pages, a version is generated for each locale like above. getStaticProps is called with each locale that is being rendered. If you would like to opt-out of a certain locale from being pre-rendered, you can return notFound: true from getStaticProps and this variant of the page will not be generated. Limits for the i18n config - locales: 100 total locales - domains: 100 total locale domain items > Good to know: These limits have been added initially to prevent potential performance issues at build time. You can workaround these limits with custom routing using Proxy in Next.js 12.",
    "excerpt": "Examples - i18n routing Next.js has built-in support for internationalized (i18n) routing since v10.0.0. You can provide a list of locales, the default locale, and domain-specific locales and Next.js...",
    "url": "https://nextjs.org/docs/02-pages/02-guides/internationalization"
  },
  {
    "id": "02-pages-02-guides-lazy-loading",
    "path": "02-pages\\02-guides\\lazy-loading.mdx",
    "title": "How to lazy load Client Components and libraries",
    "description": "Lazy load imported libraries and React Components to improve your application's overall loading performance.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/02-guides/lazy-loading"
  },
  {
    "id": "02-pages-02-guides-mdx",
    "path": "02-pages\\02-guides\\mdx.mdx",
    "title": "How to use markdown and MDX in Next.js",
    "description": "Learn how to configure MDX to write JSX in your markdown files.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/02-guides/mdx"
  },
  {
    "id": "02-pages-02-guides-migrating-app-router-migration",
    "path": "02-pages\\02-guides\\migrating\\app-router-migration.mdx",
    "title": "How to migrate from Pages to the App Router",
    "description": "Learn how to upgrade your existing Next.js application from the Pages Router to the App Router.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/02-guides/migrating/app-router-migration"
  },
  {
    "id": "02-pages-02-guides-migrating-from-create-react-app",
    "path": "02-pages\\02-guides\\migrating\\from-create-react-app.mdx",
    "title": "How to migrate from Create React App to Next.js",
    "description": "Learn how to migrate your existing React application from Create React App to Next.js.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/02-guides/migrating/from-create-react-app"
  },
  {
    "id": "02-pages-02-guides-migrating-from-vite",
    "path": "02-pages\\02-guides\\migrating\\from-vite.mdx",
    "title": "How to migrate from Vite to Next.js",
    "description": "Learn how to migrate your existing React application from Vite to Next.js.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/02-guides/migrating/from-vite"
  },
  {
    "id": "02-pages-02-guides-migrating-index",
    "path": "02-pages\\02-guides\\migrating\\index.mdx",
    "title": "Migrating",
    "description": "Learn how to migrate from popular frameworks to Next.js",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/02-guides/migrating"
  },
  {
    "id": "02-pages-02-guides-multi-zones",
    "path": "02-pages\\02-guides\\multi-zones.mdx",
    "title": "How to build micro-frontends using multi-zones and Next.js",
    "description": "Learn how to build micro-frontends using Next.js Multi-Zones to deploy multiple Next.js apps under a single domain.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/02-guides/multi-zones"
  },
  {
    "id": "02-pages-02-guides-open-telemetry",
    "path": "02-pages\\02-guides\\open-telemetry.mdx",
    "title": "How to instrument your Next.js app with OpenTelemetry",
    "description": "Learn how to instrument your Next.js app with OpenTelemetry.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/02-guides/open-telemetry"
  },
  {
    "id": "02-pages-02-guides-package-bundling",
    "path": "02-pages\\02-guides\\package-bundling.mdx",
    "title": "How to optimize package bundling",
    "description": "Learn how to optimize your application's server and client bundles.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/02-guides/package-bundling"
  },
  {
    "id": "02-pages-02-guides-post-css",
    "path": "02-pages\\02-guides\\post-css.mdx",
    "title": "How to configure PostCSS in Next.js",
    "description": "Extend the PostCSS config and plugins added by Next.js with your own.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Default Behavior",
        "slug": "default-behavior"
      },
      {
        "level": 2,
        "text": "Customizing Target Browsers",
        "slug": "customizing-target-browsers"
      },
      {
        "level": 2,
        "text": "CSS Modules",
        "slug": "css-modules"
      },
      {
        "level": 2,
        "text": "Customizing Plugins",
        "slug": "customizing-plugins"
      }
    ],
    "codeBlocks": [
      {
        "language": "css",
        "code": "/* autoprefixer grid: autoplace */",
        "context": ""
      },
      {
        "language": "json",
        "code": "{\r\n  \"plugins\": [\r\n    \"postcss-flexbugs-fixes\",\r\n    [\r\n      \"postcss-preset-env\",\r\n      {\r\n        \"autoprefixer\": {\r\n          \"flexbox\": \"no-2009\",\r\n          \"grid\": \"autoplace\"\r\n        },\r\n        \"stage\": 3,\r\n        \"features\": {\r\n          \"custom-properties\": false\r\n        }\r\n      }\r\n    ]\r\n  ]\r\n}",
        "context": "filename=\"postcss.config.json\""
      },
      {
        "language": "json",
        "code": "{\r\n  \"browserslist\": [\">0.3%\", \"not dead\", \"not op_mini all\"]\r\n}",
        "context": "filename=\"package.json\""
      },
      {
        "language": "json",
        "code": "{\r\n  \"plugins\": [\r\n    \"postcss-flexbugs-fixes\",\r\n    [\r\n      \"postcss-preset-env\",\r\n      {\r\n        \"autoprefixer\": {\r\n          \"flexbox\": \"no-2009\"\r\n        },\r\n        \"stage\": 3,\r\n        \"features\": {\r\n          \"custom-properties\": false\r\n        }\r\n      }\r\n    ]\r\n  ]\r\n}",
        "context": "filename=\"postcss.config.json\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  plugins:\r\n    process.env.NODE_ENV === 'production'\r\n      ? [\r\n          'postcss-flexbugs-fixes',\r\n          [\r\n            'postcss-preset-env',\r\n            {\r\n              autoprefixer: {\r\n                flexbox: 'no-2009',\r\n              },\r\n              stage: 3,\r\n              features: {\r\n                'custom-properties': false,\r\n              },\r\n            },\r\n          ],\r\n        ]\r\n      : [\r\n          // No transformations in development\r\n        ],\r\n}",
        "context": "filename=\"postcss.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  plugins: {\r\n    'postcss-flexbugs-fixes': {},\r\n    'postcss-preset-env': {\r\n      autoprefixer: {\r\n        flexbox: 'no-2009',\r\n      },\r\n      stage: 3,\r\n      features: {\r\n        'custom-properties': false,\r\n      },\r\n    },\r\n  },\r\n}",
        "context": ""
      }
    ],
    "content": "Default Behavior Next.js compiles CSS for its built-in CSS support using PostCSS. Out of the box, with no configuration, Next.js compiles CSS with the following transformations: - Autoprefixer automatically adds vendor prefixes to CSS rules (back to IE11). - Cross-browser Flexbox bugs are corrected to behave like the spec. - New CSS features are automatically compiled for Internet Explorer 11 compatibility: - all Property - Break Properties - font-variant Property - Gap Properties - Media Query Ranges By default, CSS Grid and Custom Properties (CSS variables) are not compiled for IE11 support. To compile CSS Grid Layout for IE11, you can place the following comment at the top of your CSS file: You can also enable IE11 support for CSS Grid Layout in your entire project by configuring autoprefixer with the configuration shown below (collapsed). See \"Customizing Plugins\" below for more information. Click to view the configuration to enable CSS Grid Layout CSS variables are not compiled because it is not possible to safely do so. If you must use variables, consider using something like Sass variables which are compiled away by Sass. Customizing Target Browsers Next.js allows you to configure the target browsers (for Autoprefixer and compiled css features) through Browserslist. To customize browserslist, create a browserslist key in your package.json like so: You can use the browsersl.ist tool to visualize what browsers you are targeting. CSS Modules No configuration is needed to support CSS Modules. To enable CSS Modules for a file, rename the file to have the extension .module.css. You can learn more about Next.js' CSS Module support here. Customizing Plugins > Warning: When you define a custom PostCSS configuration file, Next.js completely disables the default behavior. > Be sure to manually configure all the features you need compiled, including Autoprefixer. > You also need to install any plugins included in your custom configuration manually, i.e. npm install postcss-flexbugs-fixes postcss-preset-env. To customize the PostCSS configuration, create a postcss.config.json file in the root of your project. This is the default configuration used by Next.js: > Good to know: Next.js also allows the file to be named .postcssrc.json, or, to be read from the postcss key in package.json. It is also possible to configure PostCSS with a postcss.config.js file, which is useful when you want to conditionally include plugins based on environment: > Good to know: Next.js also allows the file to be named .postcssrc.js. Do not use require() to import the PostCSS Plugins. Plugins must be provided as strings. > Good to know: If your postcss.config.js needs to support other non-Next.js tools in the same project, you must use the interoperable object-based format instead: > >",
    "excerpt": "Default Behavior Next.js compiles CSS for its built-in CSS support using PostCSS. Out of the box, with no configuration, Next.js compiles CSS with the following transformations: - Autoprefixer automat...",
    "url": "https://nextjs.org/docs/02-pages/02-guides/post-css"
  },
  {
    "id": "02-pages-02-guides-preview-mode",
    "path": "02-pages\\02-guides\\preview-mode.mdx",
    "title": "How to preview content with Preview Mode in Next.js",
    "description": "Next.js has the preview mode for statically generated pages. You can learn how it works here.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Step 1: Create and access a preview API route",
        "slug": "step-1-create-and-access-a-preview-api-route"
      },
      {
        "level": 3,
        "text": "Securely accessing it from your Headless CMS",
        "slug": "securely-accessing-it-from-your-headless-cms"
      },
      {
        "level": 2,
        "text": "Step 2: Update ",
        "slug": "step-2-update-"
      },
      {
        "level": 3,
        "text": "Fetch preview data",
        "slug": "fetch-preview-data"
      },
      {
        "level": 2,
        "text": "More Details",
        "slug": "more-details"
      },
      {
        "level": 3,
        "text": "Specify the Preview Mode duration",
        "slug": "specify-the-preview-mode-duration"
      },
      {
        "level": 3,
        "text": "Clear the Preview Mode cookies",
        "slug": "clear-the-preview-mode-cookies"
      },
      {
        "level": 3,
        "text": " size limits",
        "slug": "-size-limits"
      },
      {
        "level": 3,
        "text": "Works with ",
        "slug": "works-with-"
      },
      {
        "level": 3,
        "text": "Works with API Routes",
        "slug": "works-with-api-routes"
      },
      {
        "level": 3,
        "text": "Unique per ",
        "slug": "unique-per-"
      }
    ],
    "codeBlocks": [
      {
        "language": "js",
        "code": "export default function handler(req, res) {\r\n  // ...\r\n  res.setPreviewData({})\r\n  // ...\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "// simple example for testing it manually from your browser.\r\nexport default function handler(req, res) {\r\n  res.setPreviewData({})\r\n  res.end('Preview mode enabled')\r\n}",
        "context": "filename=\"pages/api/preview.js\""
      },
      {
        "language": "bash",
        "code": "https://<your-site>/api/preview?secret=<token>&slug=<path>",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "js",
        "code": "export default async (req, res) => {\r\n  // Check the secret and next parameters\r\n  // This secret should only be known to this API route and the CMS\r\n  if (req.query.secret !== 'MY_SECRET_TOKEN' || !req.query.slug) {\r\n    return res.status(401).json({ message: 'Invalid token' })\r\n  }\r\n\r\n  // Fetch the headless CMS to check if the provided `slug` exists\r\n  // getPostBySlug would implement the required fetching logic to the headless CMS\r\n  const post = await getPostBySlug(req.query.slug)\r\n\r\n  // If the slug doesn't exist prevent preview mode from being enabled\r\n  if (!post) {\r\n    return res.status(401).json({ message: 'Invalid slug' })\r\n  }\r\n\r\n  // Enable Preview Mode by setting the cookies\r\n  res.setPreviewData({})\r\n\r\n  // Redirect to the path from the fetched post\r\n  // We don't redirect to req.query.slug as that might lead to open redirect vulnerabilities\r\n  res.redirect(post.slug)\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "export async function getStaticProps(context) {\r\n  // If you request this page with the preview mode cookies set:\r\n  //\r\n  // - context.preview will be true\r\n  // - context.previewData will be the same as\r\n  //   the argument used for `setPreviewData`.\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "export async function getStaticProps(context) {\r\n  // If context.preview is true, append \"/preview\" to the API endpoint\r\n  // to request draft data instead of published data. This will vary\r\n  // based on which headless CMS you're using.\r\n  const res = await fetch(`https://.../${context.preview ? 'preview' : ''}`)\r\n  // ...\r\n}",
        "context": ""
      },
      {
        "language": "bash",
        "code": "https://<your-site>/api/preview?secret=<token>&slug=<path>",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "js",
        "code": "setPreviewData(data, {\r\n  maxAge: 60 * 60, // The preview mode cookies expire in 1 hour\r\n  path: '/about', // The preview mode cookies apply to paths with /about\r\n})",
        "context": ""
      },
      {
        "language": "js",
        "code": "export default function handler(req, res) {\r\n  res.clearPreviewData({})\r\n}",
        "context": "filename=\"pages/api/clear-preview-mode-cookies.js\""
      },
      {
        "language": "js",
        "code": "export default function handler(req, res) {\r\n  const { path } = req.query\r\n\r\n  res.clearPreviewData({ path })\r\n}",
        "context": "filename=\"pages/api/clear-preview-mode-cookies.js\""
      },
      {
        "language": "js",
        "code": "export default function myApiRoute(req, res) {\r\n  const isPreview = req.preview\r\n  const previewData = req.previewData\r\n  // ...\r\n}",
        "context": ""
      }
    ],
    "content": "> Note: This feature is superseded by Draft Mode. Examples - Agility CMS Example (Demo) - Builder.io Example (Demo) - ButterCMS Example (Demo) - Contentful Example (Demo) - Cosmic Example (Demo) - DatoCMS Example (Demo) - DotCMS Example (Demo) - Drupal Example (Demo) - Enterspeed Example (Demo) - GraphCMS Example (Demo) - Keystone Example (Demo) - Kontent.ai Example (Demo) - Makeswift Example (Demo) - Plasmic Example (Demo) - Prepr Example (Demo) - Prismic Example (Demo) - Sanity Example (Demo) - Sitecore XM Cloud Example (Demo) - Storyblok Example (Demo) - Strapi Example (Demo) - TakeShape Example (Demo) - Tina Example (Demo) - Umbraco Example (Demo) - Umbraco Heartcore Example (Demo) - Webiny Example (Demo) - WordPress Example (Demo) - Blog Starter Example (Demo) In the Pages documentation and the Data Fetching documentation, we talked about how to pre-render a page at build time (Static Generation) using getStaticProps and getStaticPaths. Static Generation is useful when your pages fetch data from a headless CMS. However, it’s not ideal when you’re writing a draft on your headless CMS and want to preview the draft immediately on your page. You’d want Next.js to render these pages at request time instead of build time and fetch the draft content instead of the published content. You’d want Next.js to bypass Static Generation only for this specific case. Next.js has a feature called Preview Mode which solves this problem. Here are instructions on how to use it. Step 1: Create and access a preview API route > Take a look at the API Routes documentation first if you’re not familiar with Next.js API Routes. First, create a preview API route. It can have any name - e.g. pages/api/preview.js (or .ts if using TypeScript). In this API route, you need to call setPreviewData on the response object. The argument for setPreviewData should be an object, and this can be used by getStaticProps (more on this later). For now, we’ll use {}. res.setPreviewData sets some cookies on the browser which turns on the preview mode. Any requests to Next.js containing these cookies will be considered as the preview mode, and the behavior for statically generated pages will change (more on this later). You can test this manually by creating an API route like below and accessing it from your browser manually: If you open your browser’s developer tools and visit /api/preview, you’ll notice that the prerenderbypass and nextpreviewdata cookies will be set on this request. Securely accessing it from your Headless CMS In practice, you’d want to call this API route securely from your headless CMS. The specific steps will vary depending on which headless CMS you’re using, but here are some common steps you could take. These steps assume that the headless CMS you’re using supports setting custom preview URLs. If it doesn’t, you can still use this method to secure your preview URLs, but you’ll need to construct and access the preview URL manually. First, you should create a secret token string using a token generator of your choice. This secret will only be known by your Next.js app and your headless CMS. This secret prevents people who don’t have access to your CMS from accessing preview URLs. Second, if your headless CMS supports setting custom preview URLs, specify the following as the preview URL. This assumes that your preview API route is located at pages/api/preview.js. - should be your deployment domain. - should be replaced with the secret token you generated. - should be the path for the page that you want to preview. If you want to preview /posts/foo, then you should use &slug=/posts/foo. Your headless CMS might allow you to include a variable in the preview URL so that can be set dynamically based on the CMS’s data like so: &slug=/posts/{entry.fields.slug} Finally, in the preview API route: - Check that the secret matches and that the slug parameter exists (if not, the request should fail). - - Call res.setPreviewData. - Then redirect the browser to the path specified by slug. (The following example uses a 307 redirect). If it succeeds, then the browser will be redirected to the path you want to preview with the preview mode cookies being set. Step 2: Update getStaticProps The next step is to update getStaticProps to support the preview mode. If you request a page which has getStaticProps with the preview mode cookies set (via res.setPreviewData), then getStaticProps will be called at request time (instead of at build time). Furthermore, it will be called with a context object where: - context.preview will be true. - context.previewData will be the same as the argument used for setPreviewData. We used res.setPreviewData({}) in the preview API route, so context.previewData will be {}. You can use this to pass session information from the preview API route to getStaticProps if necessary. If you’re also using getStaticPaths, then context.params will also be available. Fetch preview data You can update getStaticProps to fetch different data based on context.preview and/or context.previewData. For example, your headless CMS might have a different API endpoint for draft posts. If so, you can use context.preview to modify the API endpoint URL like below: That’s it! If you access the preview API route (with secret and slug) from your headless CMS or manually, you should now be able to see the preview content. And if you update your draft without publishing, you should be able to preview the draft. Set this as the preview URL on your headless CMS or access manually, and you should be able to see the preview. More Details > Good to know: during rendering next/router exposes an isPreview flag, see the router object docs for more info. Specify the Preview Mode duration setPreviewData takes an optional second parameter which should be an options object. It accepts the following keys: - maxAge: Specifies the number (in seconds) for the preview session to last for. - path: Specifies the path the cookie should be applied under. Defaults to / enabling preview mode for all paths. Clear the Preview Mode cookies By default, no expiration date is set for Preview Mode cookies, so the preview session ends when the browser is closed. To clear the Preview Mode cookies manually, create an API route that calls clearPreviewData(): Then, send a request to /api/clear-preview-mode-cookies to invoke the API Route. If calling this route using next/link, you must pass prefetch={false} to prevent calling clearPreviewData during link prefetching. If a path was specified in the setPreviewData call, you must pass the same path to clearPreviewData: previewData size limits You can pass an object to setPreviewData and have it be available in getStaticProps. However, because the data will be stored in a cookie, there’s a size limitation. Currently, preview data is limited to 2KB. Works with getServerSideProps The preview mode works on getServerSideProps as well. It will also be available on the context object containing preview and previewData. > Good to know: You shouldn't set the Cache-Control header when using Preview Mode because it cannot be bypassed. Instead, we recommend using ISR. Works with API Routes API Routes will have access to preview and previewData under the request object. For example: Unique per next build Both the bypass cookie value and the private key for encrypting the previewData change when next build is completed. This ensures that the bypass cookie can’t be guessed. > Good to know: To test Preview Mode locally over HTTP your browser will need to allow third-party cookies and local storage access.",
    "excerpt": "> Note: This feature is superseded by Draft Mode. Examples - Agility CMS Example (Demo) - Builder.io Example (Demo) - ButterCMS Example (Demo) - Contentful Example (Demo) - Cosmic Example (Demo) - Dat...",
    "url": "https://nextjs.org/docs/02-pages/02-guides/preview-mode"
  },
  {
    "id": "02-pages-02-guides-production-checklist",
    "path": "02-pages\\02-guides\\production-checklist.mdx",
    "title": "How to optimize your Next.js application for production",
    "description": "Recommendations to ensure the best performance and user experience before taking your Next.js application to production.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/02-guides/production-checklist"
  },
  {
    "id": "02-pages-02-guides-redirecting",
    "path": "02-pages\\02-guides\\redirecting.mdx",
    "title": "How to handle redirects in Next.js",
    "description": "Learn the different ways to handle redirects in Next.js.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/02-guides/redirecting"
  },
  {
    "id": "02-pages-02-guides-sass",
    "path": "02-pages\\02-guides\\sass.mdx",
    "title": "How to use Sass in Next.js",
    "description": "Learn how to use Sass in your Next.js application.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/02-guides/sass"
  },
  {
    "id": "02-pages-02-guides-scripts",
    "path": "02-pages\\02-guides\\scripts.mdx",
    "title": "How to load and optimize scripts",
    "description": "Optimize 3rd party scripts with the built-in Script component.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/02-guides/scripts"
  },
  {
    "id": "02-pages-02-guides-self-hosting",
    "path": "02-pages\\02-guides\\self-hosting.mdx",
    "title": "How to self-host your Next.js application",
    "description": "Learn how to self-host your Next.js application on a Node.js server, Docker image, or static HTML files (static exports).",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/02-guides/self-hosting"
  },
  {
    "id": "02-pages-02-guides-static-exports",
    "path": "02-pages\\02-guides\\static-exports.mdx",
    "title": "How to create a static export of your Next.js application",
    "description": "Next.js enables starting as a static site or Single-Page Application (SPA), then later optionally upgrading to use features that require a server.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/02-guides/static-exports"
  },
  {
    "id": "02-pages-02-guides-tailwind-v3-css",
    "path": "02-pages\\02-guides\\tailwind-v3-css.mdx",
    "title": "Tailwind CSS",
    "description": "Style your Next.js Application using Tailwind CSS.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/02-guides/tailwind-v3-css"
  },
  {
    "id": "02-pages-02-guides-testing-cypress",
    "path": "02-pages\\02-guides\\testing\\cypress.mdx",
    "title": "How to set up Cypress with Next.js",
    "description": "Learn how to set up Next.js with Cypress for End-to-End (E2E) and Component Testing.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/02-guides/testing/cypress"
  },
  {
    "id": "02-pages-02-guides-testing-index",
    "path": "02-pages\\02-guides\\testing\\index.mdx",
    "title": "Testing",
    "description": "Learn how to set up Next.js with three commonly used testing tools — Cypress, Playwright, Vitest, and Jest.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/02-guides/testing"
  },
  {
    "id": "02-pages-02-guides-testing-jest",
    "path": "02-pages\\02-guides\\testing\\jest.mdx",
    "title": "How to set up Jest with Next.js",
    "description": "Learn how to set up Next.js with Jest for Unit Testing.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/02-guides/testing/jest"
  },
  {
    "id": "02-pages-02-guides-testing-playwright",
    "path": "02-pages\\02-guides\\testing\\playwright.mdx",
    "title": "How to set up Playwright with Next.js",
    "description": "Learn how to set up Next.js with Playwright for End-to-End (E2E) and Integration testing.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/02-guides/testing/playwright"
  },
  {
    "id": "02-pages-02-guides-testing-vitest",
    "path": "02-pages\\02-guides\\testing\\vitest.mdx",
    "title": "How to set up Vitest with Next.js",
    "description": "Learn how to set up Next.js with Vitest and React Testing Library - two popular unit testing libraries.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/02-guides/testing/vitest"
  },
  {
    "id": "02-pages-02-guides-third-party-libraries",
    "path": "02-pages\\02-guides\\third-party-libraries.mdx",
    "title": "How to optimize third-party libraries",
    "description": "Optimize the performance of third-party libraries in your application with the `@next/third-parties` package.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/02-guides/third-party-libraries"
  },
  {
    "id": "02-pages-02-guides-upgrading-codemods",
    "path": "02-pages\\02-guides\\upgrading\\codemods.mdx",
    "title": "Codemods",
    "description": "Use codemods to upgrade your Next.js codebase when new features are released.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/02-guides/upgrading/codemods"
  },
  {
    "id": "02-pages-02-guides-upgrading-index",
    "path": "02-pages\\02-guides\\upgrading\\index.mdx",
    "title": "Upgrading",
    "description": "Learn how to upgrade to the latest versions of Next.js.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "Learn how to upgrade to the latest versions of Next.js following the versions-specific guides:",
    "excerpt": "Learn how to upgrade to the latest versions of Next.js following the versions-specific guides:",
    "url": "https://nextjs.org/docs/02-pages/02-guides/upgrading"
  },
  {
    "id": "02-pages-02-guides-upgrading-version-10",
    "path": "02-pages\\02-guides\\upgrading\\version-10.mdx",
    "title": "How to upgrade to version 10",
    "description": "Upgrade your Next.js Application from Version 9 to Version 10.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [
      {
        "language": "bash",
        "code": "npm i next@10",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "yarn add next@10",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "pnpm up next@10",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "bun add next@10",
        "context": "filename=\"Terminal\""
      }
    ],
    "content": "There were no breaking changes between versions 9 and 10. To upgrade to version 10, run the following command: > Good to know: If you are using TypeScript, ensure you also upgrade @types/react and @types/react-dom to their corresponding versions.",
    "excerpt": "There were no breaking changes between versions 9 and 10. To upgrade to version 10, run the following command: > Good to know: If you are using TypeScript, ensure you also upgrade @types/react and @ty...",
    "url": "https://nextjs.org/docs/02-pages/02-guides/upgrading/version-10"
  },
  {
    "id": "02-pages-02-guides-upgrading-version-11",
    "path": "02-pages\\02-guides\\upgrading\\version-11.mdx",
    "title": "How to upgrade to version 11",
    "description": "Upgrade your Next.js Application from Version 10 to Version 11.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 3,
        "text": "Webpack 5",
        "slug": "webpack-5"
      },
      {
        "level": 3,
        "text": "Cleaning the  is now a default",
        "slug": "cleaning-the-is-now-a-default"
      },
      {
        "level": 3,
        "text": " is now supported for  and ",
        "slug": "-is-now-supported-for-and-"
      },
      {
        "level": 3,
        "text": " customization to import images",
        "slug": "-customization-to-import-images"
      },
      {
        "level": 3,
        "text": "Remove  from ",
        "slug": "remove-from-"
      },
      {
        "level": 3,
        "text": "Remove  from ",
        "slug": "remove-from-"
      },
      {
        "level": 3,
        "text": "Remove  usage from page components",
        "slug": "remove-usage-from-page-components"
      },
      {
        "level": 3,
        "text": "Remove  property on ",
        "slug": "remove-property-on-"
      },
      {
        "level": 3,
        "text": "Remove  property on ",
        "slug": "remove-property-on-"
      },
      {
        "level": 3,
        "text": "Remove ",
        "slug": "remove-"
      },
      {
        "level": 3,
        "text": "Moment.js locales excluded by default",
        "slug": "momentjs-locales-excluded-by-default"
      },
      {
        "level": 3,
        "text": "Update usage of ",
        "slug": "update-usage-of-"
      },
      {
        "level": 2,
        "text": "React 16 to 17",
        "slug": "react-16-to-17"
      }
    ],
    "codeBlocks": [
      {
        "language": "bash",
        "code": "npm i next@11 react@17 react-dom@17",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "yarn add next@11 react@17 react-dom@17",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "pnpm up next@11 react@17 react-dom@17",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "bun add next@11 react@17 react-dom@17",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "text",
        "code": "PORT=4000 next start",
        "context": ""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    disableStaticImages: true,\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "import moment from 'moment'\r\nimport 'moment/locale/ja'\r\n\r\nmoment.locale('ja')",
        "context": ""
      },
      {
        "language": "js",
        "code": "useEffect(() => {\r\n  const handleRouteChange = (url, { shallow }) => {\r\n    console.log(\r\n      `App is changing to ${url} ${\r\n        shallow ? 'with' : 'without'\r\n      } shallow routing`\r\n    )\r\n  }\r\n\r\n  router.events.on('routeChangeStart', handleRouteChange)\r\n\r\n  // If the component is unmounted, unsubscribe\r\n  // from the event with the `off` method:\r\n  return () => {\r\n    router.events.off('routeChangeStart', handleRouteChange)\r\n  }\r\n}, [router])",
        "context": ""
      },
      {
        "language": "text",
        "code": "npm install react@latest react-dom@latest",
        "context": ""
      },
      {
        "language": "text",
        "code": "yarn add react@latest react-dom@latest",
        "context": ""
      }
    ],
    "content": "To upgrade to version 11, run the following command: > Good to know: If you are using TypeScript, ensure you also upgrade @types/react and @types/react-dom to their corresponding versions. Webpack 5 Webpack 5 is now the default for all Next.js applications. If you did not have a custom webpack configuration, your application is already using webpack 5. If you do have a custom webpack configuration, you can refer to the Next.js webpack 5 documentation for upgrade guidance. Cleaning the distDir is now a default The build output directory (defaults to .next) is now cleared by default except for the Next.js caches. You can refer to the cleaning distDir RFC for more information. If your application was relying on this behavior previously you can disable the new default behavior by adding the cleanDistDir: false flag in next.config.js. PORT is now supported for next dev and next start Next.js 11 supports the PORT environment variable to set the port the application runs on. Using -p/--port is still recommended but if you were prohibited from using -p in any way you can now use PORT as an alternative: Example: next.config.js customization to import images Next.js 11 supports static image imports with next/image. This new feature relies on being able to process image imports. If you previously added the next-images or next-optimized-images packages you can either move to the new built-in support using next/image or disable the feature: Remove super.componentDidCatch() from pages/app.js The next/app component's componentDidCatch was deprecated in Next.js 9 as it's no longer needed and has since been a no-op. In Next.js 11, it was removed. If your pages/app.js has a custom componentDidCatch method you can remove super.componentDidCatch as it is no longer needed. Remove Container from pages/app.js This export was deprecated in Next.js 9 as it's no longer needed and has since been a no-op with a warning during development. In Next.js 11 it was removed. If your pages/app.js imports Container from next/app you can remove Container as it was removed. Learn more in the documentation. Remove props.url usage from page components This property was deprecated in Next.js 4 and has since shown a warning during development. With the introduction of getStaticProps / getServerSideProps these methods already disallowed the usage of props.url. In Next.js 11, it was removed completely. You can learn more in the documentation. Remove unsized property on next/image The unsized property on next/image was deprecated in Next.js 10.0.1. You can use layout=\"fill\" instead. In Next.js 11 unsized was removed. Remove modules property on next/dynamic The modules and render option for next/dynamic were deprecated in Next.js 9.5. This was done in order to make the next/dynamic API closer to React.lazy. In Next.js 11, the modules and render options were removed. This option hasn't been mentioned in the documentation since Next.js 8 so it's less likely that your application is using it. If your application does use modules and render you can refer to the documentation. Remove Head.rewind Head.rewind has been a no-op since Next.js 9.5, in Next.js 11 it was removed. You can safely remove your usage of Head.rewind. Moment.js locales excluded by default Moment.js includes translations for a lot of locales by default. Next.js now automatically excludes these locales by default to optimize bundle size for applications using Moment.js. To load a specific locale use this snippet: You can opt-out of this new default by adding excludeDefaultMomentLocales: false to next.config.js if you do not want the new behavior, do note it's highly recommended to not disable this new optimization as it significantly reduces the size of Moment.js. Update usage of router.events In case you're accessing router.events during rendering, in Next.js 11 router.events is no longer provided during pre-rendering. Ensure you're accessing router.events in useEffect: If your application uses router.router.events which was an internal property that was not public please make sure to use router.events as well. React 16 to 17 React 17 introduced a new JSX Transform that brings a long-time Next.js feature to the wider React ecosystem: Not having to import React from 'react' when using JSX. When using React 17 Next.js will automatically use the new transform. This transform does not make the React variable global, which was an unintended side-effect of the previous Next.js implementation. A codemod is available to automatically fix cases where you accidentally used React without importing it. Most applications already use the latest version of React, with Next.js 11 the minimum React version has been updated to 17.0.2. To upgrade you can run the following command: Or using yarn:",
    "excerpt": "To upgrade to version 11, run the following command: > Good to know: If you are using TypeScript, ensure you also upgrade @types/react and @types/react-dom to their corresponding versions. Webpack 5 W...",
    "url": "https://nextjs.org/docs/02-pages/02-guides/upgrading/version-11"
  },
  {
    "id": "02-pages-02-guides-upgrading-version-12",
    "path": "02-pages\\02-guides\\upgrading\\version-12.mdx",
    "title": "How to upgrade to version 12",
    "description": "Upgrade your Next.js Application from Version 11 to Version 12.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 3,
        "text": "Upgrading to 12.2",
        "slug": "upgrading-to-122"
      },
      {
        "level": 3,
        "text": "Upgrading to 12.0",
        "slug": "upgrading-to-120"
      },
      {
        "level": 4,
        "text": "SWC replacing Babel",
        "slug": "swc-replacing-babel"
      },
      {
        "level": 4,
        "text": "SWC replacing Terser for minification",
        "slug": "swc-replacing-terser-for-minification"
      },
      {
        "level": 4,
        "text": "Improvements to styled-jsx CSS parsing",
        "slug": "improvements-to-styled-jsx-css-parsing"
      },
      {
        "level": 4,
        "text": " changed wrapping element",
        "slug": "-changed-wrapping-element"
      },
      {
        "level": 4,
        "text": "HMR connection now uses a WebSocket",
        "slug": "hmr-connection-now-uses-a-websocket"
      },
      {
        "level": 4,
        "text": "Webpack 4 support has been removed",
        "slug": "webpack-4-support-has-been-removed"
      },
      {
        "level": 4,
        "text": " option deprecated",
        "slug": "-option-deprecated"
      }
    ],
    "codeBlocks": [
      {
        "language": "bash",
        "code": "npm i next@12 react@17 react-dom@17 eslint-config-next@12",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "yarn add next@12 react@17 react-dom@17 eslint-config-next@12",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "pnpm up next@12 react@17 react-dom@17 eslint-config-next@12",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "bun add next@12 react@17 react-dom@17 eslint-config-next@12",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "npm install react@latest react-dom@latest\r\n\r\nyarn add react@latest react-dom@latest\r\n\r\npnpm update react@latest react-dom@latest\r\n\r\nbun add react@latest react-dom@latest",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  swcMinify: true,\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "nginx",
        "code": "location /_next/webpack-hmr {\r\n    proxy_pass http://localhost:3000/_next/webpack-hmr;\r\n    proxy_http_version 1.1;\r\n    proxy_set_header Upgrade $http_upgrade;\r\n    proxy_set_header Connection \"upgrade\";\r\n}",
        "context": ""
      },
      {
        "language": "text",
        "code": "<VirtualHost *:443>\r\n # ServerName yourwebsite.local\r\n ServerName \"${WEBSITE_SERVER_NAME}\"\r\n ProxyPass / http://localhost:3000/\r\n ProxyPassReverse / http://localhost:3000/\r\n # Next.js 12 uses websocket\r\n <Location /_next/webpack-hmr>\r\n    RewriteEngine On\r\n    RewriteCond %{QUERY_STRING} transport=websocket [NC]\r\n    RewriteCond %{HTTP:Upgrade} websocket [NC]\r\n    RewriteCond %{HTTP:Connection} upgrade [NC]\r\n    RewriteRule /(.*) ws://localhost:3000/_next/webpack-hmr/$1 [P,L]\r\n    ProxyPass ws://localhost:3000/_next/webpack-hmr retry=0 timeout=30\r\n    ProxyPassReverse ws://localhost:3000/_next/webpack-hmr\r\n </Location>\r\n</VirtualHost>",
        "context": ""
      },
      {
        "language": "js",
        "code": "app.all('/_next/webpack-hmr', (req, res) => {\r\n  nextjsRequestHandler(req, res)\r\n})",
        "context": ""
      }
    ],
    "content": "To upgrade to version 12, run the following command: > Good to know: If you are using TypeScript, ensure you also upgrade @types/react and @types/react-dom to their corresponding versions. Upgrading to 12.2 Middleware - If you were using Middleware prior to 12.2, please see the upgrade guide for more information. Upgrading to 12.0 Minimum Node.js Version - The minimum Node.js version has been bumped from 12.0.0 to 12.22.0 which is the first version of Node.js with native ES Modules support. Minimum React Version - The minimum required React version is 17.0.2. To upgrade you can run the following command in the terminal: SWC replacing Babel Next.js now uses the Rust-based compiler SWC to compile JavaScript/TypeScript. This new compiler is up to 17x faster than Babel when compiling individual files and up to 5x faster Fast Refresh. Next.js provides full backward compatibility with applications that have custom Babel configuration. All transformations that Next.js handles by default like styled-jsx and tree-shaking of getStaticProps / getStaticPaths / getServerSideProps have been ported to Rust. When an application has a custom Babel configuration, Next.js will automatically opt-out of using SWC for compiling JavaScript/Typescript and will fall back to using Babel in the same way that it was used in Next.js 11. Many of the integrations with external libraries that currently require custom Babel transformations will be ported to Rust-based SWC transforms in the near future. These include but are not limited to: - Styled Components - Emotion - Relay In order to prioritize transforms that will help you adopt SWC, please provide your .babelrc on this feedback thread. SWC replacing Terser for minification You can opt-in to replacing Terser with SWC for minifying JavaScript up to 7x faster using a flag in next.config.js: Minification using SWC is an opt-in flag to ensure it can be tested against more real-world Next.js applications before it becomes the default in Next.js 12.1. If you have feedback about minification, please leave it on this feedback thread. Improvements to styled-jsx CSS parsing On top of the Rust-based compiler we've implemented a new CSS parser based on the one used for the styled-jsx Babel transform. This new parser has improved handling of CSS and now errors when invalid CSS is used that would previously slip through and cause unexpected behavior. Because of this change invalid CSS will throw an error during development and next build. This change only affects styled-jsx usage. next/image changed wrapping element next/image now renders the inside a instead of . If your application has specific CSS targeting span such as .container span, upgrading to Next.js 12 might incorrectly match the wrapping element inside the component. You can avoid this by restricting the selector to a specific class such as .container span.item and updating the relevant component with that className, such as . If your application has specific CSS targeting the next/image tag, for example .container div, it may not match anymore. You can update the selector .container span, or preferably, add a new wrapping the component and target that instead such as .container .wrapper. The className prop is unchanged and will still be passed to the underlying element. See the documentation for more info. HMR connection now uses a WebSocket Previously, Next.js used a server-sent events connection to receive HMR events. Next.js 12 now uses a WebSocket connection. In some cases when proxying requests to the Next.js dev server, you will need to ensure the upgrade request is handled correctly. For example, in nginx you would need to add the following configuration: If you are using Apache (2.x), you can add the following configuration to enable web sockets to the server. Review the port, host name and server names. For custom servers, such as express, you may need to use app.all to ensure the request is passed correctly, for example: Webpack 4 support has been removed If you are already using webpack 5 you can skip this section. Next.js has adopted webpack 5 as the default for compilation in Next.js 11. As communicated in the webpack 5 upgrading documentation Next.js 12 removes support for webpack 4. If your application is still using webpack 4 using the opt-out flag, you will now see an error linking to the webpack 5 upgrading documentation. target option deprecated If you do not have target in next.config.js you can skip this section. The target option has been deprecated in favor of built-in support for tracing what dependencies are needed to run a page. During next build, Next.js will automatically trace each page and its dependencies to determine all of the files that are needed for deploying a production version of your application. If you are currently using the target option set to serverless, please read the documentation on how to leverage the new output.",
    "excerpt": "To upgrade to version 12, run the following command: > Good to know: If you are using TypeScript, ensure you also upgrade @types/react and @types/react-dom to their corresponding versions. Upgrading t...",
    "url": "https://nextjs.org/docs/02-pages/02-guides/upgrading/version-12"
  },
  {
    "id": "02-pages-02-guides-upgrading-version-13",
    "path": "02-pages\\02-guides\\upgrading\\version-13.mdx",
    "title": "How to upgrade to version 13",
    "description": "Upgrade your Next.js Application from Version 12 to 13.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Upgrading from 12 to 13",
        "slug": "upgrading-from-12-to-13"
      },
      {
        "level": 3,
        "text": "v13 Summary",
        "slug": "v13-summary"
      },
      {
        "level": 2,
        "text": "Migrating shared features",
        "slug": "migrating-shared-features"
      },
      {
        "level": 3,
        "text": " Component",
        "slug": "-component"
      },
      {
        "level": 3,
        "text": " Component",
        "slug": "-component"
      },
      {
        "level": 3,
        "text": " Component",
        "slug": "-component"
      },
      {
        "level": 3,
        "text": "Font Optimization",
        "slug": "font-optimization"
      }
    ],
    "codeBlocks": [
      {
        "language": "bash",
        "code": "npm i next@13 react@latest react-dom@latest eslint-config-next@13",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "yarn add next@13 react@latest react-dom@latest eslint-config-next@13",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "pnpm i next@13 react@latest react-dom@latest eslint-config-next@13",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "bun add next@13 react@latest react-dom@latest eslint-config-next@13",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\n// Next.js 12: `<a>` has to be nested otherwise it's excluded\r\n<Link href=\"/about\">\r\n  <a>About</a>\r\n</Link>\r\n\r\n// Next.js 13: `<Link>` always renders `<a>` under the hood\r\n<Link href=\"/about\">\r\n  About\r\n</Link>",
        "context": ""
      }
    ],
    "content": "Upgrading from 12 to 13 To update to Next.js version 13, run the following command using your preferred package manager: > Good to know: If you are using TypeScript, ensure you also upgrade @types/react and @types/react-dom to their latest versions. v13 Summary - The Supported Browsers have been changed to drop Internet Explorer and target modern browsers. - The minimum Node.js version has been bumped from 12.22.0 to 16.14.0, since 12.x and 14.x have reached end-of-life. - The minimum React version has been bumped from 17.0.2 to 18.2.0. - The swcMinify configuration property was changed from false to true. See Next.js Compiler for more info. - The next/image import was renamed to next/legacy/image. The next/future/image import was renamed to next/image. A codemod is available to safely and automatically rename your imports. - The next/link child can no longer be . Add the legacyBehavior prop to use the legacy behavior or remove the to upgrade. A codemod is available to automatically upgrade your code. - The target configuration property has been removed and superseded by Output File Tracing. Migrating shared features Next.js 13 introduces a new app directory with new features and conventions. However, upgrading to Next.js 13 does not require using the new app Router. You can continue using pages with new features that work in both directories, such as the updated Image component, Link component, Script component, and Font optimization. Component Next.js 12 introduced many improvements to the Image Component with a temporary import: next/future/image. These improvements included less client-side JavaScript, easier ways to extend and style images, better accessibility, and native browser lazy loading. Starting in Next.js 13, this new behavior is now the default for next/image. There are two codemods to help you migrate to the new Image Component: - next-image-to-legacy-image: This codemod will safely and automatically rename next/image imports to next/legacy/image to maintain the same behavior as Next.js 12. We recommend running this codemod to quickly update to Next.js 13 automatically. - next-image-experimental: After running the previous codemod, you can optionally run this experimental codemod to upgrade next/legacy/image to the new next/image, which will remove unused props and add inline styles. Please note this codemod is experimental and only covers static usage (such as ) but not dynamic usage (such as ). Alternatively, you can manually update by following the migration guide and also see the legacy comparison. Component The Component no longer requires manually adding an tag as a child. This behavior was added as an experimental option in version 12.2 and is now the default. In Next.js 13, always renders and allows you to forward props to the underlying tag. For example: To upgrade your links to Next.js 13, you can use the new-link codemod. Component The behavior of next/script has been updated to support both pages and app. If incrementally adopting app, read the upgrade guide. Font Optimization Previously, Next.js helped you optimize fonts by inlining font CSS. Version 13 introduces the new next/font module which gives you the ability to customize your font loading experience while still ensuring great performance and privacy. See Optimizing Fonts to learn how to use next/font.",
    "excerpt": "Upgrading from 12 to 13 To update to Next.js version 13, run the following command using your preferred package manager: > Good to know: If you are using TypeScript, ensure you also upgrade @types/rea...",
    "url": "https://nextjs.org/docs/02-pages/02-guides/upgrading/version-13"
  },
  {
    "id": "02-pages-02-guides-upgrading-version-14",
    "path": "02-pages\\02-guides\\upgrading\\version-14.mdx",
    "title": "How to upgrade to version 14",
    "description": "Upgrade your Next.js Application from Version 13 to 14.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/02-guides/upgrading/version-14"
  },
  {
    "id": "02-pages-02-guides-upgrading-version-9",
    "path": "02-pages\\02-guides\\upgrading\\version-9.mdx",
    "title": "How to upgrade to version 9",
    "description": "Upgrade your Next.js Application from Version 8 to Version 9.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Check your Custom App File ()",
        "slug": "check-your-custom-app-file-"
      },
      {
        "level": 2,
        "text": "Breaking Changes",
        "slug": "breaking-changes"
      },
      {
        "level": 3,
        "text": " is no longer necessary",
        "slug": "-is-no-longer-necessary"
      },
      {
        "level": 3,
        "text": "The  key is now an export on a page",
        "slug": "the-key-is-now-an-export-on-a-page"
      },
      {
        "level": 3,
        "text": " no longer renders \"loading...\" by default while loading",
        "slug": "-no-longer-renders-loading-by-default-while-loading"
      },
      {
        "level": 3,
        "text": " has been removed in favor of an exported configuration object",
        "slug": "-has-been-removed-in-favor-of-an-exported-configuration-object"
      },
      {
        "level": 3,
        "text": " no longer exports pages as ",
        "slug": "-no-longer-exports-pages-as-"
      },
      {
        "level": 3,
        "text": " is treated differently",
        "slug": "-is-treated-differently"
      },
      {
        "level": 2,
        "text": "Deprecated Features",
        "slug": "deprecated-features"
      },
      {
        "level": 3,
        "text": " has deprecated loading multiple modules at once",
        "slug": "-has-deprecated-loading-multiple-modules-at-once"
      }
    ],
    "codeBlocks": [
      {
        "language": "bash",
        "code": "npm i next@9",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "yarn add next@9",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "pnpm up next@9",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": "bun add next@9",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "js",
        "code": "class MyApp extends App {\r\n  // Remove me, I do nothing!\r\n  static async getInitialProps({ Component, ctx }) {\r\n    let pageProps = {}\r\n\r\n    if (Component.getInitialProps) {\r\n      pageProps = await Component.getInitialProps(ctx)\r\n    }\r\n\r\n    return { pageProps }\r\n  }\r\n\r\n  render() {\r\n    // ... etc\r\n  }\r\n}",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "import { NextContext } from 'next'\r\nimport { NextAppContext, DefaultAppIProps } from 'next/app'\r\nimport { NextDocumentContext, DefaultDocumentIProps } from 'next/document'",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "import { NextPageContext } from 'next'\r\nimport { AppContext, AppInitialProps } from 'next/app'\r\nimport { DocumentContext, DocumentInitialProps } from 'next/document'",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import dynamic from 'next/dynamic'\r\n\r\nconst DynamicComponentWithCustomLoading = dynamic(\r\n  () => import('../components/hello2'),\r\n  {\r\n    loading: () => <p>Loading</p>,\r\n  }\r\n)",
        "context": ""
      },
      {
        "language": "bash",
        "code": "curl -L https://github.com/vercel/next-codemod/archive/master.tar.gz | tar -xz --strip=2 next-codemod-master/transforms/withamp-to-config.js npx jscodeshift -t ./withamp-to-config.js pages/**/*.js",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "jsx",
        "code": "import { withAmp } from 'next/amp'\r\n\r\nfunction Home() {\r\n  return <h1>My AMP Page</h1>\r\n}\r\n\r\nexport default withAmp(Home)\r\n// or\r\nexport default withAmp(Home, { hybrid: true })",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "export default function Home() {\r\n  return <h1>My AMP Page</h1>\r\n}\r\n\r\nexport const config = {\r\n  amp: true,\r\n  // or\r\n  amp: 'hybrid',\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  trailingSlash: true,\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "jsx",
        "code": "import dynamic from 'next/dynamic'\r\n\r\nconst HelloBundle = dynamic({\r\n  modules: () => {\r\n    const components = {\r\n      Hello1: () => import('../components/hello1').then((m) => m.default),\r\n      Hello2: () => import('../components/hello2').then((m) => m.default),\r\n    }\r\n\r\n    return components\r\n  },\r\n  render: (props, { Hello1, Hello2 }) => (\r\n    <div>\r\n      <h1>{props.title}</h1>\r\n      <Hello1 />\r\n      <Hello2 />\r\n    </div>\r\n  ),\r\n})\r\n\r\nfunction DynamicBundle() {\r\n  return <HelloBundle title=\"Dynamic Bundle\" />\r\n}\r\n\r\nexport default DynamicBundle",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import dynamic from 'next/dynamic'\r\n\r\nconst Hello1 = dynamic(() => import('../components/hello1'))\r\nconst Hello2 = dynamic(() => import('../components/hello2'))\r\n\r\nfunction HelloBundle({ title }) {\r\n  return (\r\n    <div>\r\n      <h1>{title}</h1>\r\n      <Hello1 />\r\n      <Hello2 />\r\n    </div>\r\n  )\r\n}\r\n\r\nfunction DynamicBundle() {\r\n  return <HelloBundle title=\"Dynamic Bundle\" />\r\n}\r\n\r\nexport default DynamicBundle",
        "context": ""
      }
    ],
    "content": "To upgrade to version 9, run the following command: > Good to know: If you are using TypeScript, ensure you also upgrade @types/react and @types/react-dom to their corresponding versions. Check your Custom App File (pages/app.js) If you previously copied the Custom example, you may be able to remove your getInitialProps. Removing getInitialProps from pages/app.js (when possible) is important to leverage new Next.js features! The following getInitialProps does nothing and may be removed: Breaking Changes @zeit/next-typescript is no longer necessary Next.js will now ignore usage @zeit/next-typescript and warn you to remove it. Please remove this plugin from your next.config.js. Remove references to @zeit/next-typescript/babel from your custom .babelrc (if present). The usage of fork-ts-checker-webpack-plugin should also be removed from your next.config.js. TypeScript Definitions are published with the next package, so you need to uninstall @types/next as they would conflict. The following types are different: > This list was created by the community to help you upgrade, if you find other differences please send a pull-request to this list to help other users. From: to The config key is now an export on a page You may no longer export a custom variable named config from a page (i.e. export { config } / export const config ...). This exported variable is now used to specify page-level Next.js configuration like Opt-in AMP and API Route features. You must rename a non-Next.js-purposed config export to something different. next/dynamic no longer renders \"loading...\" by default while loading Dynamic components will not render anything by default while loading. You can still customize this behavior by setting the loading property: withAmp has been removed in favor of an exported configuration object Next.js now has the concept of page-level configuration, so the withAmp higher-order component has been removed for consistency. This change can be automatically migrated by running the following commands in the root of your Next.js project: To perform this migration by hand, or view what the codemod will produce, see below: Before After next export no longer exports pages as index.html Previously, exporting pages/about.js would result in out/about/index.html. This behavior has been changed to result in out/about.html. You can revert to the previous behavior by creating a next.config.js with the following content: pages/api/ is treated differently Pages in pages/api/ are now considered API Routes. Pages in this directory will no longer contain a client-side bundle. Deprecated Features next/dynamic has deprecated loading multiple modules at once The ability to load multiple modules at once has been deprecated in next/dynamic to be closer to React's implementation (React.lazy and Suspense). Updating code that relies on this behavior is relatively straightforward! We've provided an example of a before/after to help you migrate your application: Before After",
    "excerpt": "To upgrade to version 9, run the following command: > Good to know: If you are using TypeScript, ensure you also upgrade @types/react and @types/react-dom to their corresponding versions. Check your C...",
    "url": "https://nextjs.org/docs/02-pages/02-guides/upgrading/version-9"
  },
  {
    "id": "02-pages-03-building-your-application-01-routing-01-pages-and-layouts",
    "path": "02-pages\\03-building-your-application\\01-routing\\01-pages-and-layouts.mdx",
    "title": "Pages and Layouts",
    "description": "Create your first page and shared layout with the Pages Router.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Index routes",
        "slug": "index-routes"
      },
      {
        "level": 2,
        "text": "Nested routes",
        "slug": "nested-routes"
      },
      {
        "level": 2,
        "text": "Pages with Dynamic Routes",
        "slug": "pages-with-dynamic-routes"
      },
      {
        "level": 2,
        "text": "Layout Pattern",
        "slug": "layout-pattern"
      },
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Single Shared Layout with Custom App",
        "slug": "single-shared-layout-with-custom-app"
      },
      {
        "level": 3,
        "text": "Per-Page Layouts",
        "slug": "per-page-layouts"
      },
      {
        "level": 3,
        "text": "With TypeScript",
        "slug": "with-typescript"
      },
      {
        "level": 3,
        "text": "Data Fetching",
        "slug": "data-fetching"
      }
    ],
    "codeBlocks": [
      {
        "language": "jsx",
        "code": "export default function About() {\r\n  return <div>About</div>\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import Navbar from './navbar'\r\nimport Footer from './footer'\r\n\r\nexport default function Layout({ children }) {\r\n  return (\r\n    <>\r\n      <Navbar />\r\n      <main>{children}</main>\r\n      <Footer />\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"components/layout.js\""
      },
      {
        "language": "jsx",
        "code": "import Layout from '../components/layout'\r\n\r\nexport default function MyApp({ Component, pageProps }) {\r\n  return (\r\n    <Layout>\r\n      <Component {...pageProps} />\r\n    </Layout>\r\n  )\r\n}",
        "context": "filename=\"pages/_app.js\""
      },
      {
        "language": "jsx",
        "code": "\r\nimport Layout from '../components/layout'\r\nimport NestedLayout from '../components/nested-layout'\r\n\r\nexport default function Page() {\r\n  return (\r\n    /** Your content */\r\n  )\r\n}\r\n\r\nPage.getLayout = function getLayout(page) {\r\n  return (\r\n    <Layout>\r\n      <NestedLayout>{page}</NestedLayout>\r\n    </Layout>\r\n  )\r\n}",
        "context": "filename=\"pages/index.js\""
      },
      {
        "language": "jsx",
        "code": "export default function MyApp({ Component, pageProps }) {\r\n  // Use the layout defined at the page level, if available\r\n  const getLayout = Component.getLayout ?? ((page) => page)\r\n\r\n  return getLayout(<Component {...pageProps} />)\r\n}",
        "context": "filename=\"pages/_app.js\""
      },
      {
        "language": "tsx",
        "code": "import type { ReactElement } from 'react'\r\nimport Layout from '../components/layout'\r\nimport NestedLayout from '../components/nested-layout'\r\nimport type { NextPageWithLayout } from './_app'\r\n\r\nconst Page: NextPageWithLayout = () => {\r\n  return <p>hello world</p>\r\n}\r\n\r\nPage.getLayout = function getLayout(page: ReactElement) {\r\n  return (\r\n    <Layout>\r\n      <NestedLayout>{page}</NestedLayout>\r\n    </Layout>\r\n  )\r\n}\r\n\r\nexport default Page",
        "context": "filename=\"pages/index.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Layout from '../components/layout'\r\nimport NestedLayout from '../components/nested-layout'\r\n\r\nconst Page = () => {\r\n  return <p>hello world</p>\r\n}\r\n\r\nPage.getLayout = function getLayout(page) {\r\n  return (\r\n    <Layout>\r\n      <NestedLayout>{page}</NestedLayout>\r\n    </Layout>\r\n  )\r\n}\r\n\r\nexport default Page",
        "context": "filename=\"pages/index.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "import type { ReactElement, ReactNode } from 'react'\r\nimport type { NextPage } from 'next'\r\nimport type { AppProps } from 'next/app'\r\n\r\nexport type NextPageWithLayout<P = {}, IP = P> = NextPage<P, IP> & {\r\n  getLayout?: (page: ReactElement) => ReactNode\r\n}\r\n\r\ntype AppPropsWithLayout = AppProps & {\r\n  Component: NextPageWithLayout\r\n}\r\n\r\nexport default function MyApp({ Component, pageProps }: AppPropsWithLayout) {\r\n  // Use the layout defined at the page level, if available\r\n  const getLayout = Component.getLayout ?? ((page) => page)\r\n\r\n  return getLayout(<Component {...pageProps} />)\r\n}",
        "context": "filename=\"pages/_app.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function MyApp({ Component, pageProps }) {\r\n  // Use the layout defined at the page level, if available\r\n  const getLayout = Component.getLayout ?? ((page) => page)\r\n\r\n  return getLayout(<Component {...pageProps} />)\r\n}",
        "context": "filename=\"pages/_app.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "import useSWR from 'swr'\r\nimport Navbar from './navbar'\r\nimport Footer from './footer'\r\n\r\nexport default function Layout({ children }) {\r\n  const { data, error } = useSWR('/api/navigation', fetcher)\r\n\r\n  if (error) return <div>Failed to load</div>\r\n  if (!data) return <div>Loading...</div>\r\n\r\n  return (\r\n    <>\r\n      <Navbar links={data.links} />\r\n      <main>{children}</main>\r\n      <Footer />\r\n    </>\r\n  )\r\n}",
        "context": "filename=\"components/layout.js\""
      }
    ],
    "content": "The Pages Router has a file-system based router built on the concept of pages. When a file is added to the pages directory, it's automatically available as a route. In Next.js, a page is a React Component exported from a .js, .jsx, .ts, or .tsx file in the pages directory. Each page is associated with a route based on its file name. Example: If you create pages/about.js that exports a React component like below, it will be accessible at /about. Index routes The router will automatically route files named index to the root of the directory. - pages/index.js → / - pages/blog/index.js → /blog Nested routes The router supports nested files. If you create a nested folder structure, files will automatically be routed in the same way still. - pages/blog/first-post.js → /blog/first-post - pages/dashboard/settings/username.js → /dashboard/settings/username Pages with Dynamic Routes Next.js supports pages with dynamic routes. For example, if you create a file called pages/posts/[id].js, then it will be accessible at posts/1, posts/2, etc. > To learn more about dynamic routing, check the Dynamic Routing documentation. Layout Pattern The React model allows us to deconstruct a page into a series of components. Many of these components are often reused between pages. For example, you might have the same navigation bar and footer on every page. Examples Single Shared Layout with Custom App If you only have one layout for your entire application, you can create a Custom App and wrap your application with the layout. Since the component is re-used when changing pages, its component state will be preserved (e.g. input values). Per-Page Layouts If you need multiple layouts, you can add a property getLayout to your page, allowing you to return a React component for the layout. This allows you to define the layout on a per-page basis. Since we're returning a function, we can have complex nested layouts if desired. When navigating between pages, we want to persist page state (input values, scroll position, etc.) for a Single-Page Application (SPA) experience. This layout pattern enables state persistence because the React component tree is maintained between page transitions. With the component tree, React can understand which elements have changed to preserve state. > Good to know: This process is called reconciliation, which is how React understands which elements have changed. With TypeScript When using TypeScript, you must first create a new type for your pages which includes a getLayout function. Then, you must create a new type for your AppProps which overrides the Component property to use the previously created type. Data Fetching Inside your layout, you can fetch data on the client-side using useEffect or a library like SWR. Because this file is not a Page, you cannot use getStaticProps or getServerSideProps currently.",
    "excerpt": "The Pages Router has a file-system based router built on the concept of pages. When a file is added to the pages directory, it's automatically available as a route. In Next.js, a page is a React Compo...",
    "url": "https://nextjs.org/docs/02-pages/03-building-your-application/01-routing/01-pages-and-layouts"
  },
  {
    "id": "02-pages-03-building-your-application-01-routing-02-dynamic-routes",
    "path": "02-pages\\03-building-your-application\\01-routing\\02-dynamic-routes.mdx",
    "title": "Dynamic Routes",
    "description": "Dynamic Routes are pages that allow you to add custom params to your URLs. Start creating Dynamic Routes and learn more here.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Convention",
        "slug": "convention"
      },
      {
        "level": 2,
        "text": "Example",
        "slug": "example"
      },
      {
        "level": 2,
        "text": "Catch-all Segments",
        "slug": "catch-all-segments"
      },
      {
        "level": 2,
        "text": "Optional Catch-all Segments",
        "slug": "optional-catch-all-segments"
      }
    ],
    "codeBlocks": [
      {
        "language": "jsx",
        "code": "import { useRouter } from 'next/router'\r\n\r\nexport default function Page() {\r\n  const router = useRouter()\r\n  return <p>Post: {router.query.slug}</p>\r\n}",
        "context": ""
      }
    ],
    "content": "When you don't know the exact segment names ahead of time and want to create routes from dynamic data, you can use Dynamic Segments that are filled in at request time or prerendered at build time. Convention A Dynamic Segment can be created by wrapping a file or folder name in square brackets: [segmentName]. For example, [id] or [slug]. Dynamic Segments can be accessed from useRouter. Example For example, a blog could include the following route pages/blog/[slug].js where [slug] is the Dynamic Segment for blog posts. | Route | Example URL | params | | ---------------------- | ----------- | --------------- | | pages/blog/[slug].js | /blog/a | { slug: 'a' } | | pages/blog/[slug].js | /blog/b | { slug: 'b' } | | pages/blog/[slug].js | /blog/c | { slug: 'c' } | Catch-all Segments Dynamic Segments can be extended to catch-all subsequent segments by adding an ellipsis inside the brackets [...segmentName]. For example, pages/shop/[...slug].js will match /shop/clothes, but also /shop/clothes/tops, /shop/clothes/tops/t-shirts, and so on. | Route | Example URL | params | | ------------------------- | ------------- | --------------------------- | | pages/shop/[...slug].js | /shop/a | { slug: ['a'] } | | pages/shop/[...slug].js | /shop/a/b | { slug: ['a', 'b'] } | | pages/shop/[...slug].js | /shop/a/b/c | { slug: ['a', 'b', 'c'] } | Optional Catch-all Segments Catch-all Segments can be made optional by including the parameter in double square brackets: [[...segmentName]]. For example, pages/shop/[[...slug]].js will also match /shop, in addition to /shop/clothes, /shop/clothes/tops, /shop/clothes/tops/t-shirts. The difference between catch-all and optional catch-all segments is that with optional, the route without the parameter is also matched (/shop in the example above). | Route | Example URL | params | | --------------------------- | ------------- | --------------------------- | | pages/shop/[[...slug]].js | /shop | { slug: undefined } | | pages/shop/[[...slug]].js | /shop/a | { slug: ['a'] } | | pages/shop/[[...slug]].js | /shop/a/b | { slug: ['a', 'b'] } | | pages/shop/[[...slug]].js | /shop/a/b/c | { slug: ['a', 'b', 'c'] } |",
    "excerpt": "When you don't know the exact segment names ahead of time and want to create routes from dynamic data, you can use Dynamic Segments that are filled in at request time or prerendered at build time. Con...",
    "url": "https://nextjs.org/docs/02-pages/03-building-your-application/01-routing/02-dynamic-routes"
  },
  {
    "id": "02-pages-03-building-your-application-01-routing-03-linking-and-navigating",
    "path": "02-pages\\03-building-your-application\\01-routing\\03-linking-and-navigating.mdx",
    "title": "Linking and Navigating",
    "description": "Learn how navigation works in Next.js, and how to use the Link Component and `useRouter` hook.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Linking to dynamic paths",
        "slug": "linking-to-dynamic-paths"
      },
      {
        "level": 2,
        "text": "Injecting the router",
        "slug": "injecting-the-router"
      },
      {
        "level": 2,
        "text": "Imperative Routing",
        "slug": "imperative-routing"
      },
      {
        "level": 2,
        "text": "Shallow Routing",
        "slug": "shallow-routing"
      },
      {
        "level": 3,
        "text": "Caveats",
        "slug": "caveats"
      }
    ],
    "codeBlocks": [
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\nfunction Home() {\r\n  return (\r\n    <ul>\r\n      <li>\r\n        <Link href=\"/\">Home</Link>\r\n      </li>\r\n      <li>\r\n        <Link href=\"/about\">About Us</Link>\r\n      </li>\r\n      <li>\r\n        <Link href=\"/blog/hello-world\">Blog Post</Link>\r\n      </li>\r\n    </ul>\r\n  )\r\n}\r\n\r\nexport default Home",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\nfunction Posts({ posts }) {\r\n  return (\r\n    <ul>\r\n      {posts.map((post) => (\r\n        <li key={post.id}>\r\n          <Link href={`/blog/${encodeURIComponent(post.slug)}`}>\r\n            {post.title}\r\n          </Link>\r\n        </li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}\r\n\r\nexport default Posts",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\n\r\nfunction Posts({ posts }) {\r\n  return (\r\n    <ul>\r\n      {posts.map((post) => (\r\n        <li key={post.id}>\r\n          <Link\r\n            href={{\r\n              pathname: '/blog/[slug]',\r\n              query: { slug: post.slug },\r\n            }}\r\n          >\r\n            {post.title}\r\n          </Link>\r\n        </li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}\r\n\r\nexport default Posts",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import { useRouter } from 'next/router'\r\n\r\nexport default function ReadMore() {\r\n  const router = useRouter()\r\n\r\n  return (\r\n    <button onClick={() => router.push('/about')}>\r\n      Click here to read more\r\n    </button>\r\n  )\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import { useEffect } from 'react'\r\nimport { useRouter } from 'next/router'\r\n\r\n// Current URL is '/'\r\nfunction Page() {\r\n  const router = useRouter()\r\n\r\n  useEffect(() => {\r\n    // Always do navigations after the first render\r\n    router.push('/?counter=10', undefined, { shallow: true })\r\n  }, [])\r\n\r\n  useEffect(() => {\r\n    // The counter changed!\r\n  }, [router.query.counter])\r\n}\r\n\r\nexport default Page",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "componentDidUpdate(prevProps) {\r\n  const { pathname, query } = this.props.router\r\n  // verify props have changed to avoid an infinite loop\r\n  if (query.counter !== prevProps.router.query.counter) {\r\n    // fetch data based on the new query\r\n  }\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "router.push('/?counter=10', '/about?counter=10', { shallow: true })",
        "context": ""
      }
    ],
    "content": "The Next.js router allows you to do client-side route transitions between pages, similar to a single-page application. A React component called Link is provided to do this client-side route transition. The example above uses multiple links. Each one maps a path (href) to a known page: - / → pages/index.js - /about → pages/about.js - /blog/hello-world → pages/blog/[slug].js Any in the viewport (initially or through scroll) will be prefetched by default (including the corresponding data) for pages using Static Generation. The corresponding data for server-rendered routes is fetched only when the is clicked. Linking to dynamic paths You can also use interpolation to create the path, which comes in handy for dynamic route segments. For example, to show a list of posts which have been passed to the component as a prop: > encodeURIComponent is used in the example to keep the path utf-8 compatible. Alternatively, using a URL Object: Now, instead of using interpolation to create the path, we use a URL object in href where: - pathname is the name of the page in the pages directory. /blog/[slug] in this case. - query is an object with the dynamic segment. slug in this case. Injecting the router To access the router object in a React component you can use useRouter or withRouter. In general we recommend using useRouter. Imperative Routing next/link should be able to cover most of your routing needs, but you can also do client-side navigations without it, take a look at the documentation for next/router. The following example shows how to do basic page navigations with useRouter: Shallow Routing Examples - Shallow Routing Shallow routing allows you to change the URL without running data fetching methods again, that includes getServerSideProps, getStaticProps, and getInitialProps. You'll receive the updated pathname and the query via the router object (added by useRouter or withRouter), without losing state. To enable shallow routing, set the shallow option to true. Consider the following example: The URL will get updated to /?counter=10 and the page won't get replaced, only the state of the route is changed. You can also watch for URL changes via componentDidUpdate as shown below: Caveats Shallow routing only works for URL changes in the current page. For example, let's assume we have another page called pages/about.js, and you run this: Since that's a new page, it'll unload the current page, load the new one and wait for data fetching even though we asked to do shallow routing. When shallow routing is used with proxy it will not ensure the new page matches the current page like previously done without proxy. This is due to proxy being able to rewrite dynamically and can't be verified client-side without a data fetch which is skipped with shallow, so a shallow route change must always be treated as shallow.",
    "excerpt": "The Next.js router allows you to do client-side route transitions between pages, similar to a single-page application. A React component called Link is provided to do this client-side route transition...",
    "url": "https://nextjs.org/docs/02-pages/03-building-your-application/01-routing/03-linking-and-navigating"
  },
  {
    "id": "02-pages-03-building-your-application-01-routing-05-custom-app",
    "path": "02-pages\\03-building-your-application\\01-routing\\05-custom-app.mdx",
    "title": "Custom App",
    "description": "Control page initialization and add a layout that persists for all pages by overriding the default App component used by Next.js.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Usage",
        "slug": "usage"
      },
      {
        "level": 2,
        "text": " with ",
        "slug": "-with-"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "import type { AppProps } from 'next/app'\r\n\r\nexport default function MyApp({ Component, pageProps }: AppProps) {\r\n  return <Component {...pageProps} />\r\n}",
        "context": "filename=\"pages/_app.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export default function MyApp({ Component, pageProps }) {\r\n  return <Component {...pageProps} />\r\n}",
        "context": "filename=\"pages/_app.jsx\" switcher"
      },
      {
        "language": "tsx",
        "code": "import App, { AppContext, AppInitialProps, AppProps } from 'next/app'\r\n\r\ntype AppOwnProps = { example: string }\r\n\r\nexport default function MyApp({\r\n  Component,\r\n  pageProps,\r\n  example,\r\n}: AppProps & AppOwnProps) {\r\n  return (\r\n    <>\r\n      <p>Data: {example}</p>\r\n      <Component {...pageProps} />\r\n    </>\r\n  )\r\n}\r\n\r\nMyApp.getInitialProps = async (\r\n  context: AppContext\r\n): Promise<AppOwnProps & AppInitialProps> => {\r\n  const ctx = await App.getInitialProps(context)\r\n\r\n  return { ...ctx, example: 'data' }\r\n}",
        "context": "filename=\"pages/_app.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import App from 'next/app'\r\n\r\nexport default function MyApp({ Component, pageProps, example }) {\r\n  return (\r\n    <>\r\n      <p>Data: {example}</p>\r\n      <Component {...pageProps} />\r\n    </>\r\n  )\r\n}\r\n\r\nMyApp.getInitialProps = async (context) => {\r\n  const ctx = await App.getInitialProps(context)\r\n\r\n  return { ...ctx, example: 'data' }\r\n}",
        "context": "filename=\"pages/_app.jsx\" switcher"
      }
    ],
    "content": "Next.js uses the App component to initialize pages. You can override it and control the page initialization and: - Create a shared layout between page changes - Inject additional data into pages - Add global CSS Usage To override the default App, create the file pages/app as shown below: The Component prop is the active page, so whenever you navigate between routes, Component will change to the new page. Therefore, any props you send to Component will be received by the page. pageProps is an object with the initial props that were preloaded for your page by one of our data fetching methods, otherwise it's an empty object. > Good to know: > > - If your app is running and you added a custom App, you'll need to restart the development server. Only required if pages/app.js didn't exist before. > - App does not support Next.js Data Fetching methods like getStaticProps or getServerSideProps. getInitialProps with App Using getInitialProps in App will disable Automatic Static Optimization for pages without getStaticProps. We do not recommend using this pattern. Instead, consider incrementally adopting the App Router, which allows you to more easily fetch data for pages and layouts.",
    "excerpt": "Next.js uses the App component to initialize pages. You can override it and control the page initialization and: - Create a shared layout between page changes - Inject additional data into pages - Add...",
    "url": "https://nextjs.org/docs/02-pages/03-building-your-application/01-routing/05-custom-app"
  },
  {
    "id": "02-pages-03-building-your-application-01-routing-06-custom-document",
    "path": "02-pages\\03-building-your-application\\01-routing\\06-custom-document.mdx",
    "title": "Custom Document",
    "description": "Extend the default document markup added by Next.js.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Caveats",
        "slug": "caveats"
      },
      {
        "level": 2,
        "text": "Customizing ",
        "slug": "customizing-"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "import { Html, Head, Main, NextScript } from 'next/document'\r\n\r\nexport default function Document() {\r\n  return (\r\n    <Html lang=\"en\">\r\n      <Head />\r\n      <body>\r\n        <Main />\r\n        <NextScript />\r\n      </body>\r\n    </Html>\r\n  )\r\n}",
        "context": "filename=\"pages/_document.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import { Html, Head, Main, NextScript } from 'next/document'\r\n\r\nexport default function Document() {\r\n  return (\r\n    <Html lang=\"en\">\r\n      <Head />\r\n      <body>\r\n        <Main />\r\n        <NextScript />\r\n      </body>\r\n    </Html>\r\n  )\r\n}",
        "context": "filename=\"pages/_document.jsx\" switcher"
      },
      {
        "language": "tsx",
        "code": "import Document, {\r\n  Html,\r\n  Head,\r\n  Main,\r\n  NextScript,\r\n  DocumentContext,\r\n  DocumentInitialProps,\r\n} from 'next/document'\r\n\r\nclass MyDocument extends Document {\r\n  static async getInitialProps(\r\n    ctx: DocumentContext\r\n  ): Promise<DocumentInitialProps> {\r\n    const originalRenderPage = ctx.renderPage\r\n\r\n    // Run the React rendering logic synchronously\r\n    ctx.renderPage = () =>\r\n      originalRenderPage({\r\n        // Useful for wrapping the whole react tree\r\n        enhanceApp: (App) => App,\r\n        // Useful for wrapping in a per-page basis\r\n        enhanceComponent: (Component) => Component,\r\n      })\r\n\r\n    // Run the parent `getInitialProps`, it now includes the custom `renderPage`\r\n    const initialProps = await Document.getInitialProps(ctx)\r\n\r\n    return initialProps\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <Html lang=\"en\">\r\n        <Head />\r\n        <body>\r\n          <Main />\r\n          <NextScript />\r\n        </body>\r\n      </Html>\r\n    )\r\n  }\r\n}\r\n\r\nexport default MyDocument",
        "context": "filename=\"pages/_document.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import Document, { Html, Head, Main, NextScript } from 'next/document'\r\n\r\nclass MyDocument extends Document {\r\n  static async getInitialProps(ctx) {\r\n    const originalRenderPage = ctx.renderPage\r\n\r\n    // Run the React rendering logic synchronously\r\n    ctx.renderPage = () =>\r\n      originalRenderPage({\r\n        // Useful for wrapping the whole react tree\r\n        enhanceApp: (App) => App,\r\n        // Useful for wrapping in a per-page basis\r\n        enhanceComponent: (Component) => Component,\r\n      })\r\n\r\n    // Run the parent `getInitialProps`, it now includes the custom `renderPage`\r\n    const initialProps = await Document.getInitialProps(ctx)\r\n\r\n    return initialProps\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <Html lang=\"en\">\r\n        <Head />\r\n        <body>\r\n          <Main />\r\n          <NextScript />\r\n        </body>\r\n      </Html>\r\n    )\r\n  }\r\n}\r\n\r\nexport default MyDocument",
        "context": "filename=\"pages/_document.jsx\" switcher"
      }
    ],
    "content": "A custom Document can update the and tags used to render a Page. To override the default Document, create the file pages/document as shown below: > Good to know: > > - document is only rendered on the server, so event handlers like onClick cannot be used in this file. > - , , and are required for the page to be properly rendered. Caveats - The component used in document is not the same as next/head. The component used here should only be used for any code that is common for all pages. For all other cases, such as tags, we recommend using next/head in your pages or components. - React components outside of will not be initialized by the browser. Do not add application logic here or custom CSS (like styled-jsx). If you need shared components in all your pages (like a menu or a toolbar), read Layouts instead. - Document currently does not support Next.js Data Fetching methods like getStaticProps or getServerSideProps. Customizing renderPage Customizing renderPage is advanced and only needed for libraries like CSS-in-JS to support server-side rendering. This is not needed for built-in styled-jsx support. We do not recommend using this pattern. Instead, consider incrementally adopting the App Router, which allows you to more easily fetch data for pages and layouts. > Good to know: > > - getInitialProps in document is not called during client-side transitions. > - The ctx object for document is equivalent to the one received in getInitialProps, with the addition of renderPage.",
    "excerpt": "A custom Document can update the and tags used to render a Page. To override the default Document, create the file pages/document as shown below: > Good to know: > > - document is only rendered on the...",
    "url": "https://nextjs.org/docs/02-pages/03-building-your-application/01-routing/06-custom-document"
  },
  {
    "id": "02-pages-03-building-your-application-01-routing-07-api-routes",
    "path": "02-pages\\03-building-your-application\\01-routing\\07-api-routes.mdx",
    "title": "API Routes",
    "description": "Next.js supports API Routes, which allow you to build your API without leaving your Next.js app. Learn how it works here.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Parameters",
        "slug": "parameters"
      },
      {
        "level": 2,
        "text": "HTTP Methods",
        "slug": "http-methods"
      },
      {
        "level": 2,
        "text": "Request Helpers",
        "slug": "request-helpers"
      },
      {
        "level": 3,
        "text": "Custom config",
        "slug": "custom-config"
      },
      {
        "level": 2,
        "text": "Response Helpers",
        "slug": "response-helpers"
      },
      {
        "level": 3,
        "text": "Setting the status code of a response",
        "slug": "setting-the-status-code-of-a-response"
      },
      {
        "level": 3,
        "text": "Sending a JSON response",
        "slug": "sending-a-json-response"
      },
      {
        "level": 3,
        "text": "Sending a HTTP response",
        "slug": "sending-a-http-response"
      },
      {
        "level": 3,
        "text": "Redirects to a specified path or URL",
        "slug": "redirects-to-a-specified-path-or-url"
      },
      {
        "level": 3,
        "text": "Adding TypeScript types",
        "slug": "adding-typescript-types"
      },
      {
        "level": 2,
        "text": "Dynamic API Routes",
        "slug": "dynamic-api-routes"
      },
      {
        "level": 3,
        "text": "Catch all API routes",
        "slug": "catch-all-api-routes"
      },
      {
        "level": 3,
        "text": "Optional catch all API routes",
        "slug": "optional-catch-all-api-routes"
      },
      {
        "level": 3,
        "text": "Caveats",
        "slug": "caveats"
      },
      {
        "level": 2,
        "text": "Streaming responses",
        "slug": "streaming-responses"
      }
    ],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "import type { NextApiRequest, NextApiResponse } from 'next'\r\n\r\ntype ResponseData = {\r\n  message: string\r\n}\r\n\r\nexport default function handler(\r\n  req: NextApiRequest,\r\n  res: NextApiResponse<ResponseData>\r\n) {\r\n  res.status(200).json({ message: 'Hello from Next.js!' })\r\n}",
        "context": "filename=\"pages/api/hello.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export default function handler(req, res) {\r\n  res.status(200).json({ message: 'Hello from Next.js!' })\r\n}",
        "context": "filename=\"pages/api/hello.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "export default function handler(req: NextApiRequest, res: NextApiResponse) {\r\n  // ...\r\n}",
        "context": ""
      },
      {
        "language": "ts",
        "code": "import type { NextApiRequest, NextApiResponse } from 'next'\r\n\r\nexport default function handler(req: NextApiRequest, res: NextApiResponse) {\r\n  if (req.method === 'POST') {\r\n    // Process a POST request\r\n  } else {\r\n    // Handle any other HTTP method\r\n  }\r\n}",
        "context": "filename=\"pages/api/hello.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export default function handler(req, res) {\r\n  if (req.method === 'POST') {\r\n    // Process a POST request\r\n  } else {\r\n    // Handle any other HTTP method\r\n  }\r\n}",
        "context": "filename=\"pages/api/hello.js\" switcher"
      },
      {
        "language": "js",
        "code": "export const config = {\r\n  api: {\r\n    bodyParser: {\r\n      sizeLimit: '1mb',\r\n    },\r\n  },\r\n  // Specifies the maximum allowed duration for this function to execute (in seconds)\r\n  maxDuration: 5,\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "export const config = {\r\n  api: {\r\n    bodyParser: false,\r\n  },\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "export const config = {\r\n  api: {\r\n    bodyParser: {\r\n      sizeLimit: '500kb',\r\n    },\r\n  },\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "export const config = {\r\n  api: {\r\n    externalResolver: true,\r\n  },\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "export const config = {\r\n  api: {\r\n    responseLimit: false,\r\n  },\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "export const config = {\r\n  api: {\r\n    responseLimit: '8mb',\r\n  },\r\n}",
        "context": ""
      },
      {
        "language": "ts",
        "code": "import type { NextApiRequest, NextApiResponse } from 'next'\r\n\r\ntype ResponseData = {\r\n  message: string\r\n}\r\n\r\nexport default function handler(\r\n  req: NextApiRequest,\r\n  res: NextApiResponse<ResponseData>\r\n) {\r\n  res.status(200).json({ message: 'Hello from Next.js!' })\r\n}",
        "context": "filename=\"pages/api/hello.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export default function handler(req, res) {\r\n  res.status(200).json({ message: 'Hello from Next.js!' })\r\n}",
        "context": "filename=\"pages/api/hello.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import type { NextApiRequest, NextApiResponse } from 'next'\r\n\r\nexport default async function handler(\r\n  req: NextApiRequest,\r\n  res: NextApiResponse\r\n) {\r\n  try {\r\n    const result = await someAsyncOperation()\r\n    res.status(200).json({ result })\r\n  } catch (err) {\r\n    res.status(500).json({ error: 'failed to load data' })\r\n  }\r\n}",
        "context": "filename=\"pages/api/hello.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export default async function handler(req, res) {\r\n  try {\r\n    const result = await someAsyncOperation()\r\n    res.status(200).json({ result })\r\n  } catch (err) {\r\n    res.status(500).json({ error: 'failed to load data' })\r\n  }\r\n}",
        "context": "filename=\"pages/api/hello.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import type { NextApiRequest, NextApiResponse } from 'next'\r\n\r\nexport default async function handler(\r\n  req: NextApiRequest,\r\n  res: NextApiResponse\r\n) {\r\n  try {\r\n    const result = await someAsyncOperation()\r\n    res.status(200).send({ result })\r\n  } catch (err) {\r\n    res.status(500).send({ error: 'failed to fetch data' })\r\n  }\r\n}",
        "context": "filename=\"pages/api/hello.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export default async function handler(req, res) {\r\n  try {\r\n    const result = await someAsyncOperation()\r\n    res.status(200).send({ result })\r\n  } catch (err) {\r\n    res.status(500).send({ error: 'failed to fetch data' })\r\n  }\r\n}",
        "context": "filename=\"pages/api/hello.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import type { NextApiRequest, NextApiResponse } from 'next'\r\n\r\nexport default async function handler(\r\n  req: NextApiRequest,\r\n  res: NextApiResponse\r\n) {\r\n  const { name, message } = req.body\r\n\r\n  try {\r\n    await handleFormInputAsync({ name, message })\r\n    res.redirect(307, '/')\r\n  } catch (err) {\r\n    res.status(500).send({ error: 'Failed to fetch data' })\r\n  }\r\n}",
        "context": "filename=\"pages/api/hello.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export default async function handler(req, res) {\r\n  const { name, message } = req.body\r\n\r\n  try {\r\n    await handleFormInputAsync({ name, message })\r\n    res.redirect(307, '/')\r\n  } catch (err) {\r\n    res.status(500).send({ error: 'failed to fetch data' })\r\n  }\r\n}",
        "context": "filename=\"pages/api/hello.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import type { NextApiRequest, NextApiResponse } from 'next'\r\n\r\ntype ResponseData = {\r\n  message: string\r\n}\r\n\r\nexport default function handler(\r\n  req: NextApiRequest,\r\n  res: NextApiResponse<ResponseData>\r\n) {\r\n  res.status(200).json({ message: 'Hello from Next.js!' })\r\n}",
        "context": ""
      },
      {
        "language": "ts",
        "code": "import type { NextApiRequest, NextApiResponse } from 'next'\r\n\r\nexport default function handler(req: NextApiRequest, res: NextApiResponse) {\r\n  const { pid } = req.query\r\n  res.end(`Post: ${pid}`)\r\n}",
        "context": "filename=\"pages/api/post/[pid].ts\" switcher"
      },
      {
        "language": "js",
        "code": "export default function handler(req, res) {\r\n  const { pid } = req.query\r\n  res.end(`Post: ${pid}`)\r\n}",
        "context": "filename=\"pages/api/post/[pid].js\" switcher"
      },
      {
        "language": "json",
        "code": "{ \"slug\": [\"a\"] }",
        "context": ""
      },
      {
        "language": "json",
        "code": "{ \"slug\": [\"a\", \"b\"] }",
        "context": ""
      },
      {
        "language": "ts",
        "code": "import type { NextApiRequest, NextApiResponse } from 'next'\r\n\r\nexport default function handler(req: NextApiRequest, res: NextApiResponse) {\r\n  const { slug } = req.query\r\n  res.end(`Post: ${slug.join(', ')}`)\r\n}",
        "context": "filename=\"pages/api/post/[...slug].ts\" switcher"
      },
      {
        "language": "js",
        "code": "export default function handler(req, res) {\r\n  const { slug } = req.query\r\n  res.end(`Post: ${slug.join(', ')}`)\r\n}",
        "context": "filename=\"pages/api/post/[...slug].js\" switcher"
      },
      {
        "language": "json",
        "code": "{ } // GET `/api/post` (empty object)\r\n{ \"slug\": [\"a\"] } // `GET /api/post/a` (single-element array)\r\n{ \"slug\": [\"a\", \"b\"] } // `GET /api/post/a/b` (multi-element array)",
        "context": ""
      },
      {
        "language": "ts",
        "code": "import { NextApiRequest, NextApiResponse } from 'next'\r\n\r\nexport default async function handler(\r\n  req: NextApiRequest,\r\n  res: NextApiResponse\r\n) {\r\n  res.writeHead(200, {\r\n    'Content-Type': 'text/event-stream',\r\n    'Cache-Control': 'no-store',\r\n  })\r\n  let i = 0\r\n  while (i < 10) {\r\n    res.write(`data: ${i}\\n\\n`)\r\n    i++\r\n    await new Promise((resolve) => setTimeout(resolve, 1000))\r\n  }\r\n  res.end()\r\n}",
        "context": "filename=\"pages/api/hello.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export default async function handler(req, res) {\r\n  res.writeHead(200, {\r\n    'Content-Type': 'text/event-stream',\r\n    'Cache-Control': 'no-store',\r\n  })\r\n  let i = 0\r\n  while (i < 10) {\r\n    res.write(`data: ${i}\\n\\n`)\r\n    i++\r\n    await new Promise((resolve) => setTimeout(resolve, 1000))\r\n  }\r\n  res.end()\r\n}",
        "context": "filename=\"pages/api/hello.js\" switcher"
      }
    ],
    "content": "Examples - API Routes Request Helpers - API Routes with GraphQL - API Routes with REST - API Routes with CORS > Good to know: If you are using the App Router, you can use Server Components or Route Handlers instead of API Routes. API routes provide a solution to build a public API with Next.js. Any file inside the folder pages/api is mapped to /api/ and will be treated as an API endpoint instead of a page. They are server-side only bundles and won't increase your client-side bundle size. For example, the following API route returns a JSON response with a status code of 200: > Good to know: > > - API Routes do not specify CORS headers, meaning they are same-origin only by default. You can customize such behavior by wrapping the request handler with the CORS request helpers. - API Routes can't be used with static exports. However, Route Handlers in the App Router can. > - API Routes will be affected by pageExtensions configuration in next.config.js. Parameters - req: An instance of http.IncomingMessage - res: An instance of http.ServerResponse HTTP Methods To handle different HTTP methods in an API route, you can use req.method in your request handler, like so: Request Helpers API Routes provide built-in request helpers which parse the incoming request (req): - req.cookies - An object containing the cookies sent by the request. Defaults to {} - req.query - An object containing the query string. Defaults to {} - req.body - An object containing the body parsed by content-type, or null if no body was sent Custom config Every API Route can export a config object to change the default configuration, which is the following: bodyParser is automatically enabled. If you want to consume the body as a Stream or with raw-body, you can set this to false. One use case for disabling the automatic bodyParsing is to allow you to verify the raw body of a webhook request, for example from GitHub. bodyParser.sizeLimit is the maximum size allowed for the parsed body, in any format supported by bytes, like so: externalResolver is an explicit flag that tells the server that this route is being handled by an external resolver like express or connect. Enabling this option disables warnings for unresolved requests. responseLimit is automatically enabled, warning when an API Routes' response body is over 4MB. If you are not using Next.js in a serverless environment, and understand the performance implications of not using a CDN or dedicated media host, you can set this limit to false. responseLimit can also take the number of bytes or any string format supported by bytes, for example 1000, '500kb' or '3mb'. This value will be the maximum response size before a warning is displayed. Default is 4MB. (see above) Response Helpers The Server Response object, (often abbreviated as res) includes a set of Express.js-like helper methods to improve the developer experience and increase the speed of creating new API endpoints. The included helpers are: - res.status(code) - A function to set the status code. code must be a valid HTTP status code - res.json(body) - Sends a JSON response. body must be a serializable object - res.send(body) - Sends the HTTP response. body can be a string, an object or a Buffer - res.redirect([status,] path) - Redirects to a specified path or URL. status must be a valid HTTP status code. If not specified, status defaults to \"307\" \"Temporary redirect\". - res.revalidate(urlPath) - Revalidate a page on demand using getStaticProps. urlPath must be a string. Setting the status code of a response When sending a response back to the client, you can set the status code of the response. The following example sets the status code of the response to 200 (OK) and returns a message property with the value of Hello from Next.js! as a JSON response: Sending a JSON response When sending a response back to the client you can send a JSON response, this must be a serializable object. In a real world application you might want to let the client know the status of the request depending on the result of the requested endpoint. The following example sends a JSON response with the status code 200 (OK) and the result of the async operation. It's contained in a try catch block to handle any errors that may occur, with the appropriate status code and error message caught and sent back to the client: Sending a HTTP response Sending an HTTP response works the same way as when sending a JSON response. The only difference is that the response body can be a string, an object or a Buffer. The following example sends a HTTP response with the status code 200 (OK) and the result of the async operation. Redirects to a specified path or URL Taking a form as an example, you may want to redirect your client to a specified path or URL once they have submitted the form. The following example redirects the client to the / path if the form is successfully submitted: Adding TypeScript types You can make your API Routes more type-safe by importing the NextApiRequest and NextApiResponse types from next, in addition to those, you can also type your response data: > Good to know: The body of NextApiRequest is any because the client may include any payload. You should validate the type/shape of the body at runtime before using it. Dynamic API Routes API Routes support dynamic routes, and follow the same file naming rules used for pages/. Now, a request to /api/post/abc will respond with the text: Post: abc. Catch all API routes API Routes can be extended to catch all paths by adding three dots (...) inside the brackets. For example: - pages/api/post/[...slug].js matches /api/post/a, but also /api/post/a/b, /api/post/a/b/c and so on. > Good to know: You can use names other than slug, such as: [...param] Matched parameters will be sent as a query parameter (slug in the example) to the page, and it will always be an array, so, the path /api/post/a will have the following query object: And in the case of /api/post/a/b, and any other matching path, new parameters will be added to the array, like so: For example: Now, a request to /api/post/a/b/c will respond with the text: Post: a, b, c. Optional catch all API routes Catch all routes can be made optional by including the parameter in double brackets ([[...slug]]). For example, pages/api/post/[[...slug]].js will match /api/post, /api/post/a, /api/post/a/b, and so on. The main difference between catch all and optional catch all routes is that with optional, the route without the parameter is also matched (/api/post in the example above). The query objects are as follows: Caveats - Predefined API routes take precedence over dynamic API routes, and dynamic API routes over catch all API routes. Take a look at the following examples: - pages/api/post/create.js - Will match /api/post/create - pages/api/post/[pid].js - Will match /api/post/1, /api/post/abc, etc. But not /api/post/create - pages/api/post/[...slug].js - Will match /api/post/1/2, /api/post/a/b/c, etc. But not /api/post/create, /api/post/abc Streaming responses While the Pages Router does support streaming responses with API Routes, we recommend incrementally adopting the App Router and using Route Handlers if you are on Next.js 14+. Here's how you can stream a response from an API Route with writeHead:",
    "excerpt": "Examples - API Routes Request Helpers - API Routes with GraphQL - API Routes with REST - API Routes with CORS > Good to know: If you are using the App Router, you can use Server Components or Route Ha...",
    "url": "https://nextjs.org/docs/02-pages/03-building-your-application/01-routing/07-api-routes"
  },
  {
    "id": "02-pages-03-building-your-application-01-routing-08-custom-error",
    "path": "02-pages\\03-building-your-application\\01-routing\\08-custom-error.mdx",
    "title": "Custom Errors",
    "description": "Override and extend the built-in Error page to handle custom errors.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "404 Page",
        "slug": "404-page"
      },
      {
        "level": 3,
        "text": "Customizing The 404 Page",
        "slug": "customizing-the-404-page"
      },
      {
        "level": 2,
        "text": "500 Page",
        "slug": "500-page"
      },
      {
        "level": 3,
        "text": "Customizing The 500 Page",
        "slug": "customizing-the-500-page"
      },
      {
        "level": 3,
        "text": "More Advanced Error Page Customizing",
        "slug": "more-advanced-error-page-customizing"
      },
      {
        "level": 3,
        "text": "Reusing the built-in error page",
        "slug": "reusing-the-built-in-error-page"
      },
      {
        "level": 3,
        "text": "Caveats",
        "slug": "caveats"
      }
    ],
    "codeBlocks": [
      {
        "language": "jsx",
        "code": "export default function Custom404() {\r\n  return <h1>404 - Page Not Found</h1>\r\n}",
        "context": "filename=\"pages/404.js\""
      },
      {
        "language": "jsx",
        "code": "export default function Custom500() {\r\n  return <h1>500 - Server-side error occurred</h1>\r\n}",
        "context": "filename=\"pages/500.js\""
      },
      {
        "language": "jsx",
        "code": "function Error({ statusCode }) {\r\n  return (\r\n    <p>\r\n      {statusCode\r\n        ? `An error ${statusCode} occurred on server`\r\n        : 'An error occurred on client'}\r\n    </p>\r\n  )\r\n}\r\n\r\nError.getInitialProps = ({ res, err }) => {\r\n  const statusCode = res ? res.statusCode : err ? err.statusCode : 404\r\n  return { statusCode }\r\n}\r\n\r\nexport default Error",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import Error from 'next/error'\r\n\r\nexport async function getServerSideProps() {\r\n  const res = await fetch('https://api.github.com/repos/vercel/next.js')\r\n  const errorCode = res.ok ? false : res.status\r\n  const json = await res.json()\r\n\r\n  return {\r\n    props: { errorCode, stars: json.stargazers_count },\r\n  }\r\n}\r\n\r\nexport default function Page({ errorCode, stars }) {\r\n  if (errorCode) {\r\n    return <Error statusCode={errorCode} />\r\n  }\r\n\r\n  return <div>Next stars: {stars}</div>\r\n}",
        "context": ""
      }
    ],
    "content": "404 Page A 404 page may be accessed very often. Server-rendering an error page for every visit increases the load of the Next.js server. This can result in increased costs and slow experiences. To avoid the above pitfalls, Next.js provides a static 404 page by default without having to add any additional files. Customizing The 404 Page To create a custom 404 page you can create a pages/404.js file. This file is statically generated at build time. > Good to know: You can use getStaticProps inside this page if you need to fetch data at build time. 500 Page Server-rendering an error page for every visit adds complexity to responding to errors. To help users get responses to errors as fast as possible, Next.js provides a static 500 page by default without having to add any additional files. Customizing The 500 Page To customize the 500 page you can create a pages/500.js file. This file is statically generated at build time. > Good to know: You can use getStaticProps inside this page if you need to fetch data at build time. More Advanced Error Page Customizing 500 errors are handled both client-side and server-side by the Error component. If you wish to override it, define the file pages/error.js and add the following code: > pages/error.js is only used in production. In development you’ll get an error with the call stack to know where the error originated from. Reusing the built-in error page If you want to render the built-in error page you can by importing the Error component: The Error component also takes title as a property if you want to pass in a text message along with a statusCode. If you have a custom Error component be sure to import that one instead. next/error exports the default component used by Next.js. Caveats - Error does not currently support Next.js Data Fetching methods like getStaticProps or getServerSideProps. - error, like app, is a reserved pathname. error is used to define the customized layouts and behaviors of the error pages. /error will render 404 when accessed directly via routing or rendering in a custom server.",
    "excerpt": "404 Page A 404 page may be accessed very often. Server-rendering an error page for every visit increases the load of the Next.js server. This can result in increased costs and slow experiences. To avo...",
    "url": "https://nextjs.org/docs/02-pages/03-building-your-application/01-routing/08-custom-error"
  },
  {
    "id": "02-pages-03-building-your-application-01-routing-index",
    "path": "02-pages\\03-building-your-application\\01-routing\\index.mdx",
    "title": "Routing",
    "description": "Learn the fundamentals of routing for front-end applications with the Pages Router.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "The Pages Router has a file-system based router built on concepts of pages. When a file is added to the pages directory it's automatically available as a route. Learn more about routing in the Pages Router:",
    "excerpt": "The Pages Router has a file-system based router built on concepts of pages. When a file is added to the pages directory it's automatically available as a route. Learn more about routing in the Pages R...",
    "url": "https://nextjs.org/docs/02-pages/03-building-your-application/01-routing"
  },
  {
    "id": "02-pages-03-building-your-application-02-rendering-01-server-side-rendering",
    "path": "02-pages\\03-building-your-application\\02-rendering\\01-server-side-rendering.mdx",
    "title": "Server-side Rendering (SSR)",
    "description": "Use Server-side Rendering to render pages on each request.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [
      {
        "language": "jsx",
        "code": "export default function Page({ data }) {\r\n  // Render data...\r\n}\r\n\r\n// This gets called on every request\r\nexport async function getServerSideProps() {\r\n  // Fetch data from external API\r\n  const res = await fetch(`https://.../data`)\r\n  const data = await res.json()\r\n\r\n  // Pass data to the page via props\r\n  return { props: { data } }\r\n}",
        "context": ""
      }
    ],
    "content": "> Also referred to as \"SSR\" or \"Dynamic Rendering\". If a page uses Server-side Rendering, the page HTML is generated on each request. To use Server-side Rendering for a page, you need to export an async function called getServerSideProps. This function will be called by the server on every request. For example, suppose that your page needs to pre-render frequently updated data (fetched from an external API). You can write getServerSideProps which fetches this data and passes it to Page like below: As you can see, getServerSideProps is similar to getStaticProps, but the difference is that getServerSideProps is run on every request instead of on build time. To learn more about how getServerSideProps works, check out our Data Fetching documentation.",
    "excerpt": "> Also referred to as \"SSR\" or \"Dynamic Rendering\". If a page uses Server-side Rendering, the page HTML is generated on each request. To use Server-side Rendering for a page, you need to export an asy...",
    "url": "https://nextjs.org/docs/02-pages/03-building-your-application/02-rendering/01-server-side-rendering"
  },
  {
    "id": "02-pages-03-building-your-application-02-rendering-02-static-site-generation",
    "path": "02-pages\\03-building-your-application\\02-rendering\\02-static-site-generation.mdx",
    "title": "Static Site Generation (SSG)",
    "description": "Use Static Site Generation (SSG) to pre-render pages at build time.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 3,
        "text": "Static Generation without data",
        "slug": "static-generation-without-data"
      },
      {
        "level": 3,
        "text": "Static Generation with data",
        "slug": "static-generation-with-data"
      },
      {
        "level": 4,
        "text": "Scenario 1: Your page content depends on external data",
        "slug": "scenario-1-your-page-content-depends-on-external-data"
      },
      {
        "level": 4,
        "text": "Scenario 2: Your page paths depend on external data",
        "slug": "scenario-2-your-page-paths-depend-on-external-data"
      },
      {
        "level": 3,
        "text": "When should I use Static Generation?",
        "slug": "when-should-i-use-static-generation"
      }
    ],
    "codeBlocks": [
      {
        "language": "jsx",
        "code": "function About() {\r\n  return <div>About</div>\r\n}\r\n\r\nexport default About",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "// TODO: Need to fetch `posts` (by calling some API endpoint)\r\n//       before this page can be pre-rendered.\r\nexport default function Blog({ posts }) {\r\n  return (\r\n    <ul>\r\n      {posts.map((post) => (\r\n        <li>{post.title}</li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "export default function Blog({ posts }) {\r\n  // Render posts...\r\n}\r\n\r\n// This function gets called at build time\r\nexport async function getStaticProps() {\r\n  // Call an external API endpoint to get posts\r\n  const res = await fetch('https://.../posts')\r\n  const posts = await res.json()\r\n\r\n  // By returning { props: { posts } }, the Blog component\r\n  // will receive `posts` as a prop at build time\r\n  return {\r\n    props: {\r\n      posts,\r\n    },\r\n  }\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "// This function gets called at build time\r\nexport async function getStaticPaths() {\r\n  // Call an external API endpoint to get posts\r\n  const res = await fetch('https://.../posts')\r\n  const posts = await res.json()\r\n\r\n  // Get the paths we want to pre-render based on posts\r\n  const paths = posts.map((post) => ({\r\n    params: { id: post.id },\r\n  }))\r\n\r\n  // We'll pre-render only these paths at build time.\r\n  // { fallback: false } means other routes should 404.\r\n  return { paths, fallback: false }\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "export default function Post({ post }) {\r\n  // Render post...\r\n}\r\n\r\nexport async function getStaticPaths() {\r\n  // ...\r\n}\r\n\r\n// This also gets called at build time\r\nexport async function getStaticProps({ params }) {\r\n  // params contains the post `id`.\r\n  // If the route is like /posts/1, then params.id is 1\r\n  const res = await fetch(`https://.../posts/${params.id}`)\r\n  const post = await res.json()\r\n\r\n  // Pass post data to the page via props\r\n  return { props: { post } }\r\n}",
        "context": ""
      }
    ],
    "content": "Examples - Agility CMS Example (Demo) - Builder.io Example (Demo) - ButterCMS Example (Demo) - Contentful Example (Demo) - Cosmic Example (Demo) - DatoCMS Example (Demo) - DotCMS Example (Demo) - Drupal Example (Demo) - Enterspeed Example (Demo) - GraphCMS Example (Demo) - Keystone Example (Demo) - Kontent.ai Example (Demo) - Makeswift Example (Demo) - Plasmic Example (Demo) - Prepr Example (Demo) - Prismic Example (Demo) - Sanity Example (Demo) - Sitecore XM Cloud Example (Demo) - Storyblok Example (Demo) - Strapi Example (Demo) - TakeShape Example (Demo) - Tina Example (Demo) - Umbraco Example (Demo) - Umbraco Heartcore Example (Demo) - Webiny Example (Demo) - WordPress Example (Demo) - Blog Starter Example (Demo) - Static Tweet (Demo) If a page uses Static Generation, the page HTML is generated at build time. That means in production, the page HTML is generated when you run next build. This HTML will then be reused on each request. It can be cached by a CDN. In Next.js, you can statically generate pages with or without data. Let's take a look at each case. Static Generation without data By default, Next.js pre-renders pages using Static Generation without fetching data. Here's an example: Note that this page does not need to fetch any external data to be pre-rendered. In cases like this, Next.js generates a single HTML file per page during build time. Static Generation with data Some pages require fetching external data for pre-rendering. There are two scenarios, and one or both might apply. In each case, you can use these functions that Next.js provides: 1. Your page content depends on external data: Use getStaticProps. 2. Your page paths depend on external data: Use getStaticPaths (usually in addition to getStaticProps). Scenario 1: Your page content depends on external data Example: Your blog page might need to fetch the list of blog posts from a CMS (content management system). To fetch this data on pre-render, Next.js allows you to export an async function called getStaticProps from the same file. This function gets called at build time and lets you pass fetched data to the page's props on pre-render. To learn more about how getStaticProps works, check out the Data Fetching documentation. Scenario 2: Your page paths depend on external data Next.js allows you to create pages with dynamic routes. For example, you can create a file called pages/posts/[id].js to show a single blog post based on id. This will allow you to show a blog post with id: 1 when you access posts/1. > To learn more about dynamic routing, check the Dynamic Routing documentation. However, which id you want to pre-render at build time might depend on external data. Example: suppose that you've only added one blog post (with id: 1) to the database. In this case, you'd only want to pre-render posts/1 at build time. Later, you might add the second post with id: 2. Then you'd want to pre-render posts/2 as well. So your page paths that are pre-rendered depend on external data. To handle this, Next.js lets you export an async function called getStaticPaths from a dynamic page (pages/posts/[id].js in this case). This function gets called at build time and lets you specify which paths you want to pre-render. Also in pages/posts/[id].js, you need to export getStaticProps so that you can fetch the data about the post with this id and use it to pre-render the page: To learn more about how getStaticPaths works, check out the Data Fetching documentation. When should I use Static Generation? We recommend using Static Generation (with and without data) whenever possible because your page can be built once and served by CDN, which makes it much faster than having a server render the page on every request. You can use Static Generation for many types of pages, including: - Marketing pages - Blog posts and portfolios - E-commerce product listings - Help and documentation You should ask yourself: \"Can I pre-render this page ahead of a user's request?\" If the answer is yes, then you should choose Static Generation. On the other hand, Static Generation is not a good idea if you cannot pre-render a page ahead of a user's request. Maybe your page shows frequently updated data, and the page content changes on every request. In cases like this, you can do one of the following: - Use Static Generation with Client-side data fetching: You can skip pre-rendering some parts of a page and then use client-side JavaScript to populate them. To learn more about this approach, check out the Data Fetching documentation. - Use Server-Side Rendering: Next.js pre-renders a page on each request. It will be slower because the page cannot be cached by a CDN, but the pre-rendered page will always be up-to-date. We'll talk about this approach below.",
    "excerpt": "Examples - Agility CMS Example (Demo) - Builder.io Example (Demo) - ButterCMS Example (Demo) - Contentful Example (Demo) - Cosmic Example (Demo) - DatoCMS Example (Demo) - DotCMS Example (Demo) - Drup...",
    "url": "https://nextjs.org/docs/02-pages/03-building-your-application/02-rendering/02-static-site-generation"
  },
  {
    "id": "02-pages-03-building-your-application-02-rendering-04-automatic-static-optimization",
    "path": "02-pages\\03-building-your-application\\02-rendering\\04-automatic-static-optimization.mdx",
    "title": "Automatic Static Optimization",
    "description": "Next.js automatically optimizes your app to be static HTML whenever possible. Learn how it works here.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "How it works",
        "slug": "how-it-works"
      },
      {
        "level": 2,
        "text": "Caveats",
        "slug": "caveats"
      }
    ],
    "codeBlocks": [
      {
        "language": "bash",
        "code": ".next/server/pages/about.html",
        "context": "filename=\"Terminal\""
      },
      {
        "language": "bash",
        "code": ".next/server/pages/about.js",
        "context": "filename=\"Terminal\""
      }
    ],
    "content": "Next.js automatically determines that a page is static (can be prerendered) if it has no blocking data requirements. This determination is made by the absence of getServerSideProps and getInitialProps in the page. This feature allows Next.js to emit hybrid applications that contain both server-rendered and statically generated pages. > Good to know: Statically generated pages are still reactive. Next.js will hydrate your application client-side to give it full interactivity. One of the main benefits of this feature is that optimized pages require no server-side computation, and can be instantly streamed to the end-user from multiple CDN locations. The result is an ultra fast loading experience for your users. How it works If getServerSideProps or getInitialProps is present in a page, Next.js will switch to render the page on-demand, per-request (meaning Server-Side Rendering). If the above is not the case, Next.js will statically optimize your page automatically by prerendering the page to static HTML. During prerendering, the router's query object will be empty since we do not have query information to provide during this phase. After hydration, Next.js will trigger an update to your application to provide the route parameters in the query object. The cases where the query will be updated after hydration triggering another render are: - The page is a dynamic-route. - The page has query values in the URL. - Rewrites are configured in your next.config.js since these can have parameters that may need to be parsed and provided in the query. To be able to distinguish if the query is fully updated and ready for use, you can leverage the isReady field on next/router. > Good to know: Parameters added with dynamic routes to a page that's using getStaticProps will always be available inside the query object. next build will emit .html files for statically optimized pages. For example, the result for the page pages/about.js would be: And if you add getServerSideProps to the page, it will then be JavaScript, like so: Caveats - If you have a custom App with getInitialProps then this optimization will be turned off in pages without Static Generation. - If you have a custom Document with getInitialProps be sure you check if ctx.req is defined before assuming the page is server-side rendered. ctx.req will be undefined for pages that are prerendered. - Avoid using the asPath value on next/router in the rendering tree until the router's isReady field is true. Statically optimized pages only know asPath on the client and not the server, so using it as a prop may lead to mismatch errors. The active-class-name example demonstrates one way to use asPath as a prop.",
    "excerpt": "Next.js automatically determines that a page is static (can be prerendered) if it has no blocking data requirements. This determination is made by the absence of getServerSideProps and getInitialProps...",
    "url": "https://nextjs.org/docs/02-pages/03-building-your-application/02-rendering/04-automatic-static-optimization"
  },
  {
    "id": "02-pages-03-building-your-application-02-rendering-05-client-side-rendering",
    "path": "02-pages\\03-building-your-application\\02-rendering\\05-client-side-rendering.mdx",
    "title": "Client-side Rendering (CSR)",
    "description": "Learn how to implement client-side rendering in the Pages Router.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [
      {
        "language": "jsx",
        "code": "import React, { useState, useEffect } from 'react'\r\n\r\nexport function Page() {\r\n  const [data, setData] = useState(null)\r\n\r\n  useEffect(() => {\r\n    const fetchData = async () => {\r\n      const response = await fetch('https://api.example.com/data')\r\n      if (!response.ok) {\r\n        throw new Error(`HTTP error! status: ${response.status}`)\r\n      }\r\n      const result = await response.json()\r\n      setData(result)\r\n    }\r\n\r\n    fetchData().catch((e) => {\r\n      // handle the error as needed\r\n      console.error('An error occurred while fetching the data: ', e)\r\n    })\r\n  }, [])\r\n\r\n  return <p>{data ? `Your data: ${data}` : 'Loading...'}</p>\r\n}",
        "context": "filename=\"pages/index.js\""
      },
      {
        "language": "jsx",
        "code": "import useSWR from 'swr'\r\n\r\nexport function Page() {\r\n  const { data, error, isLoading } = useSWR(\r\n    'https://api.example.com/data',\r\n    fetcher\r\n  )\r\n\r\n  if (error) return <p>Failed to load.</p>\r\n  if (isLoading) return <p>Loading...</p>\r\n\r\n  return <p>Your Data: {data}</p>\r\n}",
        "context": "filename=\"pages/index.js\""
      }
    ],
    "content": "In Client-Side Rendering (CSR) with React, the browser downloads a minimal HTML page and the JavaScript needed for the page. The JavaScript is then used to update the DOM and render the page. When the application is first loaded, the user may notice a slight delay before they can see the full page, this is because the page isn't fully rendered until all the JavaScript is downloaded, parsed, and executed. After the page has been loaded for the first time, navigating to other pages on the same website is typically faster, as only necessary data needs to be fetched, and JavaScript can re-render parts of the page without requiring a full page refresh. In Next.js, there are two ways you can implement client-side rendering: 1. Using React's useEffect() hook inside your pages instead of the server-side rendering methods (getStaticProps and getServerSideProps). 2. Using a data fetching library like SWR or TanStack Query to fetch data on the client (recommended). Here's an example of using useEffect() inside a Next.js page: In the example above, the component starts by rendering Loading.... Then, once the data is fetched, it re-renders and displays the data. Although fetching data in a useEffect is a pattern you may see in older React Applications, we recommend using a data-fetching library for better performance, caching, optimistic updates, and more. Here's a minimum example using SWR to fetch data on the client: > Good to know: > > Keep in mind that CSR can impact SEO. Some search engine crawlers might not execute JavaScript and therefore only see the initial empty or loading state of your application. It can also lead to performance issues for users with slower internet connections or devices, as they need to wait for all the JavaScript to load and run before they can see the full page. Next.js promotes a hybrid approach that allows you to use a combination of server-side rendering, static site generation, and client-side rendering, depending on the needs of each page in your application. In the App Router, you can also use Loading UI with Suspense to show a loading indicator while the page is being rendered.",
    "excerpt": "In Client-Side Rendering (CSR) with React, the browser downloads a minimal HTML page and the JavaScript needed for the page. The JavaScript is then used to update the DOM and render the page. When the...",
    "url": "https://nextjs.org/docs/02-pages/03-building-your-application/02-rendering/05-client-side-rendering"
  },
  {
    "id": "02-pages-03-building-your-application-02-rendering-index",
    "path": "02-pages\\03-building-your-application\\02-rendering\\index.mdx",
    "title": "Rendering",
    "description": "Learn the fundamentals of rendering in React and Next.js.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 3,
        "text": "Pre-rendering",
        "slug": "pre-rendering"
      }
    ],
    "codeBlocks": [],
    "content": "By default, Next.js pre-renders every page. This means that Next.js generates HTML for each page in advance, instead of having it all done by client-side JavaScript. Pre-rendering can result in better performance and SEO. Each generated HTML is associated with minimal JavaScript code necessary for that page. When a page is loaded by the browser, its JavaScript code runs and makes the page fully interactive (this process is called hydration in React). Pre-rendering Next.js has two forms of pre-rendering: Static Generation and Server-side Rendering. The difference is in when it generates the HTML for a page. - Static Generation: The HTML is generated at build time and will be reused on each request. - Server-side Rendering: The HTML is generated on each request. Importantly, Next.js lets you choose which pre-rendering form you'd like to use for each page. You can create a \"hybrid\" Next.js app by using Static Generation for most pages and using Server-side Rendering for others. We recommend using Static Generation over Server-side Rendering for performance reasons. Statically generated pages can be cached by CDN with no extra configuration to boost performance. However, in some cases, Server-side Rendering might be the only option. You can also use client-side data fetching along with Static Generation or Server-side Rendering. That means some parts of a page can be rendered entirely by clientside JavaScript. To learn more, take a look at the Data Fetching documentation.",
    "excerpt": "By default, Next.js pre-renders every page. This means that Next.js generates HTML for each page in advance, instead of having it all done by client-side JavaScript. Pre-rendering can result in better...",
    "url": "https://nextjs.org/docs/02-pages/03-building-your-application/02-rendering"
  },
  {
    "id": "02-pages-03-building-your-application-03-data-fetching-01-get-static-props",
    "path": "02-pages\\03-building-your-application\\03-data-fetching\\01-get-static-props.mdx",
    "title": "getStaticProps",
    "description": "Fetch data and generate static pages with `getStaticProps`. Learn more about this API for data fetching in Next.js.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "When should I use getStaticProps?",
        "slug": "when-should-i-use-getstaticprops"
      },
      {
        "level": 2,
        "text": "When does getStaticProps run",
        "slug": "when-does-getstaticprops-run"
      },
      {
        "level": 2,
        "text": "Using getStaticProps to fetch data from a CMS",
        "slug": "using-getstaticprops-to-fetch-data-from-a-cms"
      },
      {
        "level": 2,
        "text": "Write server-side code directly",
        "slug": "write-server-side-code-directly"
      },
      {
        "level": 2,
        "text": "Statically generates both HTML and JSON",
        "slug": "statically-generates-both-html-and-json"
      },
      {
        "level": 2,
        "text": "Where can I use getStaticProps",
        "slug": "where-can-i-use-getstaticprops"
      },
      {
        "level": 2,
        "text": "Runs on every request in development",
        "slug": "runs-on-every-request-in-development"
      },
      {
        "level": 2,
        "text": "Preview Mode",
        "slug": "preview-mode"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "import type { InferGetStaticPropsType, GetStaticProps } from 'next'\r\n\r\ntype Repo = {\r\n  name: string\r\n  stargazers_count: number\r\n}\r\n\r\nexport const getStaticProps = (async (context) => {\r\n  const res = await fetch('https://api.github.com/repos/vercel/next.js')\r\n  const repo = await res.json()\r\n  return { props: { repo } }\r\n}) satisfies GetStaticProps<{\r\n  repo: Repo\r\n}>\r\n\r\nexport default function Page({\r\n  repo,\r\n}: InferGetStaticPropsType<typeof getStaticProps>) {\r\n  return repo.stargazers_count\r\n}",
        "context": "filename=\"pages/index.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export async function getStaticProps() {\r\n  const res = await fetch('https://api.github.com/repos/vercel/next.js')\r\n  const repo = await res.json()\r\n  return { props: { repo } }\r\n}\r\n\r\nexport default function Page({ repo }) {\r\n  return repo.stargazers_count\r\n}",
        "context": "filename=\"pages/index.js\" switcher"
      },
      {
        "language": "tsx",
        "code": "// posts will be populated at build time by getStaticProps()\r\nexport default function Blog({ posts }) {\r\n  return (\r\n    <ul>\r\n      {posts.map((post) => (\r\n        <li>{post.title}</li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}\r\n\r\n// This function gets called at build time on server-side.\r\n// It won't be called on client-side, so you can even do\r\n// direct database queries.\r\nexport async function getStaticProps() {\r\n  // Call an external API endpoint to get posts.\r\n  // You can use any data fetching library\r\n  const res = await fetch('https://.../posts')\r\n  const posts = await res.json()\r\n\r\n  // By returning { props: { posts } }, the Blog component\r\n  // will receive `posts` as a prop at build time\r\n  return {\r\n    props: {\r\n      posts,\r\n    },\r\n  }\r\n}",
        "context": "filename=\"pages/blog.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "// posts will be populated at build time by getStaticProps()\r\nexport default function Blog({ posts }) {\r\n  return (\r\n    <ul>\r\n      {posts.map((post) => (\r\n        <li>{post.title}</li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}\r\n\r\n// This function gets called at build time on server-side.\r\n// It won't be called on client-side, so you can even do\r\n// direct database queries.\r\nexport async function getStaticProps() {\r\n  // Call an external API endpoint to get posts.\r\n  // You can use any data fetching library\r\n  const res = await fetch('https://.../posts')\r\n  const posts = await res.json()\r\n\r\n  // By returning { props: { posts } }, the Blog component\r\n  // will receive `posts` as a prop at build time\r\n  return {\r\n    props: {\r\n      posts,\r\n    },\r\n  }\r\n}",
        "context": "filename=\"pages/blog.js\" switcher"
      },
      {
        "language": "js",
        "code": "// The following function is shared\r\n// with getStaticProps and API routes\r\n// from a `lib/` directory\r\nexport async function loadPosts() {\r\n  // Call an external API endpoint to get posts\r\n  const res = await fetch('https://.../posts/')\r\n  const data = await res.json()\r\n\r\n  return data\r\n}",
        "context": "filename=\"lib/load-posts.js\""
      },
      {
        "language": "jsx",
        "code": "// pages/blog.js\r\nimport { loadPosts } from '../lib/load-posts'\r\n\r\n// This function runs only on the server side\r\nexport async function getStaticProps() {\r\n  // Instead of fetching your `/api` route you can call the same\r\n  // function directly in `getStaticProps`\r\n  const posts = await loadPosts()\r\n\r\n  // Props returned will be passed to the page component\r\n  return { props: { posts } }\r\n}",
        "context": "filename=\"pages/blog.js\""
      }
    ],
    "content": "If you export a function called getStaticProps (Static Site Generation) from a page, Next.js will pre-render this page at build time using the props returned by getStaticProps. > Note that irrespective of rendering type, any props will be passed to the page component and can be viewed on the client-side in the initial HTML. This is to allow the page to be hydrated correctly. Make sure that you don't pass any sensitive information that shouldn't be available on the client in props. The getStaticProps API reference covers all parameters and props that can be used with getStaticProps. When should I use getStaticProps? You should use getStaticProps if: - The data required to render the page is available at build time ahead of a user’s request - The data comes from a headless CMS - The page must be pre-rendered (for SEO) and be very fast — getStaticProps generates HTML and JSON files, both of which can be cached by a CDN for performance - The data can be publicly cached (not user-specific). This condition can be bypassed in certain specific situation by using a Proxy to rewrite the path. When does getStaticProps run getStaticProps always runs on the server and never on the client. You can validate code written inside getStaticProps is removed from the client-side bundle with this tool. - getStaticProps always runs during next build - getStaticProps runs in the background when using fallback: true - getStaticProps is called before initial render when using fallback: blocking - getStaticProps runs in the background when using revalidate - getStaticProps runs on-demand in the background when using revalidate() When combined with Incremental Static Regeneration, getStaticProps will run in the background while the stale page is being revalidated, and the fresh page served to the browser. getStaticProps does not have access to the incoming request (such as query parameters or HTTP headers) as it generates static HTML. If you need access to the request for your page, consider using Proxy in addition to getStaticProps. Using getStaticProps to fetch data from a CMS The following example shows how you can fetch a list of blog posts from a CMS. The getStaticProps API reference covers all parameters and props that can be used with getStaticProps. Write server-side code directly As getStaticProps runs only on the server-side, it will never run on the client-side. It won’t even be included in the JS bundle for the browser, so you can write direct database queries without them being sent to browsers. This means that instead of fetching an API route from getStaticProps (that itself fetches data from an external source), you can write the server-side code directly in getStaticProps. Take the following example. An API route is used to fetch some data from a CMS. That API route is then called directly from getStaticProps. This produces an additional call, reducing performance. Instead, the logic for fetching the data from the CMS can be shared by using a lib/ directory. Then it can be shared with getStaticProps. Alternatively, if you are not using API routes to fetch data, then the fetch() API can be used directly in getStaticProps to fetch data. To verify what Next.js eliminates from the client-side bundle, you can use the next-code-elimination tool. Statically generates both HTML and JSON When a page with getStaticProps is pre-rendered at build time, in addition to the page HTML file, Next.js generates a JSON file holding the result of running getStaticProps. This JSON file will be used in client-side routing through next/link or next/router. When you navigate to a page that’s pre-rendered using getStaticProps, Next.js fetches this JSON file (pre-computed at build time) and uses it as the props for the page component. This means that client-side page transitions will not call getStaticProps as only the exported JSON is used. When using Incremental Static Generation, getStaticProps will be executed in the background to generate the JSON needed for client-side navigation. You may see this in the form of multiple requests being made for the same page, however, this is intended and has no impact on end-user performance. Where can I use getStaticProps getStaticProps can only be exported from a page. You cannot export it from non-page files, app, document, or error. One of the reasons for this restriction is that React needs to have all the required data before the page is rendered. Also, you must use export getStaticProps as a standalone function — it will not work if you add getStaticProps as a property of the page component. > Good to know: if you have created a custom app, ensure you are passing the pageProps to the page component as shown in the linked document, otherwise the props will be empty. Runs on every request in development In development (next dev), getStaticProps will be called on every request. Preview Mode You can temporarily bypass static generation and render the page at request time instead of build time using Preview Mode. For example, you might be using a headless CMS and want to preview drafts before they're published.",
    "excerpt": "If you export a function called getStaticProps (Static Site Generation) from a page, Next.js will pre-render this page at build time using the props returned by getStaticProps. > Note that irrespectiv...",
    "url": "https://nextjs.org/docs/02-pages/03-building-your-application/03-data-fetching/01-get-static-props"
  },
  {
    "id": "02-pages-03-building-your-application-03-data-fetching-02-get-static-paths",
    "path": "02-pages\\03-building-your-application\\03-data-fetching\\02-get-static-paths.mdx",
    "title": "getStaticPaths",
    "description": "Fetch data and generate static pages with `getStaticPaths`. Learn more about this API for data fetching in Next.js.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "When should I use getStaticPaths?",
        "slug": "when-should-i-use-getstaticpaths"
      },
      {
        "level": 2,
        "text": "When does getStaticPaths run",
        "slug": "when-does-getstaticpaths-run"
      },
      {
        "level": 3,
        "text": "How does getStaticProps run with regards to getStaticPaths",
        "slug": "how-does-getstaticprops-run-with-regards-to-getstaticpaths"
      },
      {
        "level": 2,
        "text": "Where can I use getStaticPaths",
        "slug": "where-can-i-use-getstaticpaths"
      },
      {
        "level": 2,
        "text": "Runs on every request in development",
        "slug": "runs-on-every-request-in-development"
      },
      {
        "level": 2,
        "text": "Generating paths on-demand",
        "slug": "generating-paths-on-demand"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "import type {\r\n  InferGetStaticPropsType,\r\n  GetStaticProps,\r\n  GetStaticPaths,\r\n} from 'next'\r\n\r\ntype Repo = {\r\n  name: string\r\n  stargazers_count: number\r\n}\r\n\r\nexport const getStaticPaths = (async () => {\r\n  return {\r\n    paths: [\r\n      {\r\n        params: {\r\n          name: 'next.js',\r\n        },\r\n      }, // See the \"paths\" section below\r\n    ],\r\n    fallback: true, // false or \"blocking\"\r\n  }\r\n}) satisfies GetStaticPaths\r\n\r\nexport const getStaticProps = (async (context) => {\r\n  const res = await fetch('https://api.github.com/repos/vercel/next.js')\r\n  const repo = await res.json()\r\n  return { props: { repo } }\r\n}) satisfies GetStaticProps<{\r\n  repo: Repo\r\n}>\r\n\r\nexport default function Page({\r\n  repo,\r\n}: InferGetStaticPropsType<typeof getStaticProps>) {\r\n  return repo.stargazers_count\r\n}",
        "context": "filename=\"pages/repo/[name].tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export async function getStaticPaths() {\r\n  return {\r\n    paths: [\r\n      {\r\n        params: {\r\n          name: 'next.js',\r\n        },\r\n      }, // See the \"paths\" section below\r\n    ],\r\n    fallback: true, // false or \"blocking\"\r\n  }\r\n}\r\n\r\nexport async function getStaticProps() {\r\n  const res = await fetch('https://api.github.com/repos/vercel/next.js')\r\n  const repo = await res.json()\r\n  return { props: { repo } }\r\n}\r\n\r\nexport default function Page({ repo }) {\r\n  return repo.stargazers_count\r\n}",
        "context": "filename=\"pages/repo/[name].js\" switcher"
      },
      {
        "language": "jsx",
        "code": "export async function getStaticPaths() {\r\n  // When this is true (in preview environments) don't\r\n  // prerender any static pages\r\n  // (faster builds, but slower initial page load)\r\n  if (process.env.SKIP_BUILD_STATIC_GENERATION) {\r\n    return {\r\n      paths: [],\r\n      fallback: 'blocking',\r\n    }\r\n  }\r\n\r\n  // Call an external API endpoint to get posts\r\n  const res = await fetch('https://.../posts')\r\n  const posts = await res.json()\r\n\r\n  // Get the paths we want to prerender based on posts\r\n  // In production environments, prerender all pages\r\n  // (slower builds, but faster initial page load)\r\n  const paths = posts.map((post) => ({\r\n    params: { id: post.id },\r\n  }))\r\n\r\n  // { fallback: false } means other routes should 404\r\n  return { paths, fallback: false }\r\n}",
        "context": "filename=\"pages/posts/[id].js\""
      }
    ],
    "content": "If a page has Dynamic Routes and uses getStaticProps, it needs to define a list of paths to be statically generated. When you export a function called getStaticPaths (Static Site Generation) from a page that uses dynamic routes, Next.js will statically pre-render all the paths specified by getStaticPaths. The getStaticPaths API reference covers all parameters and props that can be used with getStaticPaths. When should I use getStaticPaths? You should use getStaticPaths if you’re statically pre-rendering pages that use dynamic routes and: - The data comes from a headless CMS - The data comes from a database - The data comes from the filesystem - The data can be publicly cached (not user-specific) - The page must be pre-rendered (for SEO) and be very fast — getStaticProps generates HTML and JSON files, both of which can be cached by a CDN for performance When does getStaticPaths run getStaticPaths will only run during build in production, it will not be called during runtime. You can validate code written inside getStaticPaths is removed from the client-side bundle with this tool. How does getStaticProps run with regards to getStaticPaths - getStaticProps runs during next build for any paths returned during build - getStaticProps runs in the background when using fallback: true - getStaticProps is called before initial render when using fallback: blocking Where can I use getStaticPaths - getStaticPaths must be used with getStaticProps - You cannot use getStaticPaths with getServerSideProps - You can export getStaticPaths from a Dynamic Route that also uses getStaticProps - You cannot export getStaticPaths from non-page file (e.g. your components folder) - You must export getStaticPaths as a standalone function, and not a property of the page component Runs on every request in development In development (next dev), getStaticPaths will be called on every request. Generating paths on-demand getStaticPaths allows you to control which pages are generated during the build instead of on-demand with fallback. Generating more pages during a build will cause slower builds. You can defer generating all pages on-demand by returning an empty array for paths. This can be especially helpful when deploying your Next.js application to multiple environments. For example, you can have faster builds by generating all pages on-demand for previews (but not production builds). This is helpful for sites with hundreds/thousands of static pages.",
    "excerpt": "If a page has Dynamic Routes and uses getStaticProps, it needs to define a list of paths to be statically generated. When you export a function called getStaticPaths (Static Site Generation) from a pa...",
    "url": "https://nextjs.org/docs/02-pages/03-building-your-application/03-data-fetching/02-get-static-paths"
  },
  {
    "id": "02-pages-03-building-your-application-03-data-fetching-03-forms-and-mutations",
    "path": "02-pages\\03-building-your-application\\03-data-fetching\\03-forms-and-mutations.mdx",
    "title": "Forms and Mutations",
    "description": "Learn how to handle form submissions and data mutations with Next.js.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      },
      {
        "level": 3,
        "text": "Redirecting",
        "slug": "redirecting"
      },
      {
        "level": 3,
        "text": "Setting cookies",
        "slug": "setting-cookies"
      },
      {
        "level": 3,
        "text": "Reading cookies",
        "slug": "reading-cookies"
      },
      {
        "level": 3,
        "text": "Deleting cookies",
        "slug": "deleting-cookies"
      }
    ],
    "codeBlocks": [
      {
        "language": "ts",
        "code": "import type { NextApiRequest, NextApiResponse } from 'next'\r\n\r\nexport default async function handler(\r\n  req: NextApiRequest,\r\n  res: NextApiResponse\r\n) {\r\n  const id = await addPost()\r\n  res.redirect(307, `/post/${id}`)\r\n}",
        "context": "filename=\"pages/api/submit.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export default async function handler(req, res) {\r\n  const id = await addPost()\r\n  res.redirect(307, `/post/${id}`)\r\n}",
        "context": "filename=\"pages/api/submit.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import type { NextApiRequest, NextApiResponse } from 'next'\r\n\r\nexport default async function handler(\r\n  req: NextApiRequest,\r\n  res: NextApiResponse\r\n) {\r\n  res.setHeader('Set-Cookie', 'username=lee; Path=/; HttpOnly')\r\n  res.status(200).send('Cookie has been set.')\r\n}",
        "context": "filename=\"pages/api/cookie.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export default async function handler(req, res) {\r\n  res.setHeader('Set-Cookie', 'username=lee; Path=/; HttpOnly')\r\n  res.status(200).send('Cookie has been set.')\r\n}",
        "context": "filename=\"pages/api/cookie.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import type { NextApiRequest, NextApiResponse } from 'next'\r\n\r\nexport default async function handler(\r\n  req: NextApiRequest,\r\n  res: NextApiResponse\r\n) {\r\n  const auth = req.cookies.authorization\r\n  // ...\r\n}",
        "context": "filename=\"pages/api/cookie.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export default async function handler(req, res) {\r\n  const auth = req.cookies.authorization\r\n  // ...\r\n}",
        "context": "filename=\"pages/api/cookie.js\" switcher"
      },
      {
        "language": "ts",
        "code": "import type { NextApiRequest, NextApiResponse } from 'next'\r\n\r\nexport default async function handler(\r\n  req: NextApiRequest,\r\n  res: NextApiResponse\r\n) {\r\n  res.setHeader('Set-Cookie', 'username=; Path=/; HttpOnly; Max-Age=0')\r\n  res.status(200).send('Cookie has been deleted.')\r\n}",
        "context": "filename=\"pages/api/cookie.ts\" switcher"
      },
      {
        "language": "js",
        "code": "export default async function handler(req, res) {\r\n  res.setHeader('Set-Cookie', 'username=; Path=/; HttpOnly; Max-Age=0')\r\n  res.status(200).send('Cookie has been deleted.')\r\n}",
        "context": "filename=\"pages/api/cookie.js\" switcher"
      }
    ],
    "content": "Forms enable you to create and update data in web applications. Next.js provides a powerful way to handle form submissions and data mutations using API Routes. > Good to know: > > - We will soon recommend incrementally adopting the App Router and using Server Actions for handling form submissions and data mutations. Server Actions allow you to define asynchronous server functions that can be called directly from your components, without needing to manually create an API Route. > - API Routes do not specify CORS headers, meaning they are same-origin only by default. > - Since API Routes run on the server, we're able to use sensitive values (like API keys) through Environment Variables without exposing them to the client. This is critical for the security of your application. Examples Redirecting If you would like to redirect the user to a different route after a mutation, you can redirect to any absolute or relative URL: Setting cookies You can set cookies inside an API Route using the setHeader method on the response: Reading cookies You can read cookies inside an API Route using the cookies request helper: Deleting cookies You can delete cookies inside an API Route using the setHeader method on the response:",
    "excerpt": "Forms enable you to create and update data in web applications. Next.js provides a powerful way to handle form submissions and data mutations using API Routes. > Good to know: > > - We will soon recom...",
    "url": "https://nextjs.org/docs/02-pages/03-building-your-application/03-data-fetching/03-forms-and-mutations"
  },
  {
    "id": "02-pages-03-building-your-application-03-data-fetching-03-get-server-side-props",
    "path": "02-pages\\03-building-your-application\\03-data-fetching\\03-get-server-side-props.mdx",
    "title": "getServerSideProps",
    "description": "Fetch data on each request with `getServerSideProps`.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Example",
        "slug": "example"
      },
      {
        "level": 2,
        "text": "When should I use ?",
        "slug": "when-should-i-use-"
      },
      {
        "level": 2,
        "text": "Behavior",
        "slug": "behavior"
      },
      {
        "level": 2,
        "text": "Error Handling",
        "slug": "error-handling"
      },
      {
        "level": 2,
        "text": "Edge Cases",
        "slug": "edge-cases"
      },
      {
        "level": 3,
        "text": "Caching with Server-Side Rendering (SSR)",
        "slug": "caching-with-server-side-rendering-ssr"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "import type { InferGetServerSidePropsType, GetServerSideProps } from 'next'\r\n\r\ntype Repo = {\r\n  name: string\r\n  stargazers_count: number\r\n}\r\n\r\nexport const getServerSideProps = (async () => {\r\n  // Fetch data from external API\r\n  const res = await fetch('https://api.github.com/repos/vercel/next.js')\r\n  const repo: Repo = await res.json()\r\n  // Pass data to the page via props\r\n  return { props: { repo } }\r\n}) satisfies GetServerSideProps<{ repo: Repo }>\r\n\r\nexport default function Page({\r\n  repo,\r\n}: InferGetServerSidePropsType<typeof getServerSideProps>) {\r\n  return (\r\n    <main>\r\n      <p>{repo.stargazers_count}</p>\r\n    </main>\r\n  )\r\n}",
        "context": "filename=\"pages/index.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export async function getServerSideProps() {\r\n  // Fetch data from external API\r\n  const res = await fetch('https://api.github.com/repos/vercel/next.js')\r\n  const repo = await res.json()\r\n  // Pass data to the page via props\r\n  return { props: { repo } }\r\n}\r\n\r\nexport default function Page({ repo }) {\r\n  return (\r\n    <main>\r\n      <p>{repo.stargazers_count}</p>\r\n    </main>\r\n  )\r\n}",
        "context": "filename=\"pages/index.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "// This value is considered fresh for ten seconds (s-maxage=10).\r\n// If a request is repeated within the next 10 seconds, the previously\r\n// cached value will still be fresh. If the request is repeated before 59 seconds,\r\n// the cached value will be stale but still render (stale-while-revalidate=59).\r\n//\r\n// In the background, a revalidation request will be made to populate the cache\r\n// with a fresh value. If you refresh the page, you will see the new value.\r\nexport async function getServerSideProps({ req, res }) {\r\n  res.setHeader(\r\n    'Cache-Control',\r\n    'public, s-maxage=10, stale-while-revalidate=59'\r\n  )\r\n\r\n  return {\r\n    props: {},\r\n  }\r\n}",
        "context": ""
      }
    ],
    "content": "getServerSideProps is a Next.js function that can be used to fetch data and render the contents of a page at request time. Example You can use getServerSideProps by exporting it from a Page Component. The example below shows how you can fetch data from a 3rd party API in getServerSideProps, and pass the data to the page as props: When should I use getServerSideProps? You should use getServerSideProps if you need to render a page that relies on personalized user data, or information that can only be known at request time. For example, authorization headers or a geolocation. If you do not need to fetch the data at request time, or would prefer to cache the data and pre-rendered HTML, we recommend using getStaticProps. Behavior - getServerSideProps runs on the server. - getServerSideProps can only be exported from a page. - getServerSideProps returns JSON. - When a user visits a page, getServerSideProps will be used to fetch data at request time, and the data is used to render the initial HTML of the page. - props passed to the page component can be viewed on the client as part of the initial HTML. This is to allow the page to be hydrated correctly. Make sure that you don't pass any sensitive information that shouldn't be available on the client in props. - When a user visits the page through next/link or next/router, Next.js sends an API request to the server, which runs getServerSideProps. - You do not have to call a Next.js API Route to fetch data when using getServerSideProps since the function runs on the server. Instead, you can call a CMS, database, or other third-party APIs directly from inside getServerSideProps. > Good to know: > > - See getServerSideProps API reference for parameters and props that can be used with getServerSideProps. > - You can use the next-code-elimination tool to verify what Next.js eliminates from the client-side bundle. Error Handling If an error is thrown inside getServerSideProps, it will show the pages/500.js file. Check out the documentation for 500 page to learn more on how to create it. During development, this file will not be used and the development error overlay will be shown instead. Edge Cases Caching with Server-Side Rendering (SSR) You can use caching headers (Cache-Control) inside getServerSideProps to cache dynamic responses. For example, using stale-while-revalidate. However, before reaching for cache-control, we recommend seeing if getStaticProps with ISR is a better fit for your use case.",
    "excerpt": "getServerSideProps is a Next.js function that can be used to fetch data and render the contents of a page at request time. Example You can use getServerSideProps by exporting it from a Page Component....",
    "url": "https://nextjs.org/docs/02-pages/03-building-your-application/03-data-fetching/03-get-server-side-props"
  },
  {
    "id": "02-pages-03-building-your-application-03-data-fetching-05-client-side",
    "path": "02-pages\\03-building-your-application\\03-data-fetching\\05-client-side.mdx",
    "title": "Client-side Fetching",
    "description": "Learn about client-side data fetching, and how to use SWR, a data fetching React Hook library that handles caching, revalidation, focus tracking, refetching on interval and more.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Client-side data fetching with useEffect",
        "slug": "client-side-data-fetching-with-useeffect"
      },
      {
        "level": 2,
        "text": "Client-side data fetching with SWR",
        "slug": "client-side-data-fetching-with-swr"
      }
    ],
    "codeBlocks": [
      {
        "language": "jsx",
        "code": "import { useState, useEffect } from 'react'\r\n\r\nfunction Profile() {\r\n  const [data, setData] = useState(null)\r\n  const [isLoading, setLoading] = useState(true)\r\n\r\n  useEffect(() => {\r\n    fetch('/api/profile-data')\r\n      .then((res) => res.json())\r\n      .then((data) => {\r\n        setData(data)\r\n        setLoading(false)\r\n      })\r\n  }, [])\r\n\r\n  if (isLoading) return <p>Loading...</p>\r\n  if (!data) return <p>No profile data</p>\r\n\r\n  return (\r\n    <div>\r\n      <h1>{data.name}</h1>\r\n      <p>{data.bio}</p>\r\n    </div>\r\n  )\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import useSWR from 'swr'\r\n\r\nconst fetcher = (...args) => fetch(...args).then((res) => res.json())\r\n\r\nfunction Profile() {\r\n  const { data, error } = useSWR('/api/profile-data', fetcher)\r\n\r\n  if (error) return <div>Failed to load</div>\r\n  if (!data) return <div>Loading...</div>\r\n\r\n  return (\r\n    <div>\r\n      <h1>{data.name}</h1>\r\n      <p>{data.bio}</p>\r\n    </div>\r\n  )\r\n}",
        "context": ""
      }
    ],
    "content": "Client-side data fetching is useful when your page doesn't require SEO indexing, when you don't need to pre-render your data, or when the content of your pages needs to update frequently. Unlike the server-side rendering APIs, you can use client-side data fetching at the component level. If done at the page level, the data is fetched at runtime, and the content of the page is updated as the data changes. When used at the component level, the data is fetched at the time of the component mount, and the content of the component is updated as the data changes. It's important to note that using client-side data fetching can affect the performance of your application and the load speed of your pages. This is because the data fetching is done at the time of the component or pages mount, and the data is not cached. Client-side data fetching with useEffect The following example shows how you can fetch data on the client side using the useEffect hook. Client-side data fetching with SWR The team behind Next.js has created a React Hook library for data fetching called SWR. It is highly recommended if you are fetching data on the client-side. It handles caching, revalidation, focus tracking, refetching on intervals, and more. Using the same example as above, we can now use SWR to fetch the profile data. SWR will automatically cache the data for us and will revalidate the data if it becomes stale. For more information on using SWR, check out the SWR docs.",
    "excerpt": "Client-side data fetching is useful when your page doesn't require SEO indexing, when you don't need to pre-render your data, or when the content of your pages needs to update frequently. Unlike the s...",
    "url": "https://nextjs.org/docs/02-pages/03-building-your-application/03-data-fetching/05-client-side"
  },
  {
    "id": "02-pages-03-building-your-application-03-data-fetching-index",
    "path": "02-pages\\03-building-your-application\\03-data-fetching\\index.mdx",
    "title": "Data Fetching",
    "description": "Next.js allows you to fetch data in multiple ways, with pre-rendering, server-side rendering or static-site generation, and incremental static regeneration. Learn how to manage your application data in Next.js.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Examples",
        "slug": "examples"
      }
    ],
    "codeBlocks": [],
    "content": "Data fetching in Next.js allows you to render your content in different ways, depending on your application's use case. These include pre-rendering with Server-side Rendering or Static Generation, and updating or creating content at runtime with Incremental Static Regeneration. Examples - Agility CMS Example (Demo) - Builder.io Example (Demo) - ButterCMS Example (Demo) - Contentful Example (Demo) - Cosmic Example (Demo) - DatoCMS Example (Demo) - DotCMS Example (Demo) - Drupal Example (Demo) - Enterspeed Example (Demo) - GraphCMS Example (Demo) - Keystone Example (Demo) - Kontent.ai Example (Demo) - Makeswift Example (Demo) - Plasmic Example (Demo) - Prepr Example (Demo) - Prismic Example (Demo) - Sanity Example (Demo) - Sitecore XM Cloud Example (Demo) - Storyblok Example (Demo) - Strapi Example (Demo) - TakeShape Example (Demo) - Tina Example (Demo) - Umbraco Example (Demo) - Umbraco Heartcore Example (Demo) - Webiny Example (Demo) - WordPress Example (Demo) - Blog Starter Example (Demo) - Static Tweet (Demo)",
    "excerpt": "Data fetching in Next.js allows you to render your content in different ways, depending on your application's use case. These include pre-rendering with Server-side Rendering or Static Generation, and...",
    "url": "https://nextjs.org/docs/02-pages/03-building-your-application/03-data-fetching"
  },
  {
    "id": "02-pages-03-building-your-application-06-configuring-12-error-handling",
    "path": "02-pages\\03-building-your-application\\06-configuring\\12-error-handling.mdx",
    "title": "Error Handling",
    "description": "Handle errors in your Next.js app.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Handling Errors in Development",
        "slug": "handling-errors-in-development"
      },
      {
        "level": 2,
        "text": "Handling Server Errors",
        "slug": "handling-server-errors"
      },
      {
        "level": 2,
        "text": "Handling Client Errors",
        "slug": "handling-client-errors"
      },
      {
        "level": 3,
        "text": "Reporting Errors",
        "slug": "reporting-errors"
      }
    ],
    "codeBlocks": [
      {
        "language": "jsx",
        "code": "class ErrorBoundary extends React.Component {\r\n  constructor(props) {\r\n    super(props)\r\n\r\n    // Define a state variable to track whether is an error or not\r\n    this.state = { hasError: false }\r\n  }\r\n  static getDerivedStateFromError(error) {\r\n    // Update state so the next render will show the fallback UI\r\n\r\n    return { hasError: true }\r\n  }\r\n  componentDidCatch(error, errorInfo) {\r\n    // You can use your own error logging service here\r\n    console.log({ error, errorInfo })\r\n  }\r\n  render() {\r\n    // Check if the error is thrown\r\n    if (this.state.hasError) {\r\n      // You can render any custom fallback UI\r\n      return (\r\n        <div>\r\n          <h2>Oops, there is an error!</h2>\r\n          <button\r\n            type=\"button\"\r\n            onClick={() => this.setState({ hasError: false })}\r\n          >\r\n            Try again?\r\n          </button>\r\n        </div>\r\n      )\r\n    }\r\n\r\n    // Return children components in case of no error\r\n\r\n    return this.props.children\r\n  }\r\n}\r\n\r\nexport default ErrorBoundary",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "// Import the ErrorBoundary component\r\nimport ErrorBoundary from '../components/ErrorBoundary'\r\n\r\nfunction MyApp({ Component, pageProps }) {\r\n  return (\r\n    // Wrap the Component prop with ErrorBoundary component\r\n    <ErrorBoundary>\r\n      <Component {...pageProps} />\r\n    </ErrorBoundary>\r\n  )\r\n}\r\n\r\nexport default MyApp",
        "context": ""
      }
    ],
    "content": "This documentation explains how you can handle development, server-side, and client-side errors. Handling Errors in Development When there is a runtime error during the development phase of your Next.js application, you will encounter an overlay. It is a modal that covers the webpage. It is only visible when the development server runs using next dev via pnpm dev, npm run dev, yarn dev, or bun dev and will not be shown in production. Fixing the error will automatically dismiss the overlay. Here is an example of an overlay: !Example of an overlay when in development mode Handling Server Errors Next.js provides a static 500 page by default to handle server-side errors that occur in your application. You can also customize this page by creating a pages/500.js file. Having a 500 page in your application does not show specific errors to the app user. You can also use 404 page to handle specific runtime error like file not found. Handling Client Errors React Error Boundaries is a graceful way to handle a JavaScript error on the client so that the other parts of the application continue working. In addition to preventing the page from crashing, it allows you to provide a custom fallback component and even log error information. To use Error Boundaries for your Next.js application, you must create a class component ErrorBoundary and wrap the Component prop in the pages/app.js file. This component will be responsible to: - Render a fallback UI after an error is thrown - Provide a way to reset the Application's state - Log error information You can create an ErrorBoundary class component by extending React.Component. For example: The ErrorBoundary component keeps track of an hasError state. The value of this state variable is a boolean. When the value of hasError is true, then the ErrorBoundary component will render a fallback UI. Otherwise, it will render the children components. After creating an ErrorBoundary component, import it in the pages/app.js file to wrap the Component prop in your Next.js application. You can learn more about Error Boundaries in React's documentation. Reporting Errors To monitor client errors, use a service like Sentry, Bugsnag or Datadog.",
    "excerpt": "This documentation explains how you can handle development, server-side, and client-side errors. Handling Errors in Development When there is a runtime error during the development phase of your Next....",
    "url": "https://nextjs.org/docs/02-pages/03-building-your-application/06-configuring/12-error-handling"
  },
  {
    "id": "02-pages-03-building-your-application-06-configuring-index",
    "path": "02-pages\\03-building-your-application\\06-configuring\\index.mdx",
    "title": "Configuring",
    "description": "Learn how to configure your Next.js application.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "Next.js allows you to customize your project to meet specific requirements. This includes integrations with TypeScript, ESlint, and more, as well as internal configuration options such as Absolute Imports and Environment Variables.",
    "excerpt": "Next.js allows you to customize your project to meet specific requirements. This includes integrations with TypeScript, ESlint, and more, as well as internal configuration options such as Absolute Imp...",
    "url": "https://nextjs.org/docs/02-pages/03-building-your-application/06-configuring"
  },
  {
    "id": "02-pages-03-building-your-application-index",
    "path": "02-pages\\03-building-your-application\\index.mdx",
    "title": "Building Your Application",
    "description": "Learn how to use Next.js features to build your application.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/03-building-your-application"
  },
  {
    "id": "02-pages-04-api-reference-01-components-font",
    "path": "02-pages\\04-api-reference\\01-components\\font.mdx",
    "title": "Font Module",
    "description": "API Reference for the Font Module",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/01-components/font"
  },
  {
    "id": "02-pages-04-api-reference-01-components-form",
    "path": "02-pages\\04-api-reference\\01-components\\form.mdx",
    "title": "Form",
    "description": "Learn how to use the `<Form>` component to handle form submissions and search params updates with client-side navigation.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/01-components/form"
  },
  {
    "id": "02-pages-04-api-reference-01-components-head",
    "path": "02-pages\\04-api-reference\\01-components\\head.mdx",
    "title": "Head",
    "description": "Add custom elements to the `head` of your page with the built-in Head component.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Avoid duplicated tags",
        "slug": "avoid-duplicated-tags"
      },
      {
        "level": 2,
        "text": "Use minimal nesting",
        "slug": "use-minimal-nesting"
      },
      {
        "level": 2,
        "text": "Use  for scripts",
        "slug": "use-for-scripts"
      },
      {
        "level": 2,
        "text": "No  or  tags",
        "slug": "no-or-tags"
      }
    ],
    "codeBlocks": [
      {
        "language": "jsx",
        "code": "import Head from 'next/head'\r\n\r\nfunction IndexPage() {\r\n  return (\r\n    <div>\r\n      <Head>\r\n        <title>My page title</title>\r\n      </Head>\r\n      <p>Hello world!</p>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default IndexPage",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import Head from 'next/head'\r\n\r\nfunction IndexPage() {\r\n  return (\r\n    <div>\r\n      <Head>\r\n        <title>My page title</title>\r\n        <meta property=\"og:title\" content=\"My page title\" key=\"title\" />\r\n      </Head>\r\n      <Head>\r\n        <meta property=\"og:title\" content=\"My new title\" key=\"title\" />\r\n      </Head>\r\n      <p>Hello world!</p>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default IndexPage",
        "context": ""
      }
    ],
    "content": "We expose a built-in component for appending elements to the head of the page: Avoid duplicated tags To avoid duplicate tags in your head you can use the key property, which will make sure the tag is only rendered once, as in the following example: In this case only the second is rendered. meta tags with duplicate key attributes are automatically handled. > Good to know: and tags are automatically checked for duplicates by Next.js, so using key is not necessary for these tags. > The contents of head get cleared upon unmounting the component, so make sure each page completely defines what it needs in head, without making assumptions about what other pages added. Use minimal nesting title, meta or any other elements (e.g. script) need to be contained as direct children of the Head element, or wrapped into maximum one level of or arrays—otherwise the tags won't be correctly picked up on client-side navigations. Use next/script for scripts We recommend using next/script in your component instead of manually creating a in next/head. No html or body tags You cannot use to set attributes on or tags. This will result in an next-head-count is missing error. next/head can only handle tags inside the HTML tag.",
    "excerpt": "We expose a built-in component for appending elements to the head of the page: Avoid duplicated tags To avoid duplicate tags in your head you can use the key property, which will make sure the tag is...",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/01-components/head"
  },
  {
    "id": "02-pages-04-api-reference-01-components-image-legacy",
    "path": "02-pages\\04-api-reference\\01-components\\image-legacy.mdx",
    "title": "Image (Legacy)",
    "description": "Backwards compatible Image Optimization with the Legacy Image component.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Comparison",
        "slug": "comparison"
      },
      {
        "level": 2,
        "text": "Required Props",
        "slug": "required-props"
      },
      {
        "level": 3,
        "text": "src",
        "slug": "src"
      },
      {
        "level": 3,
        "text": "width",
        "slug": "width"
      },
      {
        "level": 3,
        "text": "height",
        "slug": "height"
      },
      {
        "level": 2,
        "text": "Optional Props",
        "slug": "optional-props"
      },
      {
        "level": 3,
        "text": "layout",
        "slug": "layout"
      },
      {
        "level": 3,
        "text": "loader",
        "slug": "loader"
      },
      {
        "level": 3,
        "text": "sizes",
        "slug": "sizes"
      },
      {
        "level": 3,
        "text": "quality",
        "slug": "quality"
      },
      {
        "level": 3,
        "text": "priority",
        "slug": "priority"
      },
      {
        "level": 3,
        "text": "placeholder",
        "slug": "placeholder"
      },
      {
        "level": 2,
        "text": "Advanced Props",
        "slug": "advanced-props"
      },
      {
        "level": 3,
        "text": "style",
        "slug": "style"
      },
      {
        "level": 3,
        "text": "objectFit",
        "slug": "objectfit"
      },
      {
        "level": 3,
        "text": "objectPosition",
        "slug": "objectposition"
      },
      {
        "level": 3,
        "text": "onLoadingComplete",
        "slug": "onloadingcomplete"
      },
      {
        "level": 3,
        "text": "loading",
        "slug": "loading"
      },
      {
        "level": 3,
        "text": "blurDataURL",
        "slug": "blurdataurl"
      },
      {
        "level": 3,
        "text": "lazyBoundary",
        "slug": "lazyboundary"
      },
      {
        "level": 3,
        "text": "lazyRoot",
        "slug": "lazyroot"
      },
      {
        "level": 3,
        "text": "unoptimized",
        "slug": "unoptimized"
      },
      {
        "level": 2,
        "text": "Other Props",
        "slug": "other-props"
      },
      {
        "level": 2,
        "text": "Configuration Options",
        "slug": "configuration-options"
      },
      {
        "level": 3,
        "text": "Remote Patterns",
        "slug": "remote-patterns"
      },
      {
        "level": 3,
        "text": "Domains",
        "slug": "domains"
      },
      {
        "level": 3,
        "text": "Loader Configuration",
        "slug": "loader-configuration"
      },
      {
        "level": 4,
        "text": "Customizing the Built-in Image Path",
        "slug": "customizing-the-built-in-image-path"
      },
      {
        "level": 3,
        "text": "Built-in Loaders",
        "slug": "built-in-loaders"
      },
      {
        "level": 2,
        "text": "Advanced",
        "slug": "advanced"
      },
      {
        "level": 3,
        "text": "Device Sizes",
        "slug": "device-sizes"
      },
      {
        "level": 3,
        "text": "Image Sizes",
        "slug": "image-sizes"
      },
      {
        "level": 3,
        "text": "Acceptable Formats",
        "slug": "acceptable-formats"
      },
      {
        "level": 2,
        "text": "Caching Behavior",
        "slug": "caching-behavior"
      },
      {
        "level": 3,
        "text": "Minimum Cache TTL",
        "slug": "minimum-cache-ttl"
      },
      {
        "level": 3,
        "text": "Disable Static Imports",
        "slug": "disable-static-imports"
      },
      {
        "level": 3,
        "text": "Dangerously Allow SVG",
        "slug": "dangerously-allow-svg"
      },
      {
        "level": 3,
        "text": "Animated Images",
        "slug": "animated-images"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "js",
        "code": "import Image from 'next/legacy/image'\r\n\r\nconst myLoader = ({ src, width, quality }) => {\r\n  return `https://example.com/${src}?w=${width}&q=${quality || 75}`\r\n}\r\n\r\nconst MyImage = (props) => {\r\n  return (\r\n    <Image\r\n      loader={myLoader}\r\n      src=\"me.png\"\r\n      alt=\"Picture of the author\"\r\n      width={500}\r\n      height={500}\r\n    />\r\n  )\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "import Image from 'next/legacy/image'\r\nconst Example = () => (\r\n  <div className=\"grid-element\">\r\n    <Image\r\n      src=\"/example.png\"\r\n      layout=\"fill\"\r\n      sizes=\"(max-width: 768px) 100vw,\r\n              (max-width: 1200px) 50vw,\r\n              33vw\"\r\n    />\r\n  </div>\r\n)",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import Image from 'next/legacy/image'\r\nimport React from 'react'\r\n\r\nconst Example = () => {\r\n  const lazyRoot = React.useRef(null)\r\n\r\n  return (\r\n    <div ref={lazyRoot} style={{ overflowX: 'scroll', width: '500px' }}>\r\n      <Image lazyRoot={lazyRoot} src=\"/one.jpg\" width=\"500\" height=\"500\" />\r\n      <Image lazyRoot={lazyRoot} src=\"/two.jpg\" width=\"500\" height=\"500\" />\r\n    </div>\r\n  )\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import Image from 'next/legacy/image'\r\nimport React from 'react'\r\n\r\nconst Container = React.forwardRef((props, ref) => {\r\n  return (\r\n    <div ref={ref} style={{ overflowX: 'scroll', width: '500px' }}>\r\n      {props.children}\r\n    </div>\r\n  )\r\n})\r\n\r\nconst Example = () => {\r\n  const lazyRoot = React.useRef(null)\r\n\r\n  return (\r\n    <Container ref={lazyRoot}>\r\n      <Image lazyRoot={lazyRoot} src=\"/one.jpg\" width=\"500\" height=\"500\" />\r\n      <Image lazyRoot={lazyRoot} src=\"/two.jpg\" width=\"500\" height=\"500\" />\r\n    </Container>\r\n  )\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "import Image from 'next/image'\r\n\r\nconst UnoptimizedImage = (props) => {\r\n  return <Image {...props} unoptimized />\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    unoptimized: true,\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    remotePatterns: [\r\n      {\r\n        protocol: 'https',\r\n        hostname: 'example.com',\r\n        port: '',\r\n        pathname: '/account123/**',\r\n        search: '',\r\n      },\r\n    ],\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    remotePatterns: [\r\n      {\r\n        protocol: 'https',\r\n        hostname: '**.example.com',\r\n        port: '',\r\n        search: '',\r\n      },\r\n    ],\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    remotePatterns: [\r\n      {\r\n        protocol: 'https',\r\n        hostname: 'assets.example.com',\r\n        search: '?v=1727111025337',\r\n      },\r\n    ],\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    domains: ['assets.acme.com'],\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    loader: 'imgix',\r\n    path: 'https://example.com/myaccount/',\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    path: '/my-prefix/_next/image',\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    imageSizes: [32, 48, 64, 96, 128, 256, 384],\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    formats: ['image/webp'],\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    formats: ['image/avif'],\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    minimumCacheTTL: 14400, // 4 hours\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    minimumCacheTTL: 2678400, // 31 days\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    disableStaticImages: true,\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    dangerouslyAllowSVG: true,\r\n    contentDispositionType: 'attachment',\r\n    contentSecurityPolicy: \"default-src 'self'; script-src 'none'; sandbox;\",\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  images: {\r\n    contentDispositionType: 'inline',\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      }
    ],
    "content": "Starting with Next.js 13, the next/image component was rewritten to improve both the performance and developer experience. In order to provide a backwards compatible upgrade solution, the old next/image was renamed to next/legacy/image. > Warning: next/legacy/image is deprecated and will be removed in a future version of Next.js. Please use next/image instead. Comparison Compared to next/legacy/image, the new next/image component has the following changes: - Removes wrapper around in favor of native computed aspect ratio - Adds support for canonical style prop - Removes layout prop in favor of style or className - Removes objectFit prop in favor of style or className - Removes objectPosition prop in favor of style or className - Removes IntersectionObserver implementation in favor of native lazy loading - Removes lazyBoundary prop since there is no native equivalent - Removes lazyRoot prop since there is no native equivalent - Removes loader config in favor of loader prop - Changed alt prop from optional to required - Changed onLoadingComplete callback to receive reference to element Required Props The component requires the following properties. src Must be one of the following: - A statically imported image file - A path string. This can be either an absolute external URL, or an internal path depending on the loader prop or loader configuration. When using the default loader, also consider the following for source images: - When src is an external URL, you must also configure remotePatterns - When src is animated or not a known format (JPEG, PNG, WebP, AVIF, GIF, TIFF) the image will be served as-is - When src is SVG format, it will be blocked unless unoptimized or dangerouslyAllowSVG is enabled width The width property can represent either the rendered width or original width in pixels, depending on the layout and sizes properties. When using layout=\"intrinsic\" or layout=\"fixed\" the width property represents the rendered width in pixels, so it will affect how large the image appears. When using layout=\"responsive\", layout=\"fill\", the width property represents the original width in pixels, so it will only affect the aspect ratio. The width property is required, except for statically imported images, or those with layout=\"fill\". height The height property can represent either the rendered height or original height in pixels, depending on the layout and sizes properties. When using layout=\"intrinsic\" or layout=\"fixed\" the height property represents the rendered height in pixels, so it will affect how large the image appears. When using layout=\"responsive\", layout=\"fill\", the height property represents the original height in pixels, so it will only affect the aspect ratio. The height property is required, except for statically imported images, or those with layout=\"fill\". Optional Props The component accepts a number of additional properties beyond those which are required. This section describes the most commonly-used properties of the Image component. Find details about more rarely-used properties in the Advanced Props section. layout The layout behavior of the image as the viewport changes size. | layout | Behavior | srcSet | sizes | Has wrapper and sizer | | --------------------- | -------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------- | ------- | --------------------- | | intrinsic (default) | Scale down to fit width of container, up to image size | 1x, 2x (based on imageSizes) | N/A | yes | | fixed | Sized to width and height exactly | 1x, 2x (based on imageSizes) | N/A | yes | | responsive | Scale to fit width of container | 640w, 750w, ... 2048w, 3840w (based on imageSizes and deviceSizes) | 100vw | yes | | fill | Grow in both X and Y axes to fill container | 640w, 750w, ... 2048w, 3840w (based on imageSizes and deviceSizes) | 100vw | yes | - Demo the intrinsic layout (default) - When intrinsic, the image will scale the dimensions down for smaller viewports, but maintain the original dimensions for larger viewports. - Demo the fixed layout - When fixed, the image dimensions will not change as the viewport changes (no responsiveness) similar to the native img element. - Demo the responsive layout - When responsive, the image will scale the dimensions down for smaller viewports and scale up for larger viewports. - Ensure the parent element uses display: block in their stylesheet. - Demo the fill layout - When fill, the image will stretch both width and height to the dimensions of the parent element, provided the parent element is relative. - This is usually paired with the objectFit property. - Ensure the parent element has position: relative in their stylesheet. - Demo background image loader A custom function used to resolve URLs. Setting the loader as a prop on the Image component overrides the default loader defined in the images section of next.config.js. A loader is a function returning a URL string for the image, given the following parameters: - src - width - quality Here is an example of using a custom loader: sizes A string that provides information about how wide the image will be at different breakpoints. The value of sizes will greatly affect performance for images using layout=\"responsive\" or layout=\"fill\". It will be ignored for images using layout=\"intrinsic\" or layout=\"fixed\". The sizes property serves two important purposes related to image performance: First, the value of sizes is used by the browser to determine which size of the image to download, from next/legacy/image's automatically-generated source set. When the browser chooses, it does not yet know the size of the image on the page, so it selects an image that is the same size or larger than the viewport. The sizes property allows you to tell the browser that the image will actually be smaller than full screen. If you don't specify a sizes value, a default value of 100vw (full screen width) is used. Second, the sizes value is parsed and used to trim the values in the automatically-created source set. If the sizes property includes sizes such as 50vw, which represent a percentage of the viewport width, then the source set is trimmed to not include any values which are too small to ever be necessary. For example, if you know your styling will cause an image to be full-width on mobile devices, in a 2-column layout on tablets, and a 3-column layout on desktop displays, you should include a sizes property such as the following: This example sizes could have a dramatic effect on performance metrics. Without the 33vw sizes, the image selected from the server would be 3 times as wide as it needs to be. Because file size is proportional to the square of the width, without sizes the user would download an image that's 9 times larger than necessary. Learn more about srcset and sizes: - web.dev - mdn quality The quality of the optimized image, an integer between 1 and 100 where 100 is the best quality. Defaults to 75. priority When true, the image will be considered high priority and preload. Lazy loading is automatically disabled for images using priority. You should use the priority property on any image detected as the Largest Contentful Paint (LCP) element. It may be appropriate to have multiple priority images, as different images may be the LCP element for different viewport sizes. Should only be used when the image is visible above the fold. Defaults to false. placeholder A placeholder to use while the image is loading. Possible values are blur or empty. Defaults to empty. When blur, the blurDataURL property will be used as the placeholder. If src is an object from a static import and the imported image is .jpg, .png, .webp, or .avif, then blurDataURL will be automatically populated. For dynamic images, you must provide the blurDataURL property. Solutions such as Plaiceholder can help with base64 generation. When empty, there will be no placeholder while the image is loading, only empty space. Try it out: - Demo the blur placeholder - Demo the shimmer effect with blurDataURL prop - Demo the color effect with blurDataURL prop Advanced Props In some cases, you may need more advanced usage. The component optionally accepts the following advanced properties. style Allows passing CSS styles to the underlying image element. Note that all layout modes apply their own styles to the image element, and these automatic styles take precedence over the style prop. Also keep in mind that the required width and height props can interact with your styling. If you use styling to modify an image's width, you must set the height=\"auto\" style as well, or your image will be distorted. objectFit Defines how the image will fit into its parent container when using layout=\"fill\". This value is passed to the object-fit CSS property for the src image. objectPosition Defines how the image is positioned within its parent element when using layout=\"fill\". This value is passed to the object-position CSS property applied to the image. onLoadingComplete A callback function that is invoked once the image is completely loaded and the placeholder has been removed. The onLoadingComplete function accepts one parameter, an object with the following properties: - naturalWidth - naturalHeight loading The loading behavior of the image. Defaults to lazy. When lazy, defer loading the image until it reaches a calculated distance from the viewport. When eager, load the image immediately. Learn more blurDataURL A Data URL to be used as a placeholder image before the src image successfully loads. Only takes effect when combined with placeholder=\"blur\". Must be a base64-encoded image. It will be enlarged and blurred, so a very small image (10px or less) is recommended. Including larger images as placeholders may harm your application performance. Try it out: - Demo the default blurDataURL prop - Demo the shimmer effect with blurDataURL prop - Demo the color effect with blurDataURL prop You can also generate a solid color Data URL to match the image. lazyBoundary A string (with similar syntax to the margin property) that acts as the bounding box used to detect the intersection of the viewport with the image and trigger lazy loading. Defaults to \"200px\". If the image is nested in a scrollable parent element other than the root document, you will also need to assign the lazyRoot prop. Learn more lazyRoot A React Ref pointing to the scrollable parent element. Defaults to null (the document viewport). The Ref must point to a DOM element or a React component that forwards the Ref to the underlying DOM element. Example pointing to a DOM element Example pointing to a React component Learn more unoptimized When true, the source image will be served as-is from the src instead of changing quality, size, or format. Defaults to false. This is useful for images that do not benefit from optimization such as small images (less than 1KB), vector images (SVG), or animated images (GIF). Since Next.js 12.3.0, this prop can be assigned to all images by updating next.config.js with the following configuration: Other Props Other properties on the component will be passed to the underlying img element with the exception of the following: - srcSet. Use Device Sizes instead. - ref. Use onLoadingComplete instead. - decoding. It is always \"async\". Configuration Options Remote Patterns To protect your application from malicious users, configuration is required in order to use external images. This ensures that only external images from your account can be served from the Next.js Image Optimization API. These external images can be configured with the remotePatterns property in your next.config.js file, as shown below: > Good to know: The example above will ensure the src property of next/legacy/image must start with https://example.com/account123/ and must not have a query string. Any other protocol, hostname, port, or unmatched path will respond with 400 Bad Request. Below is an example of the remotePatterns property in the next.config.js file using a wildcard pattern in the hostname: > Good to know: The example above will ensure the src property of next/legacy/image must start with https://img1.example.com or https://me.avatar.example.com or any number of subdomains. It cannot have a port or query string. Any other protocol or unmatched hostname will respond with 400 Bad Request. Wildcard patterns can be used for both pathname and hostname and have the following syntax: - match a single path segment or subdomain - match any number of path segments at the end or subdomains at the beginning The syntax does not work in the middle of the pattern. > Good to know: When omitting protocol, port, pathname, or search then the wildcard is implied. This is not recommended because it may allow malicious actors to optimize urls you did not intend. Below is an example of the remotePatterns property in the next.config.js file using search: > Good to know: The example above will ensure the src property of next/legacy/image must start with https://assets.example.com and must have the exact query string ?v=1727111025337. Any other protocol or query string will respond with 400 Bad Request. Domains > Warning: Deprecated since Next.js 14 in favor of strict remotePatterns in order to protect your application from malicious users. Only use domains if you own all the content served from the domain. Similar to remotePatterns, the domains configuration can be used to provide a list of allowed hostnames for external images. However, the domains configuration does not support wildcard pattern matching and it cannot restrict protocol, port, or pathname. Below is an example of the domains property in the next.config.js file: Loader Configuration If you want to use a cloud provider to optimize images instead of using the Next.js built-in Image Optimization API, you can configure the loader and path prefix in your next.config.js file. This allows you to use relative URLs for the Image src and automatically generate the correct absolute URL for your provider. Customizing the Built-in Image Path If you want to change or prefix the default path for the built-in Next.js image optimization, you can do so with the path property. The default value for path is /next/image. Built-in Loaders The following Image Optimization cloud providers are included: - Default: Works automatically with next dev, next start, or a custom server - Vercel: Works automatically when you deploy on Vercel, no configuration necessary. Learn more - Imgix: loader: 'imgix' - Cloudinary: loader: 'cloudinary' - Akamai: loader: 'akamai' - Custom: loader: 'custom' use a custom cloud provider by implementing the loader prop on the next/legacy/image component If you need a different provider, you can use the loader prop with next/legacy/image. > Images can not be optimized at build time using output: 'export', only on-demand. To use next/legacy/image with output: 'export', you will need to use a different loader than the default. Read more in the discussion. Advanced The following configuration is for advanced use cases and is usually not necessary. If you choose to configure the properties below, you will override any changes to the Next.js defaults in future updates. Device Sizes If you know the expected device widths of your users, you can specify a list of device width breakpoints using the deviceSizes property in next.config.js. These widths are used when the next/legacy/image component uses layout=\"responsive\" or layout=\"fill\" to ensure the correct image is served for user's device. If no configuration is provided, the default below is used. Image Sizes You can specify a list of image widths using the images.imageSizes property in your next.config.js file. These widths are concatenated with the array of device sizes to form the full array of sizes used to generate image srcsets. The reason there are two separate lists is that imageSizes is only used for images which provide a sizes prop, which indicates that the image is less than the full width of the screen. Therefore, the sizes in imageSizes should all be smaller than the smallest size in deviceSizes. If no configuration is provided, the default below is used. Acceptable Formats The default Image Optimization API will automatically detect the browser's supported image formats via the request's Accept header in order to determine the best output format. If the Accept header matches more than one of the configured formats, the first match in the array is used. Therefore, the array order matters. If there is no match (or the source image is animated), the Image Optimization API will fallback to the original image's format. If no configuration is provided, the default below is used. You can enable AVIF support, which will fallback to the original format of the src image if the browser does not support AVIF: > Good to know: > > - We still recommend using WebP for most use cases. > - AVIF generally takes 50% longer to encode but it compresses 20% smaller compared to WebP. This means that the first time an image is requested, it will typically be slower and then subsequent requests that are cached will be faster. > - If you self-host with a Proxy/CDN in front of Next.js, you must configure the Proxy to forward the Accept header. Caching Behavior The following describes the caching algorithm for the default loader. For all other loaders, please refer to your cloud provider's documentation. Images are optimized dynamically upon request and stored in the /cache/images directory. The optimized image file will be served for subsequent requests until the expiration is reached. When a request is made that matches a cached but expired file, the expired image is served stale immediately. Then the image is optimized again in the background (also called revalidation) and saved to the cache with the new expiration date. The cache status of an image can be determined by reading the value of the x-nextjs-cache (x-vercel-cache when deployed on Vercel) response header. The possible values are the following: - MISS - the path is not in the cache (occurs at most once, on the first visit) - STALE - the path is in the cache but exceeded the revalidate time so it will be updated in the background - HIT - the path is in the cache and has not exceeded the revalidate time The expiration (or rather Max Age) is defined by either the minimumCacheTTL configuration or the upstream image Cache-Control header, whichever is larger. Specifically, the max-age value of the Cache-Control header is used. If both s-maxage and max-age are found, then s-maxage is preferred. The max-age is also passed-through to any downstream clients including CDNs and browsers. - You can configure minimumCacheTTL to increase the cache duration when the upstream image does not include Cache-Control header or the value is very low. - You can configure deviceSizes and imageSizes to reduce the total number of possible generated images. - You can configure formats to disable multiple formats in favor of a single image format. Minimum Cache TTL You can configure the Time to Live (TTL) in seconds for cached optimized images. In many cases, it's better to use a Static Image Import which will automatically hash the file contents and cache the image forever with a Cache-Control header of immutable. If no configuration is provided, the default below is used. You can increase the TTL to reduce the number of revalidations and potentially lower cost: The expiration (or rather Max Age) of the optimized image is defined by either the minimumCacheTTL or the upstream image Cache-Control header, whichever is larger. If you need to change the caching behavior per image, you can configure headers to set the Cache-Control header on the upstream image (e.g. /some-asset.jpg, not /next/image itself). There is no mechanism to invalidate the cache at this time, so its best to keep minimumCacheTTL low. Otherwise you may need to manually change the src prop or delete /cache/images. Disable Static Imports The default behavior allows you to import static files such as import icon from './icon.png' and then pass that to the src property. In some cases, you may wish to disable this feature if it conflicts with other plugins that expect the import to behave differently. You can disable static image imports inside your next.config.js: Dangerously Allow SVG The default loader does not optimize SVG images for a few reasons. First, SVG is a vector format meaning it can be resized losslessly. Second, SVG has many of the same features as HTML/CSS, which can lead to vulnerabilities without proper Content Security Policy (CSP) headers. Therefore, we recommended using the unoptimized prop when the src prop is known to be SVG. This happens automatically when src ends with \".svg\". However, if you need to serve SVG images with the default Image Optimization API, you can set dangerouslyAllowSVG inside your next.config.js: In addition, it is strongly recommended to also set contentDispositionType to force the browser to download the image, as well as contentSecurityPolicy to prevent scripts embedded in the image from executing. contentDispositionType The default loader sets the Content-Disposition header to attachment for added protection since the API can serve arbitrary remote images. The default value is attachment which forces the browser to download the image when visiting directly. This is particularly important when dangerouslyAllowSVG is true. You can optionally configure inline to allow the browser to render the image when visiting directly, without downloading it. Animated Images The default loader will automatically bypass Image Optimization for animated images and serve the image as-is. Auto-detection for animated files is best-effort and supports GIF, APNG, and WebP. If you want to explicitly bypass Image Optimization for a given animated image, use the unoptimized prop. Version History | Version | Changes | | --------- | ------------------------------------------------------------------------------------------------------------------- | | v16.0.0 | next/legacy/image deprecated and will be removed in a future version of Next.js. Please use next/image instead. | | v13.0.0 | next/image renamed to next/legacy/image |",
    "excerpt": "Starting with Next.js 13, the next/image component was rewritten to improve both the performance and developer experience. In order to provide a backwards compatible upgrade solution, the old next/ima...",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/01-components/image-legacy"
  },
  {
    "id": "02-pages-04-api-reference-01-components-image",
    "path": "02-pages\\04-api-reference\\01-components\\image.mdx",
    "title": "Image",
    "description": "Optimize Images in your Next.js Application using the built-in `next/image` Component.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/01-components/image"
  },
  {
    "id": "02-pages-04-api-reference-01-components-index",
    "path": "02-pages\\04-api-reference\\01-components\\index.mdx",
    "title": "Components",
    "description": "API Reference for Next.js built-in components in the Pages Router.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/01-components"
  },
  {
    "id": "02-pages-04-api-reference-01-components-link",
    "path": "02-pages\\04-api-reference\\01-components\\link.mdx",
    "title": "Link",
    "description": "API reference for the `<Link>` component.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/01-components/link"
  },
  {
    "id": "02-pages-04-api-reference-01-components-script",
    "path": "02-pages\\04-api-reference\\01-components\\script.mdx",
    "title": "Script",
    "description": "Optimize third-party scripts in your Next.js application using the built-in `next/script` Component.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/01-components/script"
  },
  {
    "id": "02-pages-04-api-reference-02-file-conventions-index",
    "path": "02-pages\\04-api-reference\\02-file-conventions\\index.mdx",
    "title": "File-system conventions",
    "description": "API Reference for Next.js file-system conventions.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/02-file-conventions"
  },
  {
    "id": "02-pages-04-api-reference-02-file-conventions-instrumentation",
    "path": "02-pages\\04-api-reference\\02-file-conventions\\instrumentation.mdx",
    "title": "instrumentation.js",
    "description": "API reference for the instrumentation.js file.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/02-file-conventions/instrumentation"
  },
  {
    "id": "02-pages-04-api-reference-02-file-conventions-proxy",
    "path": "02-pages\\04-api-reference\\02-file-conventions\\proxy.mdx",
    "title": "Proxy",
    "description": "Learn how to use Proxy to run code before a request is completed.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/02-file-conventions/proxy"
  },
  {
    "id": "02-pages-04-api-reference-02-file-conventions-public-folder",
    "path": "02-pages\\04-api-reference\\02-file-conventions\\public-folder.mdx",
    "title": "public Folder",
    "description": "Next.js allows you to serve static files, like images, in the public directory. You can learn how it works here.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/02-file-conventions/public-folder"
  },
  {
    "id": "02-pages-04-api-reference-02-file-conventions-src-folder",
    "path": "02-pages\\04-api-reference\\02-file-conventions\\src-folder.mdx",
    "title": "src Directory",
    "description": "Save pages under the `src` folder as an alternative to the root `pages` directory.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/02-file-conventions/src-folder"
  },
  {
    "id": "02-pages-04-api-reference-03-functions-get-initial-props",
    "path": "02-pages\\04-api-reference\\03-functions\\get-initial-props.mdx",
    "title": "getInitialProps",
    "description": "Fetch dynamic data on the server for your React component with getInitialProps.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Context Object",
        "slug": "context-object"
      },
      {
        "level": 2,
        "text": "Caveats",
        "slug": "caveats"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "import { NextPageContext } from 'next'\r\n\r\nPage.getInitialProps = async (ctx: NextPageContext) => {\r\n  const res = await fetch('https://api.github.com/repos/vercel/next.js')\r\n  const json = await res.json()\r\n  return { stars: json.stargazers_count }\r\n}\r\n\r\nexport default function Page({ stars }: { stars: number }) {\r\n  return stars\r\n}",
        "context": "filename=\"pages/index.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "Page.getInitialProps = async (ctx) => {\r\n  const res = await fetch('https://api.github.com/repos/vercel/next.js')\r\n  const json = await res.json()\r\n  return { stars: json.stargazers_count }\r\n}\r\n\r\nexport default function Page({ stars }) {\r\n  return stars\r\n}",
        "context": "filename=\"pages/index.js\" switcher"
      }
    ],
    "content": "> Good to know: getInitialProps is a legacy API. We recommend using getStaticProps or getServerSideProps instead. getInitialProps is an async function that can be added to the default exported React component for the page. It will run on both the server-side and again on the client-side during page transitions. The result of the function will be forwarded to the React component as props. > Good to know: > > - Data returned from getInitialProps is serialized when server rendering. Ensure the returned object from getInitialProps is a plain Object, and not using Date, Map or Set. > - For the initial page load, getInitialProps will run on the server only. getInitialProps will then also run on the client when navigating to a different route with the next/link component or by using next/router. > - If getInitialProps is used in a custom app.js, and the page being navigated to is using getServerSideProps, then getInitialProps will also run on the server. Context Object getInitialProps receives a single argument called context, which is an object with the following properties: | Name | Description | | ---------- | ----------------------------------------------------------------------------------------------------- | | pathname | Current route, the path of the page in /pages | | query | Query string of the URL, parsed as an object | | asPath | String of the actual path (including the query) shown in the browser | | req | HTTP request object (server only) | | res | HTTP response object (server only) | | err | Error object if any error is encountered during the rendering | Caveats - getInitialProps can only be used in pages/ top level files, and not in nested components. To have nested data fetching at the component level, consider exploring the App Router. - Regardless of whether your route is static or dynamic, any data returned from getInitialProps as props will be able to be examined on the client-side in the initial HTML. This is to allow the page to be hydrated correctly. Make sure that you don't pass any sensitive information that shouldn't be available on the client in props.",
    "excerpt": "> Good to know: getInitialProps is a legacy API. We recommend using getStaticProps or getServerSideProps instead. getInitialProps is an async function that can be added to the default exported React c...",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/03-functions/get-initial-props"
  },
  {
    "id": "02-pages-04-api-reference-03-functions-get-server-side-props",
    "path": "02-pages\\04-api-reference\\03-functions\\get-server-side-props.mdx",
    "title": "getServerSideProps",
    "description": "API reference for `getServerSideProps`. Learn how to fetch data on each request with Next.js.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Context parameter",
        "slug": "context-parameter"
      },
      {
        "level": 2,
        "text": "getServerSideProps return values",
        "slug": "getserversideprops-return-values"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "import type { InferGetServerSidePropsType, GetServerSideProps } from 'next'\r\n\r\ntype Repo = {\r\n  name: string\r\n  stargazers_count: number\r\n}\r\n\r\nexport const getServerSideProps = (async () => {\r\n  // Fetch data from external API\r\n  const res = await fetch('https://api.github.com/repos/vercel/next.js')\r\n  const repo: Repo = await res.json()\r\n  // Pass data to the page via props\r\n  return { props: { repo } }\r\n}) satisfies GetServerSideProps<{ repo: Repo }>\r\n\r\nexport default function Page({\r\n  repo,\r\n}: InferGetServerSidePropsType<typeof getServerSideProps>) {\r\n  return (\r\n    <main>\r\n      <p>{repo.stargazers_count}</p>\r\n    </main>\r\n  )\r\n}",
        "context": "filename=\"pages/index.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export async function getServerSideProps() {\r\n  // Fetch data from external API\r\n  const res = await fetch('https://api.github.com/repos/vercel/next.js')\r\n  const repo = await res.json()\r\n  // Pass data to the page via props\r\n  return { props: { repo } }\r\n}\r\n\r\nexport default function Page({ repo }) {\r\n  return (\r\n    <main>\r\n      <p>{repo.stargazers_count}</p>\r\n    </main>\r\n  )\r\n}",
        "context": "filename=\"pages/index.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "export async function getServerSideProps(context) {\r\n  return {\r\n    props: { message: `Next.js is awesome` }, // will be passed to the page component as props\r\n  }\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "export async function getServerSideProps(context) {\r\n  const res = await fetch(`https://.../data`)\r\n  const data = await res.json()\r\n\r\n  if (!data) {\r\n    return {\r\n      notFound: true,\r\n    }\r\n  }\r\n\r\n  return {\r\n    props: { data }, // will be passed to the page component as props\r\n  }\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "export async function getServerSideProps(context) {\r\n  const res = await fetch(`https://.../data`)\r\n  const data = await res.json()\r\n\r\n  if (!data) {\r\n    return {\r\n      redirect: {\r\n        destination: '/',\r\n        permanent: false,\r\n      },\r\n    }\r\n  }\r\n\r\n  return {\r\n    props: {}, // will be passed to the page component as props\r\n  }\r\n}",
        "context": ""
      }
    ],
    "content": "When exporting a function called getServerSideProps (Server-Side Rendering) from a page, Next.js will pre-render this page on each request using the data returned by getServerSideProps. This is useful if you want to fetch data that changes often, and have the page update to show the most current data. You can import modules in top-level scope for use in getServerSideProps. Imports used will not be bundled for the client-side. This means you can write server-side code directly in getServerSideProps, including fetching data from your database. Context parameter The context parameter is an object containing the following keys: | Name | Description | | --------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | params | If this page uses a dynamic route, params contains the route parameters. If the page name is [id].js, then params will look like { id: ... }. | | req | The HTTP IncomingMessage object, with an additional cookies prop, which is an object with string keys mapping to string values of cookies. | | res | The HTTP response object. | | query | An object representing the query string, including dynamic route parameters. | | preview | (Deprecated for draftMode) preview is true if the page is in the Preview Mode and false otherwise. | | previewData | (Deprecated for draftMode) The preview data set by setPreviewData. | | draftMode | draftMode is true if the page is in the Draft Mode and false otherwise. | | resolvedUrl | A normalized version of the request URL that strips the next/data prefix for client transitions and includes original query values. | | locale | Contains the active locale (if enabled). | | locales | Contains all supported locales (if enabled). | | defaultLocale | Contains the configured default locale (if enabled). | getServerSideProps return values The getServerSideProps function should return an object with any one of the following properties: props The props object is a key-value pair, where each value is received by the page component. It should be a serializable object so that any props passed, could be serialized with JSON.stringify. notFound The notFound boolean allows the page to return a 404 status and 404 Page. With notFound: true, the page will return a 404 even if there was a successfully generated page before. This is meant to support use cases like user-generated content getting removed by its author. redirect The redirect object allows redirecting to internal and external resources. It should match the shape of { destination: string, permanent: boolean }. In some rare cases, you might need to assign a custom status code for older HTTP clients to properly redirect. In these cases, you can use the statusCode property instead of the permanent property, but not both. Version History | Version | Changes | | --------- | ------------------------------------------------------------------------------------------------- | | v13.4.0 | App Router is now stable with simplified data fetching | | v10.0.0 | locale, locales, defaultLocale, and notFound options added. | | v9.3.0 | getServerSideProps introduced. |",
    "excerpt": "When exporting a function called getServerSideProps (Server-Side Rendering) from a page, Next.js will pre-render this page on each request using the data returned by getServerSideProps. This is useful...",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/03-functions/get-server-side-props"
  },
  {
    "id": "02-pages-04-api-reference-03-functions-get-static-paths",
    "path": "02-pages\\04-api-reference\\03-functions\\get-static-paths.mdx",
    "title": "getStaticPaths",
    "description": "API reference for `getStaticPaths`. Learn how to fetch data and generate static pages with `getStaticPaths`.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "getStaticPaths return values",
        "slug": "getstaticpaths-return-values"
      },
      {
        "level": 4,
        "text": "When is  useful?",
        "slug": "when-is-useful"
      },
      {
        "level": 3,
        "text": "Fallback pages",
        "slug": "fallback-pages"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "import type {\r\n  InferGetStaticPropsType,\r\n  GetStaticProps,\r\n  GetStaticPaths,\r\n} from 'next'\r\n\r\ntype Repo = {\r\n  name: string\r\n  stargazers_count: number\r\n}\r\n\r\nexport const getStaticPaths = (async () => {\r\n  return {\r\n    paths: [\r\n      {\r\n        params: {\r\n          name: 'next.js',\r\n        },\r\n      }, // See the \"paths\" section below\r\n    ],\r\n    fallback: true, // false or \"blocking\"\r\n  }\r\n}) satisfies GetStaticPaths\r\n\r\nexport const getStaticProps = (async (context) => {\r\n  const res = await fetch('https://api.github.com/repos/vercel/next.js')\r\n  const repo = await res.json()\r\n  return { props: { repo } }\r\n}) satisfies GetStaticProps<{\r\n  repo: Repo\r\n}>\r\n\r\nexport default function Page({\r\n  repo,\r\n}: InferGetStaticPropsType<typeof getStaticProps>) {\r\n  return repo.stargazers_count\r\n}",
        "context": "filename=\"pages/repo/[name].tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export async function getStaticPaths() {\r\n  return {\r\n    paths: [\r\n      {\r\n        params: {\r\n          name: 'next.js',\r\n        },\r\n      }, // See the \"paths\" section below\r\n    ],\r\n    fallback: true, // false or \"blocking\"\r\n  }\r\n}\r\n\r\nexport async function getStaticProps() {\r\n  const res = await fetch('https://api.github.com/repos/vercel/next.js')\r\n  const repo = await res.json()\r\n  return { props: { repo } }\r\n}\r\n\r\nexport default function Page({ repo }) {\r\n  return repo.stargazers_count\r\n}",
        "context": "filename=\"pages/repo/[name].js\" switcher"
      },
      {
        "language": "js",
        "code": "return {\r\n  paths: [\r\n    { params: { id: '1' }},\r\n    {\r\n      params: { id: '2' },\r\n      // with i18n configured the locale for the path can be returned as well\r\n      locale: \"en\",\r\n    },\r\n  ],\r\n  fallback: ...\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "function Post({ post }) {\r\n  // Render post...\r\n}\r\n\r\n// This function gets called at build time\r\nexport async function getStaticPaths() {\r\n  // Call an external API endpoint to get posts\r\n  const res = await fetch('https://.../posts')\r\n  const posts = await res.json()\r\n\r\n  // Get the paths we want to pre-render based on posts\r\n  const paths = posts.map((post) => ({\r\n    params: { id: post.id },\r\n  }))\r\n\r\n  // We'll pre-render only these paths at build time.\r\n  // { fallback: false } means other routes should 404.\r\n  return { paths, fallback: false }\r\n}\r\n\r\n// This also gets called at build time\r\nexport async function getStaticProps({ params }) {\r\n  // params contains the post `id`.\r\n  // If the route is like /posts/1, then params.id is 1\r\n  const res = await fetch(`https://.../posts/${params.id}`)\r\n  const post = await res.json()\r\n\r\n  // Pass post data to the page via props\r\n  return { props: { post } }\r\n}\r\n\r\nexport default Post",
        "context": "filename=\"pages/posts/[id].js\""
      },
      {
        "language": "jsx",
        "code": "import { useRouter } from 'next/router'\r\n\r\nfunction Post({ post }) {\r\n  const router = useRouter()\r\n\r\n  // If the page is not yet generated, this will be displayed\r\n  // initially until getStaticProps() finishes running\r\n  if (router.isFallback) {\r\n    return <div>Loading...</div>\r\n  }\r\n\r\n  // Render post...\r\n}\r\n\r\n// This function gets called at build time\r\nexport async function getStaticPaths() {\r\n  return {\r\n    // Only `/posts/1` and `/posts/2` are generated at build time\r\n    paths: [{ params: { id: '1' } }, { params: { id: '2' } }],\r\n    // Enable statically generating additional pages\r\n    // For example: `/posts/3`\r\n    fallback: true,\r\n  }\r\n}\r\n\r\n// This also gets called at build time\r\nexport async function getStaticProps({ params }) {\r\n  // params contains the post `id`.\r\n  // If the route is like /posts/1, then params.id is 1\r\n  const res = await fetch(`https://.../posts/${params.id}`)\r\n  const post = await res.json()\r\n\r\n  // Pass post data to the page via props\r\n  return {\r\n    props: { post },\r\n    // Re-generate the post at most once per second\r\n    // if a request comes in\r\n    revalidate: 1,\r\n  }\r\n}\r\n\r\nexport default Post",
        "context": "filename=\"pages/posts/[id].js\""
      }
    ],
    "content": "When exporting a function called getStaticPaths from a page that uses Dynamic Routes, Next.js will statically pre-render all the paths specified by getStaticPaths. getStaticPaths return values The getStaticPaths function should return an object with the following required properties: paths The paths key determines which paths will be pre-rendered. For example, suppose that you have a page that uses Dynamic Routes named pages/posts/[id].js. If you export getStaticPaths from this page and return the following for paths: Then, Next.js will statically generate /posts/1 and /posts/2 during next build using the page component in pages/posts/[id].js. The value for each params object must match the parameters used in the page name: - If the page name is pages/posts/[postId]/[commentId], then params should contain postId and commentId. - If the page name uses catch-all routes like pages/[...slug], then params should contain slug (which is an array). If this array is ['hello', 'world'], then Next.js will statically generate the page at /hello/world. - If the page uses an optional catch-all route, use null, [], undefined or false to render the root-most route. For example, if you supply slug: false for pages/[[...slug]], Next.js will statically generate the page /. The params strings are case-sensitive and ideally should be normalized to ensure the paths are generated correctly. For example, if WoRLD is returned for a param it will only match if WoRLD is the actual path visited, not world or World. Separate of the params object a locale field can be returned when i18n is configured, which configures the locale for the path being generated. fallback: false If fallback is false, then any paths not returned by getStaticPaths will result in a 404 page. When next build is run, Next.js will check if getStaticPaths returned fallback: false, it will then build only the paths returned by getStaticPaths. This option is useful if you have a small number of paths to create, or new page data is not added often. If you find that you need to add more paths, and you have fallback: false, you will need to run next build again so that the new paths can be generated. The following example pre-renders one blog post per page called pages/posts/[id].js. The list of blog posts will be fetched from a CMS and returned by getStaticPaths. Then, for each page, it fetches the post data from a CMS using getStaticProps. fallback: true Examples - Static generation of a large number of pages If fallback is true, then the behavior of getStaticProps changes in the following ways: - The paths returned from getStaticPaths will be rendered to HTML at build time by getStaticProps. - The paths that have not been generated at build time will not result in a 404 page. Instead, Next.js will serve a “fallback” version of the page on the first request to such a path. Web crawlers, such as Google, won't be served a fallback and instead the path will behave as in fallback: 'blocking'. - When a page with fallback: true is navigated to through next/link or next/router (client-side) Next.js will not serve a fallback and instead the page will behave as fallback: 'blocking'. - In the background, Next.js will statically generate the requested path HTML and JSON. This includes running getStaticProps. - When complete, the browser receives the JSON for the generated path. This will be used to automatically render the page with the required props. From the user’s perspective, the page will be swapped from the fallback page to the full page. - At the same time, Next.js adds this path to the list of pre-rendered pages. Subsequent requests to the same path will serve the generated page, like other pages pre-rendered at build time. > Good to know: fallback: true is not supported when using output: 'export'. When is fallback: true useful? fallback: true is useful if your app has a very large number of static pages that depend on data (such as a very large e-commerce site). If you want to pre-render all product pages, the builds would take a very long time. Instead, you may statically generate a small subset of pages and use fallback: true for the rest. When someone requests a page that is not generated yet, the user will see the page with a loading indicator or skeleton component. Shortly after, getStaticProps finishes and the page will be rendered with the requested data. From now on, everyone who requests the same page will get the statically pre-rendered page. This ensures that users always have a fast experience while preserving fast builds and the benefits of Static Generation. fallback: true will not update generated pages, for that take a look at Incremental Static Regeneration. fallback: 'blocking' If fallback is 'blocking', new paths not returned by getStaticPaths will wait for the HTML to be generated, identical to SSR (hence why blocking), and then be cached for future requests so it only happens once per path. getStaticProps will behave as follows: - The paths returned from getStaticPaths will be rendered to HTML at build time by getStaticProps. - The paths that have not been generated at build time will not result in a 404 page. Instead, Next.js will SSR on the first request and return the generated HTML. - When complete, the browser receives the HTML for the generated path. From the user’s perspective, it will transition from \"the browser is requesting the page\" to \"the full page is loaded\". There is no flash of loading/fallback state. - At the same time, Next.js adds this path to the list of pre-rendered pages. Subsequent requests to the same path will serve the generated page, like other pages pre-rendered at build time. fallback: 'blocking' will not update generated pages by default. To update generated pages, use Incremental Static Regeneration in conjunction with fallback: 'blocking'. > Good to know: fallback: 'blocking' is not supported when using output: 'export'. Fallback pages In the “fallback” version of a page: - The page’s props will be empty. - Using the router, you can detect if the fallback is being rendered, router.isFallback will be true. The following example showcases using isFallback: Version History | Version | Changes | | --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | v13.4.0 | App Router is now stable with simplified data fetching, including generateStaticParams() | | v12.2.0 | On-Demand Incremental Static Regeneration is stable. | | v12.1.0 | On-Demand Incremental Static Regeneration added (beta). | | v9.5.0 | Stable Incremental Static Regeneration | | v9.3.0 | getStaticPaths introduced. |",
    "excerpt": "When exporting a function called getStaticPaths from a page that uses Dynamic Routes, Next.js will statically pre-render all the paths specified by getStaticPaths. getStaticPaths return values The get...",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/03-functions/get-static-paths"
  },
  {
    "id": "02-pages-04-api-reference-03-functions-get-static-props",
    "path": "02-pages\\04-api-reference\\03-functions\\get-static-props.mdx",
    "title": "getStaticProps",
    "description": "API reference for `getStaticProps`. Learn how to use `getStaticProps` to generate static pages with Next.js.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Context parameter",
        "slug": "context-parameter"
      },
      {
        "level": 2,
        "text": "getStaticProps return values",
        "slug": "getstaticprops-return-values"
      },
      {
        "level": 2,
        "text": "Reading files: Use ",
        "slug": "reading-files-use-"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "tsx",
        "code": "import type { InferGetStaticPropsType, GetStaticProps } from 'next'\r\n\r\ntype Repo = {\r\n  name: string\r\n  stargazers_count: number\r\n}\r\n\r\nexport const getStaticProps = (async (context) => {\r\n  const res = await fetch('https://api.github.com/repos/vercel/next.js')\r\n  const repo = await res.json()\r\n  return { props: { repo } }\r\n}) satisfies GetStaticProps<{\r\n  repo: Repo\r\n}>\r\n\r\nexport default function Page({\r\n  repo,\r\n}: InferGetStaticPropsType<typeof getStaticProps>) {\r\n  return repo.stargazers_count\r\n}",
        "context": "filename=\"pages/index.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "export async function getStaticProps() {\r\n  const res = await fetch('https://api.github.com/repos/vercel/next.js')\r\n  const repo = await res.json()\r\n  return { props: { repo } }\r\n}\r\n\r\nexport default function Page({ repo }) {\r\n  return repo.stargazers_count\r\n}",
        "context": "filename=\"pages/index.js\" switcher"
      },
      {
        "language": "jsx",
        "code": "export async function getStaticProps(context) {\r\n  return {\r\n    props: { message: `Next.js is awesome` }, // will be passed to the page component as props\r\n  }\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "// This function gets called at build time on server-side.\r\n// It may be called again, on a serverless function, if\r\n// revalidation is enabled and a new request comes in\r\nexport async function getStaticProps() {\r\n  const res = await fetch('https://.../posts')\r\n  const posts = await res.json()\r\n\r\n  return {\r\n    props: {\r\n      posts,\r\n    },\r\n    // Next.js will attempt to re-generate the page:\r\n    // - When a request comes in\r\n    // - At most once every 10 seconds\r\n    revalidate: 10, // In seconds\r\n  }\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "export async function getStaticProps(context) {\r\n  const res = await fetch(`https://.../data`)\r\n  const data = await res.json()\r\n\r\n  if (!data) {\r\n    return {\r\n      notFound: true,\r\n    }\r\n  }\r\n\r\n  return {\r\n    props: { data }, // will be passed to the page component as props\r\n  }\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "export async function getStaticProps(context) {\r\n  const res = await fetch(`https://...`)\r\n  const data = await res.json()\r\n\r\n  if (!data) {\r\n    return {\r\n      redirect: {\r\n        destination: '/',\r\n        permanent: false,\r\n        // statusCode: 301\r\n      },\r\n    }\r\n  }\r\n\r\n  return {\r\n    props: { data }, // will be passed to the page component as props\r\n  }\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import { promises as fs } from 'fs'\r\nimport path from 'path'\r\n\r\n// posts will be populated at build time by getStaticProps()\r\nfunction Blog({ posts }) {\r\n  return (\r\n    <ul>\r\n      {posts.map((post) => (\r\n        <li>\r\n          <h3>{post.filename}</h3>\r\n          <p>{post.content}</p>\r\n        </li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}\r\n\r\n// This function gets called at build time on server-side.\r\n// It won't be called on client-side, so you can even do\r\n// direct database queries.\r\nexport async function getStaticProps() {\r\n  const postsDirectory = path.join(process.cwd(), 'posts')\r\n  const filenames = await fs.readdir(postsDirectory)\r\n\r\n  const posts = filenames.map(async (filename) => {\r\n    const filePath = path.join(postsDirectory, filename)\r\n    const fileContents = await fs.readFile(filePath, 'utf8')\r\n\r\n    // Generally you would parse/transform the contents\r\n    // For example you can transform markdown to HTML here\r\n\r\n    return {\r\n      filename,\r\n      content: fileContents,\r\n    }\r\n  })\r\n  // By returning { props: { posts } }, the Blog component\r\n  // will receive `posts` as a prop at build time\r\n  return {\r\n    props: {\r\n      posts: await Promise.all(posts),\r\n    },\r\n  }\r\n}\r\n\r\nexport default Blog",
        "context": ""
      }
    ],
    "content": "Exporting a function called getStaticProps will pre-render a page at build time using the props returned from the function: You can import modules in top-level scope for use in getStaticProps. Imports used will not be bundled for the client-side. This means you can write server-side code directly in getStaticProps, including fetching data from your database. Context parameter The context parameter is an object containing the following keys: | Name | Description | | ------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | | params | Contains the route parameters for pages using dynamic routes. For example, if the page name is [id].js, then params will look like { id: ... }. You should use this together with getStaticPaths, which we'll explain later. | | preview | (Deprecated for draftMode) preview is true if the page is in the Preview Mode and false otherwise. | | previewData | (Deprecated for draftMode) The preview data set by setPreviewData. | | draftMode | draftMode is true if the page is in the Draft Mode and false otherwise. | | locale | Contains the active locale (if enabled). | | locales | Contains all supported locales (if enabled). | | defaultLocale | Contains the configured default locale (if enabled). | | revalidateReason | Provides a reason for why the function was called. Can be one of: \"build\" (run at build time), \"stale\" (revalidate period expired, or running in development mode), \"on-demand\" (triggered via on-demand revalidation) | getStaticProps return values The getStaticProps function should return an object containing either props, redirect, or notFound followed by an optional revalidate property. props The props object is a key-value pair, where each value is received by the page component. It should be a serializable object so that any props passed, could be serialized with JSON.stringify. revalidate The revalidate property is the amount in seconds after which a page re-generation can occur (defaults to false or no revalidation). Learn more about Incremental Static Regeneration. The cache status of a page leveraging ISR can be determined by reading the value of the x-nextjs-cache response header. The possible values are the following: - MISS - the path is not in the cache (occurs at most once, on the first visit) - STALE - the path is in the cache but exceeded the revalidate time so it will be updated in the background - HIT - the path is in the cache and has not exceeded the revalidate time notFound The notFound boolean allows the page to return a 404 status and 404 Page. With notFound: true, the page will return a 404 even if there was a successfully generated page before. This is meant to support use cases like user-generated content getting removed by its author. Note, notFound follows the same revalidate behavior described here. > Good to know: notFound is not needed for fallback: false mode as only paths returned from getStaticPaths will be pre-rendered. redirect The redirect object allows redirecting to internal or external resources. It should match the shape of { destination: string, permanent: boolean }. In some rare cases, you might need to assign a custom status code for older HTTP clients to properly redirect. In these cases, you can use the statusCode property instead of the permanent property, but not both. You can also set basePath: false similar to redirects in next.config.js. If the redirects are known at build-time, they should be added in next.config.js instead. Reading files: Use process.cwd() Files can be read directly from the filesystem in getStaticProps. In order to do so you have to get the full path to a file. Since Next.js compiles your code into a separate directory you can't use dirname as the path it returns will be different from the Pages Router. Instead you can use process.cwd() which gives you the directory where Next.js is being executed. Version History | Version | Changes | | --------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- | | v13.4.0 | App Router is now stable with simplified data fetching | | v12.2.0 | On-Demand Incremental Static Regeneration is stable. | | v12.1.0 | On-Demand Incremental Static Regeneration added (beta). | | v10.0.0 | locale, locales, defaultLocale, and notFound options added. | | v10.0.0 | fallback: 'blocking' return option added. | | v9.5.0 | Stable Incremental Static Regeneration | | v9.3.0 | getStaticProps introduced. |",
    "excerpt": "Exporting a function called getStaticProps will pre-render a page at build time using the props returned from the function: You can import modules in top-level scope for use in getStaticProps. Imports...",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/03-functions/get-static-props"
  },
  {
    "id": "02-pages-04-api-reference-03-functions-index",
    "path": "02-pages\\04-api-reference\\03-functions\\index.mdx",
    "title": "Functions",
    "description": "API Reference for Functions and Hooks in Pages Router.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/03-functions"
  },
  {
    "id": "02-pages-04-api-reference-03-functions-next-request",
    "path": "02-pages\\04-api-reference\\03-functions\\next-request.mdx",
    "title": "NextRequest",
    "description": "API Reference for NextRequest.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/03-functions/next-request"
  },
  {
    "id": "02-pages-04-api-reference-03-functions-next-response",
    "path": "02-pages\\04-api-reference\\03-functions\\next-response.mdx",
    "title": "NextResponse",
    "description": "API Reference for NextResponse.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/03-functions/next-response"
  },
  {
    "id": "02-pages-04-api-reference-03-functions-use-report-web-vitals",
    "path": "02-pages\\04-api-reference\\03-functions\\use-report-web-vitals.mdx",
    "title": "useReportWebVitals",
    "description": "useReportWebVitals",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/03-functions/use-report-web-vitals"
  },
  {
    "id": "02-pages-04-api-reference-03-functions-use-router",
    "path": "02-pages\\04-api-reference\\03-functions\\use-router.mdx",
    "title": "useRouter",
    "description": "Learn more about the API of the Next.js Router, and access the router instance in your page with the useRouter hook.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": " object",
        "slug": "-object"
      },
      {
        "level": 3,
        "text": "router.push",
        "slug": "routerpush"
      },
      {
        "level": 4,
        "text": "Resetting state after navigation",
        "slug": "resetting-state-after-navigation"
      },
      {
        "level": 4,
        "text": "With URL object",
        "slug": "with-url-object"
      },
      {
        "level": 3,
        "text": "router.replace",
        "slug": "routerreplace"
      },
      {
        "level": 3,
        "text": "router.prefetch",
        "slug": "routerprefetch"
      },
      {
        "level": 3,
        "text": "router.beforePopState",
        "slug": "routerbeforepopstate"
      },
      {
        "level": 3,
        "text": "router.back",
        "slug": "routerback"
      },
      {
        "level": 3,
        "text": "router.reload",
        "slug": "routerreload"
      },
      {
        "level": 3,
        "text": "router.events",
        "slug": "routerevents"
      },
      {
        "level": 2,
        "text": "The  export",
        "slug": "the-export"
      },
      {
        "level": 3,
        "text": "Using  outside of Next.js context in pages",
        "slug": "using-outside-of-nextjs-context-in-pages"
      },
      {
        "level": 2,
        "text": "Potential ESLint errors",
        "slug": "potential-eslint-errors"
      },
      {
        "level": 3,
        "text": "Potential solutions",
        "slug": "potential-solutions"
      },
      {
        "level": 2,
        "text": "withRouter",
        "slug": "withrouter"
      },
      {
        "level": 3,
        "text": "Usage",
        "slug": "usage"
      },
      {
        "level": 3,
        "text": "TypeScript",
        "slug": "typescript"
      }
    ],
    "codeBlocks": [
      {
        "language": "jsx",
        "code": "import { useRouter } from 'next/router'\r\n\r\nfunction ActiveLink({ children, href }) {\r\n  const router = useRouter()\r\n  const style = {\r\n    marginRight: 10,\r\n    color: router.asPath === href ? 'red' : 'black',\r\n  }\r\n\r\n  const handleClick = (e) => {\r\n    e.preventDefault()\r\n    router.push(href)\r\n  }\r\n\r\n  return (\r\n    <a href={href} onClick={handleClick} style={style}>\r\n      {children}\r\n    </a>\r\n  )\r\n}\r\n\r\nexport default ActiveLink",
        "context": ""
      },
      {
        "language": "js",
        "code": "router.push(url, as, options)",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import { useRouter } from 'next/router'\r\n\r\nexport default function Page() {\r\n  const router = useRouter()\r\n\r\n  return (\r\n    <button type=\"button\" onClick={() => router.push('/about')}>\r\n      Click me\r\n    </button>\r\n  )\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import { useRouter } from 'next/router'\r\n\r\nexport default function Page() {\r\n  const router = useRouter()\r\n\r\n  return (\r\n    <button type=\"button\" onClick={() => router.push('/post/abc')}>\r\n      Click me\r\n    </button>\r\n  )\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import { useEffect } from 'react'\r\nimport { useRouter } from 'next/router'\r\n\r\n// Here you would fetch and return the user\r\nconst useUser = () => ({ user: null, loading: false })\r\n\r\nexport default function Page() {\r\n  const { user, loading } = useUser()\r\n  const router = useRouter()\r\n\r\n  useEffect(() => {\r\n    if (!(user || loading)) {\r\n      router.push('/login')\r\n    }\r\n  }, [user, loading])\r\n\r\n  return <p>Redirecting...</p>\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import Link from 'next/link'\r\nimport { useState } from 'react'\r\nimport { useRouter } from 'next/router'\r\n\r\nexport default function Page(props) {\r\n  const router = useRouter()\r\n  const [count, setCount] = useState(0)\r\n  return (\r\n    <div>\r\n      <h1>Page: {router.query.slug}</h1>\r\n      <p>Count: {count}</p>\r\n      <button onClick={() => setCount(count + 1)}>Increase count</button>\r\n      <Link href=\"/one\">one</Link> <Link href=\"/two\">two</Link>\r\n    </div>\r\n  )\r\n}",
        "context": "filename=\"pages/[slug].js\""
      },
      {
        "language": "jsx",
        "code": "useEffect(() => {\r\n  setCount(0)\r\n}, [router.query.slug])",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import { useRouter } from 'next/router'\r\n\r\nexport default function MyApp({ Component, pageProps }) {\r\n  const router = useRouter()\r\n  return <Component key={router.asPath} {...pageProps} />\r\n}",
        "context": "filename=\"pages/_app.js\""
      },
      {
        "language": "jsx",
        "code": "import { useRouter } from 'next/router'\r\n\r\nexport default function ReadMore({ post }) {\r\n  const router = useRouter()\r\n\r\n  return (\r\n    <button\r\n      type=\"button\"\r\n      onClick={() => {\r\n        router.push({\r\n          pathname: '/post/[pid]',\r\n          query: { pid: post.id },\r\n        })\r\n      }}\r\n    >\r\n      Click here to read more\r\n    </button>\r\n  )\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "router.replace(url, as, options)",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import { useRouter } from 'next/router'\r\n\r\nexport default function Page() {\r\n  const router = useRouter()\r\n\r\n  return (\r\n    <button type=\"button\" onClick={() => router.replace('/home')}>\r\n      Click me\r\n    </button>\r\n  )\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "router.prefetch(url, as, options)",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import { useCallback, useEffect } from 'react'\r\nimport { useRouter } from 'next/router'\r\n\r\nexport default function Login() {\r\n  const router = useRouter()\r\n  const handleSubmit = useCallback((e) => {\r\n    e.preventDefault()\r\n\r\n    fetch('/api/login', {\r\n      method: 'POST',\r\n      headers: { 'Content-Type': 'application/json' },\r\n      body: JSON.stringify({\r\n        /* Form data */\r\n      }),\r\n    }).then((res) => {\r\n      // Do a fast client-side transition to the already prefetched dashboard page\r\n      if (res.ok) router.push('/dashboard')\r\n    })\r\n  }, [])\r\n\r\n  useEffect(() => {\r\n    // Prefetch the dashboard page\r\n    router.prefetch('/dashboard')\r\n  }, [router])\r\n\r\n  return (\r\n    <form onSubmit={handleSubmit}>\r\n      {/* Form fields */}\r\n      <button type=\"submit\">Login</button>\r\n    </form>\r\n  )\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "router.beforePopState(cb)",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import { useEffect } from 'react'\r\nimport { useRouter } from 'next/router'\r\n\r\nexport default function Page() {\r\n  const router = useRouter()\r\n\r\n  useEffect(() => {\r\n    router.beforePopState(({ url, as, options }) => {\r\n      // I only want to allow these two routes!\r\n      if (as !== '/' && as !== '/other') {\r\n        // Have SSR render bad routes as a 404.\r\n        window.location.href = as\r\n        return false\r\n      }\r\n\r\n      return true\r\n    })\r\n  }, [router])\r\n\r\n  return <p>Welcome to the page</p>\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import { useRouter } from 'next/router'\r\n\r\nexport default function Page() {\r\n  const router = useRouter()\r\n\r\n  return (\r\n    <button type=\"button\" onClick={() => router.back()}>\r\n      Click here to go back\r\n    </button>\r\n  )\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import { useRouter } from 'next/router'\r\n\r\nexport default function Page() {\r\n  const router = useRouter()\r\n\r\n  return (\r\n    <button type=\"button\" onClick={() => router.reload()}>\r\n      Click here to reload\r\n    </button>\r\n  )\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import { useEffect } from 'react'\r\nimport { useRouter } from 'next/router'\r\n\r\nexport default function MyApp({ Component, pageProps }) {\r\n  const router = useRouter()\r\n\r\n  useEffect(() => {\r\n    const handleRouteChange = (url, { shallow }) => {\r\n      console.log(\r\n        `App is changing to ${url} ${\r\n          shallow ? 'with' : 'without'\r\n        } shallow routing`\r\n      )\r\n    }\r\n\r\n    router.events.on('routeChangeStart', handleRouteChange)\r\n\r\n    // If the component is unmounted, unsubscribe\r\n    // from the event with the `off` method:\r\n    return () => {\r\n      router.events.off('routeChangeStart', handleRouteChange)\r\n    }\r\n  }, [router])\r\n\r\n  return <Component {...pageProps} />\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import { useEffect } from 'react'\r\nimport { useRouter } from 'next/router'\r\n\r\nexport default function MyApp({ Component, pageProps }) {\r\n  const router = useRouter()\r\n\r\n  useEffect(() => {\r\n    const handleRouteChangeError = (err, url) => {\r\n      if (err.cancelled) {\r\n        console.log(`Route to ${url} was cancelled!`)\r\n      }\r\n    }\r\n\r\n    router.events.on('routeChangeError', handleRouteChangeError)\r\n\r\n    // If the component is unmounted, unsubscribe\r\n    // from the event with the `off` method:\r\n    return () => {\r\n      router.events.off('routeChangeError', handleRouteChangeError)\r\n    }\r\n  }, [router])\r\n\r\n  return <Component {...pageProps} />\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import { useRouter } from 'next/router'\r\nconst MyComponent = () => {\r\n  const { isReady, query } = useRouter()\r\n  // ...\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import { useEffect } from 'react'\r\nimport { useRouter } from 'next/compat/router'\r\nimport { useSearchParams } from 'next/navigation'\r\nconst MyComponent = () => {\r\n  const router = useRouter() // may be null or a NextRouter instance\r\n  const searchParams = useSearchParams()\r\n  useEffect(() => {\r\n    if (router && !router.isReady) {\r\n      return\r\n    }\r\n    // In `app/`, searchParams will be ready immediately with the values, in\r\n    // `pages/` it will be available after the router is ready.\r\n    const search = searchParams.get('search')\r\n    // ...\r\n  }, [router, searchParams])\r\n  // ...\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import { useSearchParams } from 'next/navigation'\r\nconst MyComponent = () => {\r\n  const searchParams = useSearchParams()\r\n  // As this component is only used in `app/`, the compat router can be removed.\r\n  const search = searchParams.get('search')\r\n  // ...\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import { renderToString } from 'react-dom/server'\r\nimport { useRouter } from 'next/compat/router'\r\nconst MyComponent = () => {\r\n  const router = useRouter() // may be null or a NextRouter instance\r\n  // ...\r\n}\r\nexport async function getServerSideProps() {\r\n  const renderedComponent = renderToString(<MyComponent />)\r\n  return {\r\n    props: {\r\n      renderedComponent,\r\n    },\r\n  }\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import { useEffect } from 'react'\r\nimport { useRouter } from 'next/router'\r\n\r\n// Here you would fetch and return the user\r\nconst useUser = () => ({ user: null, loading: false })\r\n\r\nexport default function Page() {\r\n  const { user, loading } = useUser()\r\n  const router = useRouter()\r\n\r\n  useEffect(() => {\r\n    // disable the linting on the next line - This is the cleanest solution\r\n    // eslint-disable-next-line no-floating-promises\r\n    router.push('/login')\r\n\r\n    // void the Promise returned by router.push\r\n    if (!(user || loading)) {\r\n      void router.push('/login')\r\n    }\r\n    // or use an async function, await the Promise, then void the function call\r\n    async function handleRouteChange() {\r\n      if (!(user || loading)) {\r\n        await router.push('/login')\r\n      }\r\n    }\r\n    void handleRouteChange()\r\n  }, [user, loading])\r\n\r\n  return <p>Redirecting...</p>\r\n}",
        "context": ""
      },
      {
        "language": "jsx",
        "code": "import { withRouter } from 'next/router'\r\n\r\nfunction Page({ router }) {\r\n  return <p>{router.pathname}</p>\r\n}\r\n\r\nexport default withRouter(Page)",
        "context": ""
      },
      {
        "language": "tsx",
        "code": "import React from 'react'\r\nimport { withRouter, NextRouter } from 'next/router'\r\n\r\ninterface WithRouterProps {\r\n  router: NextRouter\r\n}\r\n\r\ninterface MyComponentProps extends WithRouterProps {}\r\n\r\nclass MyComponent extends React.Component<MyComponentProps> {\r\n  render() {\r\n    return <p>{this.props.router.pathname}</p>\r\n  }\r\n}\r\n\r\nexport default withRouter(MyComponent)",
        "context": ""
      }
    ],
    "content": "If you want to access the router object inside any function component in your app, you can use the useRouter hook, take a look at the following example: > useRouter is a React Hook, meaning it cannot be used with classes. You can either use withRouter or wrap your class in a function component. router object The following is the definition of the router object returned by both useRouter and withRouter: - pathname: String - The path for current route file that comes after /pages. Therefore, basePath, locale and trailing slash (trailingSlash: true) are not included. - query: Object - The query string parsed to an object, including dynamic route parameters. It will be an empty object during prerendering if the page doesn't use Server-side Rendering. Defaults to {} - asPath: String - The path as shown in the browser including the search params and respecting the trailingSlash configuration. basePath and locale are not included. - isFallback: boolean - Whether the current page is in fallback mode. - basePath: String - The active basePath (if enabled). - locale: String - The active locale (if enabled). - locales: String[] - All supported locales (if enabled). - defaultLocale: String - The current default locale (if enabled). - domainLocales: Array - Any configured domain locales. - isReady: boolean - Whether the router fields are updated client-side and ready for use. Should only be used inside of useEffect methods and not for conditionally rendering on the server. See related docs for use case with automatically statically optimized pages - isPreview: boolean - Whether the application is currently in preview mode. > Using the asPath field may lead to a mismatch between client and server if the page is rendered using server-side rendering or automatic static optimization. Avoid using asPath until the isReady field is true. The following methods are included inside router: router.push Handles client-side transitions, this method is useful for cases where next/link is not enough. - url: UrlObject | String - The URL to navigate to (see Node.JS URL module documentation for UrlObject properties). - as: UrlObject | String - Optional decorator for the path that will be shown in the browser URL bar. Before Next.js 9.5.3 this was used for dynamic routes. - options - Optional object with the following configuration options: - scroll - Optional boolean, controls scrolling to the top of the page after navigation. Defaults to true - shallow: Update the path of the current page without rerunning getStaticProps, getServerSideProps or getInitialProps. Defaults to false - locale - Optional string, indicates locale of the new page > You don't need to use router.push for external URLs. window.location is better suited for those cases. Navigating to pages/about.js, which is a predefined route: Navigating pages/post/[pid].js, which is a dynamic route: Redirecting the user to pages/login.js, useful for pages behind authentication: Resetting state after navigation When navigating to the same page in Next.js, the page's state will not be reset by default as React does not unmount unless the parent component has changed. In the above example, navigating between /one and /two will not reset the count . The useState is maintained between renders because the top-level React component, Page, is the same. If you do not want this behavior, you have a couple of options: - Manually ensure each state is updated using useEffect. In the above example, that could look like: - Use a React key to tell React to remount the component. To do this for all pages, you can use a custom app: With URL object You can use a URL object in the same way you can use it for next/link. Works for both the url and as parameters: router.replace Similar to the replace prop in next/link, router.replace will prevent adding a new URL entry into the history stack. - The API for router.replace is exactly the same as the API for router.push. Take a look at the following example: router.prefetch Prefetch pages for faster client-side transitions. This method is only useful for navigations without next/link, as next/link takes care of prefetching pages automatically. > This is a production only feature. Next.js doesn't prefetch pages in development. - url - The URL to prefetch, including explicit routes (e.g. /dashboard) and dynamic routes (e.g. /product/[id]) - as - Optional decorator for url. Before Next.js 9.5.3 this was used to prefetch dynamic routes. - options - Optional object with the following allowed fields: - locale - allows providing a different locale from the active one. If false, url has to include the locale as the active locale won't be used. Let's say you have a login page, and after a login, you redirect the user to the dashboard. For that case, we can prefetch the dashboard to make a faster transition, like in the following example: router.beforePopState In some cases (for example, if using a Custom Server), you may wish to listen to popstate and do something before the router acts on it. - cb - The function to run on incoming popstate events. The function receives the state of the event as an object with the following props: - url: String - the route for the new state. This is usually the name of a page - as: String - the url that will be shown in the browser - options: Object - Additional options sent by router.push If cb returns false, the Next.js router will not handle popstate, and you'll be responsible for handling it in that case. See Disabling file-system routing. You could use beforePopState to manipulate the request, or force a SSR refresh, as in the following example: router.back Navigate back in history. Equivalent to clicking the browser’s back button. It executes window.history.back(). router.reload Reload the current URL. Equivalent to clicking the browser’s refresh button. It executes window.location.reload(). router.events You can listen to different events happening inside the Next.js Router. Here's a list of supported events: - routeChangeStart(url, { shallow }) - Fires when a route starts to change - routeChangeComplete(url, { shallow }) - Fires when a route changed completely - routeChangeError(err, url, { shallow }) - Fires when there's an error when changing routes, or a route load is cancelled - err.cancelled - Indicates if the navigation was cancelled - beforeHistoryChange(url, { shallow }) - Fires before changing the browser's history - hashChangeStart(url, { shallow }) - Fires when the hash will change but not the page - hashChangeComplete(url, { shallow }) - Fires when the hash has changed but not the page > Good to know: Here url is the URL shown in the browser, including the basePath. For example, to listen to the router event routeChangeStart, open or create pages/app.js and subscribe to the event, like so: > We use a Custom App (pages/app.js) for this example to subscribe to the event because it's not unmounted on page navigations, but you can subscribe to router events on any component in your application. Router events should be registered when a component mounts (useEffect or componentDidMount / componentWillUnmount) or imperatively when an event happens. If a route load is cancelled (for example, by clicking two links rapidly in succession), routeChangeError will fire. And the passed err will contain a cancelled property set to true, as in the following example: The next/compat/router export This is the same useRouter hook, but can be used in both app and pages directories. It differs from next/router in that it does not throw an error when the pages router is not mounted, and instead has a return type of NextRouter | null. This allows developers to convert components to support running in both app and pages as they transition to the app router. A component that previously looked like this: Will error when converted over to next/compat/router, as null can not be destructured. Instead, developers will be able to take advantage of new hooks: This component will now work in both pages and app directories. When the component is no longer used in pages, you can remove the references to the compat router: Using useRouter outside of Next.js context in pages Another specific use case is when rendering components outside of a Next.js application context, such as inside getServerSideProps on the pages directory. In this case, the compat router can be used to avoid errors: Potential ESLint errors Certain methods accessible on the router object return a Promise. If you have the ESLint rule, no-floating-promises enabled, consider disabling it either globally, or for the affected line. If your application needs this rule, you should either void the promise – or use an async function, await the Promise, then void the function call. This is not applicable when the method is called from inside an onClick handler. The affected methods are: - router.push - router.replace - router.prefetch Potential solutions withRouter If useRouter is not the best fit for you, withRouter can also add the same router object to any component. Usage TypeScript To use class components with withRouter, the component needs to accept a router prop:",
    "excerpt": "If you want to access the router object inside any function component in your app, you can use the useRouter hook, take a look at the following example: > useRouter is a React Hook, meaning it cannot...",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/03-functions/use-router"
  },
  {
    "id": "02-pages-04-api-reference-03-functions-userAgent",
    "path": "02-pages\\04-api-reference\\03-functions\\userAgent.mdx",
    "title": "userAgent",
    "description": "The userAgent helper extends the Web Request API with additional properties and methods to interact with the user agent object from the request.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/03-functions/userAgent"
  },
  {
    "id": "02-pages-04-api-reference-04-config-01-next-config-js-adapterPath",
    "path": "02-pages\\04-api-reference\\04-config\\01-next-config-js\\adapterPath.mdx",
    "title": "experimental.adapterPath",
    "description": "Configure a custom adapter for Next.js to hook into the build process with modifyConfig and buildComplete callbacks.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/04-config/01-next-config-js/adapterPath"
  },
  {
    "id": "02-pages-04-api-reference-04-config-01-next-config-js-allowedDevOrigins",
    "path": "02-pages\\04-api-reference\\04-config\\01-next-config-js\\allowedDevOrigins.mdx",
    "title": "allowedDevOrigins",
    "description": "Use `allowedDevOrigins` to configure additional origins that can request the dev server.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/04-config/01-next-config-js/allowedDevOrigins"
  },
  {
    "id": "02-pages-04-api-reference-04-config-01-next-config-js-assetPrefix",
    "path": "02-pages\\04-api-reference\\04-config\\01-next-config-js\\assetPrefix.mdx",
    "title": "assetPrefix",
    "description": "Learn how to use the assetPrefix config option to configure your CDN.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/04-config/01-next-config-js/assetPrefix"
  },
  {
    "id": "02-pages-04-api-reference-04-config-01-next-config-js-basePath",
    "path": "02-pages\\04-api-reference\\04-config\\01-next-config-js\\basePath.mdx",
    "title": "basePath",
    "description": "Use `basePath` to deploy a Next.js application under a sub-path of a domain.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/04-config/01-next-config-js/basePath"
  },
  {
    "id": "02-pages-04-api-reference-04-config-01-next-config-js-bundlePagesRouterDependencies",
    "path": "02-pages\\04-api-reference\\04-config\\01-next-config-js\\bundlePagesRouterDependencies.mdx",
    "title": "bundlePagesRouterDependencies",
    "description": "Enable automatic dependency bundling for Pages Router",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  bundlePagesRouterDependencies: true,\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\""
      }
    ],
    "content": "Enable automatic server-side dependency bundling for Pages Router applications. Matches the automatic dependency bundling in App Router. Explicitly opt-out certain packages from being bundled using the serverExternalPackages option. Version History | Version | Changes | | --------- | --------------------------------------------------------------------------------------------------------- | | v15.0.0 | Moved from experimental to stable. Renamed from bundlePagesExternals to bundlePagesRouterDependencies |",
    "excerpt": "Enable automatic server-side dependency bundling for Pages Router applications. Matches the automatic dependency bundling in App Router. Explicitly opt-out certain packages from being bundled using th...",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/04-config/01-next-config-js/bundlePagesRouterDependencies"
  },
  {
    "id": "02-pages-04-api-reference-04-config-01-next-config-js-compress",
    "path": "02-pages\\04-api-reference\\04-config\\01-next-config-js\\compress.mdx",
    "title": "compress",
    "description": "Next.js provides gzip compression to compress rendered content and static files, it only works with the server target. Learn more about it here.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/04-config/01-next-config-js/compress"
  },
  {
    "id": "02-pages-04-api-reference-04-config-01-next-config-js-crossOrigin",
    "path": "02-pages\\04-api-reference\\04-config\\01-next-config-js\\crossOrigin.mdx",
    "title": "crossOrigin",
    "description": "Use the `crossOrigin` option to add a crossOrigin tag on the `script` tags generated by `next/script` and `next/head`.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/04-config/01-next-config-js/crossOrigin"
  },
  {
    "id": "02-pages-04-api-reference-04-config-01-next-config-js-devIndicators",
    "path": "02-pages\\04-api-reference\\04-config\\01-next-config-js\\devIndicators.mdx",
    "title": "devIndicators",
    "description": "Optimized pages include an indicator to let you know if it's being statically optimized. You can opt-out of it here.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/04-config/01-next-config-js/devIndicators"
  },
  {
    "id": "02-pages-04-api-reference-04-config-01-next-config-js-distDir",
    "path": "02-pages\\04-api-reference\\04-config\\01-next-config-js\\distDir.mdx",
    "title": "distDir",
    "description": "Set a custom build directory to use instead of the default .next directory.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/04-config/01-next-config-js/distDir"
  },
  {
    "id": "02-pages-04-api-reference-04-config-01-next-config-js-env",
    "path": "02-pages\\04-api-reference\\04-config\\01-next-config-js\\env.mdx",
    "title": "env",
    "description": "Learn to add and access environment variables in your Next.js application at build time.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/04-config/01-next-config-js/env"
  },
  {
    "id": "02-pages-04-api-reference-04-config-01-next-config-js-exportPathMap",
    "path": "02-pages\\04-api-reference\\04-config\\01-next-config-js\\exportPathMap.mdx",
    "title": "exportPathMap",
    "description": "Customize the pages that will be exported as HTML files when using `next export`.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/04-config/01-next-config-js/exportPathMap"
  },
  {
    "id": "02-pages-04-api-reference-04-config-01-next-config-js-generateBuildId",
    "path": "02-pages\\04-api-reference\\04-config\\01-next-config-js\\generateBuildId.mdx",
    "title": "generateBuildId",
    "description": "Configure the build id, which is used to identify the current build in which your application is being served.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/04-config/01-next-config-js/generateBuildId"
  },
  {
    "id": "02-pages-04-api-reference-04-config-01-next-config-js-generateEtags",
    "path": "02-pages\\04-api-reference\\04-config\\01-next-config-js\\generateEtags.mdx",
    "title": "generateEtags",
    "description": "Next.js will generate etags for every page by default. Learn more about how to disable etag generation here.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/04-config/01-next-config-js/generateEtags"
  },
  {
    "id": "02-pages-04-api-reference-04-config-01-next-config-js-headers",
    "path": "02-pages\\04-api-reference\\04-config\\01-next-config-js\\headers.mdx",
    "title": "headers",
    "description": "Add custom HTTP headers to your Next.js app.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/04-config/01-next-config-js/headers"
  },
  {
    "id": "02-pages-04-api-reference-04-config-01-next-config-js-httpAgentOptions",
    "path": "02-pages\\04-api-reference\\04-config\\01-next-config-js\\httpAgentOptions.mdx",
    "title": "httpAgentOptions",
    "description": "Next.js will automatically use HTTP Keep-Alive by default. Learn more about how to disable HTTP Keep-Alive here.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/04-config/01-next-config-js/httpAgentOptions"
  },
  {
    "id": "02-pages-04-api-reference-04-config-01-next-config-js-images",
    "path": "02-pages\\04-api-reference\\04-config\\01-next-config-js\\images.mdx",
    "title": "images",
    "description": "Custom configuration for the next/image loader",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/04-config/01-next-config-js/images"
  },
  {
    "id": "02-pages-04-api-reference-04-config-01-next-config-js-index",
    "path": "02-pages\\04-api-reference\\04-config\\01-next-config-js\\index.mdx",
    "title": "next.config.js Options",
    "description": "Learn about the options available in next.config.js for the Pages Router.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/04-config/01-next-config-js"
  },
  {
    "id": "02-pages-04-api-reference-04-config-01-next-config-js-isolatedDevBuild",
    "path": "02-pages\\04-api-reference\\04-config\\01-next-config-js\\isolatedDevBuild.mdx",
    "title": "isolatedDevBuild",
    "description": "Use isolated directories for development builds to prevent conflicts with production builds.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/04-config/01-next-config-js/isolatedDevBuild"
  },
  {
    "id": "02-pages-04-api-reference-04-config-01-next-config-js-onDemandEntries",
    "path": "02-pages\\04-api-reference\\04-config\\01-next-config-js\\onDemandEntries.mdx",
    "title": "onDemandEntries",
    "description": "Configure how Next.js will dispose and keep in memory pages created in development.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/04-config/01-next-config-js/onDemandEntries"
  },
  {
    "id": "02-pages-04-api-reference-04-config-01-next-config-js-optimizePackageImports",
    "path": "02-pages\\04-api-reference\\04-config\\01-next-config-js\\optimizePackageImports.mdx",
    "title": "optimizePackageImports",
    "description": "API Reference for optimizePackageImports Next.js Config Option",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/04-config/01-next-config-js/optimizePackageImports"
  },
  {
    "id": "02-pages-04-api-reference-04-config-01-next-config-js-output",
    "path": "02-pages\\04-api-reference\\04-config\\01-next-config-js\\output.mdx",
    "title": "output",
    "description": "Next.js automatically traces which files are needed by each page to allow for easy deployment of your application. Learn how it works here.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/04-config/01-next-config-js/output"
  },
  {
    "id": "02-pages-04-api-reference-04-config-01-next-config-js-pageExtensions",
    "path": "02-pages\\04-api-reference\\04-config\\01-next-config-js\\pageExtensions.mdx",
    "title": "pageExtensions",
    "description": "Extend the default page extensions used by Next.js when resolving pages in the Pages Router.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/04-config/01-next-config-js/pageExtensions"
  },
  {
    "id": "02-pages-04-api-reference-04-config-01-next-config-js-poweredByHeader",
    "path": "02-pages\\04-api-reference\\04-config\\01-next-config-js\\poweredByHeader.mdx",
    "title": "poweredByHeader",
    "description": "Next.js will add the `x-powered-by` header by default. Learn to opt-out of it here.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/04-config/01-next-config-js/poweredByHeader"
  },
  {
    "id": "02-pages-04-api-reference-04-config-01-next-config-js-productionBrowserSourceMaps",
    "path": "02-pages\\04-api-reference\\04-config\\01-next-config-js\\productionBrowserSourceMaps.mdx",
    "title": "productionBrowserSourceMaps",
    "description": "Enables browser source map generation during the production build.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/04-config/01-next-config-js/productionBrowserSourceMaps"
  },
  {
    "id": "02-pages-04-api-reference-04-config-01-next-config-js-proxyClientMaxBodySize",
    "path": "02-pages\\04-api-reference\\04-config\\01-next-config-js\\proxyClientMaxBodySize.mdx",
    "title": "experimental.proxyClientMaxBodySize",
    "description": "Configure the maximum request body size when using proxy.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/04-config/01-next-config-js/proxyClientMaxBodySize"
  },
  {
    "id": "02-pages-04-api-reference-04-config-01-next-config-js-reactStrictMode",
    "path": "02-pages\\04-api-reference\\04-config\\01-next-config-js\\reactStrictMode.mdx",
    "title": "reactStrictMode",
    "description": "The complete Next.js runtime is now Strict Mode-compliant, learn how to opt-in",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/04-config/01-next-config-js/reactStrictMode"
  },
  {
    "id": "02-pages-04-api-reference-04-config-01-next-config-js-redirects",
    "path": "02-pages\\04-api-reference\\04-config\\01-next-config-js\\redirects.mdx",
    "title": "redirects",
    "description": "Add redirects to your Next.js app.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/04-config/01-next-config-js/redirects"
  },
  {
    "id": "02-pages-04-api-reference-04-config-01-next-config-js-rewrites",
    "path": "02-pages\\04-api-reference\\04-config\\01-next-config-js\\rewrites.mdx",
    "title": "rewrites",
    "description": "Add rewrites to your Next.js app.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/04-config/01-next-config-js/rewrites"
  },
  {
    "id": "02-pages-04-api-reference-04-config-01-next-config-js-serverExternalPackages",
    "path": "02-pages\\04-api-reference\\04-config\\01-next-config-js\\serverExternalPackages.mdx",
    "title": "serverExternalPackages",
    "description": "Opt-out specific dependencies from the dependency bundling enabled by `bundlePagesRouterDependencies`.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [
      {
        "language": "js",
        "code": "/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  serverExternalPackages: ['@acme/ui'],\r\n}\r\n\r\nmodule.exports = nextConfig",
        "context": "filename=\"next.config.js\""
      }
    ],
    "content": "Opt-out specific dependencies from being included in the automatic bundling of the bundlePagesRouterDependencies option. These pages will then use native Node.js require to resolve the dependency. Next.js includes a short list of popular packages that currently are working on compatibility and automatically opt-ed out: - @appsignal/nodejs - @aws-sdk/client-s3 - @aws-sdk/s3-presigned-post - @blockfrost/blockfrost-js - @highlight-run/node - @huggingface/transformers - @jpg-store/lucid-cardano - @libsql/client - @mikro-orm/core - @mikro-orm/knex - @node-rs/argon2 - @node-rs/bcrypt - @prisma/client - @react-pdf/renderer - @sentry/profiling-node - @sparticuz/chromium - @sparticuz/chromium-min - @statsig/statsig-node-core - @swc/core - @xenova/transformers - argon2 - autoprefixer - aws-crt - bcrypt - better-sqlite3 - canvas - chromadb-default-embed - config - cpu-features - cypress - dd-trace - eslint - express - firebase-admin - htmlrewriter - import-in-the-middle - isolated-vm - jest - jsdom - keyv - libsql - mdx-bundler - mongodb - mongoose - newrelic - next-mdx-remote - next-seo - node-cron - node-pty - node-web-audio-api - onnxruntime-node - oslo - pg - playwright - playwright-core - postcss - prettier - prisma - puppeteer-core - puppeteer - ravendb - require-in-the-middle - rimraf - sharp - shiki - sqlite3 - ts-node - ts-morph - typescript - vscode-oniguruma - webpack - websocket - zeromq",
    "excerpt": "Opt-out specific dependencies from being included in the automatic bundling of the bundlePagesRouterDependencies option. These pages will then use native Node.js require to resolve the dependency. Nex...",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/04-config/01-next-config-js/serverExternalPackages"
  },
  {
    "id": "02-pages-04-api-reference-04-config-01-next-config-js-trailingSlash",
    "path": "02-pages\\04-api-reference\\04-config\\01-next-config-js\\trailingSlash.mdx",
    "title": "trailingSlash",
    "description": "Configure Next.js pages to resolve with or without a trailing slash.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/04-config/01-next-config-js/trailingSlash"
  },
  {
    "id": "02-pages-04-api-reference-04-config-01-next-config-js-transpilePackages",
    "path": "02-pages\\04-api-reference\\04-config\\01-next-config-js\\transpilePackages.mdx",
    "title": "transpilePackages",
    "description": "Automatically transpile and bundle dependencies from local packages (like monorepos) or from external dependencies (`node_modules`).",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/04-config/01-next-config-js/transpilePackages"
  },
  {
    "id": "02-pages-04-api-reference-04-config-01-next-config-js-turbopack",
    "path": "02-pages\\04-api-reference\\04-config\\01-next-config-js\\turbopack.mdx",
    "title": "turbopack",
    "description": "Configure Next.js with Turbopack-specific options",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/04-config/01-next-config-js/turbopack"
  },
  {
    "id": "02-pages-04-api-reference-04-config-01-next-config-js-typescript",
    "path": "02-pages\\04-api-reference\\04-config\\01-next-config-js\\typescript.mdx",
    "title": "typescript",
    "description": "Next.js reports TypeScript errors by default. Learn to opt-out of this behavior here.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/04-config/01-next-config-js/typescript"
  },
  {
    "id": "02-pages-04-api-reference-04-config-01-next-config-js-urlImports",
    "path": "02-pages\\04-api-reference\\04-config\\01-next-config-js\\urlImports.mdx",
    "title": "urlImports",
    "description": "Configure Next.js to allow importing modules from external URLs.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/04-config/01-next-config-js/urlImports"
  },
  {
    "id": "02-pages-04-api-reference-04-config-01-next-config-js-useLightningcss",
    "path": "02-pages\\04-api-reference\\04-config\\01-next-config-js\\useLightningcss.mdx",
    "title": "useLightningcss",
    "description": "Enable experimental support for Lightning CSS.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/04-config/01-next-config-js/useLightningcss"
  },
  {
    "id": "02-pages-04-api-reference-04-config-01-next-config-js-webpack",
    "path": "02-pages\\04-api-reference\\04-config\\01-next-config-js\\webpack.mdx",
    "title": "Custom Webpack Config",
    "description": "Learn how to customize the webpack config used by Next.js",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/04-config/01-next-config-js/webpack"
  },
  {
    "id": "02-pages-04-api-reference-04-config-01-next-config-js-webVitalsAttribution",
    "path": "02-pages\\04-api-reference\\04-config\\01-next-config-js\\webVitalsAttribution.mdx",
    "title": "webVitalsAttribution",
    "description": "Learn how to use the webVitalsAttribution option to pinpoint the source of Web Vitals issues.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/04-config/01-next-config-js/webVitalsAttribution"
  },
  {
    "id": "02-pages-04-api-reference-04-config-01-typescript",
    "path": "02-pages\\04-api-reference\\04-config\\01-typescript.mdx",
    "title": "TypeScript",
    "description": "Next.js provides a TypeScript-first development experience for building your React application.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/04-config/01-typescript"
  },
  {
    "id": "02-pages-04-api-reference-04-config-02-eslint",
    "path": "02-pages\\04-api-reference\\04-config\\02-eslint.mdx",
    "title": "ESLint",
    "description": "Next.js reports ESLint errors and warnings during builds by default. Learn how to opt-out of this behavior here.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/04-config/02-eslint"
  },
  {
    "id": "02-pages-04-api-reference-04-config-index",
    "path": "02-pages\\04-api-reference\\04-config\\index.mdx",
    "title": "Configuration",
    "description": "Learn how to configure your Next.js application.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/04-config"
  },
  {
    "id": "02-pages-04-api-reference-05-cli-create-next-app",
    "path": "02-pages\\04-api-reference\\05-cli\\create-next-app.mdx",
    "title": "create-next-app CLI",
    "description": "Create Next.js apps using one command with the create-next-app CLI.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/05-cli/create-next-app"
  },
  {
    "id": "02-pages-04-api-reference-05-cli-index",
    "path": "02-pages\\04-api-reference\\05-cli\\index.mdx",
    "title": "CLI",
    "description": "API Reference for the Next.js Command Line Interface (CLI) tools.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/05-cli"
  },
  {
    "id": "02-pages-04-api-reference-05-cli-next",
    "path": "02-pages\\04-api-reference\\05-cli\\next.mdx",
    "title": "next CLI",
    "description": "Learn how to run and build your application with the Next.js CLI.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/05-cli/next"
  },
  {
    "id": "02-pages-04-api-reference-06-edge",
    "path": "02-pages\\04-api-reference\\06-edge.mdx",
    "title": "Edge Runtime",
    "description": "API Reference for the Edge Runtime.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/06-edge"
  },
  {
    "id": "02-pages-04-api-reference-08-turbopack",
    "path": "02-pages\\04-api-reference\\08-turbopack.mdx",
    "title": "Turbopack",
    "description": "Turbopack is an incremental bundler optimized for JavaScript and TypeScript, written in Rust, and built into Next.js.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference/08-turbopack"
  },
  {
    "id": "02-pages-04-api-reference-index",
    "path": "02-pages\\04-api-reference\\index.mdx",
    "title": "API Reference",
    "description": "Next.js API Reference for the Pages Router.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "",
    "excerpt": "",
    "url": "https://nextjs.org/docs/02-pages/04-api-reference"
  },
  {
    "id": "02-pages-index",
    "path": "02-pages\\index.mdx",
    "title": "Pages Router",
    "description": "Before Next.js 13, the Pages Router was the main way to create routes in Next.js with an intuitive file-system router.",
    "category": "pages-router",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "> You're viewing the documentation for the Pages Router. See the App Router documentation for the latest features. The Pages Router uses an intuitive file-system router to map each file to a route. Before Next.js 13, the Pages Router was the main way to create routes in Next.js. It's still supported in newer versions of Next.js, but we recommend migrating to the new App Router to leverage React's latest features.",
    "excerpt": "> You're viewing the documentation for the Pages Router. See the App Router documentation for the latest features. The Pages Router uses an intuitive file-system router to map each file to a route. Be...",
    "url": "https://nextjs.org/docs/02-pages"
  },
  {
    "id": "03-architecture-accessibility",
    "path": "03-architecture\\accessibility.mdx",
    "title": "Accessibility",
    "description": "The built-in accessibility features of Next.js.",
    "category": "architecture",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Route Announcements",
        "slug": "route-announcements"
      },
      {
        "level": 2,
        "text": "Linting",
        "slug": "linting"
      },
      {
        "level": 2,
        "text": "Accessibility Resources",
        "slug": "accessibility-resources"
      }
    ],
    "codeBlocks": [],
    "content": "The Next.js team is committed to making Next.js accessible to all developers (and their end-users). By adding accessibility features to Next.js by default, we aim to make the Web more inclusive for everyone. Route Announcements When transitioning between pages rendered on the server (e.g. using the tag) screen readers and other assistive technology announce the page title when the page loads so that users understand that the page has changed. In addition to traditional page navigations, Next.js also supports client-side transitions for improved performance (using next/link). To ensure that client-side transitions are also announced to assistive technology, Next.js includes a route announcer by default. The Next.js route announcer looks for the page name to announce by first inspecting document.title, then the element, and finally the URL pathname. For the most accessible user experience, ensure that each page in your application has a unique and descriptive title. Linting Next.js provides an integrated ESLint experience out of the box, including custom rules for Next.js. By default, Next.js includes eslint-plugin-jsx-a11y to help catch accessibility issues early, including warning on: - aria-props - aria-proptypes - aria-unsupported-elements - role-has-required-aria-props - role-supports-aria-props For example, this plugin helps ensure you add alt text to img tags, use correct aria- attributes, use correct role attributes, and more. Accessibility Resources - WebAIM WCAG checklist - WCAG 2.2 Guidelines - The A11y Project - Check color contrast ratios between foreground and background elements - Use prefers-reduced-motion when working with animations",
    "excerpt": "The Next.js team is committed to making Next.js accessible to all developers (and their end-users). By adding accessibility features to Next.js by default, we aim to make the Web more inclusive for ev...",
    "url": "https://nextjs.org/docs/03-architecture/accessibility"
  },
  {
    "id": "03-architecture-fast-refresh",
    "path": "03-architecture\\fast-refresh.mdx",
    "title": "Fast Refresh",
    "description": "Fast Refresh is a hot module reloading experience that gives you instantaneous feedback on edits made to your React components.",
    "category": "architecture",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "How It Works",
        "slug": "how-it-works"
      },
      {
        "level": 2,
        "text": "Error Resilience",
        "slug": "error-resilience"
      },
      {
        "level": 3,
        "text": "Syntax Errors",
        "slug": "syntax-errors"
      },
      {
        "level": 3,
        "text": "Runtime Errors",
        "slug": "runtime-errors"
      },
      {
        "level": 2,
        "text": "Limitations",
        "slug": "limitations"
      },
      {
        "level": 2,
        "text": "Tips",
        "slug": "tips"
      },
      {
        "level": 2,
        "text": "Fast Refresh and Hooks",
        "slug": "fast-refresh-and-hooks"
      }
    ],
    "codeBlocks": [],
    "content": "Fast refresh is a React feature integrated into Next.js that allows you to live reload the browser page while maintaining temporary client-side state when you save changes to a file. It's enabled by default in all Next.js applications on 9.4 or newer. With Fast Refresh enabled, most edits should be visible within a second. How It Works - If you edit a file that only exports React component(s), Fast Refresh will update the code only for that file, and re-render your component. You can edit anything in that file, including styles, rendering logic, event handlers, or effects. - If you edit a file with exports that aren't React components, Fast Refresh will re-run both that file, and the other files importing it. So if both Button.js and Modal.js import theme.js, editing theme.js will update both components. - Finally, if you edit a file that's imported by files outside of the React tree, Fast Refresh will fall back to doing a full reload. You might have a file which renders a React component but also exports a value that is imported by a non-React component. For example, maybe your component also exports a constant, and a non-React utility file imports it. In that case, consider migrating the constant to a separate file and importing it into both files. This will re-enable Fast Refresh to work. Other cases can usually be solved in a similar way. Error Resilience Syntax Errors If you make a syntax error during development, you can fix it and save the file again. The error will disappear automatically, so you won't need to reload the app. You will not lose component state. Runtime Errors If you make a mistake that leads to a runtime error inside your component, you'll be greeted with a contextual overlay. Fixing the error will automatically dismiss the overlay, without reloading the app. Component state will be retained if the error did not occur during rendering. If the error did occur during rendering, React will remount your application using the updated code. If you have error boundaries in your app (which is a good idea for graceful failures in production), they will retry rendering on the next edit after a rendering error. This means having an error boundary can prevent you from always getting reset to the root app state. However, keep in mind that error boundaries shouldn't be too granular. They are used by React in production, and should always be designed intentionally. Limitations Fast Refresh tries to preserve local React state in the component you're editing, but only if it's safe to do so. Here's a few reasons why you might see local state being reset on every edit to a file: - Local state is not preserved for class components (only function components and Hooks preserve state). - The file you're editing might have other exports in addition to a React component. - Sometimes, a file would export the result of calling a higher-order component like HOC(WrappedComponent). If the returned component is a class, its state will be reset. - Anonymous arrow functions like export default () => ; cause Fast Refresh to not preserve local component state. For large codebases you can use our name-default-component codemod. As more of your codebase moves to function components and Hooks, you can expect state to be preserved in more cases. Tips - Fast Refresh preserves React local state in function components (and Hooks) by default. - Sometimes you might want to force the state to be reset, and a component to be remounted. For example, this can be handy if you're tweaking an animation that only happens on mount. To do this, you can add // @refresh reset anywhere in the file you're editing. This directive is local to the file, and instructs Fast Refresh to remount components defined in that file on every edit. - You can put console.log or debugger; into the components you edit during development. - Remember that imports are case sensitive. Both fast and full refresh can fail, when your import doesn't match the actual filename. For example, './header' vs './Header'. Fast Refresh and Hooks When possible, Fast Refresh attempts to preserve the state of your component between edits. In particular, useState and useRef preserve their previous values as long as you don't change their arguments or the order of the Hook calls. Hooks with dependencies—such as useEffect, useMemo, and useCallback—will always update during Fast Refresh. Their list of dependencies will be ignored while Fast Refresh is happening. For example, when you edit useMemo(() => x 2, [x]) to useMemo(() => x 10, [x]), it will re-run even though x (the dependency) has not changed. If React didn't do that, your edit wouldn't reflect on the screen! Sometimes, this can lead to unexpected results. For example, even a useEffect with an empty array of dependencies would still re-run once during Fast Refresh. However, writing code resilient to occasional re-running of useEffect is a good practice even without Fast Refresh. It will make it easier for you to introduce new dependencies to it later on and it's enforced by React Strict Mode, which we highly recommend enabling.",
    "excerpt": "Fast refresh is a React feature integrated into Next.js that allows you to live reload the browser page while maintaining temporary client-side state when you save changes to a file. It's enabled by d...",
    "url": "https://nextjs.org/docs/03-architecture/fast-refresh"
  },
  {
    "id": "03-architecture-index",
    "path": "03-architecture\\index.mdx",
    "title": "Architecture",
    "description": "How Next.js Works",
    "category": "architecture",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "Learn about the Next.js architecture and how it works under the hood.",
    "excerpt": "Learn about the Next.js architecture and how it works under the hood.",
    "url": "https://nextjs.org/docs/03-architecture"
  },
  {
    "id": "03-architecture-nextjs-compiler",
    "path": "03-architecture\\nextjs-compiler.mdx",
    "title": "Next.js Compiler",
    "description": "Next.js Compiler, written in Rust, which transforms and minifies your Next.js application.",
    "category": "architecture",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Why SWC?",
        "slug": "why-swc"
      },
      {
        "level": 2,
        "text": "Supported Features",
        "slug": "supported-features"
      },
      {
        "level": 3,
        "text": "Styled Components",
        "slug": "styled-components"
      },
      {
        "level": 3,
        "text": "Jest",
        "slug": "jest"
      },
      {
        "level": 3,
        "text": "Relay",
        "slug": "relay"
      },
      {
        "level": 3,
        "text": "Remove React Properties",
        "slug": "remove-react-properties"
      },
      {
        "level": 3,
        "text": "Remove Console",
        "slug": "remove-console"
      },
      {
        "level": 3,
        "text": "Legacy Decorators",
        "slug": "legacy-decorators"
      },
      {
        "level": 3,
        "text": "importSource",
        "slug": "importsource"
      },
      {
        "level": 3,
        "text": "Emotion",
        "slug": "emotion"
      },
      {
        "level": 3,
        "text": "Minification",
        "slug": "minification"
      },
      {
        "level": 3,
        "text": "Module Transpilation",
        "slug": "module-transpilation"
      },
      {
        "level": 3,
        "text": "Modularize Imports",
        "slug": "modularize-imports"
      },
      {
        "level": 3,
        "text": "Define (Replacing variables during build)",
        "slug": "define-replacing-variables-during-build"
      },
      {
        "level": 3,
        "text": "Build Lifecycle Hooks",
        "slug": "build-lifecycle-hooks"
      },
      {
        "level": 4,
        "text": "runAfterProductionCompile",
        "slug": "runafterproductioncompile"
      },
      {
        "level": 2,
        "text": "Experimental Features",
        "slug": "experimental-features"
      },
      {
        "level": 3,
        "text": "SWC Trace profiling",
        "slug": "swc-trace-profiling"
      },
      {
        "level": 3,
        "text": "SWC Plugins (experimental)",
        "slug": "swc-plugins-experimental"
      },
      {
        "level": 2,
        "text": "Unsupported Features",
        "slug": "unsupported-features"
      },
      {
        "level": 2,
        "text": "Version History",
        "slug": "version-history"
      }
    ],
    "codeBlocks": [
      {
        "language": "js",
        "code": "module.exports = {\r\n  compiler: {\r\n    styledComponents: true,\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  compiler: {\r\n    // see https://styled-components.com/docs/tooling#babel-plugin for more info on the options.\r\n    styledComponents: {\r\n      // Enabled by default in development, disabled in production to reduce file size,\r\n      // setting this will override the default for all environments.\r\n      displayName?: boolean,\r\n      // Enabled by default.\r\n      ssr?: boolean,\r\n      // Enabled by default.\r\n      fileName?: boolean,\r\n      // Empty by default.\r\n      topLevelImportPaths?: string[],\r\n      // Defaults to [\"index\"].\r\n      meaninglessFileNames?: string[],\r\n      // Enabled by default.\r\n      minify?: boolean,\r\n      // Enabled by default.\r\n      transpileTemplateLiterals?: boolean,\r\n      // Empty by default.\r\n      namespace?: string,\r\n      // Disabled by default.\r\n      pure?: boolean,\r\n      // Enabled by default.\r\n      cssProp?: boolean,\r\n    },\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "const nextJest = require('next/jest')\r\n\r\n// Providing the path to your Next.js app which will enable loading next.config.js and .env files\r\nconst createJestConfig = nextJest({ dir: './' })\r\n\r\n// Any custom config you want to pass to Jest\r\nconst customJestConfig = {\r\n  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],\r\n}\r\n\r\n// createJestConfig is exported in this way to ensure that next/jest can load the Next.js configuration, which is async\r\nmodule.exports = createJestConfig(customJestConfig)",
        "context": "filename=\"jest.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  compiler: {\r\n    relay: {\r\n      // This should match relay.config.js\r\n      src: './',\r\n      artifactDirectory: './__generated__',\r\n      language: 'typescript',\r\n      eagerEsModules: false,\r\n    },\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  compiler: {\r\n    reactRemoveProperties: true,\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  compiler: {\r\n    // The regexes defined here are processed in Rust so the syntax is different from\r\n    // JavaScript `RegExp`s. See https://docs.rs/regex.\r\n    reactRemoveProperties: { properties: ['^data-custom$'] },\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  compiler: {\r\n    removeConsole: true,\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  compiler: {\r\n    removeConsole: {\r\n      exclude: ['error'],\r\n    },\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "{\r\n  \"compilerOptions\": {\r\n    \"experimentalDecorators\": true\r\n  }\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "{\r\n  \"compilerOptions\": {\r\n    \"jsxImportSource\": \"theme-ui\"\r\n  }\r\n}",
        "context": ""
      },
      {
        "language": "js",
        "code": "\r\nmodule.exports = {\r\n  compiler: {\r\n    emotion: boolean | {\r\n      // default is true. It will be disabled when build type is production.\r\n      sourceMap?: boolean,\r\n      // default is 'dev-only'.\r\n      autoLabel?: 'never' | 'dev-only' | 'always',\r\n      // default is '[local]'.\r\n      // Allowed values: `[local]` `[filename]` and `[dirname]`\r\n      // This option only works when autoLabel is set to 'dev-only' or 'always'.\r\n      // It allows you to define the format of the resulting label.\r\n      // The format is defined via string where variable parts are enclosed in square brackets [].\r\n      // For example labelFormat: \"my-classname--[local]\", where [local] will be replaced with the name of the variable the result is assigned to.\r\n      labelFormat?: string,\r\n      // default is undefined.\r\n      // This option allows you to tell the compiler what imports it should\r\n      // look at to determine what it should transform so if you re-export\r\n      // Emotion's exports, you can still use transforms.\r\n      importMap?: {\r\n        [packageName: string]: {\r\n          [exportName: string]: {\r\n            canonicalImport?: [string, string],\r\n            styledBaseImport?: [string, string],\r\n          }\r\n        }\r\n      },\r\n    },\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  transpilePackages: ['@acme/ui', 'lodash-es'],\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  compiler: {\r\n    define: {\r\n      MY_VARIABLE: 'my-string',\r\n      'process.env.MY_ENV_VAR': 'my-env-var',\r\n    },\r\n    defineServer: {\r\n      MY_SERVER_VARIABLE: 'my-server-var',\r\n    },\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  compiler: {\r\n    runAfterProductionCompile: async ({ distDir, projectDir }) => {\r\n      // Your custom code here\r\n    },\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  experimental: {\r\n    swcTraceProfiling: true,\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      },
      {
        "language": "js",
        "code": "module.exports = {\r\n  experimental: {\r\n    swcPlugins: [\r\n      [\r\n        'plugin',\r\n        {\r\n          ...pluginOptions,\r\n        },\r\n      ],\r\n    ],\r\n  },\r\n}",
        "context": "filename=\"next.config.js\""
      }
    ],
    "content": "The Next.js Compiler, written in Rust using SWC, allows Next.js to transform and minify your JavaScript code for production. This replaces Babel for individual files and Terser for minifying output bundles. Compilation using the Next.js Compiler is 17x faster than Babel and enabled by default since Next.js version 12. If you have an existing Babel configuration or are using unsupported features, your application will opt-out of the Next.js Compiler and continue using Babel. Why SWC? SWC is an extensible Rust-based platform for the next generation of fast developer tools. SWC can be used for compilation, minification, bundling, and more – and is designed to be extended. It's something you can call to perform code transformations (either built-in or custom). Running those transformations happens through higher-level tools like Next.js. We chose to build on SWC for a few reasons: - Extensibility: SWC can be used as a Crate inside Next.js, without having to fork the library or workaround design constraints. - Performance: We were able to achieve ~3x faster Fast Refresh and ~5x faster builds in Next.js by switching to SWC, with more room for optimization still in progress. - WebAssembly: Rust's support for WASM is essential for supporting all possible platforms and taking Next.js development everywhere. - Community: The Rust community and ecosystem are amazing and still growing. Supported Features Styled Components We're working to port babel-plugin-styled-components to the Next.js Compiler. First, update to the latest version of Next.js: npm install next@latest. Then, update your next.config.js file: For advanced use cases, you can configure individual properties for styled-components compilation. > Note: ssr and displayName transforms are the main requirement for using styled-components in Next.js. Jest The Next.js Compiler transpiles your tests and simplifies configuring Jest together with Next.js including: - Auto mocking of .css, .module.css (and their .scss variants), and image imports - Automatically sets up transform using SWC - Loading .env (and all variants) into process.env - Ignores nodemodules from test resolving and transforms - Ignoring .next from test resolving - Loads next.config.js for flags that enable experimental SWC transforms First, update to the latest version of Next.js: npm install next@latest. Then, update your jest.config.js file: Relay To enable Relay support: > Good to know: In Next.js, all JavaScript files in pages directory are considered routes. So, for relay-compiler you'll need to specify artifactDirectory configuration settings outside of the pages, otherwise relay-compiler will generate files next to the source file in the generated directory, and this file will be considered a route, which will break production builds. Remove React Properties Allows to remove JSX properties. This is often used for testing. Similar to babel-plugin-react-remove-properties. To remove properties matching the default regex ^data-test: To remove custom properties: Remove Console This transform allows for removing all console. calls in application code (not nodemodules). Similar to babel-plugin-transform-remove-console. Remove all console. calls: Remove console. output except console.error: Legacy Decorators Next.js will automatically detect experimentalDecorators in jsconfig.json or tsconfig.json. Legacy decorators are commonly used with older versions of libraries like mobx. This flag is only supported for compatibility with existing applications. We do not recommend using legacy decorators in new applications. First, update to the latest version of Next.js: npm install next@latest. Then, update your jsconfig.json or tsconfig.json file: importSource Next.js will automatically detect jsxImportSource in jsconfig.json or tsconfig.json and apply that. This is commonly used with libraries like Theme UI. First, update to the latest version of Next.js: npm install next@latest. Then, update your jsconfig.json or tsconfig.json file: Emotion We're working to port @emotion/babel-plugin to the Next.js Compiler. First, update to the latest version of Next.js: npm install next@latest. Then, update your next.config.js file: Minification Next.js' swc compiler is used for minification by default since v13. This is 7x faster than Terser. > Good to know: Starting with v15, minification cannot be customized using next.config.js. Support for the swcMinify flag has been removed. Module Transpilation Next.js can automatically transpile and bundle dependencies from local packages (like monorepos) or from external dependencies (nodemodules). This replaces the next-transpile-modules package. Modularize Imports This option has been superseded by optimizePackageImports in Next.js 13.5. We recommend upgrading to use the new option that does not require manual configuration of import paths. Define (Replacing variables during build) The define option allows you to statically replace variables in your code at build-time. The option takes an object as key-value pairs, where the keys are the variables that should be replaced with the corresponding values. Use the compiler.define field in next.config.js to define variables for all environments (server, edge, and client). Or, use compiler.defineServer to define variables only for server-side (server and edge) code: Build Lifecycle Hooks The Next.js Compiler supports lifecycle hooks that allow you to run custom code at specific points during the build process. Currently, the following hook is supported: runAfterProductionCompile A hook function that executes after production build compilation finishes, but before running post-compilation tasks such as type checking and static page generation. This hook provides access to project metadata including the project directory and build output directory, making it useful for third-party tools to collect build outputs like sourcemaps. The hook receives an object with the following properties: - distDir: The build output directory (defaults to .next) - projectDir: The root directory of the project Experimental Features SWC Trace profiling You can generate SWC's internal transform traces as chromium's trace event format. Once enabled, swc will generate trace named as swc-trace-profile-${timestamp}.json under .next/. Chromium's trace viewer (chrome://tracing/, https://ui.perfetto.dev/), or compatible flamegraph viewer (https://www.speedscope.app/) can load & visualize generated traces. SWC Plugins (experimental) You can configure swc's transform to use SWC's experimental plugin support written in wasm to customize transformation behavior. swcPlugins accepts an array of tuples for configuring plugins. A tuple for the plugin contains the path to the plugin and an object for plugin configuration. The path to the plugin can be an npm module package name or an absolute path to the .wasm binary itself. Unsupported Features When your application has a .babelrc file, Next.js will automatically fall back to using Babel for transforming individual files. This ensures backwards compatibility with existing applications that leverage custom Babel plugins. If you're using a custom Babel setup, please share your configuration. We're working to port as many commonly used Babel transformations as possible, as well as supporting plugins in the future. Version History | Version | Changes | | --------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | v13.1.0 | Module Transpilation and Modularize Imports stable. | | v13.0.0 | SWC Minifier enabled by default. | | v12.3.0 | SWC Minifier stable. | | v12.2.0 | SWC Plugins experimental support added. | | v12.1.0 | Added support for Styled Components, Jest, Relay, Remove React Properties, Legacy Decorators, Remove Console, and jsxImportSource. | | v12.0.0 | Next.js Compiler introduced. |",
    "excerpt": "The Next.js Compiler, written in Rust using SWC, allows Next.js to transform and minify your JavaScript code for production. This replaces Babel for individual files and Terser for minifying output bu...",
    "url": "https://nextjs.org/docs/03-architecture/nextjs-compiler"
  },
  {
    "id": "03-architecture-supported-browsers",
    "path": "03-architecture\\supported-browsers.mdx",
    "title": "Supported Browsers",
    "description": "Browser support and which JavaScript features are supported by Next.js.",
    "category": "architecture",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Browserslist",
        "slug": "browserslist"
      },
      {
        "level": 2,
        "text": "Polyfills",
        "slug": "polyfills"
      },
      {
        "level": 3,
        "text": "Custom Polyfills",
        "slug": "custom-polyfills"
      },
      {
        "level": 4,
        "text": "In App Router",
        "slug": "in-app-router"
      },
      {
        "level": 4,
        "text": "In Pages Router",
        "slug": "in-pages-router"
      },
      {
        "level": 4,
        "text": "Conditionally loading polyfills",
        "slug": "conditionally-loading-polyfills"
      },
      {
        "level": 2,
        "text": "JavaScript Language Features",
        "slug": "javascript-language-features"
      },
      {
        "level": 3,
        "text": "TypeScript Features",
        "slug": "typescript-features"
      },
      {
        "level": 3,
        "text": "Customizing Babel Config (Advanced)",
        "slug": "customizing-babel-config-advanced"
      }
    ],
    "codeBlocks": [
      {
        "language": "json",
        "code": "{\r\n  \"browserslist\": [\"chrome 111\", \"edge 111\", \"firefox 111\", \"safari 16.4\"]\r\n}",
        "context": "filename=\"package.json\""
      },
      {
        "language": "ts",
        "code": "import './polyfills'",
        "context": "filename=\"instrumentation-client.ts\""
      },
      {
        "language": "tsx",
        "code": "import './polyfills'\r\n\r\nimport type { AppProps } from 'next/app'\r\n\r\nexport default function MyApp({ Component, pageProps }: AppProps) {\r\n  return <Component {...pageProps} />\r\n}",
        "context": "filename=\"pages/_app.tsx\" switcher"
      },
      {
        "language": "jsx",
        "code": "import './polyfills'\r\n\r\nexport default function MyApp({ Component, pageProps }) {\r\n  return <Component {...pageProps} />\r\n}",
        "context": "filename=\"pages/_app.jsx\" switcher"
      },
      {
        "language": "ts",
        "code": "import { useCallback } from 'react'\r\n\r\nexport const useAnalytics = () => {\r\n  const tracker = useCallback(async (data: unknown) => {\r\n    if (!('structuredClone' in globalThis)) {\r\n      import('polyfills/structured-clone').then((mod) => {\r\n        globalThis.structuredClone = mod.default\r\n      })\r\n    }\r\n\r\n    /* Do some work that uses structured clone */\r\n  }, [])\r\n\r\n  return tracker\r\n}",
        "context": "filename=\"hooks/analytics.ts\" switcher"
      },
      {
        "language": "js",
        "code": "import { useCallback } from 'react'\r\n\r\nexport const useAnalytics = () => {\r\n  const tracker = useCallback(async (data) => {\r\n    if (!('structuredClone' in globalThis)) {\r\n      import('polyfills/structured-clone').then((mod) => {\r\n        globalThis.structuredClone = mod.default\r\n      })\r\n    }\r\n\r\n    /* Do some work that uses structured clone */\r\n  }, [])\r\n\r\n  return tracker\r\n}",
        "context": "filename=\"hooks/analytics.js\" switcher"
      }
    ],
    "content": "Next.js supports modern browsers with zero configuration. - Chrome 111+ - Edge 111+ - Firefox 111+ - Safari 16.4+ Browserslist If you would like to target specific browsers or features, Next.js supports Browserslist configuration in your package.json file. Next.js uses the following Browserslist configuration by default: Polyfills We inject widely used polyfills, including: - fetch() — Replacing: whatwg-fetch and unfetch. - URL — Replacing: the url package (Node.js API). - Object.assign() — Replacing: object-assign, object.assign, and core-js/object/assign. If any of your dependencies include these polyfills, they’ll be eliminated automatically from the production build to avoid duplication. In addition, to reduce bundle size, Next.js will only load these polyfills for browsers that require them. The majority of the web traffic globally will not download these polyfills. Custom Polyfills If your own code or any external npm dependencies require features not supported by your target browsers (such as IE 11), you need to add polyfills yourself. In App Router To include polyfills, you can import them into the instrumentation-client.js file. In Pages Router In this case, you should add a top-level import for the specific polyfill you need in your Custom or the individual component. Conditionally loading polyfills The best approach is to isolate unsupported features to specific UI sections and conditionally load the polyfill if needed. JavaScript Language Features Next.js allows you to use the latest JavaScript features out of the box. In addition to ES6 features, Next.js also supports: - Async/await (ES2017) - Object Rest/Spread Properties (ES2018) - Dynamic import() (ES2020) - Optional Chaining (ES2020) - Nullish Coalescing (ES2020) - Class Fields and Static Properties (ES2022) - and more! TypeScript Features Next.js has built-in TypeScript support. Learn more here. Customizing Babel Config (Advanced) You can customize babel configuration. Learn more here.",
    "excerpt": "Next.js supports modern browsers with zero configuration. - Chrome 111+ - Edge 111+ - Firefox 111+ - Safari 16.4+ Browserslist If you would like to target specific browsers or features, Next.js suppor...",
    "url": "https://nextjs.org/docs/03-architecture/supported-browsers"
  },
  {
    "id": "04-community-01-contribution-guide",
    "path": "04-community\\01-contribution-guide.mdx",
    "title": "Docs Contribution Guide",
    "description": "Learn how to contribute to Next.js Documentation",
    "category": "community",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Why Contribute?",
        "slug": "why-contribute"
      },
      {
        "level": 2,
        "text": "How to Contribute",
        "slug": "how-to-contribute"
      },
      {
        "level": 3,
        "text": "GitHub Workflow",
        "slug": "github-workflow"
      },
      {
        "level": 3,
        "text": "Writing MDX",
        "slug": "writing-mdx"
      },
      {
        "level": 3,
        "text": "VSCode",
        "slug": "vscode"
      },
      {
        "level": 4,
        "text": "Previewing Changes Locally",
        "slug": "previewing-changes-locally"
      },
      {
        "level": 4,
        "text": "Extensions",
        "slug": "extensions"
      },
      {
        "level": 3,
        "text": "Review Process",
        "slug": "review-process"
      },
      {
        "level": 2,
        "text": "File Structure",
        "slug": "file-structure"
      },
      {
        "level": 2,
        "text": "Metadata",
        "slug": "metadata"
      },
      {
        "level": 3,
        "text": "Required Fields",
        "slug": "required-fields"
      },
      {
        "level": 3,
        "text": "Optional Fields",
        "slug": "optional-fields"
      },
      {
        "level": 2,
        "text": " and  Docs",
        "slug": "-and-docs"
      },
      {
        "level": 3,
        "text": "Shared Pages",
        "slug": "shared-pages"
      },
      {
        "level": 3,
        "text": "Shared Content",
        "slug": "shared-content"
      },
      {
        "level": 2,
        "text": "Code Blocks",
        "slug": "code-blocks"
      },
      {
        "level": 3,
        "text": "Language and Filename",
        "slug": "language-and-filename"
      },
      {
        "level": 3,
        "text": "TS and JS Switcher",
        "slug": "ts-and-js-switcher"
      },
      {
        "level": 3,
        "text": "Line Highlighting",
        "slug": "line-highlighting"
      },
      {
        "level": 2,
        "text": "Icons",
        "slug": "icons"
      },
      {
        "level": 2,
        "text": "Notes",
        "slug": "notes"
      },
      {
        "level": 2,
        "text": "Related Links",
        "slug": "related-links"
      },
      {
        "level": 3,
        "text": "Nested Fields",
        "slug": "nested-fields"
      },
      {
        "level": 2,
        "text": "Diagrams",
        "slug": "diagrams"
      },
      {
        "level": 2,
        "text": "Custom Components and HTML",
        "slug": "custom-components-and-html"
      },
      {
        "level": 2,
        "text": "Style Guide",
        "slug": "style-guide"
      },
      {
        "level": 3,
        "text": "Page Templates",
        "slug": "page-templates"
      },
      {
        "level": 3,
        "text": "Page Types",
        "slug": "page-types"
      },
      {
        "level": 3,
        "text": "Voice",
        "slug": "voice"
      }
    ],
    "codeBlocks": [
      {
        "language": "json",
        "code": "{\r\n  \"files.associations\": {\r\n    \"*.mdx\": \"markdown\"\r\n  }\r\n}",
        "context": "filename=\"settings.json\""
      },
      {
        "language": "txt",
        "code": "04-functions\r\n├── after.mdx\r\n├── cacheLife.mdx\r\n├── cacheTag.mdx\r\n└── ...",
        "context": ""
      },
      {
        "language": "txt",
        "code": "01-routing\r\n├── 01-defining-routes.mdx\r\n├── 02-pages.mdx\r\n├── 03-layouts-and-templates.mdx\r\n└── ...",
        "context": ""
      },
      {
        "language": "yaml",
        "code": "---\r\ntitle: Page Title\r\ndescription: Page Description\r\n---",
        "context": "filename=\"required-fields.mdx\""
      },
      {
        "language": "yaml",
        "code": "---\r\nnav_title: Nav Item Title\r\nsource: app/building-your-application/optimizing/images\r\nrelated:\r\n  description: See the image component API reference.\r\n  links:\r\n    - app/api-reference/components/image\r\nversion: experimental\r\n---",
        "context": "filename=\"optional-fields.mdx\""
      },
      {
        "language": "mdx",
        "code": "---\r\ntitle: <Link>\r\ndescription: API reference for the <Link> component.\r\n---\r\n\r\nThis API reference will help you understand how to use the props\r\nand configuration options available for the Link Component.",
        "context": "filename=\"app/.../link.mdx\""
      },
      {
        "language": "mdx",
        "code": "---\r\ntitle: <Link>\r\ndescription: API reference for the <Link> component.\r\nsource: app/api-reference/components/link\r\n---\r\n\r\n{/* DO NOT EDIT THIS PAGE. */}\r\n{/* The content of this page is pulled from the source above. */}",
        "context": "filename=\"pages/.../link.mdx\""
      },
      {
        "language": "mdx",
        "code": "This content is shared between App and Pages.\r\n\r\n<PagesOnly>\r\n\r\nThis content will only be shown on the Pages docs.\r\n\r\n</PagesOnly>\r\n\r\nThis content is shared between App and Pages.",
        "context": "filename=\"app/.../link.mdx\""
      },
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Page() {\r\n  return <Link href=\"/about\">About</Link>\r\n}",
        "context": "filename=\"app/page.tsx\""
      },
      {
        "language": "mdx",
        "code": "```bash filename=\"Terminal\"\r\nnpx create-next-app\r\n```",
        "context": "filename=\"code-example.mdx\""
      },
      {
        "language": "mdx",
        "code": "```tsx filename=\"app/page.tsx\" switcher\r\n\r\n```\r\n\r\n```jsx filename=\"app/page.js\" switcher\r\n\r\n```",
        "context": "filename=\"code-example.mdx\""
      },
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Page() {\r\n  return <Link href=\"/about\">About</Link>\r\n}",
        "context": "filename=\"app/page.tsx\" {1}"
      },
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Page() {\r\n  return <Link href=\"/about\">About</Link>\r\n}",
        "context": "filename=\"app/page.tsx\" highlight={1,3}"
      },
      {
        "language": "tsx",
        "code": "import Link from 'next/link'\r\n\r\nexport default function Page() {\r\n  return <Link href=\"/about\">About</Link>\r\n}",
        "context": "filename=\"app/page.tsx\" highlight={1-5}"
      },
      {
        "language": "mdx",
        "code": "<Check size={18} />\r\n<Cross size={18} />",
        "context": "filename=\"mdx-icon.mdx\""
      },
      {
        "language": "mdx",
        "code": "> **Good to know**: This is a single line note.\r\n\r\n> **Good to know**:\r\n>\r\n> - We also use this format for multi-line notes.\r\n> - There are sometimes multiple items worth knowing or keeping in mind.",
        "context": "filename=\"notes.mdx\""
      },
      {
        "language": "yaml",
        "code": "---\r\nrelated:\r\n  description: Learn how to quickly get started with your first application.\r\n  links:\r\n    - app/building-your-application/routing/defining-routes\r\n    - app/building-your-application/data-fetching\r\n    - app/api-reference/file-conventions/page\r\n---",
        "context": "filename=\"example.mdx\""
      }
    ],
    "content": "Welcome to the Next.js Docs Contribution Guide! We're excited to have you here. This page provides instructions on how to edit the Next.js documentation. Our goal is to ensure that everyone in the community feels empowered to contribute and improve our docs. Why Contribute? Open-source work is never done, and neither is documentation. Contributing to docs is a good way for beginners to get involved in open-source and for experienced developers to clarify more complex topics while sharing their knowledge with the community. By contributing to the Next.js docs, you're helping us build a more robust learning resource for all developers. Whether you've found a typo, a confusing section, or you've realized that a particular topic is missing, your contributions are welcomed and appreciated. How to Contribute The docs content can be found on the Next.js repo. To contribute, you can edit the files directly on GitHub or clone the repo and edit the files locally. GitHub Workflow If you're new to GitHub, we recommend reading the GitHub Open Source Guide to learn how to fork a repository, create a branch, and submit a pull request. > Good to know: The underlying docs code lives in a private codebase that is synced to the Next.js public repo. This means that you can't preview the docs locally. However, you'll see your changes on nextjs.org after merging a pull request. Writing MDX The docs are written in MDX, a markdown format that supports JSX syntax. This allows us to embed React components in the docs. See the GitHub Markdown Guide for a quick overview of markdown syntax. VSCode Previewing Changes Locally VSCode has a built-in markdown previewer that you can use to see your edits locally. To enable the previewer for MDX files, you'll need to add a configuration option to your user settings. Open the command palette (⌘ + ⇧ + P on Mac or Ctrl + Shift + P on Windows) and search from Preferences: Open User Settings (JSON). Then, add the following line to your settings.json file: Next, open the command palette again, and search for Markdown: Preview File or Markdown: Open Preview to the Side. This will open a preview window where you can see your formatted changes. Extensions We also recommend the following extensions for VSCode users: - MDX: Intellisense and syntax highlighting for MDX. - Prettier: Format MDX files on save. Review Process Once you've submitted your contribution, the Next.js or Developer Experience teams will review your changes, provide feedback, and merge the pull request when it's ready. Please let us know if you have any questions or need further assistance in your PR's comments. Thank you for contributing to the Next.js docs and being a part of our community! > Tip: Run pnpm prettier-fix to run Prettier before submitting your PR. File Structure The docs use file-system routing. Each folder and files inside /docs represent a route segment. These segments are used to generate the URL paths, navigation, and breadcrumbs. The file structure reflects the navigation that you see on the site, and by default, navigation items are sorted alphabetically. However, we can change the order of the items by prepending a two-digit number (00-) to the folder or file name. For example, in the functions API Reference, the pages are sorted alphabetically because it makes it easier for developers to find a specific function: But, in the routing section, the files are prefixed with a two-digit number, sorted in the order developers should learn these concepts: To quickly find a page, you can use ⌘ + P (Mac) or Ctrl + P (Windows) to open the search bar on VSCode. Then, type the slug of the page you're looking for. E.g. defining-routes > Why not use a manifest? > > We considered using a manifest file (another popular way to generate the docs navigation), but we found that a manifest would quickly get out of sync with the files. File-system routing forces us to think about the structure of the docs and feels more native to Next.js. Metadata Each page has a metadata block at the top of the file separated by three dashes. Required Fields The following fields are required: | Field | Description | | ------------- | ---------------------------------------------------------------------------- | | title | The page's title, used for SEO and OG Images. | | description | The page's description, used in the tag for SEO. | It's good practice to limit the page title to 2-3 words (e.g. Optimizing Images) and the description to 1-2 sentences (e.g. Learn how to optimize images in Next.js). Optional Fields The following fields are optional: | Field | Description | | ----------- | -------------------------------------------------------------------------------------------------------------------------------------------------- | | navtitle | Overrides the page's title in the navigation. This is useful when the page's title is too long to fit. If not provided, the title field is used. | | source | Pulls content into a shared page. See Shared Pages. | | related | A list of related pages at the bottom of the document. These will automatically be turned into cards. See Related Links. | | version | A stage of development. e.g. experimental,legacy,unstable,RC | App and Pages Docs Since most of the features in the App Router and Pages Router are completely different, their docs for each are kept in separate sections (02-app and 03-pages). However, there are a few features that are shared between them. Shared Pages To avoid content duplication and risk the content becoming out of sync, we use the source field to pull content from one page into another. For example, the component behaves mostly the same in App and Pages. Instead of duplicating the content, we can pull the content from app/.../link.mdx into pages/.../link.mdx: We can therefore edit the content in one place and have it reflected in both sections. Shared Content In shared pages, sometimes there might be content that is App Router or Pages Router specific. For example, the component has a shallow prop that is only available in Pages but not in App. To make sure the content only shows in the correct router, we can wrap content blocks in an or components: You'll likely use these components for examples and code blocks. Code Blocks Code blocks should contain a minimum working example that can be copied and pasted. This means that the code should be able to run without any additional configuration. For example, if you're showing how to use the component, you should include the import statement and the component itself. Always run examples locally before committing them. This will ensure that the code is up-to-date and working. Language and Filename Code blocks should have a header that includes the language and the filename. Add a filename prop to render a special Terminal icon that helps orientate users where to input the command. For example: bash filename=\"Terminal\" npx create-next-app Most examples in the docs are written in tsx and jsx, and a few in bash. However, you can use any supported language, here's the full list. When writing JavaScript code blocks, we use the following language and extension combinations. | | Language | Extension | | ------------------------------ | -------- | --------- | | JavaScript files with JSX code | js | .js | | TypeScript files with JSX | ts | .ts | > Good to know: > > - Make sure to use .js extension for JavaScript files with JSX code. > - For example, mdx filename=\"code-example.mdx\" tsx filename=\"app/page.tsx\" {1} import Link from 'next/link' export default function Page() { return About } tsx filename=\"app/page.tsx\" highlight={1,3} import Link from 'next/link' export default function Page() { return About } tsx filename=\"app/page.tsx\" highlight={1-5} import Link from 'next/link' export default function Page() { return About } mdx filename=\"mdx-icon.mdx\" mdx filename=\"notes.mdx\" > Good to know: This is a single line note. > Good to know: > > - We also use this format for multi-line notes. > - There are sometimes multiple items worth knowing or keeping in mind. yaml filename=\"example.mdx\" --- related: description: Learn how to quickly get started with your first application. links: - app/building-your-application/routing/defining-routes - app/building-your-application/data-fetching - app/api-reference/file-conventions/page --- Nested Fields | Field | Required? | Description | | ------------- | --------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- | | title | Optional | The title of the card list. Defaults to Next Steps. | | description | Optional | The description of the card list. | | links | Required | A list of links to other doc pages. Each list item should be a relative URL path (without a leading slash) e.g. app/api-reference/file-conventions/page | Diagrams Diagrams are a great way to explain complex concepts. We use Figma to create diagrams, following Vercel's design guide. The diagrams currently live in the /public folder in our private Next.js site. If you'd like to update or add a diagram, please open a GitHub issue with your ideas. Custom Components and HTML These are the React Components available for the docs: (next/image), , , , and . We do not allow raw HTML in the docs besides the tag. If you have ideas for new components, please open a GitHub issue. Style Guide This section contains guidelines for writing docs for those who are new to technical writing. Page Templates While we don't have a strict template for pages, there are page sections you'll see repeated across the docs: - Overview: The first paragraph of a page should tell the user what the feature is and what it's used for. Followed by a minimum working example or its API reference. - Convention: If the feature has a convention, it should be explained here. - Examples: Show how the feature can be used with different use cases. - API Tables: API Pages should have an overview table at the of the page with jump-to-section links (when possible). - Next Steps (Related Links): Add links to related pages to guide the user's learning journey. Feel free to add these sections as needed. Page Types Docs pages are also split into two categories: Conceptual and Reference. - Conceptual pages are used to explain a concept or feature. They are usually longer and contain more information than reference pages. In the Next.js docs, conceptual pages are found in the Building Your Application section. - Reference pages are used to explain a specific API. They are usually shorter and more focused. In the Next.js docs, reference pages are found in the API Reference section. > Good to know: Depending on the page you're contributing to, you may need to follow a different voice and style. For example, conceptual pages are more instructional and use the word you to address the user. Reference pages are more technical, they use more imperative words like \"create, update, accept\" and tend to omit the word you. Voice Here are some guidelines to maintain a consistent style and voice across the docs: - Write clear, concise sentences. Avoid tangents. - If you find yourself using a lot of commas, consider breaking the sentence into multiple sentences or use a list. - Swap out complex words for simpler ones. For example, use instead of utilize. - Be mindful with the word this. It can be ambiguous and confusing, don't be afraid to repeat the subject of the sentence if unclear. - For example, Next.js uses React instead of Next.js uses this. - Use an active voice instead of passive. An active sentence is easier to read. - For example, Next.js uses React instead of React is used by Next.js. If you find yourself using words like was and by you may be using a passive voice. - Avoid using words like easy, quick, simple, just, etc. This is subjective and can be discouraging to users. - Avoid negative words like don't, can't, won't, etc. This can be discouraging to readers. - For example, \"You can use the Link component to create links between pages\" instead of \"Don't use the tag to create links between pages\". - Write in second person (you/your). This is more personal and engaging. - Use gender-neutral language. Use developers, users, or readers, when referring to the audience. - If adding code examples, ensure they are properly formatted and working. While these guidelines are not exhaustive, they should help you get started. If you'd like to dive deeper into technical writing, check out the Google Technical Writing Course. --- Thank you for contributing to the docs and being part of the Next.js community!",
    "excerpt": "Welcome to the Next.js Docs Contribution Guide! We're excited to have you here. This page provides instructions on how to edit the Next.js documentation. Our goal is to ensure that everyone in the com...",
    "url": "https://nextjs.org/docs/04-community/01-contribution-guide"
  },
  {
    "id": "04-community-02-rspack",
    "path": "04-community\\02-rspack.mdx",
    "title": "Rspack Integration",
    "description": "Use the `next-rspack` plugin to bundle your Next.js with Rspack.",
    "category": "community",
    "version": "15.1.8",
    "headings": [],
    "codeBlocks": [],
    "content": "The Rspack team has created a community plugin for Next.js, which is part of a partnering effort with the Rspack team. This plugin is currently experimental. Please use this discussion thread to give feedback on any issues you encounter. Learn more on the Rspack docs and try out this example.",
    "excerpt": "The Rspack team has created a community plugin for Next.js, which is part of a partnering effort with the Rspack team. This plugin is currently experimental. Please use this discussion thread to give...",
    "url": "https://nextjs.org/docs/04-community/02-rspack"
  },
  {
    "id": "04-community-index",
    "path": "04-community\\index.mdx",
    "title": "Next.js Community",
    "description": "Get involved in the Next.js community.",
    "category": "community",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "Contributing",
        "slug": "contributing"
      },
      {
        "level": 2,
        "text": "Discussions",
        "slug": "discussions"
      },
      {
        "level": 2,
        "text": "Social Media",
        "slug": "social-media"
      },
      {
        "level": 2,
        "text": "Code of Conduct",
        "slug": "code-of-conduct"
      }
    ],
    "codeBlocks": [],
    "content": "With over 5 million weekly downloads, Next.js has a large and active community of developers across the world. Here's how you can get involved in our community: Contributing There are a couple of ways you can contribute to the development of Next.js: - Documentation: Suggest improvements or even write new sections to help our users understand how to use Next.js. - Examples: Help developers integrate Next.js with other tools and services by creating a new example or improving an existing one. - Codebase: Learn more about the underlying architecture, contribute to bug fixes, errors, and suggest new features. Discussions If you have a question about Next.js, or want to help others, you're always welcome to join the conversation: - GitHub Discussions - Discord - Reddit Social Media Follow Next.js on Twitter for the latest updates, and subscribe to the Vercel YouTube channel for Next.js videos. Code of Conduct We believe in creating an inclusive, welcoming community. As such, we ask all members to adhere to our Code of Conduct. This document outlines our expectations for participant behavior. We invite you to read it and help us maintain a safe and respectful environment.",
    "excerpt": "With over 5 million weekly downloads, Next.js has a large and active community of developers across the world. Here's how you can get involved in our community: Contributing There are a couple of ways...",
    "url": "https://nextjs.org/docs/04-community"
  },
  {
    "id": "index",
    "path": "index.mdx",
    "title": "Next.js Docs",
    "description": "Welcome to the Next.js Documentation.",
    "category": "app-router",
    "version": "15.1.8",
    "headings": [
      {
        "level": 2,
        "text": "What is Next.js?",
        "slug": "what-is-nextjs"
      },
      {
        "level": 2,
        "text": "How to use the docs",
        "slug": "how-to-use-the-docs"
      },
      {
        "level": 2,
        "text": "App Router and Pages Router",
        "slug": "app-router-and-pages-router"
      },
      {
        "level": 3,
        "text": "React version handling",
        "slug": "react-version-handling"
      },
      {
        "level": 2,
        "text": "Pre-requisite knowledge",
        "slug": "pre-requisite-knowledge"
      },
      {
        "level": 2,
        "text": "Accessibility",
        "slug": "accessibility"
      },
      {
        "level": 2,
        "text": "Join our Community",
        "slug": "join-our-community"
      }
    ],
    "codeBlocks": [],
    "content": "Welcome to the Next.js documentation! What is Next.js? Next.js is a React framework for building full-stack web applications. You use React Components to build user interfaces, and Next.js for additional features and optimizations. It also automatically configures lower-level tools like bundlers and compilers. You can instead focus on building your product and shipping quickly. Whether you're an individual developer or part of a larger team, Next.js can help you build interactive, dynamic, and fast React applications. How to use the docs The docs are organized into 3 sections: - Getting Started: Step-by-step tutorials to help you create a new application and learn the core Next.js features. - Guides: Tutorials on specific use cases, choose what's relevant to you. - API Reference: Detailed technical reference for every feature. Use the sidebar to navigate through the sections, or search (Ctrl+K or Cmd+K) to quickly find a page. App Router and Pages Router Next.js has two different routers: - App Router: The newer router that supports new React features like Server Components. - Pages Router: The original router, still supported and being improved. At the top of the sidebar, you'll notice a dropdown menu that allows you to switch between the App Router and the Pages Router docs. React version handling The App Router and Pages Router handle React versions differently: - App Router: Uses React canary releases built-in, which include all the stable React 19 changes, as well as newer features being validated in frameworks, prior to a new React release. - Pages Router: Uses the React version installed in your project's package.json. This approach ensures new React features work reliably in the App Router while maintaining backwards compatibility for existing Pages Router applications. Pre-requisite knowledge Our documentation assumes some familiarity with web development. Before getting started, it'll help if you're comfortable with: - HTML - CSS - JavaScript - React If you're new to React or need a refresher, we recommend starting with our React Foundations course, and the Next.js Foundations course that has you building an application as you learn. Accessibility For the best experience when using a screen reader, we recommend using Firefox and NVDA, or Safari and VoiceOver. Join our Community If you have questions about anything related to Next.js, you're always welcome to ask our community on GitHub Discussions, Discord, X (Twitter), and Reddit.",
    "excerpt": "Welcome to the Next.js documentation! What is Next.js? Next.js is a React framework for building full-stack web applications. You use React Components to build user interfaces, and Next.js for additio...",
    "url": "https://nextjs.org/docs/index"
  }
]